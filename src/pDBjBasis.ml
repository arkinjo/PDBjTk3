(*** This file is machine-generated. Edit at your own risk. ***)

(*
   Based on PDBx/mmCIF dictionary:
     dictionary.title: mmcif_pdbx.dic
     dictionary.datablock_id: mmcif_pdbx.dic
     dictionary.version: 5.286
 *)


open ExtLib


module PDBjDict = struct
  let dictionary_file = "mmcif_pdbx_v50.dic"
  let xsd_file = "pdbx-v50.xsd"
  let dictionary_title = "mmcif_pdbx.dic"
  let dictionary_datablock_id = "mmcif_pdbx.dic"
  let dictionary_version = "5.286"

  let some_float s = if s = "?" || s = "." then None else Some (float_of_string s)
  let some_int s = if s = "?" || s = "." then None else if String.starts_with s "+" then Some (int_of_string (String.lchop s)) else Some (int_of_string s)
  let type_of_item =
    let ht = Hashtbl.create 100 in
    List.iter (fun (k,v) -> Hashtbl.add ht k v) [
    (("jV_command","name"),"text"); (("jV_command","command"),"text"); (("jV_command","document"),"text"); 
    (("atom_site","aniso_B[1][1]"),"float"); (("atom_site","aniso_B[1][1]_esd"),"float"); (("atom_site","aniso_B[1][2]"),"float"); (("atom_site","aniso_B[1][2]_esd"),"float"); (("atom_site","aniso_B[1][3]"),"float"); (("atom_site","aniso_B[1][3]_esd"),"float"); (("atom_site","aniso_B[2][2]"),"float"); (("atom_site","aniso_B[2][2]_esd"),"float"); (("atom_site","aniso_B[2][3]"),"float"); (("atom_site","aniso_B[2][3]_esd"),"float"); (("atom_site","aniso_B[3][3]"),"float"); (("atom_site","aniso_B[3][3]_esd"),"float"); (("atom_site","aniso_ratio"),"float"); (("atom_site","aniso_U[1][1]"),"float"); (("atom_site","aniso_U[1][1]_esd"),"float"); (("atom_site","aniso_U[1][2]"),"float"); (("atom_site","aniso_U[1][2]_esd"),"float"); (("atom_site","aniso_U[1][3]"),"float"); (("atom_site","aniso_U[1][3]_esd"),"float"); (("atom_site","aniso_U[2][2]"),"float"); (("atom_site","aniso_U[2][2]_esd"),"float"); (("atom_site","aniso_U[2][3]"),"float"); (("atom_site","aniso_U[2][3]_esd"),"float"); (("atom_site","aniso_U[3][3]"),"float"); (("atom_site","aniso_U[3][3]_esd"),"float"); (("atom_site","attached_hydrogens"),"int"); (("atom_site","auth_asym_id"),"code"); (("atom_site","auth_atom_id"),"atcode"); (("atom_site","auth_comp_id"),"code"); (("atom_site","auth_seq_id"),"code"); (("atom_site","B_equiv_geom_mean"),"float"); (("atom_site","B_equiv_geom_mean_esd"),"float"); (("atom_site","B_iso_or_equiv"),"float"); (("atom_site","B_iso_or_equiv_esd"),"float"); (("atom_site","calc_attached_atom"),"code"); (("atom_site","calc_flag"),"ucode"); (("atom_site","Cartn_x"),"float"); (("atom_site","Cartn_x_esd"),"float"); (("atom_site","Cartn_y"),"float"); (("atom_site","Cartn_y_esd"),"float"); (("atom_site","Cartn_z"),"float"); (("atom_site","Cartn_z_esd"),"float"); (("atom_site","chemical_conn_number"),"int"); (("atom_site","constraints"),"line"); (("atom_site","details"),"text"); (("atom_site","disorder_assembly"),"code"); (("atom_site","disorder_group"),"code"); (("atom_site","footnote_id"),"code"); (("atom_site","fract_x"),"float"); (("atom_site","fract_x_esd"),"float"); (("atom_site","fract_y"),"float"); (("atom_site","fract_y_esd"),"float"); (("atom_site","fract_z"),"float"); (("atom_site","fract_z_esd"),"float"); (("atom_site","group_PDB"),"code"); (("atom_site","id"),"code"); (("atom_site","label_alt_id"),"code"); (("atom_site","label_asym_id"),"code"); (("atom_site","label_atom_id"),"atcode"); (("atom_site","label_comp_id"),"ucode"); (("atom_site","label_entity_id"),"code"); (("atom_site","label_seq_id"),"int"); (("atom_site","occupancy"),"float"); (("atom_site","occupancy_esd"),"float"); (("atom_site","restraints"),"text"); (("atom_site","symmetry_multiplicity"),"int"); (("atom_site","thermal_displace_type"),"ucode"); (("atom_site","type_symbol"),"code"); (("atom_site","U_equiv_geom_mean"),"float"); (("atom_site","U_equiv_geom_mean_esd"),"float"); (("atom_site","U_iso_or_equiv"),"float"); (("atom_site","U_iso_or_equiv_esd"),"float"); (("atom_site","Wyckoff_symbol"),"line"); (("atom_site","adp_type"),"code"); (("atom_site","refinement_flags"),"code"); (("atom_site","refinement_flags_adp"),"code"); (("atom_site","refinement_flags_occupancy"),"code"); (("atom_site","refinement_flags_posn"),"code"); (("atom_site","pdbx_auth_alt_id"),"code"); (("atom_site","pdbx_PDB_ins_code"),"code"); (("atom_site","pdbx_PDB_model_num"),"int"); (("atom_site","pdbx_PDB_residue_no"),"code"); (("atom_site","pdbx_PDB_residue_name"),"code"); (("atom_site","pdbx_PDB_strand_id"),"code"); (("atom_site","pdbx_PDB_atom_name"),"code"); (("atom_site","pdbx_auth_atom_name"),"atcode"); (("atom_site","pdbx_formal_charge"),"int"); (("atom_site","pdbx_auth_comp_id"),"code"); (("atom_site","pdbx_auth_asym_id"),"code"); (("atom_site","pdbx_auth_seq_id"),"code"); (("atom_site","pdbx_tls_group_id"),"code"); (("atom_site","pdbx_ncs_dom_id"),"code"); (("atom_site","pdbx_struct_group_id"),"ucode-alphanum-csv"); (("atom_site","pdbx_group_NDB"),"code"); (("atom_site","pdbx_atom_group"),"code"); (("atom_site","pdbx_label_seq_num"),"code"); (("atom_site","pdbx_not_in_asym"),"code"); 
    (("atom_site_anisotrop","B[1][1]"),"float"); (("atom_site_anisotrop","B[1][1]_esd"),"float"); (("atom_site_anisotrop","B[1][2]"),"float"); (("atom_site_anisotrop","B[1][2]_esd"),"float"); (("atom_site_anisotrop","B[1][3]"),"float"); (("atom_site_anisotrop","B[1][3]_esd"),"float"); (("atom_site_anisotrop","B[2][2]"),"float"); (("atom_site_anisotrop","B[2][2]_esd"),"float"); (("atom_site_anisotrop","B[2][3]"),"float"); (("atom_site_anisotrop","B[2][3]_esd"),"float"); (("atom_site_anisotrop","B[3][3]"),"float"); (("atom_site_anisotrop","B[3][3]_esd"),"float"); (("atom_site_anisotrop","ratio"),"float"); (("atom_site_anisotrop","id"),"code"); (("atom_site_anisotrop","type_symbol"),"code"); (("atom_site_anisotrop","U[1][1]"),"float"); (("atom_site_anisotrop","U[1][1]_esd"),"float"); (("atom_site_anisotrop","U[1][2]"),"float"); (("atom_site_anisotrop","U[1][2]_esd"),"float"); (("atom_site_anisotrop","U[1][3]"),"float"); (("atom_site_anisotrop","U[1][3]_esd"),"float"); (("atom_site_anisotrop","U[2][2]"),"float"); (("atom_site_anisotrop","U[2][2]_esd"),"float"); (("atom_site_anisotrop","U[2][3]"),"float"); (("atom_site_anisotrop","U[2][3]_esd"),"float"); (("atom_site_anisotrop","U[3][3]"),"float"); (("atom_site_anisotrop","U[3][3]_esd"),"float"); (("atom_site_anisotrop","pdbx_auth_seq_id"),"code"); (("atom_site_anisotrop","pdbx_auth_alt_id"),"code"); (("atom_site_anisotrop","pdbx_auth_asym_id"),"code"); (("atom_site_anisotrop","pdbx_auth_atom_id"),"atcode"); (("atom_site_anisotrop","pdbx_auth_comp_id"),"code"); (("atom_site_anisotrop","pdbx_label_seq_id"),"int"); (("atom_site_anisotrop","pdbx_label_alt_id"),"code"); (("atom_site_anisotrop","pdbx_label_asym_id"),"code"); (("atom_site_anisotrop","pdbx_label_atom_id"),"atcode"); (("atom_site_anisotrop","pdbx_label_comp_id"),"ucode"); (("atom_site_anisotrop","pdbx_PDB_ins_code"),"code"); (("atom_site_anisotrop","pdbx_PDB_model_num"),"int"); (("atom_site_anisotrop","pdbx_not_in_asym"),"code"); (("atom_site_anisotrop","pdbx_PDB_residue_no"),"code"); (("atom_site_anisotrop","pdbx_PDB_residue_name"),"code"); (("atom_site_anisotrop","pdbx_PDB_strand_id"),"code"); (("atom_site_anisotrop","pdbx_PDB_atom_name"),"atcode"); (("atom_site_anisotrop","pdbx_auth_atom_name"),"atcode"); (("atom_site_anisotrop","pdbx_label_ins_code"),"code"); 
    (("atom_sites","entry_id"),"code"); (("atom_sites","Cartn_transf_matrix[1][1]"),"float"); (("atom_sites","Cartn_transf_matrix[1][2]"),"float"); (("atom_sites","Cartn_transf_matrix[1][3]"),"float"); (("atom_sites","Cartn_transf_matrix[2][1]"),"float"); (("atom_sites","Cartn_transf_matrix[2][2]"),"float"); (("atom_sites","Cartn_transf_matrix[2][3]"),"float"); (("atom_sites","Cartn_transf_matrix[3][1]"),"float"); (("atom_sites","Cartn_transf_matrix[3][2]"),"float"); (("atom_sites","Cartn_transf_matrix[3][3]"),"float"); (("atom_sites","Cartn_transf_vector[1]"),"float"); (("atom_sites","Cartn_transf_vector[2]"),"float"); (("atom_sites","Cartn_transf_vector[3]"),"float"); (("atom_sites","Cartn_transform_axes"),"text"); (("atom_sites","fract_transf_matrix[1][1]"),"float"); (("atom_sites","fract_transf_matrix[1][2]"),"float"); (("atom_sites","fract_transf_matrix[1][3]"),"float"); (("atom_sites","fract_transf_matrix[2][1]"),"float"); (("atom_sites","fract_transf_matrix[2][2]"),"float"); (("atom_sites","fract_transf_matrix[2][3]"),"float"); (("atom_sites","fract_transf_matrix[3][1]"),"float"); (("atom_sites","fract_transf_matrix[3][2]"),"float"); (("atom_sites","fract_transf_matrix[3][3]"),"float"); (("atom_sites","fract_transf_vector[1]"),"float"); (("atom_sites","fract_transf_vector[2]"),"float"); (("atom_sites","fract_transf_vector[3]"),"float"); (("atom_sites","solution_primary"),"ucode"); (("atom_sites","solution_secondary"),"ucode"); (("atom_sites","solution_hydrogens"),"ucode"); (("atom_sites","special_details"),"text"); 
    (("atom_sites_alt","details"),"text"); (("atom_sites_alt","id"),"code"); 
    (("atom_sites_alt_ens","details"),"text"); (("atom_sites_alt_ens","id"),"code"); 
    (("atom_sites_alt_gen","alt_id"),"code"); (("atom_sites_alt_gen","ens_id"),"code"); 
    (("atom_sites_footnote","id"),"code"); (("atom_sites_footnote","text"),"text"); 
    (("atom_type","analytical_mass_percent"),"float"); (("atom_type","description"),"text"); (("atom_type","number_in_cell"),"int"); (("atom_type","oxidation_number"),"int"); (("atom_type","radius_bond"),"float"); (("atom_type","radius_contact"),"float"); (("atom_type","scat_Cromer_Mann_a1"),"float"); (("atom_type","scat_Cromer_Mann_a2"),"float"); (("atom_type","scat_Cromer_Mann_a3"),"float"); (("atom_type","scat_Cromer_Mann_a4"),"float"); (("atom_type","scat_Cromer_Mann_b1"),"float"); (("atom_type","scat_Cromer_Mann_b2"),"float"); (("atom_type","scat_Cromer_Mann_b3"),"float"); (("atom_type","scat_Cromer_Mann_b4"),"float"); (("atom_type","scat_Cromer_Mann_c"),"float"); (("atom_type","scat_dispersion_imag"),"float"); (("atom_type","scat_dispersion_real"),"float"); (("atom_type","scat_length_neutron"),"text"); (("atom_type","scat_source"),"text"); (("atom_type","scat_versus_stol_list"),"text"); (("atom_type","symbol"),"code"); (("atom_type","scat_dispersion_source"),"text"); (("atom_type","pdbx_scat_Cromer_Mann_a5"),"float"); (("atom_type","pdbx_scat_Cromer_Mann_b5"),"float"); 
    (("audit","creation_date"),"yyyy-mm-dd"); (("audit","creation_method"),"text"); (("audit","revision_id"),"code"); (("audit","update_record"),"text"); 
    (("audit_author","address"),"text"); (("audit_author","name"),"line"); (("audit_author","pdbx_ordinal"),"int"); (("audit_author","identifier_ORCID"),"orcid_id"); 
    (("audit_conform","dict_location"),"text"); (("audit_conform","dict_name"),"text"); (("audit_conform","dict_version"),"text"); 
    (("audit_contact_author","address"),"text"); (("audit_contact_author","email"),"line"); (("audit_contact_author","fax"),"line"); (("audit_contact_author","name"),"line"); (("audit_contact_author","phone"),"line"); 
    (("cell","angle_alpha"),"float"); (("cell","angle_alpha_esd"),"float"); (("cell","angle_beta"),"float"); (("cell","angle_beta_esd"),"float"); (("cell","angle_gamma"),"float"); (("cell","angle_gamma_esd"),"float"); (("cell","entry_id"),"code"); (("cell","details"),"text"); (("cell","formula_units_Z"),"int"); (("cell","length_a"),"float"); (("cell","length_a_esd"),"float"); (("cell","length_b"),"float"); (("cell","length_b_esd"),"float"); (("cell","length_c"),"float"); (("cell","length_c_esd"),"float"); (("cell","volume"),"float"); (("cell","volume_esd"),"float"); (("cell","Z_PDB"),"int"); (("cell","reciprocal_angle_alpha"),"float"); (("cell","reciprocal_angle_beta"),"float"); (("cell","reciprocal_angle_gamma"),"float"); (("cell","reciprocal_angle_alpha_esd"),"float"); (("cell","reciprocal_angle_beta_esd"),"float"); (("cell","reciprocal_angle_gamma_esd"),"float"); (("cell","reciprocal_length_a"),"float"); (("cell","reciprocal_length_b"),"float"); (("cell","reciprocal_length_c"),"float"); (("cell","reciprocal_length_a_esd"),"float"); (("cell","reciprocal_length_b_esd"),"float"); (("cell","reciprocal_length_c_esd"),"float"); (("cell","pdbx_unique_axis"),"text"); 
    (("cell_measurement","entry_id"),"code"); (("cell_measurement","pressure"),"float"); (("cell_measurement","pressure_esd"),"float"); (("cell_measurement","radiation"),"line"); (("cell_measurement","reflns_used"),"int"); (("cell_measurement","temp"),"float"); (("cell_measurement","temp_esd"),"float"); (("cell_measurement","theta_max"),"float"); (("cell_measurement","theta_min"),"float"); (("cell_measurement","wavelength"),"float"); 
    (("cell_measurement_refln","index_h"),"int"); (("cell_measurement_refln","index_k"),"int"); (("cell_measurement_refln","index_l"),"int"); (("cell_measurement_refln","theta"),"float"); 
    (("chem_comp","formula"),"text"); (("chem_comp","formula_weight"),"float"); (("chem_comp","id"),"ucode"); (("chem_comp","model_details"),"text"); (("chem_comp","model_erf"),"line"); (("chem_comp","model_source"),"text"); (("chem_comp","mon_nstd_class"),"text"); (("chem_comp","mon_nstd_details"),"text"); (("chem_comp","mon_nstd_flag"),"ucode"); (("chem_comp","mon_nstd_parent"),"code"); (("chem_comp","mon_nstd_parent_comp_id"),"uline"); (("chem_comp","name"),"text"); (("chem_comp","number_atoms_all"),"int"); (("chem_comp","number_atoms_nh"),"int"); (("chem_comp","one_letter_code"),"ucode"); (("chem_comp","three_letter_code"),"uchar3"); (("chem_comp","type"),"uline"); (("chem_comp","pdbx_synonyms"),"text"); (("chem_comp","pdbx_modification_details"),"text"); (("chem_comp","pdbx_component_no"),"int"); (("chem_comp","pdbx_type"),"uline"); (("chem_comp","pdbx_ambiguous_flag"),"code"); (("chem_comp","pdbx_replaced_by"),"ucode"); (("chem_comp","pdbx_replaces"),"uline"); (("chem_comp","pdbx_formal_charge"),"int"); (("chem_comp","pdbx_subcomponent_list"),"text"); (("chem_comp","pdbx_model_coordinates_details"),"text"); (("chem_comp","pdbx_model_coordinates_db_code"),"line"); (("chem_comp","pdbx_ideal_coordinates_details"),"text"); (("chem_comp","pdbx_ideal_coordinates_missing_flag"),"ucode"); (("chem_comp","pdbx_model_coordinates_missing_flag"),"ucode"); (("chem_comp","pdbx_initial_date"),"yyyy-mm-dd"); (("chem_comp","pdbx_modified_date"),"yyyy-mm-dd"); (("chem_comp","pdbx_release_status"),"line"); (("chem_comp","pdbx_processing_site"),"code"); (("chem_comp","pdbx_number_subcomponents"),"int"); (("chem_comp","pdbx_class_1"),"line"); (("chem_comp","pdbx_class_2"),"line"); (("chem_comp","pdbx_comp_type"),"line"); (("chem_comp","pdbx_reserved_name"),"text"); (("chem_comp","pdbx_status"),"code"); (("chem_comp","pdbx_type_modified"),"int"); (("chem_comp","pdbx_casnum"),"line"); (("chem_comp","pdbx_smiles"),"text"); (("chem_comp","pdbx_nscnum"),"code"); 
    (("chem_comp_angle","atom_id_1"),"atcode"); (("chem_comp_angle","atom_id_2"),"atcode"); (("chem_comp_angle","atom_id_3"),"atcode"); (("chem_comp_angle","comp_id"),"ucode"); (("chem_comp_angle","value_angle"),"float"); (("chem_comp_angle","value_angle_esd"),"float"); (("chem_comp_angle","value_dist"),"float"); (("chem_comp_angle","value_dist_esd"),"float"); 
    (("chem_comp_atom","alt_atom_id"),"line"); (("chem_comp_atom","atom_id"),"atcode"); (("chem_comp_atom","charge"),"int"); (("chem_comp_atom","model_Cartn_x"),"float"); (("chem_comp_atom","model_Cartn_x_esd"),"float"); (("chem_comp_atom","model_Cartn_y"),"float"); (("chem_comp_atom","model_Cartn_y_esd"),"float"); (("chem_comp_atom","model_Cartn_z"),"float"); (("chem_comp_atom","model_Cartn_z_esd"),"float"); (("chem_comp_atom","comp_id"),"ucode"); (("chem_comp_atom","partial_charge"),"float"); (("chem_comp_atom","substruct_code"),"ucode"); (("chem_comp_atom","type_symbol"),"code"); (("chem_comp_atom","pdbx_align"),"int"); (("chem_comp_atom","pdbx_ordinal"),"int"); (("chem_comp_atom","pdbx_component_atom_id"),"atcode"); (("chem_comp_atom","pdbx_component_comp_id"),"ucode"); (("chem_comp_atom","pdbx_alt_atom_id"),"atcode"); (("chem_comp_atom","pdbx_alt_comp_id"),"ucode"); (("chem_comp_atom","pdbx_model_Cartn_x_ideal"),"float"); (("chem_comp_atom","pdbx_model_Cartn_y_ideal"),"float"); (("chem_comp_atom","pdbx_model_Cartn_z_ideal"),"float"); (("chem_comp_atom","pdbx_stereo_config"),"ucode"); (("chem_comp_atom","pdbx_aromatic_flag"),"ucode"); (("chem_comp_atom","pdbx_leaving_atom_flag"),"ucode"); (("chem_comp_atom","pdbx_residue_numbering"),"int"); (("chem_comp_atom","pdbx_polymer_type"),"line"); (("chem_comp_atom","pdbx_ref_id"),"ucode"); (("chem_comp_atom","pdbx_component_id"),"int"); (("chem_comp_atom","pdbx_component_entity_id"),"int"); 
    (("chem_comp_bond","atom_id_1"),"atcode"); (("chem_comp_bond","atom_id_2"),"atcode"); (("chem_comp_bond","comp_id"),"ucode"); (("chem_comp_bond","value_order"),"ucode"); (("chem_comp_bond","value_dist"),"float"); (("chem_comp_bond","value_dist_esd"),"float"); (("chem_comp_bond","pdbx_ordinal"),"int"); (("chem_comp_bond","pdbx_stereo_config"),"ucode"); (("chem_comp_bond","pdbx_aromatic_flag"),"ucode"); 
    (("chem_comp_chir","atom_id"),"atcode"); (("chem_comp_chir","atom_config"),"ucode"); (("chem_comp_chir","id"),"code"); (("chem_comp_chir","comp_id"),"ucode"); (("chem_comp_chir","number_atoms_all"),"int"); (("chem_comp_chir","number_atoms_nh"),"int"); (("chem_comp_chir","volume_flag"),"ucode"); (("chem_comp_chir","volume_three"),"float"); (("chem_comp_chir","volume_three_esd"),"float"); 
    (("chem_comp_chir_atom","atom_id"),"atcode"); (("chem_comp_chir_atom","chir_id"),"code"); (("chem_comp_chir_atom","comp_id"),"ucode"); (("chem_comp_chir_atom","dev"),"float"); 
    (("chem_comp_link","link_id"),"code"); (("chem_comp_link","details"),"text"); (("chem_comp_link","type_comp_1"),"uline"); (("chem_comp_link","type_comp_2"),"uline"); 
    (("chem_comp_plane","id"),"code"); (("chem_comp_plane","comp_id"),"ucode"); (("chem_comp_plane","number_atoms_all"),"int"); (("chem_comp_plane","number_atoms_nh"),"int"); 
    (("chem_comp_plane_atom","atom_id"),"atcode"); (("chem_comp_plane_atom","comp_id"),"ucode"); (("chem_comp_plane_atom","plane_id"),"code"); (("chem_comp_plane_atom","dist_esd"),"float"); 
    (("chem_comp_tor","atom_id_1"),"atcode"); (("chem_comp_tor","atom_id_2"),"atcode"); (("chem_comp_tor","atom_id_3"),"atcode"); (("chem_comp_tor","atom_id_4"),"atcode"); (("chem_comp_tor","id"),"code"); (("chem_comp_tor","comp_id"),"ucode"); 
    (("chem_comp_tor_value","comp_id"),"ucode"); (("chem_comp_tor_value","tor_id"),"code"); (("chem_comp_tor_value","angle"),"float"); (("chem_comp_tor_value","angle_esd"),"float"); (("chem_comp_tor_value","dist"),"float"); (("chem_comp_tor_value","dist_esd"),"float"); 
    (("chem_link","id"),"code"); (("chem_link","details"),"text"); 
    (("chem_link_angle","atom_1_comp_id"),"ucode"); (("chem_link_angle","atom_2_comp_id"),"ucode"); (("chem_link_angle","atom_3_comp_id"),"ucode"); (("chem_link_angle","atom_id_1"),"code"); (("chem_link_angle","atom_id_2"),"code"); (("chem_link_angle","atom_id_3"),"code"); (("chem_link_angle","link_id"),"code"); (("chem_link_angle","value_angle"),"float"); (("chem_link_angle","value_angle_esd"),"float"); (("chem_link_angle","value_dist"),"float"); (("chem_link_angle","value_dist_esd"),"float"); 
    (("chem_link_bond","atom_1_comp_id"),"ucode"); (("chem_link_bond","atom_2_comp_id"),"ucode"); (("chem_link_bond","atom_id_1"),"code"); (("chem_link_bond","atom_id_2"),"code"); (("chem_link_bond","link_id"),"code"); (("chem_link_bond","value_dist"),"float"); (("chem_link_bond","value_dist_esd"),"float"); (("chem_link_bond","value_order"),"ucode"); 
    (("chem_link_chir","atom_comp_id"),"ucode"); (("chem_link_chir","atom_id"),"code"); (("chem_link_chir","atom_config"),"ucode"); (("chem_link_chir","id"),"code"); (("chem_link_chir","link_id"),"code"); (("chem_link_chir","number_atoms_all"),"int"); (("chem_link_chir","number_atoms_nh"),"int"); (("chem_link_chir","volume_flag"),"ucode"); (("chem_link_chir","volume_three"),"float"); (("chem_link_chir","volume_three_esd"),"float"); 
    (("chem_link_chir_atom","atom_comp_id"),"ucode"); (("chem_link_chir_atom","atom_id"),"code"); (("chem_link_chir_atom","chir_id"),"code"); (("chem_link_chir_atom","dev"),"float"); 
    (("chem_link_plane","id"),"code"); (("chem_link_plane","link_id"),"code"); (("chem_link_plane","number_atoms_all"),"int"); (("chem_link_plane","number_atoms_nh"),"int"); 
    (("chem_link_plane_atom","atom_comp_id"),"ucode"); (("chem_link_plane_atom","atom_id"),"code"); (("chem_link_plane_atom","plane_id"),"code"); 
    (("chem_link_tor","atom_1_comp_id"),"ucode"); (("chem_link_tor","atom_2_comp_id"),"ucode"); (("chem_link_tor","atom_3_comp_id"),"ucode"); (("chem_link_tor","atom_4_comp_id"),"ucode"); (("chem_link_tor","atom_id_1"),"code"); (("chem_link_tor","atom_id_2"),"code"); (("chem_link_tor","atom_id_3"),"code"); (("chem_link_tor","atom_id_4"),"code"); (("chem_link_tor","id"),"code"); (("chem_link_tor","link_id"),"code"); 
    (("chem_link_tor_value","tor_id"),"code"); (("chem_link_tor_value","angle"),"float"); (("chem_link_tor_value","angle_esd"),"float"); (("chem_link_tor_value","dist"),"float"); (("chem_link_tor_value","dist_esd"),"float"); 
    (("chemical","entry_id"),"code"); (("chemical","compound_source"),"text"); (("chemical","melting_point"),"float"); (("chemical","name_common"),"text"); (("chemical","name_mineral"),"text"); (("chemical","name_structure_type"),"text"); (("chemical","name_systematic"),"text"); (("chemical","absolute_configuration"),"code"); (("chemical","melting_point_gt"),"float"); (("chemical","melting_point_lt"),"float"); (("chemical","optical_rotation"),"line"); (("chemical","properties_biological"),"text"); (("chemical","properties_physical"),"text"); (("chemical","temperature_decomposition"),"float"); (("chemical","temperature_decomposition_esd"),"float"); (("chemical","temperature_decomposition_gt"),"float"); (("chemical","temperature_decomposition_lt"),"float"); (("chemical","temperature_sublimation"),"float"); (("chemical","temperature_sublimation_esd"),"float"); (("chemical","temperature_sublimation_gt"),"float"); (("chemical","temperature_sublimation_lt"),"float"); 
    (("chemical_conn_atom","charge"),"int"); (("chemical_conn_atom","display_x"),"float"); (("chemical_conn_atom","display_y"),"float"); (("chemical_conn_atom","NCA"),"int"); (("chemical_conn_atom","NH"),"int"); (("chemical_conn_atom","number"),"int"); (("chemical_conn_atom","type_symbol"),"code"); 
    (("chemical_conn_bond","atom_1"),"int"); (("chemical_conn_bond","atom_2"),"int"); (("chemical_conn_bond","type"),"ucode"); 
    (("chemical_formula","analytical"),"text"); (("chemical_formula","entry_id"),"code"); (("chemical_formula","iupac"),"text"); (("chemical_formula","moiety"),"text"); (("chemical_formula","structural"),"text"); (("chemical_formula","sum"),"text"); (("chemical_formula","weight"),"float"); (("chemical_formula","weight_meas"),"float"); 
    (("citation","abstract"),"text"); (("citation","abstract_id_CAS"),"text"); (("citation","book_id_ISBN"),"line"); (("citation","book_publisher"),"text"); (("citation","book_publisher_city"),"text"); (("citation","book_title"),"text"); (("citation","coordinate_linkage"),"ucode"); (("citation","country"),"line"); (("citation","database_id_Medline"),"int"); (("citation","details"),"text"); (("citation","id"),"code"); (("citation","journal_abbrev"),"line"); (("citation","journal_id_ASTM"),"line"); (("citation","journal_id_CSD"),"line"); (("citation","journal_id_ISSN"),"line"); (("citation","journal_full"),"text"); (("citation","journal_issue"),"line"); (("citation","journal_volume"),"line"); (("citation","language"),"line"); (("citation","page_first"),"line"); (("citation","page_last"),"line"); (("citation","title"),"text"); (("citation","year"),"int"); (("citation","database_id_CSD"),"code"); (("citation","pdbx_database_id_DOI"),"code"); (("citation","pdbx_database_id_PubMed"),"int"); (("citation","unpublished_flag"),"code"); 
    (("citation_author","citation_id"),"code"); (("citation_author","name"),"line"); (("citation_author","ordinal"),"int"); 
    (("citation_editor","citation_id"),"code"); (("citation_editor","name"),"line"); (("citation_editor","ordinal"),"int"); 
    (("computing","entry_id"),"code"); (("computing","cell_refinement"),"text"); (("computing","data_collection"),"text"); (("computing","data_reduction"),"text"); (("computing","molecular_graphics"),"text"); (("computing","publication_material"),"text"); (("computing","structure_refinement"),"text"); (("computing","structure_solution"),"text"); (("computing","pdbx_structure_refinement_method"),"text"); (("computing","pdbx_data_reduction_ii"),"text"); (("computing","pdbx_data_reduction_ds"),"text"); 
    (("database","entry_id"),"code"); (("database","journal_ASTM"),"line"); (("database","journal_CSD"),"line"); (("database","CSD_history"),"text"); (("database","code_CAS"),"line"); (("database","code_CSD"),"line"); (("database","code_ICSD"),"line"); (("database","code_MDF"),"line"); (("database","code_NBS"),"line"); (("database","code_PDB"),"line"); (("database","code_PDF"),"line"); (("database","code_depnum_ccdc_fiz"),"line"); (("database","code_depnum_ccdc_journal"),"line"); (("database","code_depnum_ccdc_archive"),"line"); (("database","pdbx_code_NDB"),"line"); (("database","pdbx_code_PDB"),"code"); (("database","pdbx_related_codes_PDB"),"line"); 
    (("database_2","database_id"),"ucode"); (("database_2","database_code"),"line"); 
    (("database_PDB_caveat","id"),"int"); (("database_PDB_caveat","text"),"text"); 
    (("database_PDB_matrix","entry_id"),"code"); (("database_PDB_matrix","origx[1][1]"),"float"); (("database_PDB_matrix","origx[1][2]"),"float"); (("database_PDB_matrix","origx[1][3]"),"float"); (("database_PDB_matrix","origx[2][1]"),"float"); (("database_PDB_matrix","origx[2][2]"),"float"); (("database_PDB_matrix","origx[2][3]"),"float"); (("database_PDB_matrix","origx[3][1]"),"float"); (("database_PDB_matrix","origx[3][2]"),"float"); (("database_PDB_matrix","origx[3][3]"),"float"); (("database_PDB_matrix","origx_vector[1]"),"float"); (("database_PDB_matrix","origx_vector[2]"),"float"); (("database_PDB_matrix","origx_vector[3]"),"float"); (("database_PDB_matrix","scale[1][1]"),"float"); (("database_PDB_matrix","scale[1][2]"),"float"); (("database_PDB_matrix","scale[1][3]"),"float"); (("database_PDB_matrix","scale[2][1]"),"float"); (("database_PDB_matrix","scale[2][2]"),"float"); (("database_PDB_matrix","scale[2][3]"),"float"); (("database_PDB_matrix","scale[3][1]"),"float"); (("database_PDB_matrix","scale[3][2]"),"float"); (("database_PDB_matrix","scale[3][3]"),"float"); (("database_PDB_matrix","scale_vector[1]"),"float"); (("database_PDB_matrix","scale_vector[2]"),"float"); (("database_PDB_matrix","scale_vector[3]"),"float"); 
    (("database_PDB_remark","id"),"int"); (("database_PDB_remark","text"),"text"); 
    (("database_PDB_rev","author_name"),"line"); (("database_PDB_rev","date"),"yyyy-mm-dd"); (("database_PDB_rev","date_original"),"yyyy-mm-dd"); (("database_PDB_rev","mod_type"),"int"); (("database_PDB_rev","num"),"int"); (("database_PDB_rev","replaced_by"),"line"); (("database_PDB_rev","replaces"),"line"); (("database_PDB_rev","status"),"uline"); (("database_PDB_rev","pdbx_record_revised_1"),"code"); (("database_PDB_rev","pdbx_record_revised_2"),"code"); (("database_PDB_rev","pdbx_record_revised_3"),"code"); (("database_PDB_rev","pdbx_record_revised_4"),"code"); 
    (("database_PDB_rev_record","details"),"text"); (("database_PDB_rev_record","rev_num"),"int"); (("database_PDB_rev_record","type"),"line"); 
    (("database_PDB_tvect","details"),"text"); (("database_PDB_tvect","id"),"code"); (("database_PDB_tvect","vector[1]"),"float"); (("database_PDB_tvect","vector[2]"),"float"); (("database_PDB_tvect","vector[3]"),"float"); 
    (("diffrn","ambient_environment"),"line"); (("diffrn","ambient_temp"),"float"); (("diffrn","ambient_temp_details"),"text"); (("diffrn","ambient_temp_esd"),"float"); (("diffrn","crystal_id"),"code"); (("diffrn","crystal_support"),"text"); (("diffrn","crystal_treatment"),"text"); (("diffrn","details"),"text"); (("diffrn","id"),"code"); (("diffrn","ambient_pressure"),"float"); (("diffrn","ambient_pressure_esd"),"float"); (("diffrn","ambient_pressure_gt"),"float"); (("diffrn","ambient_pressure_lt"),"float"); (("diffrn","ambient_temp_gt"),"float"); (("diffrn","ambient_temp_lt"),"float"); 
    (("diffrn_attenuator","code"),"code"); (("diffrn_attenuator","scale"),"float"); (("diffrn_attenuator","material"),"text"); 
    (("diffrn_detector","details"),"text"); (("diffrn_detector","detector"),"text"); (("diffrn_detector","diffrn_id"),"code"); (("diffrn_detector","type"),"text"); (("diffrn_detector","area_resol_mean"),"float"); (("diffrn_detector","dtime"),"float"); (("diffrn_detector","pdbx_frames_total"),"int"); (("diffrn_detector","pdbx_collection_time_total"),"float"); (("diffrn_detector","pdbx_collection_date"),"yyyy-mm-dd:hh:mm-flex"); 
    (("diffrn_measurement","diffrn_id"),"code"); (("diffrn_measurement","details"),"text"); (("diffrn_measurement","device"),"text"); (("diffrn_measurement","device_details"),"text"); (("diffrn_measurement","device_type"),"text"); (("diffrn_measurement","method"),"text"); (("diffrn_measurement","specimen_support"),"text"); (("diffrn_measurement","pdbx_date"),"yyyy-mm-dd"); 
    (("diffrn_orient_matrix","diffrn_id"),"code"); (("diffrn_orient_matrix","type"),"text"); (("diffrn_orient_matrix","UB[1][1]"),"float"); (("diffrn_orient_matrix","UB[1][2]"),"float"); (("diffrn_orient_matrix","UB[1][3]"),"float"); (("diffrn_orient_matrix","UB[2][1]"),"float"); (("diffrn_orient_matrix","UB[2][2]"),"float"); (("diffrn_orient_matrix","UB[2][3]"),"float"); (("diffrn_orient_matrix","UB[3][1]"),"float"); (("diffrn_orient_matrix","UB[3][2]"),"float"); (("diffrn_orient_matrix","UB[3][3]"),"float"); 
    (("diffrn_orient_refln","angle_chi"),"float"); (("diffrn_orient_refln","angle_kappa"),"float"); (("diffrn_orient_refln","angle_omega"),"float"); (("diffrn_orient_refln","angle_phi"),"float"); (("diffrn_orient_refln","angle_psi"),"float"); (("diffrn_orient_refln","angle_theta"),"float"); (("diffrn_orient_refln","diffrn_id"),"code"); (("diffrn_orient_refln","index_h"),"int"); (("diffrn_orient_refln","index_k"),"int"); (("diffrn_orient_refln","index_l"),"int"); 
    (("diffrn_radiation","collimation"),"text"); (("diffrn_radiation","diffrn_id"),"code"); (("diffrn_radiation","filter_edge"),"float"); (("diffrn_radiation","inhomogeneity"),"float"); (("diffrn_radiation","monochromator"),"text"); (("diffrn_radiation","polarisn_norm"),"float"); (("diffrn_radiation","polarisn_ratio"),"float"); (("diffrn_radiation","probe"),"line"); (("diffrn_radiation","type"),"line"); (("diffrn_radiation","xray_symbol"),"line"); (("diffrn_radiation","wavelength_id"),"code"); (("diffrn_radiation","pdbx_monochromatic_or_laue_m_l"),"code"); (("diffrn_radiation","pdbx_wavelength_list"),"line"); (("diffrn_radiation","pdbx_wavelength"),"line"); (("diffrn_radiation","pdbx_diffrn_protocol"),"line"); (("diffrn_radiation","pdbx_analyzer"),"text"); (("diffrn_radiation","pdbx_scattering_type"),"line"); 
    (("diffrn_radiation_wavelength","id"),"code"); (("diffrn_radiation_wavelength","wavelength"),"float"); (("diffrn_radiation_wavelength","wt"),"float"); 
    (("diffrn_refln","angle_chi"),"float"); (("diffrn_refln","angle_kappa"),"float"); (("diffrn_refln","angle_omega"),"float"); (("diffrn_refln","angle_phi"),"float"); (("diffrn_refln","angle_psi"),"float"); (("diffrn_refln","angle_theta"),"float"); (("diffrn_refln","attenuator_code"),"code"); (("diffrn_refln","counts_bg_1"),"int"); (("diffrn_refln","counts_bg_2"),"int"); (("diffrn_refln","counts_net"),"int"); (("diffrn_refln","counts_peak"),"int"); (("diffrn_refln","counts_total"),"int"); (("diffrn_refln","detect_slit_horiz"),"float"); (("diffrn_refln","detect_slit_vert"),"float"); (("diffrn_refln","diffrn_id"),"code"); (("diffrn_refln","elapsed_time"),"float"); (("diffrn_refln","id"),"code"); (("diffrn_refln","index_h"),"int"); (("diffrn_refln","index_k"),"int"); (("diffrn_refln","index_l"),"int"); (("diffrn_refln","intensity_net"),"float"); (("diffrn_refln","intensity_sigma"),"float"); (("diffrn_refln","scale_group_code"),"code"); (("diffrn_refln","scan_mode"),"ucode"); (("diffrn_refln","scan_mode_backgd"),"ucode"); (("diffrn_refln","scan_rate"),"float"); (("diffrn_refln","scan_time_backgd"),"float"); (("diffrn_refln","scan_width"),"float"); (("diffrn_refln","sint_over_lambda"),"float"); (("diffrn_refln","standard_code"),"code"); (("diffrn_refln","wavelength"),"float"); (("diffrn_refln","wavelength_id"),"code"); (("diffrn_refln","class_code"),"code"); (("diffrn_refln","intensity_u"),"float"); 
    (("diffrn_reflns","av_R_equivalents"),"float"); (("diffrn_reflns","av_sigmaI_over_netI"),"float"); (("diffrn_reflns","diffrn_id"),"code"); (("diffrn_reflns","limit_h_max"),"int"); (("diffrn_reflns","limit_h_min"),"int"); (("diffrn_reflns","limit_k_max"),"int"); (("diffrn_reflns","limit_k_min"),"int"); (("diffrn_reflns","limit_l_max"),"int"); (("diffrn_reflns","limit_l_min"),"int"); (("diffrn_reflns","number"),"int"); (("diffrn_reflns","reduction_process"),"text"); (("diffrn_reflns","theta_max"),"float"); (("diffrn_reflns","theta_min"),"float"); (("diffrn_reflns","transf_matrix[1][1]"),"float"); (("diffrn_reflns","transf_matrix[1][2]"),"float"); (("diffrn_reflns","transf_matrix[1][3]"),"float"); (("diffrn_reflns","transf_matrix[2][1]"),"float"); (("diffrn_reflns","transf_matrix[2][2]"),"float"); (("diffrn_reflns","transf_matrix[2][3]"),"float"); (("diffrn_reflns","transf_matrix[3][1]"),"float"); (("diffrn_reflns","transf_matrix[3][2]"),"float"); (("diffrn_reflns","transf_matrix[3][3]"),"float"); (("diffrn_reflns","av_unetI/netI"),"float"); (("diffrn_reflns","pdbx_d_res_low"),"float"); (("diffrn_reflns","pdbx_d_res_high"),"float"); (("diffrn_reflns","pdbx_percent_possible_obs"),"float"); (("diffrn_reflns","pdbx_Rmerge_I_obs"),"float"); (("diffrn_reflns","pdbx_Rsym_value"),"float"); (("diffrn_reflns","pdbx_chi_squared"),"float"); (("diffrn_reflns","pdbx_redundancy"),"float"); (("diffrn_reflns","pdbx_rejects"),"int"); (("diffrn_reflns","pdbx_observed_criterion"),"float"); (("diffrn_reflns","pdbx_number_obs"),"int"); 
    (("diffrn_scale_group","code"),"code"); (("diffrn_scale_group","I_net"),"float"); 
    (("diffrn_source","current"),"float"); (("diffrn_source","details"),"text"); (("diffrn_source","diffrn_id"),"code"); (("diffrn_source","power"),"float"); (("diffrn_source","size"),"text"); (("diffrn_source","source"),"text"); (("diffrn_source","target"),"code"); (("diffrn_source","type"),"text"); (("diffrn_source","voltage"),"float"); (("diffrn_source","take-off_angle"),"float"); (("diffrn_source","pdbx_wavelength_list"),"line"); (("diffrn_source","pdbx_wavelength"),"line"); (("diffrn_source","pdbx_synchrotron_beamline"),"line"); (("diffrn_source","pdbx_synchrotron_site"),"line"); (("diffrn_source","pdbx_synchrotron_y_n"),"text"); (("diffrn_source","pdbx_source_specific_beamline"),"text"); 
    (("diffrn_standard_refln","code"),"code"); (("diffrn_standard_refln","diffrn_id"),"code"); (("diffrn_standard_refln","index_h"),"int"); (("diffrn_standard_refln","index_k"),"int"); (("diffrn_standard_refln","index_l"),"int"); 
    (("diffrn_standards","diffrn_id"),"code"); (("diffrn_standards","decay_%"),"float"); (("diffrn_standards","interval_count"),"int"); (("diffrn_standards","interval_time"),"float"); (("diffrn_standards","number"),"int"); (("diffrn_standards","scale_sigma"),"float"); (("diffrn_standards","scale_u"),"float"); 
    (("entity","details"),"text"); (("entity","formula_weight"),"float"); (("entity","id"),"code"); (("entity","src_method"),"ucode"); (("entity","type"),"ucode"); (("entity","pdbx_description"),"line"); (("entity","pdbx_number_of_molecules"),"float"); (("entity","pdbx_parent_entity_id"),"code"); (("entity","pdbx_mutation"),"line"); (("entity","pdbx_fragment"),"line"); (("entity","pdbx_ec"),"ec-type"); (("entity","pdbx_modification"),"line"); (("entity","pdbx_formula_weight_exptl"),"float"); (("entity","pdbx_formula_weight_exptl_method"),"line"); (("entity","pdbx_target_id"),"code"); (("entity","pdbx_entities_per_biological_unit"),"float"); 
    (("entity_keywords","entity_id"),"code"); (("entity_keywords","text"),"text"); (("entity_keywords","pdbx_mutation"),"line"); (("entity_keywords","pdbx_fragment"),"line"); (("entity_keywords","pdbx_ec"),"line"); (("entity_keywords","pdbx_antibody_isotype"),"text"); 
    (("entity_link","link_id"),"code"); (("entity_link","details"),"text"); (("entity_link","entity_id_1"),"code"); (("entity_link","entity_id_2"),"code"); (("entity_link","entity_seq_num_1"),"int"); (("entity_link","entity_seq_num_2"),"int"); 
    (("entity_name_com","entity_id"),"code"); (("entity_name_com","name"),"text"); 
    (("entity_name_sys","entity_id"),"code"); (("entity_name_sys","name"),"text"); (("entity_name_sys","system"),"text"); 
    (("entity_poly","entity_id"),"code"); (("entity_poly","nstd_chirality"),"ucode"); (("entity_poly","nstd_linkage"),"ucode"); (("entity_poly","nstd_monomer"),"ucode"); (("entity_poly","number_of_monomers"),"int"); (("entity_poly","type"),"line"); (("entity_poly","type_details"),"text"); (("entity_poly","pdbx_strand_id"),"line"); (("entity_poly","pdbx_seq_one_letter_code"),"text"); (("entity_poly","pdbx_seq_one_letter_code_can"),"text"); (("entity_poly","pdbx_target_identifier"),"line"); (("entity_poly","pdbx_seq_one_letter_code_sample"),"text"); (("entity_poly","pdbx_explicit_linking_flag"),"ucode"); (("entity_poly","pdbx_sequence_evidence_code"),"line"); (("entity_poly","pdbx_build_self_reference"),"uchar1"); (("entity_poly","pdbx_N_terminal_seq_one_letter_code"),"text"); (("entity_poly","pdbx_C_terminal_seq_one_letter_code"),"text"); (("entity_poly","pdbx_seq_three_letter_code"),"text"); (("entity_poly","pdbx_seq_db_name"),"line"); (("entity_poly","pdbx_seq_db_id"),"line"); (("entity_poly","pdbx_seq_align_begin"),"int"); (("entity_poly","pdbx_seq_align_end"),"int"); 
    (("entity_poly_seq","entity_id"),"code"); (("entity_poly_seq","hetero"),"ucode"); (("entity_poly_seq","mon_id"),"ucode"); (("entity_poly_seq","num"),"int"); 
    (("entry","id"),"code"); (("entry","pdbx_DOI"),"code"); 
    (("entry_link","entry_id"),"code"); (("entry_link","id"),"code"); (("entry_link","details"),"text"); 
    (("exptl","absorpt_coefficient_mu"),"float"); (("exptl","absorpt_correction_T_max"),"float"); (("exptl","absorpt_correction_T_min"),"float"); (("exptl","absorpt_correction_type"),"ucode"); (("exptl","absorpt_process_details"),"text"); (("exptl","entry_id"),"code"); (("exptl","crystals_number"),"int"); (("exptl","details"),"text"); (("exptl","method"),"line"); (("exptl","method_details"),"text"); 
    (("exptl_crystal","colour"),"line"); (("exptl_crystal","density_diffrn"),"float"); (("exptl_crystal","density_Matthews"),"float"); (("exptl_crystal","density_method"),"text"); (("exptl_crystal","density_percent_sol"),"float"); (("exptl_crystal","description"),"text"); (("exptl_crystal","F_000"),"int"); (("exptl_crystal","id"),"code"); (("exptl_crystal","preparation"),"text"); (("exptl_crystal","size_max"),"float"); (("exptl_crystal","size_mid"),"float"); (("exptl_crystal","size_min"),"float"); (("exptl_crystal","size_rad"),"float"); (("exptl_crystal","colour_lustre"),"line"); (("exptl_crystal","colour_modifier"),"line"); (("exptl_crystal","colour_primary"),"line"); (("exptl_crystal","density_meas"),"float"); (("exptl_crystal","density_meas_esd"),"float"); (("exptl_crystal","density_meas_gt"),"float"); (("exptl_crystal","density_meas_lt"),"float"); (("exptl_crystal","density_meas_temp"),"float"); (("exptl_crystal","density_meas_temp_esd"),"float"); (("exptl_crystal","density_meas_temp_gt"),"float"); (("exptl_crystal","density_meas_temp_lt"),"float"); (("exptl_crystal","pdbx_crystal_image_url"),"line"); (("exptl_crystal","pdbx_crystal_image_format"),"line"); (("exptl_crystal","pdbx_mosaicity"),"float"); (("exptl_crystal","pdbx_mosaicity_esd"),"float"); (("exptl_crystal","pdbx_crystal_image"),"code"); (("exptl_crystal","pdbx_x-ray_image"),"code"); (("exptl_crystal","pdbx_x-ray_image_type"),"text"); (("exptl_crystal","pdbx_crystal_diffrn_limit"),"float"); (("exptl_crystal","pdbx_crystal_diffrn_lifetime"),"float"); (("exptl_crystal","pdbx_crystal_direction_1"),"float"); (("exptl_crystal","pdbx_crystal_direction_2"),"float"); (("exptl_crystal","pdbx_crystal_direction_3"),"float"); 
    (("exptl_crystal_face","crystal_id"),"code"); (("exptl_crystal_face","diffr_chi"),"float"); (("exptl_crystal_face","diffr_kappa"),"float"); (("exptl_crystal_face","diffr_phi"),"float"); (("exptl_crystal_face","diffr_psi"),"float"); (("exptl_crystal_face","index_h"),"int"); (("exptl_crystal_face","index_k"),"int"); (("exptl_crystal_face","index_l"),"int"); (("exptl_crystal_face","perp_dist"),"float"); 
    (("exptl_crystal_grow","apparatus"),"text"); (("exptl_crystal_grow","atmosphere"),"text"); (("exptl_crystal_grow","crystal_id"),"code"); (("exptl_crystal_grow","details"),"text"); (("exptl_crystal_grow","method"),"text"); (("exptl_crystal_grow","method_ref"),"text"); (("exptl_crystal_grow","pH"),"float"); (("exptl_crystal_grow","pressure"),"float"); (("exptl_crystal_grow","pressure_esd"),"float"); (("exptl_crystal_grow","seeding"),"text"); (("exptl_crystal_grow","seeding_ref"),"text"); (("exptl_crystal_grow","temp"),"float"); (("exptl_crystal_grow","temp_details"),"text"); (("exptl_crystal_grow","temp_esd"),"float"); (("exptl_crystal_grow","time"),"text"); (("exptl_crystal_grow","pdbx_details"),"text"); (("exptl_crystal_grow","pdbx_pH_range"),"line"); 
    (("exptl_crystal_grow_comp","conc"),"line"); (("exptl_crystal_grow_comp","details"),"text"); (("exptl_crystal_grow_comp","crystal_id"),"code"); (("exptl_crystal_grow_comp","id"),"line"); (("exptl_crystal_grow_comp","name"),"line"); (("exptl_crystal_grow_comp","sol_id"),"line"); (("exptl_crystal_grow_comp","volume"),"line"); (("exptl_crystal_grow_comp","pdbx_conc_final"),"line"); (("exptl_crystal_grow_comp","pdbx_bath"),"line"); (("exptl_crystal_grow_comp","pdbx_salt"),"line"); (("exptl_crystal_grow_comp","pdbx_soak_salt"),"line"); (("exptl_crystal_grow_comp","pdbx_soak_solv"),"line"); (("exptl_crystal_grow_comp","pdbx_solv"),"line"); 
    (("geom","entry_id"),"code"); (("geom","details"),"text"); 
    (("geom_angle","atom_site_id_1"),"code"); (("geom_angle","atom_site_label_alt_id_1"),"code"); (("geom_angle","atom_site_label_atom_id_1"),"atcode"); (("geom_angle","atom_site_label_comp_id_1"),"ucode"); (("geom_angle","atom_site_label_seq_id_1"),"int"); (("geom_angle","atom_site_label_asym_id_1"),"code"); (("geom_angle","atom_site_id_2"),"code"); (("geom_angle","atom_site_label_alt_id_2"),"code"); (("geom_angle","atom_site_label_atom_id_2"),"atcode"); (("geom_angle","atom_site_label_comp_id_2"),"ucode"); (("geom_angle","atom_site_label_seq_id_2"),"int"); (("geom_angle","atom_site_label_asym_id_2"),"code"); (("geom_angle","atom_site_id_3"),"code"); (("geom_angle","atom_site_label_alt_id_3"),"code"); (("geom_angle","atom_site_label_atom_id_3"),"atcode"); (("geom_angle","atom_site_label_comp_id_3"),"ucode"); (("geom_angle","atom_site_label_seq_id_3"),"int"); (("geom_angle","atom_site_label_asym_id_3"),"code"); (("geom_angle","atom_site_auth_asym_id_1"),"code"); (("geom_angle","atom_site_auth_atom_id_1"),"atcode"); (("geom_angle","atom_site_auth_comp_id_1"),"code"); (("geom_angle","atom_site_auth_seq_id_1"),"code"); (("geom_angle","atom_site_auth_atom_id_2"),"atcode"); (("geom_angle","atom_site_auth_asym_id_2"),"code"); (("geom_angle","atom_site_auth_comp_id_2"),"code"); (("geom_angle","atom_site_auth_seq_id_2"),"code"); (("geom_angle","atom_site_auth_atom_id_3"),"atcode"); (("geom_angle","atom_site_auth_asym_id_3"),"code"); (("geom_angle","atom_site_auth_comp_id_3"),"code"); (("geom_angle","atom_site_auth_seq_id_3"),"code"); (("geom_angle","publ_flag"),"ucode"); (("geom_angle","site_symmetry_1"),"symop"); (("geom_angle","site_symmetry_2"),"symop"); (("geom_angle","site_symmetry_3"),"symop"); (("geom_angle","value"),"float"); (("geom_angle","value_esd"),"float"); (("geom_angle","pdbx_atom_site_PDB_ins_code_1"),"code"); (("geom_angle","pdbx_atom_site_PDB_ins_code_2"),"code"); (("geom_angle","pdbx_atom_site_PDB_ins_code_3"),"code"); (("geom_angle","pdbx_PDB_model_num"),"int"); 
    (("geom_bond","atom_site_id_1"),"code"); (("geom_bond","atom_site_label_alt_id_1"),"code"); (("geom_bond","atom_site_label_atom_id_1"),"atcode"); (("geom_bond","atom_site_label_comp_id_1"),"ucode"); (("geom_bond","atom_site_label_seq_id_1"),"int"); (("geom_bond","atom_site_label_asym_id_1"),"code"); (("geom_bond","atom_site_id_2"),"code"); (("geom_bond","atom_site_label_alt_id_2"),"code"); (("geom_bond","atom_site_label_atom_id_2"),"atcode"); (("geom_bond","atom_site_label_comp_id_2"),"ucode"); (("geom_bond","atom_site_label_seq_id_2"),"int"); (("geom_bond","atom_site_label_asym_id_2"),"code"); (("geom_bond","atom_site_auth_atom_id_1"),"atcode"); (("geom_bond","atom_site_auth_asym_id_1"),"code"); (("geom_bond","atom_site_auth_comp_id_1"),"code"); (("geom_bond","atom_site_auth_seq_id_1"),"code"); (("geom_bond","atom_site_auth_atom_id_2"),"atcode"); (("geom_bond","atom_site_auth_asym_id_2"),"code"); (("geom_bond","atom_site_auth_comp_id_2"),"code"); (("geom_bond","atom_site_auth_seq_id_2"),"code"); (("geom_bond","dist"),"float"); (("geom_bond","dist_esd"),"float"); (("geom_bond","publ_flag"),"ucode"); (("geom_bond","site_symmetry_1"),"symop"); (("geom_bond","site_symmetry_2"),"symop"); (("geom_bond","valence"),"int"); (("geom_bond","pdbx_atom_site_PDB_ins_code_1"),"code"); (("geom_bond","pdbx_atom_site_PDB_ins_code_2"),"code"); (("geom_bond","pdbx_PDB_model_num"),"int"); 
    (("geom_contact","atom_site_id_1"),"code"); (("geom_contact","atom_site_label_alt_id_1"),"code"); (("geom_contact","atom_site_label_atom_id_1"),"atcode"); (("geom_contact","atom_site_label_comp_id_1"),"ucode"); (("geom_contact","atom_site_label_seq_id_1"),"int"); (("geom_contact","atom_site_label_asym_id_1"),"code"); (("geom_contact","atom_site_id_2"),"code"); (("geom_contact","atom_site_label_alt_id_2"),"code"); (("geom_contact","atom_site_label_atom_id_2"),"atcode"); (("geom_contact","atom_site_label_comp_id_2"),"ucode"); (("geom_contact","atom_site_label_seq_id_2"),"int"); (("geom_contact","atom_site_label_asym_id_2"),"code"); (("geom_contact","atom_site_auth_atom_id_1"),"atcode"); (("geom_contact","atom_site_auth_asym_id_1"),"code"); (("geom_contact","atom_site_auth_comp_id_1"),"code"); (("geom_contact","atom_site_auth_seq_id_1"),"code"); (("geom_contact","atom_site_auth_atom_id_2"),"atcode"); (("geom_contact","atom_site_auth_asym_id_2"),"code"); (("geom_contact","atom_site_auth_comp_id_2"),"code"); (("geom_contact","atom_site_auth_seq_id_2"),"code"); (("geom_contact","dist"),"float"); (("geom_contact","dist_esd"),"float"); (("geom_contact","publ_flag"),"ucode"); (("geom_contact","site_symmetry_1"),"symop"); (("geom_contact","site_symmetry_2"),"symop"); (("geom_contact","pdbx_atom_site_PDB_ins_code_1"),"code"); (("geom_contact","pdbx_atom_site_PDB_ins_code_2"),"code"); (("geom_contact","pdbx_PDB_model_num"),"int"); 
    (("geom_hbond","angle_DHA"),"float"); (("geom_hbond","angle_DHA_esd"),"float"); (("geom_hbond","atom_site_id_A"),"code"); (("geom_hbond","atom_site_label_alt_id_A"),"code"); (("geom_hbond","atom_site_label_asym_id_A"),"code"); (("geom_hbond","atom_site_label_atom_id_A"),"atcode"); (("geom_hbond","atom_site_label_comp_id_A"),"ucode"); (("geom_hbond","atom_site_label_seq_id_A"),"int"); (("geom_hbond","atom_site_id_D"),"code"); (("geom_hbond","atom_site_label_alt_id_D"),"code"); (("geom_hbond","atom_site_label_asym_id_D"),"code"); (("geom_hbond","atom_site_label_atom_id_D"),"atcode"); (("geom_hbond","atom_site_label_comp_id_D"),"ucode"); (("geom_hbond","atom_site_label_seq_id_D"),"int"); (("geom_hbond","atom_site_id_H"),"code"); (("geom_hbond","atom_site_label_alt_id_H"),"code"); (("geom_hbond","atom_site_label_asym_id_H"),"code"); (("geom_hbond","atom_site_label_atom_id_H"),"atcode"); (("geom_hbond","atom_site_label_comp_id_H"),"ucode"); (("geom_hbond","atom_site_label_seq_id_H"),"int"); (("geom_hbond","atom_site_auth_asym_id_A"),"code"); (("geom_hbond","atom_site_auth_atom_id_A"),"atcode"); (("geom_hbond","atom_site_auth_comp_id_A"),"code"); (("geom_hbond","atom_site_auth_seq_id_A"),"code"); (("geom_hbond","atom_site_auth_asym_id_D"),"code"); (("geom_hbond","atom_site_auth_atom_id_D"),"atcode"); (("geom_hbond","atom_site_auth_comp_id_D"),"code"); (("geom_hbond","atom_site_auth_seq_id_D"),"code"); (("geom_hbond","atom_site_auth_asym_id_H"),"code"); (("geom_hbond","atom_site_auth_atom_id_H"),"atcode"); (("geom_hbond","atom_site_auth_comp_id_H"),"code"); (("geom_hbond","atom_site_auth_seq_id_H"),"code"); (("geom_hbond","dist_DA"),"float"); (("geom_hbond","dist_DA_esd"),"float"); (("geom_hbond","dist_DH"),"float"); (("geom_hbond","dist_DH_esd"),"float"); (("geom_hbond","dist_HA"),"float"); (("geom_hbond","dist_HA_esd"),"float"); (("geom_hbond","publ_flag"),"ucode"); (("geom_hbond","site_symmetry_A"),"symop"); (("geom_hbond","site_symmetry_D"),"symop"); (("geom_hbond","site_symmetry_H"),"symop"); 
    (("geom_torsion","atom_site_id_1"),"code"); (("geom_torsion","atom_site_label_alt_id_1"),"code"); (("geom_torsion","atom_site_label_atom_id_1"),"atcode"); (("geom_torsion","atom_site_label_comp_id_1"),"ucode"); (("geom_torsion","atom_site_label_seq_id_1"),"int"); (("geom_torsion","atom_site_label_asym_id_1"),"code"); (("geom_torsion","atom_site_id_2"),"code"); (("geom_torsion","atom_site_label_alt_id_2"),"code"); (("geom_torsion","atom_site_label_atom_id_2"),"atcode"); (("geom_torsion","atom_site_label_comp_id_2"),"ucode"); (("geom_torsion","atom_site_label_seq_id_2"),"int"); (("geom_torsion","atom_site_label_asym_id_2"),"code"); (("geom_torsion","atom_site_id_3"),"code"); (("geom_torsion","atom_site_label_alt_id_3"),"code"); (("geom_torsion","atom_site_label_atom_id_3"),"atcode"); (("geom_torsion","atom_site_label_comp_id_3"),"ucode"); (("geom_torsion","atom_site_label_seq_id_3"),"int"); (("geom_torsion","atom_site_label_asym_id_3"),"code"); (("geom_torsion","atom_site_id_4"),"code"); (("geom_torsion","atom_site_label_alt_id_4"),"code"); (("geom_torsion","atom_site_label_atom_id_4"),"atcode"); (("geom_torsion","atom_site_label_comp_id_4"),"ucode"); (("geom_torsion","atom_site_label_seq_id_4"),"int"); (("geom_torsion","atom_site_label_asym_id_4"),"code"); (("geom_torsion","atom_site_auth_atom_id_1"),"atcode"); (("geom_torsion","atom_site_auth_asym_id_1"),"code"); (("geom_torsion","atom_site_auth_comp_id_1"),"code"); (("geom_torsion","atom_site_auth_seq_id_1"),"code"); (("geom_torsion","atom_site_auth_atom_id_2"),"atcode"); (("geom_torsion","atom_site_auth_asym_id_2"),"code"); (("geom_torsion","atom_site_auth_comp_id_2"),"code"); (("geom_torsion","atom_site_auth_seq_id_2"),"code"); (("geom_torsion","atom_site_auth_atom_id_3"),"atcode"); (("geom_torsion","atom_site_auth_asym_id_3"),"code"); (("geom_torsion","atom_site_auth_comp_id_3"),"code"); (("geom_torsion","atom_site_auth_seq_id_3"),"code"); (("geom_torsion","atom_site_auth_atom_id_4"),"atcode"); (("geom_torsion","atom_site_auth_asym_id_4"),"code"); (("geom_torsion","atom_site_auth_comp_id_4"),"code"); (("geom_torsion","atom_site_auth_seq_id_4"),"code"); (("geom_torsion","publ_flag"),"ucode"); (("geom_torsion","site_symmetry_1"),"symop"); (("geom_torsion","site_symmetry_2"),"symop"); (("geom_torsion","site_symmetry_3"),"symop"); (("geom_torsion","site_symmetry_4"),"symop"); (("geom_torsion","value"),"float"); (("geom_torsion","value_esd"),"float"); (("geom_torsion","pdbx_atom_site_PDB_ins_code_1"),"code"); (("geom_torsion","pdbx_atom_site_PDB_ins_code_2"),"code"); (("geom_torsion","pdbx_atom_site_PDB_ins_code_3"),"code"); (("geom_torsion","pdbx_atom_site_PDB_ins_code_4"),"code"); (("geom_torsion","pdbx_PDB_model_num"),"int"); 
    (("journal","entry_id"),"code"); (("journal","coden_ASTM"),"line"); (("journal","coden_Cambridge"),"line"); (("journal","coeditor_address"),"text"); (("journal","coeditor_code"),"line"); (("journal","coeditor_email"),"line"); (("journal","coeditor_fax"),"line"); (("journal","coeditor_name"),"line"); (("journal","coeditor_notes"),"text"); (("journal","coeditor_phone"),"line"); (("journal","data_validation_number"),"code"); (("journal","date_accepted"),"yyyy-mm-dd"); (("journal","date_from_coeditor"),"yyyy-mm-dd"); (("journal","date_to_coeditor"),"yyyy-mm-dd"); (("journal","date_printers_final"),"yyyy-mm-dd"); (("journal","date_printers_first"),"yyyy-mm-dd"); (("journal","date_proofs_in"),"yyyy-mm-dd"); (("journal","date_proofs_out"),"yyyy-mm-dd"); (("journal","date_recd_copyright"),"yyyy-mm-dd"); (("journal","date_recd_electronic"),"yyyy-mm-dd"); (("journal","date_recd_hard_copy"),"yyyy-mm-dd"); (("journal","issue"),"line"); (("journal","language"),"line"); (("journal","name_full"),"line"); (("journal","page_first"),"line"); (("journal","page_last"),"line"); (("journal","paper_category"),"line"); (("journal","suppl_publ_number"),"line"); (("journal","suppl_publ_pages"),"line"); (("journal","techeditor_address"),"text"); (("journal","techeditor_code"),"line"); (("journal","techeditor_email"),"line"); (("journal","techeditor_fax"),"line"); (("journal","techeditor_name"),"line"); (("journal","techeditor_notes"),"text"); (("journal","techeditor_phone"),"line"); (("journal","volume"),"line"); (("journal","year"),"line"); 
    (("journal_index","subterm"),"line"); (("journal_index","term"),"line"); (("journal_index","type"),"line"); 
    (("phasing","method"),"ucode"); 
    (("phasing_averaging","details"),"text"); (("phasing_averaging","entry_id"),"code"); (("phasing_averaging","method"),"text"); 
    (("phasing_isomorphous","details"),"text"); (("phasing_isomorphous","entry_id"),"code"); (("phasing_isomorphous","method"),"text"); (("phasing_isomorphous","parent"),"text"); 
    (("phasing_MAD","details"),"text"); (("phasing_MAD","entry_id"),"code"); (("phasing_MAD","method"),"text"); (("phasing_MAD","pdbx_d_res_low"),"float"); (("phasing_MAD","pdbx_d_res_high"),"float"); (("phasing_MAD","pdbx_reflns_acentric"),"int"); (("phasing_MAD","pdbx_reflns_centric"),"int"); (("phasing_MAD","pdbx_reflns"),"int"); (("phasing_MAD","pdbx_fom_acentric"),"float"); (("phasing_MAD","pdbx_fom_centric"),"float"); (("phasing_MAD","pdbx_fom"),"float"); (("phasing_MAD","pdbx_R_cullis_centric"),"float"); (("phasing_MAD","pdbx_R_cullis_acentric"),"float"); (("phasing_MAD","pdbx_R_cullis"),"float"); (("phasing_MAD","pdbx_R_kraut_centric"),"float"); (("phasing_MAD","pdbx_R_kraut_acentric"),"float"); (("phasing_MAD","pdbx_R_kraut"),"float"); (("phasing_MAD","pdbx_loc_centric"),"float"); (("phasing_MAD","pdbx_loc_acentric"),"float"); (("phasing_MAD","pdbx_loc"),"float"); (("phasing_MAD","pdbx_power_centric"),"float"); (("phasing_MAD","pdbx_power_acentric"),"float"); (("phasing_MAD","pdbx_power"),"float"); (("phasing_MAD","pdbx_number_data_sets"),"int"); (("phasing_MAD","pdbx_anom_scat_method"),"text"); 
    (("phasing_MAD_clust","expt_id"),"line"); (("phasing_MAD_clust","id"),"line"); (("phasing_MAD_clust","number_set"),"int"); 
    (("phasing_MAD_expt","delta_delta_phi"),"float"); (("phasing_MAD_expt","delta_phi"),"float"); (("phasing_MAD_expt","delta_phi_sigma"),"float"); (("phasing_MAD_expt","id"),"line"); (("phasing_MAD_expt","mean_fom"),"float"); (("phasing_MAD_expt","number_clust"),"int"); (("phasing_MAD_expt","R_normal_all"),"float"); (("phasing_MAD_expt","R_normal_anom_scat"),"float"); 
    (("phasing_MAD_ratio","d_res_high"),"float"); (("phasing_MAD_ratio","d_res_low"),"float"); (("phasing_MAD_ratio","expt_id"),"line"); (("phasing_MAD_ratio","clust_id"),"line"); (("phasing_MAD_ratio","ratio_one_wl"),"float"); (("phasing_MAD_ratio","ratio_one_wl_centric"),"float"); (("phasing_MAD_ratio","ratio_two_wl"),"float"); (("phasing_MAD_ratio","wavelength_1"),"float"); (("phasing_MAD_ratio","wavelength_2"),"float"); 
    (("phasing_MAD_set","clust_id"),"line"); (("phasing_MAD_set","d_res_high"),"float"); (("phasing_MAD_set","d_res_low"),"float"); (("phasing_MAD_set","expt_id"),"line"); (("phasing_MAD_set","f_double_prime"),"float"); (("phasing_MAD_set","f_prime"),"float"); (("phasing_MAD_set","set_id"),"line"); (("phasing_MAD_set","wavelength"),"float"); (("phasing_MAD_set","wavelength_details"),"text"); (("phasing_MAD_set","pdbx_atom_type"),"code"); (("phasing_MAD_set","pdbx_f_prime_refined"),"float"); (("phasing_MAD_set","pdbx_f_double_prime_refined"),"float"); 
    (("phasing_MIR","details"),"text"); (("phasing_MIR","d_res_high"),"float"); (("phasing_MIR","d_res_low"),"float"); (("phasing_MIR","entry_id"),"code"); (("phasing_MIR","FOM"),"float"); (("phasing_MIR","FOM_acentric"),"float"); (("phasing_MIR","FOM_centric"),"float"); (("phasing_MIR","method"),"text"); (("phasing_MIR","reflns"),"int"); (("phasing_MIR","reflns_acentric"),"int"); (("phasing_MIR","reflns_centric"),"int"); (("phasing_MIR","reflns_criterion"),"text"); (("phasing_MIR","pdbx_number_derivatives"),"int"); 
    (("phasing_MIR_der","d_res_high"),"float"); (("phasing_MIR_der","d_res_low"),"float"); (("phasing_MIR_der","der_set_id"),"line"); (("phasing_MIR_der","details"),"text"); (("phasing_MIR_der","id"),"line"); (("phasing_MIR_der","native_set_id"),"line"); (("phasing_MIR_der","number_of_sites"),"int"); (("phasing_MIR_der","power_acentric"),"float"); (("phasing_MIR_der","power_centric"),"float"); (("phasing_MIR_der","R_cullis_acentric"),"float"); (("phasing_MIR_der","R_cullis_anomalous"),"float"); (("phasing_MIR_der","R_cullis_centric"),"float"); (("phasing_MIR_der","reflns_acentric"),"int"); (("phasing_MIR_der","reflns_anomalous"),"int"); (("phasing_MIR_der","reflns_centric"),"int"); (("phasing_MIR_der","reflns_criteria"),"text"); (("phasing_MIR_der","pdbx_R_kraut_centric"),"float"); (("phasing_MIR_der","pdbx_R_kraut_acentric"),"float"); (("phasing_MIR_der","pdbx_R_kraut"),"float"); (("phasing_MIR_der","pdbx_loc_centric"),"float"); (("phasing_MIR_der","pdbx_loc_acentric"),"float"); (("phasing_MIR_der","pdbx_loc"),"float"); (("phasing_MIR_der","pdbx_fom_centric"),"float"); (("phasing_MIR_der","pdbx_fom_acentric"),"float"); (("phasing_MIR_der","pdbx_fom"),"float"); (("phasing_MIR_der","pdbx_power"),"float"); (("phasing_MIR_der","pdbx_R_cullis"),"float"); (("phasing_MIR_der","pdbx_reflns"),"int"); 
    (("phasing_MIR_der_refln","der_id"),"line"); (("phasing_MIR_der_refln","F_calc"),"float"); (("phasing_MIR_der_refln","F_calc_au"),"float"); (("phasing_MIR_der_refln","F_meas"),"float"); (("phasing_MIR_der_refln","F_meas_au"),"float"); (("phasing_MIR_der_refln","F_meas_sigma"),"float"); (("phasing_MIR_der_refln","F_meas_sigma_au"),"float"); (("phasing_MIR_der_refln","HL_A_iso"),"float"); (("phasing_MIR_der_refln","HL_B_iso"),"float"); (("phasing_MIR_der_refln","HL_C_iso"),"float"); (("phasing_MIR_der_refln","HL_D_iso"),"float"); (("phasing_MIR_der_refln","index_h"),"int"); (("phasing_MIR_der_refln","index_k"),"int"); (("phasing_MIR_der_refln","index_l"),"int"); (("phasing_MIR_der_refln","phase_calc"),"float"); (("phasing_MIR_der_refln","set_id"),"line"); 
    (("phasing_MIR_der_shell","d_res_high"),"float"); (("phasing_MIR_der_shell","d_res_low"),"float"); (("phasing_MIR_der_shell","der_id"),"line"); (("phasing_MIR_der_shell","fom"),"float"); (("phasing_MIR_der_shell","ha_ampl"),"float"); (("phasing_MIR_der_shell","loc"),"float"); (("phasing_MIR_der_shell","phase"),"float"); (("phasing_MIR_der_shell","power"),"float"); (("phasing_MIR_der_shell","R_cullis"),"float"); (("phasing_MIR_der_shell","R_kraut"),"float"); (("phasing_MIR_der_shell","reflns"),"int"); (("phasing_MIR_der_shell","pdbx_R_cullis_centric"),"float"); (("phasing_MIR_der_shell","pdbx_R_cullis_acentric"),"float"); (("phasing_MIR_der_shell","pdbx_R_kraut_centric"),"float"); (("phasing_MIR_der_shell","pdbx_R_kraut_acentric"),"float"); (("phasing_MIR_der_shell","pdbx_loc_centric"),"float"); (("phasing_MIR_der_shell","pdbx_loc_acentric"),"float"); (("phasing_MIR_der_shell","pdbx_power_centric"),"float"); (("phasing_MIR_der_shell","pdbx_power_acentric"),"float"); (("phasing_MIR_der_shell","pdbx_fom_centric"),"float"); (("phasing_MIR_der_shell","pdbx_fom_acentric"),"float"); (("phasing_MIR_der_shell","pdbx_reflns_centric"),"float"); (("phasing_MIR_der_shell","pdbx_reflns_acentric"),"int"); 
    (("phasing_MIR_der_site","atom_type_symbol"),"code"); (("phasing_MIR_der_site","B_iso"),"float"); (("phasing_MIR_der_site","B_iso_esd"),"float"); (("phasing_MIR_der_site","Cartn_x"),"float"); (("phasing_MIR_der_site","Cartn_x_esd"),"float"); (("phasing_MIR_der_site","Cartn_y"),"float"); (("phasing_MIR_der_site","Cartn_y_esd"),"float"); (("phasing_MIR_der_site","Cartn_z"),"float"); (("phasing_MIR_der_site","Cartn_z_esd"),"float"); (("phasing_MIR_der_site","der_id"),"line"); (("phasing_MIR_der_site","details"),"text"); (("phasing_MIR_der_site","fract_x"),"float"); (("phasing_MIR_der_site","fract_x_esd"),"float"); (("phasing_MIR_der_site","fract_y"),"float"); (("phasing_MIR_der_site","fract_y_esd"),"float"); (("phasing_MIR_der_site","fract_z"),"float"); (("phasing_MIR_der_site","fract_z_esd"),"float"); (("phasing_MIR_der_site","id"),"code"); (("phasing_MIR_der_site","occupancy"),"float"); (("phasing_MIR_der_site","occupancy_anom"),"float"); (("phasing_MIR_der_site","occupancy_anom_su"),"float"); (("phasing_MIR_der_site","occupancy_iso"),"float"); (("phasing_MIR_der_site","occupancy_iso_su"),"float"); 
    (("phasing_MIR_shell","d_res_high"),"float"); (("phasing_MIR_shell","d_res_low"),"float"); (("phasing_MIR_shell","FOM"),"float"); (("phasing_MIR_shell","FOM_acentric"),"float"); (("phasing_MIR_shell","FOM_centric"),"float"); (("phasing_MIR_shell","loc"),"float"); (("phasing_MIR_shell","mean_phase"),"float"); (("phasing_MIR_shell","power"),"float"); (("phasing_MIR_shell","R_cullis"),"float"); (("phasing_MIR_shell","R_kraut"),"float"); (("phasing_MIR_shell","reflns"),"int"); (("phasing_MIR_shell","reflns_acentric"),"int"); (("phasing_MIR_shell","reflns_anomalous"),"int"); (("phasing_MIR_shell","reflns_centric"),"int"); (("phasing_MIR_shell","pdbx_loc_centric"),"float"); (("phasing_MIR_shell","pdbx_loc_acentric"),"float"); (("phasing_MIR_shell","pdbx_power_centric"),"float"); (("phasing_MIR_shell","pdbx_power_acentric"),"float"); (("phasing_MIR_shell","pdbx_R_kraut_centric"),"float"); (("phasing_MIR_shell","pdbx_R_kraut_acentric"),"float"); (("phasing_MIR_shell","pdbx_R_cullis_centric"),"float"); (("phasing_MIR_shell","pdbx_R_cullis_acentric"),"float"); 
    (("phasing_set","cell_angle_alpha"),"float"); (("phasing_set","cell_angle_beta"),"float"); (("phasing_set","cell_angle_gamma"),"float"); (("phasing_set","cell_length_a"),"float"); (("phasing_set","cell_length_b"),"float"); (("phasing_set","cell_length_c"),"float"); (("phasing_set","detector_specific"),"text"); (("phasing_set","detector_type"),"text"); (("phasing_set","id"),"line"); (("phasing_set","radiation_source_specific"),"text"); (("phasing_set","radiation_wavelength"),"float"); (("phasing_set","temp"),"float"); (("phasing_set","pdbx_temp_details"),"text"); (("phasing_set","pdbx_d_res_high"),"float"); (("phasing_set","pdbx_d_res_low"),"float"); 
    (("phasing_set_refln","set_id"),"line"); (("phasing_set_refln","F_meas"),"float"); (("phasing_set_refln","F_meas_au"),"float"); (("phasing_set_refln","F_meas_sigma"),"float"); (("phasing_set_refln","F_meas_sigma_au"),"float"); (("phasing_set_refln","index_h"),"int"); (("phasing_set_refln","index_k"),"int"); (("phasing_set_refln","index_l"),"int"); 
    (("publ","entry_id"),"code"); (("publ","contact_author"),"text"); (("publ","contact_author_address"),"text"); (("publ","contact_author_email"),"line"); (("publ","contact_author_fax"),"line"); (("publ","contact_author_name"),"text"); (("publ","contact_author_phone"),"line"); (("publ","contact_letter"),"text"); (("publ","manuscript_creation"),"text"); (("publ","manuscript_processed"),"text"); (("publ","manuscript_text"),"text"); (("publ","requested_category"),"line"); (("publ","requested_coeditor_name"),"line"); (("publ","requested_journal"),"line"); (("publ","section_abstract"),"text"); (("publ","section_acknowledgements"),"text"); (("publ","section_comment"),"text"); (("publ","section_discussion"),"text"); (("publ","section_experimental"),"text"); (("publ","section_exptl_prep"),"text"); (("publ","section_exptl_refinement"),"text"); (("publ","section_exptl_solution"),"text"); (("publ","section_figure_captions"),"text"); (("publ","section_introduction"),"text"); (("publ","section_references"),"text"); (("publ","section_synopsis"),"text"); (("publ","section_table_legends"),"text"); (("publ","section_title"),"text"); (("publ","section_title_footnote"),"text"); 
    (("publ_author","address"),"text"); (("publ_author","email"),"text"); (("publ_author","footnote"),"line"); (("publ_author","name"),"line"); (("publ_author","id_iucr"),"code"); 
    (("publ_body","contents"),"text"); (("publ_body","element"),"code"); (("publ_body","format"),"code"); (("publ_body","label"),"code"); (("publ_body","title"),"text"); 
    (("publ_manuscript_incl","entry_id"),"code"); (("publ_manuscript_incl","extra_defn"),"line"); (("publ_manuscript_incl","extra_info"),"text"); (("publ_manuscript_incl","extra_item"),"line"); 
    (("refine","aniso_B[1][1]"),"float"); (("refine","aniso_B[1][2]"),"float"); (("refine","aniso_B[1][3]"),"float"); (("refine","aniso_B[2][2]"),"float"); (("refine","aniso_B[2][3]"),"float"); (("refine","aniso_B[3][3]"),"float"); (("refine","B_iso_max"),"float"); (("refine","B_iso_mean"),"float"); (("refine","B_iso_min"),"float"); (("refine","correlation_coeff_Fo_to_Fc"),"float"); (("refine","correlation_coeff_Fo_to_Fc_free"),"float"); (("refine","details"),"text"); (("refine","diff_density_max"),"float"); (("refine","diff_density_max_esd"),"float"); (("refine","diff_density_min"),"float"); (("refine","diff_density_min_esd"),"float"); (("refine","diff_density_rms"),"float"); (("refine","diff_density_rms_esd"),"float"); (("refine","entry_id"),"code"); (("refine","pdbx_refine_id"),"line"); (("refine","ls_abs_structure_details"),"text"); (("refine","ls_abs_structure_Flack"),"float"); (("refine","ls_abs_structure_Flack_esd"),"float"); (("refine","ls_abs_structure_Rogers"),"float"); (("refine","ls_abs_structure_Rogers_esd"),"float"); (("refine","ls_d_res_high"),"float"); (("refine","ls_d_res_low"),"float"); (("refine","ls_extinction_coef"),"float"); (("refine","ls_extinction_coef_esd"),"float"); (("refine","ls_extinction_expression"),"text"); (("refine","ls_extinction_method"),"text"); (("refine","ls_goodness_of_fit_all"),"float"); (("refine","ls_goodness_of_fit_all_esd"),"float"); (("refine","ls_goodness_of_fit_obs"),"float"); (("refine","ls_goodness_of_fit_obs_esd"),"float"); (("refine","ls_hydrogen_treatment"),"ucode"); (("refine","ls_matrix_type"),"ucode"); (("refine","ls_number_constraints"),"int"); (("refine","ls_number_parameters"),"int"); (("refine","ls_number_reflns_all"),"int"); (("refine","ls_number_reflns_obs"),"int"); (("refine","ls_number_reflns_R_free"),"int"); (("refine","ls_number_reflns_R_work"),"int"); (("refine","ls_number_restraints"),"int"); (("refine","ls_percent_reflns_obs"),"float"); (("refine","ls_percent_reflns_R_free"),"float"); (("refine","ls_R_factor_all"),"float"); (("refine","ls_R_factor_obs"),"float"); (("refine","ls_R_factor_R_free"),"float"); (("refine","ls_R_factor_R_free_error"),"float"); (("refine","ls_R_factor_R_free_error_details"),"text"); (("refine","ls_R_factor_R_work"),"float"); (("refine","ls_R_Fsqd_factor_obs"),"float"); (("refine","ls_R_I_factor_obs"),"float"); (("refine","ls_redundancy_reflns_all"),"float"); (("refine","ls_redundancy_reflns_obs"),"float"); (("refine","ls_restrained_S_all"),"float"); (("refine","ls_restrained_S_obs"),"float"); (("refine","ls_shift_over_esd_max"),"float"); (("refine","ls_shift_over_esd_mean"),"float"); (("refine","ls_structure_factor_coef"),"ucode"); (("refine","ls_weighting_details"),"text"); (("refine","ls_weighting_scheme"),"ucode"); (("refine","ls_wR_factor_all"),"float"); (("refine","ls_wR_factor_obs"),"float"); (("refine","ls_wR_factor_R_free"),"float"); (("refine","ls_wR_factor_R_work"),"float"); (("refine","occupancy_max"),"float"); (("refine","occupancy_min"),"float"); (("refine","solvent_model_details"),"text"); (("refine","solvent_model_param_bsol"),"float"); (("refine","solvent_model_param_ksol"),"float"); (("refine","ls_R_factor_gt"),"float"); (("refine","ls_goodness_of_fit_gt"),"float"); (("refine","ls_goodness_of_fit_ref"),"float"); (("refine","ls_shift_over_su_max"),"float"); (("refine","ls_shift_over_su_max_lt"),"float"); (("refine","ls_shift_over_su_mean"),"float"); (("refine","ls_shift_over_su_mean_lt"),"float"); (("refine","pdbx_ls_sigma_I"),"float"); (("refine","pdbx_ls_sigma_F"),"float"); (("refine","pdbx_ls_sigma_Fsqd"),"float"); (("refine","pdbx_data_cutoff_high_absF"),"float"); (("refine","pdbx_data_cutoff_high_rms_absF"),"float"); (("refine","pdbx_data_cutoff_low_absF"),"float"); (("refine","pdbx_isotropic_thermal_model"),"text"); (("refine","pdbx_ls_cross_valid_method"),"text"); (("refine","pdbx_method_to_determine_struct"),"text"); (("refine","pdbx_starting_model"),"text"); (("refine","pdbx_stereochemistry_target_values"),"text"); (("refine","pdbx_R_Free_selection_details"),"text"); (("refine","pdbx_stereochem_target_val_spec_case"),"text"); (("refine","pdbx_overall_ESU_R"),"float"); (("refine","pdbx_overall_ESU_R_Free"),"float"); (("refine","pdbx_solvent_vdw_probe_radii"),"float"); (("refine","pdbx_solvent_ion_probe_radii"),"float"); (("refine","pdbx_solvent_shrinkage_radii"),"float"); (("refine","pdbx_real_space_R"),"float"); (("refine","pdbx_density_correlation"),"float"); (("refine","pdbx_pd_number_of_powder_patterns"),"int"); (("refine","pdbx_pd_number_of_points"),"int"); (("refine","pdbx_pd_meas_number_of_points"),"int"); (("refine","pdbx_pd_proc_ls_prof_R_factor"),"float"); (("refine","pdbx_pd_proc_ls_prof_wR_factor"),"float"); (("refine","pdbx_pd_Marquardt_correlation_coeff"),"float"); (("refine","pdbx_pd_Fsqrd_R_factor"),"float"); (("refine","pdbx_pd_ls_matrix_band_width"),"int"); (("refine","pdbx_overall_phase_error"),"float"); (("refine","pdbx_overall_SU_R_free_Cruickshank_DPI"),"float"); (("refine","pdbx_overall_SU_R_free_Blow_DPI"),"float"); (("refine","pdbx_overall_SU_R_Blow_DPI"),"float"); (("refine","pdbx_TLS_residual_ADP_flag"),"line"); (("refine","pdbx_diffrn_id"),"code"); (("refine","overall_SU_B"),"float"); (("refine","overall_SU_ML"),"float"); (("refine","overall_SU_R_Cruickshank_DPI"),"float"); (("refine","overall_SU_R_free"),"float"); (("refine","overall_FOM_free_R_set"),"float"); (("refine","overall_FOM_work_R_set"),"float"); (("refine","pdbx_average_fsc_overall"),"float"); (("refine","pdbx_average_fsc_work"),"float"); (("refine","pdbx_average_fsc_free"),"float"); (("refine","pdbx_overall_ESU_B"),"float"); (("refine","pdbx_overall_ESU_ML"),"float"); 
    (("refine_analyze","entry_id"),"code"); (("refine_analyze","pdbx_refine_id"),"line"); (("refine_analyze","Luzzati_coordinate_error_free"),"float"); (("refine_analyze","Luzzati_coordinate_error_obs"),"float"); (("refine_analyze","Luzzati_d_res_low_free"),"float"); (("refine_analyze","Luzzati_d_res_low_obs"),"float"); (("refine_analyze","Luzzati_sigma_a_free"),"float"); (("refine_analyze","Luzzati_sigma_a_free_details"),"text"); (("refine_analyze","Luzzati_sigma_a_obs"),"float"); (("refine_analyze","Luzzati_sigma_a_obs_details"),"text"); (("refine_analyze","number_disordered_residues"),"float"); (("refine_analyze","occupancy_sum_hydrogen"),"float"); (("refine_analyze","occupancy_sum_non_hydrogen"),"float"); (("refine_analyze","RG_d_res_high"),"float"); (("refine_analyze","RG_d_res_low"),"float"); (("refine_analyze","RG_free"),"float"); (("refine_analyze","RG_work"),"float"); (("refine_analyze","RG_free_work_ratio"),"float"); (("refine_analyze","pdbx_Luzzati_d_res_high_obs"),"float"); 
    (("refine_B_iso","pdbx_refine_id"),"line"); (("refine_B_iso","class"),"text"); (("refine_B_iso","details"),"text"); (("refine_B_iso","treatment"),"ucode"); (("refine_B_iso","value"),"float"); (("refine_B_iso","pdbx_residue_name"),"code"); (("refine_B_iso","pdbx_strand"),"code"); (("refine_B_iso","pdbx_residue_num"),"code"); 
    (("refine_funct_minimized","pdbx_refine_id"),"line"); (("refine_funct_minimized","number_terms"),"int"); (("refine_funct_minimized","residual"),"float"); (("refine_funct_minimized","type"),"line"); (("refine_funct_minimized","weight"),"float"); 
    (("refine_hist","pdbx_refine_id"),"line"); (("refine_hist","cycle_id"),"code"); (("refine_hist","details"),"text"); (("refine_hist","d_res_high"),"float"); (("refine_hist","d_res_low"),"float"); (("refine_hist","number_atoms_solvent"),"int"); (("refine_hist","number_atoms_total"),"int"); (("refine_hist","number_reflns_all"),"int"); (("refine_hist","number_reflns_obs"),"int"); (("refine_hist","number_reflns_R_free"),"int"); (("refine_hist","number_reflns_R_work"),"int"); (("refine_hist","R_factor_all"),"float"); (("refine_hist","R_factor_obs"),"float"); (("refine_hist","R_factor_R_free"),"float"); (("refine_hist","R_factor_R_work"),"float"); (("refine_hist","pdbx_number_residues_total"),"int"); (("refine_hist","pdbx_B_iso_mean_ligand"),"float"); (("refine_hist","pdbx_B_iso_mean_solvent"),"float"); (("refine_hist","pdbx_number_atoms_protein"),"int"); (("refine_hist","pdbx_number_atoms_nucleic_acid"),"int"); (("refine_hist","pdbx_number_atoms_ligand"),"int"); (("refine_hist","pdbx_number_atoms_lipid"),"int"); (("refine_hist","pdbx_number_atoms_carb"),"int"); (("refine_hist","pdbx_pseudo_atom_details"),"text"); (("refine_hist","pdbx_number_atoms_solvent"),"int"); (("refine_hist","pdbx_number_atoms_total"),"int"); 
    (("refine_ls_restr","pdbx_refine_id"),"line"); (("refine_ls_restr","criterion"),"text"); (("refine_ls_restr","dev_ideal"),"float"); (("refine_ls_restr","dev_ideal_target"),"float"); (("refine_ls_restr","number"),"int"); (("refine_ls_restr","rejects"),"int"); (("refine_ls_restr","type"),"line"); (("refine_ls_restr","weight"),"float"); (("refine_ls_restr","pdbx_restraint_function"),"text"); 
    (("refine_ls_restr_ncs","pdbx_refine_id"),"line"); (("refine_ls_restr_ncs","dom_id"),"code"); (("refine_ls_restr_ncs","ncs_model_details"),"text"); (("refine_ls_restr_ncs","rms_dev_B_iso"),"float"); (("refine_ls_restr_ncs","rms_dev_position"),"float"); (("refine_ls_restr_ncs","weight_B_iso"),"float"); (("refine_ls_restr_ncs","weight_position"),"float"); (("refine_ls_restr_ncs","pdbx_ordinal"),"int"); (("refine_ls_restr_ncs","pdbx_type"),"text"); (("refine_ls_restr_ncs","pdbx_asym_id"),"code"); (("refine_ls_restr_ncs","pdbx_auth_asym_id"),"code"); (("refine_ls_restr_ncs","pdbx_number"),"int"); (("refine_ls_restr_ncs","pdbx_rms"),"float"); (("refine_ls_restr_ncs","pdbx_weight"),"float"); (("refine_ls_restr_ncs","pdbx_ens_id"),"code"); 
    (("refine_ls_restr_type","distance_cutoff_high"),"float"); (("refine_ls_restr_type","distance_cutoff_low"),"float"); (("refine_ls_restr_type","type"),"line"); 
    (("refine_ls_shell","pdbx_refine_id"),"line"); (("refine_ls_shell","d_res_high"),"float"); (("refine_ls_shell","d_res_low"),"float"); (("refine_ls_shell","number_reflns_all"),"int"); (("refine_ls_shell","number_reflns_obs"),"int"); (("refine_ls_shell","number_reflns_R_free"),"int"); (("refine_ls_shell","number_reflns_R_work"),"int"); (("refine_ls_shell","percent_reflns_obs"),"float"); (("refine_ls_shell","percent_reflns_R_free"),"float"); (("refine_ls_shell","R_factor_all"),"float"); (("refine_ls_shell","R_factor_obs"),"float"); (("refine_ls_shell","R_factor_R_free"),"float"); (("refine_ls_shell","R_factor_R_free_error"),"float"); (("refine_ls_shell","R_factor_R_work"),"float"); (("refine_ls_shell","redundancy_reflns_all"),"float"); (("refine_ls_shell","redundancy_reflns_obs"),"float"); (("refine_ls_shell","wR_factor_all"),"float"); (("refine_ls_shell","wR_factor_obs"),"float"); (("refine_ls_shell","wR_factor_R_free"),"float"); (("refine_ls_shell","wR_factor_R_work"),"float"); (("refine_ls_shell","pdbx_total_number_of_bins_used"),"int"); (("refine_ls_shell","pdbx_phase_error"),"float"); (("refine_ls_shell","pdbx_fsc_work"),"float"); (("refine_ls_shell","pdbx_fsc_free"),"float"); 
    (("refine_occupancy","pdbx_refine_id"),"line"); (("refine_occupancy","class"),"text"); (("refine_occupancy","details"),"text"); (("refine_occupancy","treatment"),"ucode"); (("refine_occupancy","value"),"float"); 
    (("refln","A_calc"),"float"); (("refln","A_calc_au"),"float"); (("refln","A_meas"),"float"); (("refln","A_meas_au"),"float"); (("refln","B_calc"),"float"); (("refln","B_calc_au"),"float"); (("refln","B_meas"),"float"); (("refln","B_meas_au"),"float"); (("refln","crystal_id"),"code"); (("refln","F_calc"),"float"); (("refln","F_calc_au"),"float"); (("refln","F_meas"),"float"); (("refln","F_meas_au"),"float"); (("refln","F_meas_sigma"),"float"); (("refln","F_meas_sigma_au"),"float"); (("refln","F_squared_calc"),"float"); (("refln","F_squared_meas"),"float"); (("refln","F_squared_sigma"),"float"); (("refln","fom"),"float"); (("refln","index_h"),"int"); (("refln","index_k"),"int"); (("refln","index_l"),"int"); (("refln","intensity_calc"),"float"); (("refln","intensity_meas"),"float"); (("refln","intensity_sigma"),"float"); (("refln","status"),"ucode"); (("refln","phase_calc"),"float"); (("refln","phase_meas"),"float"); (("refln","refinement_status"),"ucode"); (("refln","scale_group_code"),"line"); (("refln","sint_over_lambda"),"float"); (("refln","symmetry_epsilon"),"int"); (("refln","symmetry_multiplicity"),"int"); (("refln","wavelength"),"float"); (("refln","wavelength_id"),"code"); (("refln","class_code"),"code"); (("refln","d_spacing"),"float"); (("refln","include_status"),"code"); (("refln","mean_path_length_tbar"),"float"); (("refln","pdbx_F_calc_part_solvent"),"float"); (("refln","pdbx_phase_calc_part_solvent"),"float"); (("refln","pdbx_F_calc_with_solvent"),"float"); (("refln","pdbx_phase_calc_with_solvent"),"float"); (("refln","pdbx_anom_difference"),"float"); (("refln","pdbx_anom_difference_sigma"),"float"); (("refln","pdbx_I_plus"),"float"); (("refln","pdbx_I_minus"),"float"); (("refln","pdbx_F_plus"),"float"); (("refln","pdbx_F_minus"),"float"); (("refln","pdbx_I_plus_sigma"),"float"); (("refln","pdbx_I_minus_sigma"),"float"); (("refln","pdbx_F_minus_sigma"),"float"); (("refln","pdbx_F_plus_sigma"),"float"); (("refln","pdbx_HL_A_iso"),"float"); (("refln","pdbx_HL_B_iso"),"float"); (("refln","pdbx_HL_C_iso"),"float"); (("refln","pdbx_HL_D_iso"),"float"); (("refln","pdbx_fiber_layer"),"int"); (("refln","pdbx_fiber_coordinate"),"float"); (("refln","pdbx_fiber_F_meas_au"),"float"); (("refln","pdbx_FWT"),"float"); (("refln","pdbx_PHWT"),"float"); (("refln","pdbx_DELFWT"),"float"); (("refln","pdbx_DELPHWT"),"float"); (("refln","pdbx_diffrn_id"),"code"); (("refln","pdbx_r_free_flag"),"int"); (("refln","pdbx_anomalous_diff"),"float"); (("refln","pdbx_anomalous_diff_sigma"),"float"); (("refln","pdbx_phase_cycle"),"float"); (("refln","pdbx_cos_phase_calc"),"float"); (("refln","pdbx_sin_phase_calc"),"float"); 
    (("refln_sys_abs","I"),"float"); (("refln_sys_abs","I_over_sigmaI"),"float"); (("refln_sys_abs","index_h"),"int"); (("refln_sys_abs","index_k"),"int"); (("refln_sys_abs","index_l"),"int"); (("refln_sys_abs","sigmaI"),"float"); 
    (("reflns","B_iso_Wilson_estimate"),"float"); (("reflns","entry_id"),"code"); (("reflns","data_reduction_details"),"text"); (("reflns","data_reduction_method"),"text"); (("reflns","d_resolution_high"),"float"); (("reflns","d_resolution_low"),"float"); (("reflns","details"),"text"); (("reflns","limit_h_max"),"int"); (("reflns","limit_h_min"),"int"); (("reflns","limit_k_max"),"int"); (("reflns","limit_k_min"),"int"); (("reflns","limit_l_max"),"int"); (("reflns","limit_l_min"),"int"); (("reflns","number_all"),"int"); (("reflns","number_obs"),"int"); (("reflns","observed_criterion"),"text"); (("reflns","observed_criterion_F_max"),"float"); (("reflns","observed_criterion_F_min"),"float"); (("reflns","observed_criterion_I_max"),"float"); (("reflns","observed_criterion_I_min"),"float"); (("reflns","observed_criterion_sigma_F"),"float"); (("reflns","observed_criterion_sigma_I"),"float"); (("reflns","percent_possible_obs"),"float"); (("reflns","R_free_details"),"text"); (("reflns","Rmerge_F_all"),"float"); (("reflns","Rmerge_F_obs"),"float"); (("reflns","Friedel_coverage"),"float"); (("reflns","number_gt"),"int"); (("reflns","threshold_expression"),"text"); (("reflns","pdbx_redundancy"),"float"); (("reflns","pdbx_Rmerge_I_obs"),"float"); (("reflns","pdbx_Rmerge_I_all"),"float"); (("reflns","pdbx_Rsym_value"),"float"); (("reflns","pdbx_netI_over_av_sigmaI"),"float"); (("reflns","pdbx_netI_over_sigmaI"),"float"); (("reflns","pdbx_res_netI_over_av_sigmaI_2"),"float"); (("reflns","pdbx_res_netI_over_sigmaI_2"),"float"); (("reflns","pdbx_chi_squared"),"float"); (("reflns","pdbx_scaling_rejects"),"int"); (("reflns","pdbx_d_res_high_opt"),"float"); (("reflns","pdbx_d_res_low_opt"),"float"); (("reflns","pdbx_d_res_opt_method"),"text"); (("reflns","phase_calculation_details"),"text"); (("reflns","pdbx_Rrim_I_all"),"float"); (("reflns","pdbx_Rpim_I_all"),"float"); (("reflns","pdbx_d_opt"),"float"); (("reflns","pdbx_number_measured_all"),"int"); (("reflns","pdbx_diffrn_id"),"code"); (("reflns","pdbx_ordinal"),"int"); (("reflns","pdbx_CC_half"),"float"); (("reflns","pdbx_R_split"),"float"); (("reflns","pdbx_redundancy_reflns_obs"),"float"); (("reflns","pdbx_number_anomalous"),"int"); (("reflns","pdbx_Rrim_I_all_anomalous"),"float"); (("reflns","pdbx_Rpim_I_all_anomalous"),"float"); (("reflns","pdbx_Rmerge_I_anomalous"),"float"); 
    (("reflns_scale","group_code"),"line"); (("reflns_scale","meas_F"),"float"); (("reflns_scale","meas_F_squared"),"float"); (("reflns_scale","meas_intensity"),"float"); 
    (("reflns_shell","d_res_high"),"float"); (("reflns_shell","d_res_low"),"float"); (("reflns_shell","meanI_over_sigI_all"),"float"); (("reflns_shell","meanI_over_sigI_obs"),"float"); (("reflns_shell","number_measured_all"),"int"); (("reflns_shell","number_measured_obs"),"int"); (("reflns_shell","number_possible"),"int"); (("reflns_shell","number_unique_all"),"int"); (("reflns_shell","number_unique_obs"),"int"); (("reflns_shell","percent_possible_all"),"float"); (("reflns_shell","percent_possible_obs"),"float"); (("reflns_shell","Rmerge_F_all"),"float"); (("reflns_shell","Rmerge_F_obs"),"float"); (("reflns_shell","Rmerge_I_all"),"float"); (("reflns_shell","Rmerge_I_obs"),"float"); (("reflns_shell","meanI_over_sigI_gt"),"float"); (("reflns_shell","meanI_over_uI_all"),"float"); (("reflns_shell","meanI_over_uI_gt"),"float"); (("reflns_shell","number_measured_gt"),"int"); (("reflns_shell","number_unique_gt"),"int"); (("reflns_shell","percent_possible_gt"),"float"); (("reflns_shell","Rmerge_F_gt"),"float"); (("reflns_shell","Rmerge_I_gt"),"float"); (("reflns_shell","pdbx_redundancy"),"float"); (("reflns_shell","pdbx_Rsym_value"),"float"); (("reflns_shell","pdbx_chi_squared"),"float"); (("reflns_shell","pdbx_netI_over_sigmaI_all"),"float"); (("reflns_shell","pdbx_netI_over_sigmaI_obs"),"float"); (("reflns_shell","pdbx_Rrim_I_all"),"float"); (("reflns_shell","pdbx_Rpim_I_all"),"float"); (("reflns_shell","pdbx_rejects"),"int"); (("reflns_shell","pdbx_ordinal"),"int"); (("reflns_shell","pdbx_diffrn_id"),"code"); (("reflns_shell","pdbx_CC_half"),"float"); (("reflns_shell","pdbx_R_split"),"float"); (("reflns_shell","pdbx_redundancy_reflns_obs"),"float"); (("reflns_shell","pdbx_number_anomalous"),"int"); (("reflns_shell","pdbx_Rrim_I_all_anomalous"),"float"); (("reflns_shell","pdbx_Rpim_I_all_anomalous"),"float"); (("reflns_shell","pdbx_Rmerge_I_all_anomalous"),"float"); 
    (("software","citation_id"),"code"); (("software","classification"),"uline"); (("software","compiler_name"),"line"); (("software","compiler_version"),"line"); (("software","contact_author"),"line"); (("software","contact_author_email"),"line"); (("software","date"),"line"); (("software","description"),"line"); (("software","dependencies"),"line"); (("software","hardware"),"line"); (("software","language"),"uline"); (("software","location"),"line"); (("software","mods"),"line"); (("software","name"),"text"); (("software","os"),"text"); (("software","os_version"),"text"); (("software","type"),"uline"); (("software","version"),"line"); (("software","pdbx_ordinal"),"int"); 
    (("struct","entry_id"),"code"); (("struct","title"),"text"); (("struct","pdbx_descriptor"),"text"); (("struct","pdbx_model_details"),"text"); (("struct","pdbx_formula_weight"),"float"); (("struct","pdbx_formula_weight_method"),"line"); (("struct","pdbx_model_type_details"),"line"); (("struct","pdbx_CASP_flag"),"uchar1"); (("struct","pdbx_details"),"text"); (("struct","pdbx_title_text"),"text"); 
    (("struct_asym","details"),"text"); (("struct_asym","entity_id"),"code"); (("struct_asym","id"),"code"); (("struct_asym","pdbx_modified"),"text"); (("struct_asym","pdbx_blank_PDB_chainid_flag"),"code"); (("struct_asym","pdbx_PDB_id"),"code"); (("struct_asym","pdbx_alt_id"),"code"); (("struct_asym","pdbx_type"),"ucode"); (("struct_asym","pdbx_order"),"int"); (("struct_asym","pdbx_fraction_per_asym_unit"),"text"); (("struct_asym","pdbx_missing_num_begin_of_chain_not_in_seqres"),"int"); (("struct_asym","pdbx_missing_num_end_of_chain_not_in_seqres"),"int"); (("struct_asym","pdbx_missing_num_begin_of_chain_in_seqres"),"int"); 
    (("struct_biol","details"),"text"); (("struct_biol","id"),"line"); (("struct_biol","pdbx_parent_biol_id"),"line"); (("struct_biol","pdbx_formula_weight"),"float"); (("struct_biol","pdbx_formula_weight_method"),"line"); (("struct_biol","pdbx_aggregation_state"),"line"); (("struct_biol","pdbx_assembly_method"),"text"); 
    (("struct_biol_gen","asym_id"),"code"); (("struct_biol_gen","biol_id"),"line"); (("struct_biol_gen","details"),"text"); (("struct_biol_gen","symmetry"),"symop"); (("struct_biol_gen","pdbx_full_symmetry_operation"),"code"); (("struct_biol_gen","pdbx_PDB_order"),"int"); (("struct_biol_gen","pdbx_new_asym_id"),"code"); (("struct_biol_gen","pdbx_new_pdb_asym_id"),"code"); (("struct_biol_gen","pdbx_color_red"),"float"); (("struct_biol_gen","pdbx_color_green"),"float"); (("struct_biol_gen","pdbx_color_blue"),"float"); (("struct_biol_gen","pdbx_after_begin_residue_no"),"code"); (("struct_biol_gen","pdbx_after_end_residue_no"),"code"); (("struct_biol_gen","pdbx_before_begin_residue_no"),"code"); (("struct_biol_gen","pdbx_before_end_residue_no"),"code"); 
    (("struct_biol_keywords","biol_id"),"line"); (("struct_biol_keywords","text"),"text"); 
    (("struct_biol_view","biol_id"),"line"); (("struct_biol_view","details"),"text"); (("struct_biol_view","id"),"line"); (("struct_biol_view","rot_matrix[1][1]"),"float"); (("struct_biol_view","rot_matrix[1][2]"),"float"); (("struct_biol_view","rot_matrix[1][3]"),"float"); (("struct_biol_view","rot_matrix[2][1]"),"float"); (("struct_biol_view","rot_matrix[2][2]"),"float"); (("struct_biol_view","rot_matrix[2][3]"),"float"); (("struct_biol_view","rot_matrix[3][1]"),"float"); (("struct_biol_view","rot_matrix[3][2]"),"float"); (("struct_biol_view","rot_matrix[3][3]"),"float"); (("struct_biol_view","pdbx_vector[1]"),"float"); (("struct_biol_view","pdbx_vector[2]"),"float"); (("struct_biol_view","pdbx_vector[3]"),"float"); 
    (("struct_conf","beg_label_asym_id"),"code"); (("struct_conf","beg_label_comp_id"),"ucode"); (("struct_conf","beg_label_seq_id"),"int"); (("struct_conf","beg_auth_asym_id"),"code"); (("struct_conf","beg_auth_comp_id"),"code"); (("struct_conf","beg_auth_seq_id"),"code"); (("struct_conf","conf_type_id"),"ucode"); (("struct_conf","details"),"text"); (("struct_conf","end_label_asym_id"),"code"); (("struct_conf","end_label_comp_id"),"ucode"); (("struct_conf","end_label_seq_id"),"int"); (("struct_conf","end_auth_asym_id"),"code"); (("struct_conf","end_auth_comp_id"),"code"); (("struct_conf","end_auth_seq_id"),"code"); (("struct_conf","id"),"code"); (("struct_conf","pdbx_beg_PDB_ins_code"),"code"); (("struct_conf","pdbx_end_PDB_ins_code"),"code"); (("struct_conf","pdbx_PDB_helix_class"),"line"); (("struct_conf","pdbx_PDB_helix_length"),"int"); (("struct_conf","pdbx_PDB_helix_id"),"code"); 
    (("struct_conf_type","criteria"),"text"); (("struct_conf_type","id"),"ucode"); (("struct_conf_type","reference"),"text"); 
    (("struct_conn","conn_type_id"),"ucode"); (("struct_conn","details"),"text"); (("struct_conn","id"),"code"); (("struct_conn","ptnr1_label_alt_id"),"code"); (("struct_conn","ptnr1_label_asym_id"),"code"); (("struct_conn","ptnr1_label_atom_id"),"atcode"); (("struct_conn","ptnr1_label_comp_id"),"ucode"); (("struct_conn","ptnr1_label_seq_id"),"int"); (("struct_conn","ptnr1_auth_asym_id"),"code"); (("struct_conn","ptnr1_auth_atom_id"),"atcode"); (("struct_conn","ptnr1_auth_comp_id"),"code"); (("struct_conn","ptnr1_auth_seq_id"),"code"); (("struct_conn","ptnr1_role"),"uline"); (("struct_conn","ptnr1_symmetry"),"symop"); (("struct_conn","ptnr2_label_alt_id"),"code"); (("struct_conn","ptnr2_label_asym_id"),"code"); (("struct_conn","ptnr2_label_atom_id"),"atcode"); (("struct_conn","ptnr2_label_comp_id"),"ucode"); (("struct_conn","ptnr2_label_seq_id"),"int"); (("struct_conn","ptnr2_auth_asym_id"),"code"); (("struct_conn","ptnr2_auth_atom_id"),"atcode"); (("struct_conn","ptnr2_auth_comp_id"),"code"); (("struct_conn","ptnr2_auth_seq_id"),"code"); (("struct_conn","ptnr2_role"),"uline"); (("struct_conn","ptnr2_symmetry"),"symop"); (("struct_conn","pdbx_ptnr1_PDB_ins_code"),"code"); (("struct_conn","pdbx_ptnr1_auth_alt_id"),"code"); (("struct_conn","pdbx_ptnr1_label_alt_id"),"code"); (("struct_conn","pdbx_ptnr1_standard_comp_id"),"code"); (("struct_conn","pdbx_ptnr2_PDB_ins_code"),"code"); (("struct_conn","pdbx_ptnr2_auth_alt_id"),"code"); (("struct_conn","pdbx_ptnr2_label_alt_id"),"code"); (("struct_conn","pdbx_ptnr3_auth_alt_id"),"code"); (("struct_conn","pdbx_ptnr3_auth_asym_id"),"code"); (("struct_conn","pdbx_ptnr3_auth_atom_id"),"atcode"); (("struct_conn","pdbx_ptnr3_auth_comp_id"),"code"); (("struct_conn","pdbx_ptnr3_PDB_ins_code"),"code"); (("struct_conn","pdbx_ptnr3_auth_seq_id"),"code"); (("struct_conn","pdbx_ptnr3_label_alt_id"),"code"); (("struct_conn","pdbx_ptnr3_label_asym_id"),"code"); (("struct_conn","pdbx_ptnr3_label_atom_id"),"atcode"); (("struct_conn","pdbx_ptnr3_label_comp_id"),"ucode"); (("struct_conn","pdbx_ptnr3_label_seq_id"),"int"); (("struct_conn","pdbx_PDB_id"),"code"); (("struct_conn","pdbx_dist_value"),"float"); (("struct_conn","pdbx_value_order"),"ucode"); (("struct_conn","pdbx_leaving_atom_flag"),"code"); (("struct_conn","pdbx_ptnr1_mod_name"),"line"); (("struct_conn","pdbx_ptnr1_sugar_name"),"line"); (("struct_conn","pdbx_ptnr1_replaced_atom"),"code"); (("struct_conn","pdbx_ptnr3_auth_ins_code"),"code"); 
    (("struct_conn_type","criteria"),"text"); (("struct_conn_type","id"),"ucode"); (("struct_conn_type","reference"),"text"); 
    (("struct_keywords","entry_id"),"code"); (("struct_keywords","text"),"text"); (("struct_keywords","pdbx_keywords"),"line"); (("struct_keywords","pdbx_details"),"text"); 
    (("struct_mon_details","entry_id"),"code"); (("struct_mon_details","prot_cis"),"float"); (("struct_mon_details","RSCC"),"text"); (("struct_mon_details","RSR"),"text"); 
    (("struct_mon_nucl","alpha"),"float"); (("struct_mon_nucl","auth_asym_id"),"code"); (("struct_mon_nucl","auth_comp_id"),"code"); (("struct_mon_nucl","auth_seq_id"),"code"); (("struct_mon_nucl","beta"),"float"); (("struct_mon_nucl","chi1"),"float"); (("struct_mon_nucl","chi2"),"float"); (("struct_mon_nucl","delta"),"float"); (("struct_mon_nucl","details"),"float"); (("struct_mon_nucl","epsilon"),"float"); (("struct_mon_nucl","gamma"),"float"); (("struct_mon_nucl","label_alt_id"),"code"); (("struct_mon_nucl","label_asym_id"),"code"); (("struct_mon_nucl","label_comp_id"),"ucode"); (("struct_mon_nucl","label_seq_id"),"int"); (("struct_mon_nucl","mean_B_all"),"float"); (("struct_mon_nucl","mean_B_base"),"float"); (("struct_mon_nucl","mean_B_phos"),"float"); (("struct_mon_nucl","mean_B_sugar"),"float"); (("struct_mon_nucl","nu0"),"float"); (("struct_mon_nucl","nu1"),"float"); (("struct_mon_nucl","nu2"),"float"); (("struct_mon_nucl","nu3"),"float"); (("struct_mon_nucl","nu4"),"float"); (("struct_mon_nucl","P"),"float"); (("struct_mon_nucl","RSCC_all"),"float"); (("struct_mon_nucl","RSCC_base"),"float"); (("struct_mon_nucl","RSCC_phos"),"float"); (("struct_mon_nucl","RSCC_sugar"),"float"); (("struct_mon_nucl","RSR_all"),"float"); (("struct_mon_nucl","RSR_base"),"float"); (("struct_mon_nucl","RSR_phos"),"float"); (("struct_mon_nucl","RSR_sugar"),"float"); (("struct_mon_nucl","tau0"),"float"); (("struct_mon_nucl","tau1"),"float"); (("struct_mon_nucl","tau2"),"float"); (("struct_mon_nucl","tau3"),"float"); (("struct_mon_nucl","tau4"),"float"); (("struct_mon_nucl","taum"),"float"); (("struct_mon_nucl","zeta"),"float"); 
    (("struct_mon_prot","chi1"),"float"); (("struct_mon_prot","chi2"),"float"); (("struct_mon_prot","chi3"),"float"); (("struct_mon_prot","chi4"),"float"); (("struct_mon_prot","chi5"),"float"); (("struct_mon_prot","details"),"float"); (("struct_mon_prot","label_alt_id"),"code"); (("struct_mon_prot","label_asym_id"),"code"); (("struct_mon_prot","label_comp_id"),"ucode"); (("struct_mon_prot","label_seq_id"),"int"); (("struct_mon_prot","auth_asym_id"),"code"); (("struct_mon_prot","auth_comp_id"),"code"); (("struct_mon_prot","auth_seq_id"),"code"); (("struct_mon_prot","RSCC_all"),"float"); (("struct_mon_prot","RSCC_main"),"float"); (("struct_mon_prot","RSCC_side"),"float"); (("struct_mon_prot","RSR_all"),"float"); (("struct_mon_prot","RSR_main"),"float"); (("struct_mon_prot","RSR_side"),"float"); (("struct_mon_prot","mean_B_all"),"float"); (("struct_mon_prot","mean_B_main"),"float"); (("struct_mon_prot","mean_B_side"),"float"); (("struct_mon_prot","omega"),"float"); (("struct_mon_prot","phi"),"float"); (("struct_mon_prot","psi"),"float"); 
    (("struct_mon_prot_cis","label_alt_id"),"code"); (("struct_mon_prot_cis","label_asym_id"),"code"); (("struct_mon_prot_cis","label_comp_id"),"ucode"); (("struct_mon_prot_cis","label_seq_id"),"int"); (("struct_mon_prot_cis","auth_asym_id"),"code"); (("struct_mon_prot_cis","auth_comp_id"),"code"); (("struct_mon_prot_cis","auth_seq_id"),"code"); (("struct_mon_prot_cis","pdbx_auth_asym_id_2"),"code"); (("struct_mon_prot_cis","pdbx_auth_comp_id_2"),"code"); (("struct_mon_prot_cis","pdbx_auth_seq_id_2"),"code"); (("struct_mon_prot_cis","pdbx_label_asym_id_2"),"code"); (("struct_mon_prot_cis","pdbx_label_comp_id_2"),"ucode"); (("struct_mon_prot_cis","pdbx_label_seq_id_2"),"int"); (("struct_mon_prot_cis","pdbx_PDB_ins_code"),"code"); (("struct_mon_prot_cis","pdbx_PDB_ins_code_2"),"code"); (("struct_mon_prot_cis","pdbx_PDB_model_num"),"int"); (("struct_mon_prot_cis","pdbx_omega_angle"),"code"); (("struct_mon_prot_cis","pdbx_id"),"code"); (("struct_mon_prot_cis","pdbx_auth_ins_code"),"code"); (("struct_mon_prot_cis","pdbx_auth_ins_code_2"),"code"); 
    (("struct_ncs_dom","details"),"text"); (("struct_ncs_dom","id"),"code"); (("struct_ncs_dom","pdbx_ens_id"),"code"); 
    (("struct_ncs_dom_lim","beg_label_alt_id"),"code"); (("struct_ncs_dom_lim","beg_label_asym_id"),"code"); (("struct_ncs_dom_lim","beg_label_comp_id"),"code"); (("struct_ncs_dom_lim","beg_label_seq_id"),"int"); (("struct_ncs_dom_lim","beg_auth_asym_id"),"code"); (("struct_ncs_dom_lim","beg_auth_comp_id"),"code"); (("struct_ncs_dom_lim","beg_auth_seq_id"),"code"); (("struct_ncs_dom_lim","dom_id"),"code"); (("struct_ncs_dom_lim","end_label_alt_id"),"code"); (("struct_ncs_dom_lim","end_label_asym_id"),"code"); (("struct_ncs_dom_lim","end_label_comp_id"),"code"); (("struct_ncs_dom_lim","end_label_seq_id"),"int"); (("struct_ncs_dom_lim","end_auth_asym_id"),"code"); (("struct_ncs_dom_lim","end_auth_comp_id"),"code"); (("struct_ncs_dom_lim","end_auth_seq_id"),"code"); (("struct_ncs_dom_lim","selection_details"),"text"); (("struct_ncs_dom_lim","pdbx_component_id"),"int"); (("struct_ncs_dom_lim","pdbx_refine_code"),"float"); (("struct_ncs_dom_lim","pdbx_ens_id"),"code"); 
    (("struct_ncs_ens","details"),"text"); (("struct_ncs_ens","id"),"code"); (("struct_ncs_ens","point_group"),"line"); 
    (("struct_ncs_ens_gen","dom_id_1"),"code"); (("struct_ncs_ens_gen","dom_id_2"),"code"); (("struct_ncs_ens_gen","ens_id"),"code"); (("struct_ncs_ens_gen","oper_id"),"code"); 
    (("struct_ncs_oper","code"),"code"); (("struct_ncs_oper","details"),"text"); (("struct_ncs_oper","id"),"code"); (("struct_ncs_oper","matrix[1][1]"),"float"); (("struct_ncs_oper","matrix[1][2]"),"float"); (("struct_ncs_oper","matrix[1][3]"),"float"); (("struct_ncs_oper","matrix[2][1]"),"float"); (("struct_ncs_oper","matrix[2][2]"),"float"); (("struct_ncs_oper","matrix[2][3]"),"float"); (("struct_ncs_oper","matrix[3][1]"),"float"); (("struct_ncs_oper","matrix[3][2]"),"float"); (("struct_ncs_oper","matrix[3][3]"),"float"); (("struct_ncs_oper","vector[1]"),"float"); (("struct_ncs_oper","vector[2]"),"float"); (("struct_ncs_oper","vector[3]"),"float"); 
    (("struct_ref","biol_id"),"line"); (("struct_ref","db_code"),"line"); (("struct_ref","db_name"),"line"); (("struct_ref","details"),"text"); (("struct_ref","entity_id"),"code"); (("struct_ref","id"),"code"); (("struct_ref","seq_align"),"ucode"); (("struct_ref","seq_dif"),"ucode"); (("struct_ref","pdbx_db_accession"),"code"); (("struct_ref","pdbx_db_isoform"),"code"); (("struct_ref","pdbx_seq_one_letter_code"),"text"); (("struct_ref","pdbx_align_begin"),"code"); (("struct_ref","pdbx_align_end"),"code"); 
    (("struct_ref_seq","align_id"),"code"); (("struct_ref_seq","db_align_beg"),"int"); (("struct_ref_seq","db_align_end"),"int"); (("struct_ref_seq","details"),"text"); (("struct_ref_seq","ref_id"),"code"); (("struct_ref_seq","seq_align_beg"),"int"); (("struct_ref_seq","seq_align_end"),"int"); (("struct_ref_seq","pdbx_strand_id"),"code"); (("struct_ref_seq","pdbx_db_accession"),"code"); (("struct_ref_seq","pdbx_db_align_beg_ins_code"),"code"); (("struct_ref_seq","pdbx_db_align_end_ins_code"),"code"); (("struct_ref_seq","pdbx_PDB_id_code"),"code"); (("struct_ref_seq","pdbx_auth_seq_align_beg"),"code"); (("struct_ref_seq","pdbx_auth_seq_align_end"),"code"); (("struct_ref_seq","pdbx_seq_align_beg_ins_code"),"code"); (("struct_ref_seq","pdbx_seq_align_end_ins_code"),"code"); 
    (("struct_ref_seq_dif","align_id"),"code"); (("struct_ref_seq_dif","db_mon_id"),"ucode"); (("struct_ref_seq_dif","details"),"text"); (("struct_ref_seq_dif","mon_id"),"ucode"); (("struct_ref_seq_dif","seq_num"),"int"); (("struct_ref_seq_dif","pdbx_pdb_id_code"),"code"); (("struct_ref_seq_dif","pdbx_pdb_strand_id"),"code"); (("struct_ref_seq_dif","pdbx_pdb_ins_code"),"code"); (("struct_ref_seq_dif","pdbx_auth_seq_num"),"code"); (("struct_ref_seq_dif","pdbx_seq_db_name"),"code"); (("struct_ref_seq_dif","pdbx_seq_db_accession_code"),"code"); (("struct_ref_seq_dif","pdbx_seq_db_seq_num"),"code"); (("struct_ref_seq_dif","pdbx_ordinal"),"int"); 
    (("struct_sheet","details"),"text"); (("struct_sheet","id"),"code"); (("struct_sheet","number_strands"),"int"); (("struct_sheet","type"),"text"); 
    (("struct_sheet_hbond","range_1_beg_label_atom_id"),"atcode"); (("struct_sheet_hbond","range_1_beg_label_seq_id"),"int"); (("struct_sheet_hbond","range_1_end_label_atom_id"),"atcode"); (("struct_sheet_hbond","range_1_end_label_seq_id"),"int"); (("struct_sheet_hbond","range_2_beg_label_atom_id"),"atcode"); (("struct_sheet_hbond","range_2_beg_label_seq_id"),"int"); (("struct_sheet_hbond","range_2_end_label_atom_id"),"atcode"); (("struct_sheet_hbond","range_2_end_label_seq_id"),"int"); (("struct_sheet_hbond","range_1_beg_auth_atom_id"),"atcode"); (("struct_sheet_hbond","range_1_beg_auth_seq_id"),"code"); (("struct_sheet_hbond","range_1_end_auth_atom_id"),"atcode"); (("struct_sheet_hbond","range_1_end_auth_seq_id"),"code"); (("struct_sheet_hbond","range_2_beg_auth_atom_id"),"atcode"); (("struct_sheet_hbond","range_2_beg_auth_seq_id"),"code"); (("struct_sheet_hbond","range_2_end_auth_atom_id"),"atcode"); (("struct_sheet_hbond","range_2_end_auth_seq_id"),"code"); (("struct_sheet_hbond","range_id_1"),"code"); (("struct_sheet_hbond","range_id_2"),"code"); (("struct_sheet_hbond","sheet_id"),"code"); (("struct_sheet_hbond","pdbx_range_1_beg_auth_comp_id"),"code"); (("struct_sheet_hbond","pdbx_range_1_beg_auth_asym_id"),"code"); (("struct_sheet_hbond","pdbx_range_1_end_auth_comp_id"),"code"); (("struct_sheet_hbond","pdbx_range_1_end_auth_asym_id"),"code"); (("struct_sheet_hbond","pdbx_range_1_beg_label_comp_id"),"ucode"); (("struct_sheet_hbond","pdbx_range_1_beg_label_asym_id"),"code"); (("struct_sheet_hbond","pdbx_range_1_beg_PDB_ins_code"),"code"); (("struct_sheet_hbond","pdbx_range_1_end_label_comp_id"),"ucode"); (("struct_sheet_hbond","pdbx_range_1_end_label_asym_id"),"code"); (("struct_sheet_hbond","pdbx_range_1_end_PDB_ins_code"),"code"); (("struct_sheet_hbond","pdbx_range_2_beg_label_comp_id"),"ucode"); (("struct_sheet_hbond","pdbx_range_2_beg_label_asym_id"),"code"); (("struct_sheet_hbond","pdbx_range_2_beg_PDB_ins_code"),"code"); (("struct_sheet_hbond","pdbx_range_2_end_label_comp_id"),"ucode"); (("struct_sheet_hbond","pdbx_range_2_end_label_asym_id"),"code"); (("struct_sheet_hbond","pdbx_range_2_end_label_ins_code"),"code"); 
    (("struct_sheet_order","offset"),"int"); (("struct_sheet_order","range_id_1"),"code"); (("struct_sheet_order","range_id_2"),"code"); (("struct_sheet_order","sense"),"ucode"); (("struct_sheet_order","sheet_id"),"code"); 
    (("struct_sheet_range","beg_label_asym_id"),"code"); (("struct_sheet_range","beg_label_comp_id"),"ucode"); (("struct_sheet_range","beg_label_seq_id"),"int"); (("struct_sheet_range","end_label_asym_id"),"code"); (("struct_sheet_range","end_label_comp_id"),"ucode"); (("struct_sheet_range","end_label_seq_id"),"int"); (("struct_sheet_range","beg_auth_asym_id"),"code"); (("struct_sheet_range","beg_auth_comp_id"),"code"); (("struct_sheet_range","beg_auth_seq_id"),"code"); (("struct_sheet_range","end_auth_asym_id"),"code"); (("struct_sheet_range","end_auth_comp_id"),"code"); (("struct_sheet_range","end_auth_seq_id"),"code"); (("struct_sheet_range","id"),"code"); (("struct_sheet_range","sheet_id"),"code"); (("struct_sheet_range","symmetry"),"symop"); (("struct_sheet_range","pdbx_beg_PDB_ins_code"),"code"); (("struct_sheet_range","pdbx_end_PDB_ins_code"),"code"); 
    (("struct_sheet_topology","offset"),"int"); (("struct_sheet_topology","range_id_1"),"code"); (("struct_sheet_topology","range_id_2"),"code"); (("struct_sheet_topology","sense"),"ucode"); (("struct_sheet_topology","sheet_id"),"code"); 
    (("struct_site","details"),"text"); (("struct_site","id"),"line"); (("struct_site","pdbx_num_residues"),"int"); (("struct_site","pdbx_evidence_code"),"text"); (("struct_site","pdbx_auth_asym_id"),"code"); (("struct_site","pdbx_auth_comp_id"),"code"); (("struct_site","pdbx_auth_seq_id"),"code"); (("struct_site","pdbx_auth_ins_code"),"code"); 
    (("struct_site_gen","details"),"text"); (("struct_site_gen","id"),"line"); (("struct_site_gen","label_alt_id"),"code"); (("struct_site_gen","label_asym_id"),"code"); (("struct_site_gen","label_atom_id"),"atcode"); (("struct_site_gen","label_comp_id"),"ucode"); (("struct_site_gen","label_seq_id"),"int"); (("struct_site_gen","auth_asym_id"),"code"); (("struct_site_gen","auth_atom_id"),"atcode"); (("struct_site_gen","auth_comp_id"),"code"); (("struct_site_gen","auth_seq_id"),"code"); (("struct_site_gen","site_id"),"line"); (("struct_site_gen","symmetry"),"symop"); (("struct_site_gen","pdbx_auth_ins_code"),"code"); (("struct_site_gen","pdbx_num_res"),"int"); 
    (("struct_site_keywords","site_id"),"line"); (("struct_site_keywords","text"),"text"); 
    (("struct_site_view","details"),"text"); (("struct_site_view","id"),"line"); (("struct_site_view","rot_matrix[1][1]"),"float"); (("struct_site_view","rot_matrix[1][2]"),"float"); (("struct_site_view","rot_matrix[1][3]"),"float"); (("struct_site_view","rot_matrix[2][1]"),"float"); (("struct_site_view","rot_matrix[2][2]"),"float"); (("struct_site_view","rot_matrix[2][3]"),"float"); (("struct_site_view","rot_matrix[3][1]"),"float"); (("struct_site_view","rot_matrix[3][2]"),"float"); (("struct_site_view","rot_matrix[3][3]"),"float"); (("struct_site_view","site_id"),"line"); 
    (("symmetry","entry_id"),"code"); (("symmetry","cell_setting"),"ucode"); (("symmetry","Int_Tables_number"),"int"); (("symmetry","space_group_name_Hall"),"line"); (("symmetry","space_group_name_H-M"),"line"); (("symmetry","pdbx_full_space_group_name_H-M"),"line"); 
    (("symmetry_equiv","id"),"code"); (("symmetry_equiv","pos_as_xyz"),"line"); 
    (("audit_link","block_code"),"code"); (("audit_link","block_description"),"text"); 
    (("diffrn_reflns_class","av_R_eq"),"float"); (("diffrn_reflns_class","av_sgI/I"),"float"); (("diffrn_reflns_class","av_uI/I"),"float"); (("diffrn_reflns_class","code"),"code"); (("diffrn_reflns_class","description"),"text"); (("diffrn_reflns_class","d_res_high"),"float"); (("diffrn_reflns_class","d_res_low"),"float"); (("diffrn_reflns_class","number"),"int"); 
    (("refine_ls_class","code"),"code"); (("refine_ls_class","d_res_high"),"float"); (("refine_ls_class","d_res_low"),"float"); (("refine_ls_class","R_factor_gt"),"float"); (("refine_ls_class","R_factor_all"),"float"); (("refine_ls_class","R_Fsqd_factor"),"float"); (("refine_ls_class","R_I_factor"),"float"); (("refine_ls_class","wR_factor_all"),"float"); 
    (("reflns_class","code"),"code"); (("reflns_class","description"),"text"); (("reflns_class","d_res_high"),"float"); (("reflns_class","d_res_low"),"float"); (("reflns_class","number_gt"),"int"); (("reflns_class","number_total"),"int"); (("reflns_class","R_factor_all"),"float"); (("reflns_class","R_factor_gt"),"float"); (("reflns_class","R_Fsqd_factor"),"float"); (("reflns_class","R_I_factor"),"float"); (("reflns_class","wR_factor_all"),"float"); 
    (("space_group","crystal_system"),"code"); (("space_group","id"),"code"); (("space_group","IT_number"),"int"); (("space_group","name_Hall"),"line"); (("space_group","name_H-M_alt"),"line"); 
    (("space_group_symop","id"),"code"); (("space_group_symop","operation_xyz"),"line"); (("space_group_symop","sg_id"),"code"); 
    (("valence_param","atom_1"),"code"); (("valence_param","atom_1_valence"),"int"); (("valence_param","atom_2"),"code"); (("valence_param","atom_2_valence"),"int"); (("valence_param","B"),"float"); (("valence_param","details"),"text"); (("valence_param","id"),"code"); (("valence_param","ref_id"),"code"); (("valence_param","Ro"),"float"); 
    (("valence_ref","id"),"code"); (("valence_ref","reference"),"text"); 
    (("pdbx_audit","entry_id"),"code"); (("pdbx_audit","current_version"),"code"); 
    (("pdbx_version","entry_id"),"code"); (("pdbx_version","revision_date"),"yyyy-mm-dd"); (("pdbx_version","major_version"),"int"); (("pdbx_version","minor_version"),"code"); (("pdbx_version","details"),"text"); (("pdbx_version","revision_type"),"line"); 
    (("pdbx_audit_author","address"),"text"); (("pdbx_audit_author","name"),"line"); (("pdbx_audit_author","ordinal"),"int"); 
    (("pdbx_database_message","entry_id"),"code"); (("pdbx_database_message","message_id"),"text"); (("pdbx_database_message","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_message","content_type"),"code"); (("pdbx_database_message","message_type"),"code"); (("pdbx_database_message","sender"),"text"); (("pdbx_database_message","sender_address_fax"),"fax"); (("pdbx_database_message","sender_address_phone"),"phone"); (("pdbx_database_message","sender_address_email"),"email"); (("pdbx_database_message","sender_address_mail"),"text"); (("pdbx_database_message","receiver"),"text"); (("pdbx_database_message","receiver_address_fax"),"fax"); (("pdbx_database_message","receiver_address_phone"),"phone"); (("pdbx_database_message","receiver_address_email"),"email"); (("pdbx_database_message","receiver_address_mail"),"text"); (("pdbx_database_message","message"),"text"); 
    (("pdbx_database_PDB_obs_spr","id"),"code"); (("pdbx_database_PDB_obs_spr","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_PDB_obs_spr","pdb_id"),"code"); (("pdbx_database_PDB_obs_spr","replace_pdb_id"),"line"); (("pdbx_database_PDB_obs_spr","details"),"text"); 
    (("pdbx_database_proc","entry_id"),"code"); (("pdbx_database_proc","cycle_id"),"code"); (("pdbx_database_proc","date_begin_cycle"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_proc","date_end_cycle"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_proc","details"),"text"); 
    (("pdbx_database_remark","id"),"int"); (("pdbx_database_remark","text"),"text"); 
    (("pdbx_database_status","status_code"),"code"); (("pdbx_database_status","author_release_status_code"),"code"); (("pdbx_database_status","status_code_sf"),"code"); (("pdbx_database_status","status_code_mr"),"code"); (("pdbx_database_status","dep_release_code_coordinates"),"line"); (("pdbx_database_status","dep_release_code_sequence"),"line"); (("pdbx_database_status","dep_release_code_struct_fact"),"line"); (("pdbx_database_status","dep_release_code_nmr_constraints"),"line"); (("pdbx_database_status","entry_id"),"code"); (("pdbx_database_status","recvd_deposit_form"),"uchar1"); (("pdbx_database_status","date_deposition_form"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","date_begin_deposition"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","date_begin_processing"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","date_end_processing"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","date_begin_release_preparation"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","date_author_release_request"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","recvd_coordinates"),"uchar1"); (("pdbx_database_status","date_coordinates"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","recvd_struct_fact"),"uchar1"); (("pdbx_database_status","date_struct_fact"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","recvd_nmr_constraints"),"uchar1"); (("pdbx_database_status","date_nmr_constraints"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","recvd_internal_approval"),"uchar1"); (("pdbx_database_status","recvd_manuscript"),"uchar1"); (("pdbx_database_status","date_manuscript"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","name_depositor"),"text"); (("pdbx_database_status","recvd_author_approval"),"uchar1"); (("pdbx_database_status","author_approval_type"),"code"); (("pdbx_database_status","date_author_approval"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","recvd_initial_deposition_date"),"yyyy-mm-dd"); (("pdbx_database_status","date_submitted"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","rcsb_annotator"),"code"); (("pdbx_database_status","date_of_sf_release"),"yyyy-mm-dd"); (("pdbx_database_status","date_of_mr_release"),"yyyy-mm-dd"); (("pdbx_database_status","date_of_PDB_release"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","date_hold_coordinates"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","date_hold_struct_fact"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","date_hold_nmr_constraints"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","hold_for_publication"),"uchar1"); (("pdbx_database_status","SG_entry"),"uchar1"); (("pdbx_database_status","pdb_date_of_author_approval"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","deposit_site"),"code"); (("pdbx_database_status","process_site"),"code"); (("pdbx_database_status","dep_release_code_chemical_shifts"),"line"); (("pdbx_database_status","recvd_chemical_shifts"),"uchar1"); (("pdbx_database_status","date_chemical_shifts"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","date_hold_chemical_shifts"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status","status_code_cs"),"code"); (("pdbx_database_status","date_of_cs_release"),"yyyy-mm-dd"); (("pdbx_database_status","methods_development_category"),"line"); (("pdbx_database_status","pdb_format_compatible"),"uchar1"); (("pdbx_database_status","auth_req_rel_date"),"yyyy-mm-dd"); (("pdbx_database_status","ndb_tid"),"code"); (("pdbx_database_status","status_coordinates_in_NDB"),"uchar1"); (("pdbx_database_status","date_revised"),"yyyy-mm-dd"); (("pdbx_database_status","replaced_entry_id"),"code"); (("pdbx_database_status","revision_id"),"code"); (("pdbx_database_status","revision_description"),"text"); (("pdbx_database_status","pdbx_annotator"),"code"); (("pdbx_database_status","date_of_NDB_release"),"yyyy-mm-dd"); (("pdbx_database_status","date_released_to_PDB"),"yyyy-mm-dd"); (("pdbx_database_status","skip_PDB_REMARK_500"),"uchar1"); (("pdbx_database_status","skip_PDB_REMARK"),"line"); (("pdbx_database_status","title_suppression"),"uchar1"); 
    (("pdbx_entity_name","entity_id"),"code"); (("pdbx_entity_name","name"),"line"); (("pdbx_entity_name","name_type"),"line"); 
    (("pdbx_prerelease_seq","entity_id"),"code"); (("pdbx_prerelease_seq","seq_one_letter_code"),"text"); 
    (("pdbx_poly_seq_scheme","asym_id"),"code"); (("pdbx_poly_seq_scheme","entity_id"),"code"); (("pdbx_poly_seq_scheme","seq_id"),"int"); (("pdbx_poly_seq_scheme","hetero"),"ucode"); (("pdbx_poly_seq_scheme","mon_id"),"ucode"); (("pdbx_poly_seq_scheme","pdb_strand_id"),"code"); (("pdbx_poly_seq_scheme","ndb_seq_num"),"int"); (("pdbx_poly_seq_scheme","pdb_seq_num"),"code"); (("pdbx_poly_seq_scheme","auth_seq_num"),"code"); (("pdbx_poly_seq_scheme","pdb_mon_id"),"code"); (("pdbx_poly_seq_scheme","auth_mon_id"),"code"); (("pdbx_poly_seq_scheme","pdb_ins_code"),"code"); 
    (("pdbx_nonpoly_scheme","asym_id"),"code"); (("pdbx_nonpoly_scheme","entity_id"),"code"); (("pdbx_nonpoly_scheme","mon_id"),"ucode"); (("pdbx_nonpoly_scheme","pdb_strand_id"),"code"); (("pdbx_nonpoly_scheme","ndb_seq_num"),"code"); (("pdbx_nonpoly_scheme","pdb_seq_num"),"code"); (("pdbx_nonpoly_scheme","auth_seq_num"),"code"); (("pdbx_nonpoly_scheme","pdb_mon_id"),"code"); (("pdbx_nonpoly_scheme","auth_mon_id"),"code"); (("pdbx_nonpoly_scheme","pdb_ins_code"),"code"); 
    (("pdbx_refine","entry_id"),"code"); (("pdbx_refine","pdbx_refine_id"),"line"); (("pdbx_refine","R_factor_all_no_cutoff"),"float"); (("pdbx_refine","R_factor_obs_no_cutoff"),"float"); (("pdbx_refine","free_R_factor_4sig_cutoff"),"float"); (("pdbx_refine","free_R_factor_no_cutoff"),"float"); (("pdbx_refine","free_R_error_no_cutoff"),"float"); (("pdbx_refine","free_R_val_test_set_size_perc_no_cutoff"),"float"); (("pdbx_refine","free_R_val_test_set_ct_no_cutoff"),"float"); (("pdbx_refine","number_reflns_obs_no_cutoff"),"float"); (("pdbx_refine","R_factor_all_4sig_cutoff"),"float"); (("pdbx_refine","R_factor_obs_4sig_cutoff"),"float"); (("pdbx_refine","free_R_val_4sig_cutoff"),"float"); (("pdbx_refine","free_R_val_test_set_size_perc_4sig_cutoff"),"float"); (("pdbx_refine","free_R_val_test_set_ct_4sig_cutoff"),"float"); (("pdbx_refine","number_reflns_obs_4sig_cutoff"),"float"); (("pdbx_refine","free_R_val_no_cutoff"),"float"); 
    (("pdbx_struct_sheet_hbond","range_id_1"),"code"); (("pdbx_struct_sheet_hbond","range_id_2"),"code"); (("pdbx_struct_sheet_hbond","sheet_id"),"code"); (("pdbx_struct_sheet_hbond","range_1_label_atom_id"),"atcode"); (("pdbx_struct_sheet_hbond","range_1_label_seq_id"),"int"); (("pdbx_struct_sheet_hbond","range_1_label_comp_id"),"ucode"); (("pdbx_struct_sheet_hbond","range_1_label_asym_id"),"code"); (("pdbx_struct_sheet_hbond","range_1_auth_atom_id"),"atcode"); (("pdbx_struct_sheet_hbond","range_1_auth_seq_id"),"code"); (("pdbx_struct_sheet_hbond","range_1_auth_comp_id"),"code"); (("pdbx_struct_sheet_hbond","range_1_auth_asym_id"),"code"); (("pdbx_struct_sheet_hbond","range_1_PDB_ins_code"),"code"); (("pdbx_struct_sheet_hbond","range_2_label_atom_id"),"atcode"); (("pdbx_struct_sheet_hbond","range_2_label_seq_id"),"int"); (("pdbx_struct_sheet_hbond","range_2_label_comp_id"),"ucode"); (("pdbx_struct_sheet_hbond","range_2_label_asym_id"),"code"); (("pdbx_struct_sheet_hbond","range_2_auth_atom_id"),"atcode"); (("pdbx_struct_sheet_hbond","range_2_auth_seq_id"),"code"); (("pdbx_struct_sheet_hbond","range_2_auth_comp_id"),"code"); (("pdbx_struct_sheet_hbond","range_2_auth_asym_id"),"code"); (("pdbx_struct_sheet_hbond","range_2_PDB_ins_code"),"code"); 
    (("pdbx_xplor_file","serial_no"),"code"); (("pdbx_xplor_file","pdbx_refine_id"),"line"); (("pdbx_xplor_file","param_file"),"line"); (("pdbx_xplor_file","topol_file"),"line"); 
    (("pdbx_refine_aux_file","serial_no"),"code"); (("pdbx_refine_aux_file","pdbx_refine_id"),"line"); (("pdbx_refine_aux_file","file_name"),"line"); (("pdbx_refine_aux_file","file_type"),"line"); 
    (("pdbx_database_related","db_name"),"code"); (("pdbx_database_related","details"),"text"); (("pdbx_database_related","db_id"),"line"); (("pdbx_database_related","content_type"),"line"); 
    (("pdbx_entity_assembly","id"),"code"); (("pdbx_entity_assembly","entity_id"),"code"); (("pdbx_entity_assembly","biol_id"),"line"); (("pdbx_entity_assembly","num_copies"),"int"); 
    (("pdbx_exptl_crystal_grow_comp","crystal_id"),"code"); (("pdbx_exptl_crystal_grow_comp","comp_id"),"code"); (("pdbx_exptl_crystal_grow_comp","comp_name"),"line"); (("pdbx_exptl_crystal_grow_comp","sol_id"),"line"); (("pdbx_exptl_crystal_grow_comp","conc"),"float"); (("pdbx_exptl_crystal_grow_comp","conc_range"),"line"); (("pdbx_exptl_crystal_grow_comp","conc_units"),"line"); 
    (("pdbx_exptl_crystal_grow_sol","crystal_id"),"code"); (("pdbx_exptl_crystal_grow_sol","sol_id"),"line"); (("pdbx_exptl_crystal_grow_sol","volume"),"float"); (("pdbx_exptl_crystal_grow_sol","volume_units"),"line"); (("pdbx_exptl_crystal_grow_sol","pH"),"float"); 
    (("pdbx_exptl_crystal_cryo_treatment","crystal_id"),"code"); (("pdbx_exptl_crystal_cryo_treatment","final_solution_details"),"text"); (("pdbx_exptl_crystal_cryo_treatment","soaking_details"),"text"); (("pdbx_exptl_crystal_cryo_treatment","cooling_details"),"text"); (("pdbx_exptl_crystal_cryo_treatment","annealing_details"),"text"); 
    (("pdbx_refine_tls","id"),"code"); (("pdbx_refine_tls","pdbx_refine_id"),"line"); (("pdbx_refine_tls","details"),"text"); (("pdbx_refine_tls","method"),"ucode"); (("pdbx_refine_tls","origin_x"),"float"); (("pdbx_refine_tls","origin_y"),"float"); (("pdbx_refine_tls","origin_z"),"float"); (("pdbx_refine_tls","T[1][1]"),"float"); (("pdbx_refine_tls","T[1][1]_esd"),"float"); (("pdbx_refine_tls","T[1][2]"),"float"); (("pdbx_refine_tls","T[1][2]_esd"),"float"); (("pdbx_refine_tls","T[1][3]"),"float"); (("pdbx_refine_tls","T[1][3]_esd"),"float"); (("pdbx_refine_tls","T[2][2]"),"float"); (("pdbx_refine_tls","T[2][2]_esd"),"float"); (("pdbx_refine_tls","T[2][3]"),"float"); (("pdbx_refine_tls","T[2][3]_esd"),"float"); (("pdbx_refine_tls","T[3][3]"),"float"); (("pdbx_refine_tls","T[3][3]_esd"),"float"); (("pdbx_refine_tls","L[1][1]"),"float"); (("pdbx_refine_tls","L[1][1]_esd"),"float"); (("pdbx_refine_tls","L[1][2]"),"float"); (("pdbx_refine_tls","L[1][2]_esd"),"float"); (("pdbx_refine_tls","L[1][3]"),"float"); (("pdbx_refine_tls","L[1][3]_esd"),"float"); (("pdbx_refine_tls","L[2][2]"),"float"); (("pdbx_refine_tls","L[2][2]_esd"),"float"); (("pdbx_refine_tls","L[2][3]"),"float"); (("pdbx_refine_tls","L[2][3]_esd"),"float"); (("pdbx_refine_tls","L[3][3]"),"float"); (("pdbx_refine_tls","L[3][3]_esd"),"float"); (("pdbx_refine_tls","S[1][1]"),"float"); (("pdbx_refine_tls","S[1][1]_esd"),"float"); (("pdbx_refine_tls","S[1][2]"),"float"); (("pdbx_refine_tls","S[1][2]_esd"),"float"); (("pdbx_refine_tls","S[1][3]"),"float"); (("pdbx_refine_tls","S[1][3]_esd"),"float"); (("pdbx_refine_tls","S[2][1]"),"float"); (("pdbx_refine_tls","S[2][1]_esd"),"float"); (("pdbx_refine_tls","S[2][2]"),"float"); (("pdbx_refine_tls","S[2][2]_esd"),"float"); (("pdbx_refine_tls","S[2][3]"),"float"); (("pdbx_refine_tls","S[2][3]_esd"),"float"); (("pdbx_refine_tls","S[3][1]"),"float"); (("pdbx_refine_tls","S[3][1]_esd"),"float"); (("pdbx_refine_tls","S[3][2]"),"float"); (("pdbx_refine_tls","S[3][2]_esd"),"float"); (("pdbx_refine_tls","S[3][3]"),"float"); (("pdbx_refine_tls","S[3][3]_esd"),"float"); 
    (("pdbx_refine_tls_group","id"),"code"); (("pdbx_refine_tls_group","pdbx_refine_id"),"line"); (("pdbx_refine_tls_group","refine_tls_id"),"code"); (("pdbx_refine_tls_group","beg_label_asym_id"),"code"); (("pdbx_refine_tls_group","beg_label_seq_id"),"int"); (("pdbx_refine_tls_group","beg_auth_asym_id"),"code"); (("pdbx_refine_tls_group","beg_auth_seq_id"),"code"); (("pdbx_refine_tls_group","end_label_asym_id"),"code"); (("pdbx_refine_tls_group","end_label_seq_id"),"int"); (("pdbx_refine_tls_group","end_auth_asym_id"),"code"); (("pdbx_refine_tls_group","end_auth_seq_id"),"code"); (("pdbx_refine_tls_group","selection"),"line"); (("pdbx_refine_tls_group","selection_details"),"text"); 
    (("pdbx_contact_author","id"),"int"); (("pdbx_contact_author","address_1"),"text"); (("pdbx_contact_author","address_2"),"text"); (("pdbx_contact_author","address_3"),"text"); (("pdbx_contact_author","legacy_address"),"text"); (("pdbx_contact_author","city"),"line"); (("pdbx_contact_author","state_province"),"line"); (("pdbx_contact_author","postal_code"),"line"); (("pdbx_contact_author","email"),"line"); (("pdbx_contact_author","fax"),"line"); (("pdbx_contact_author","name_first"),"line"); (("pdbx_contact_author","name_last"),"line"); (("pdbx_contact_author","name_mi"),"line"); (("pdbx_contact_author","name_salutation"),"line"); (("pdbx_contact_author","country"),"line"); (("pdbx_contact_author","continent"),"line"); (("pdbx_contact_author","phone"),"line"); (("pdbx_contact_author","role"),"line"); (("pdbx_contact_author","organization_type"),"line"); (("pdbx_contact_author","identifier_ORCID"),"orcid_id"); 
    (("pdbx_SG_project","id"),"int"); (("pdbx_SG_project","project_name"),"text"); (("pdbx_SG_project","full_name_of_center"),"text"); (("pdbx_SG_project","initial_of_center"),"text"); 
    (("pdbx_atom_site_aniso_tls","id"),"code"); (("pdbx_atom_site_aniso_tls","type_symbol"),"code"); (("pdbx_atom_site_aniso_tls","tls_group_id"),"code"); (("pdbx_atom_site_aniso_tls","auth_comp_id"),"code"); (("pdbx_atom_site_aniso_tls","auth_seq_id"),"code"); (("pdbx_atom_site_aniso_tls","auth_atom_id"),"atcode"); (("pdbx_atom_site_aniso_tls","auth_asym_id"),"code"); (("pdbx_atom_site_aniso_tls","PDB_ins_code"),"code"); (("pdbx_atom_site_aniso_tls","label_alt_id"),"code"); (("pdbx_atom_site_aniso_tls","label_asym_id"),"code"); (("pdbx_atom_site_aniso_tls","label_atom_id"),"atcode"); (("pdbx_atom_site_aniso_tls","label_comp_id"),"ucode"); (("pdbx_atom_site_aniso_tls","label_seq_id"),"int"); (("pdbx_atom_site_aniso_tls","U_tls[1][1]"),"float"); (("pdbx_atom_site_aniso_tls","U_tls[2][2]"),"float"); (("pdbx_atom_site_aniso_tls","U_tls[3][3]"),"float"); (("pdbx_atom_site_aniso_tls","U_tls[1][2]"),"float"); (("pdbx_atom_site_aniso_tls","U_tls[1][3]"),"float"); (("pdbx_atom_site_aniso_tls","U_tls[2][3]"),"float"); 
    (("pdbx_nmr_details","entry_id"),"code"); (("pdbx_nmr_details","text"),"text"); 
    (("pdbx_nmr_sample_details","solution_id"),"code"); (("pdbx_nmr_sample_details","contents"),"text"); (("pdbx_nmr_sample_details","solvent_system"),"text"); (("pdbx_nmr_sample_details","label"),"line"); (("pdbx_nmr_sample_details","type"),"line"); (("pdbx_nmr_sample_details","details"),"text"); 
    (("pdbx_nmr_exptl_sample","solution_id"),"code"); (("pdbx_nmr_exptl_sample","component"),"line"); (("pdbx_nmr_exptl_sample","concentration"),"float"); (("pdbx_nmr_exptl_sample","concentration_range"),"float-range"); (("pdbx_nmr_exptl_sample","concentration_units"),"line"); (("pdbx_nmr_exptl_sample","isotopic_labeling"),"line"); (("pdbx_nmr_exptl_sample","concentration_err"),"float"); 
    (("pdbx_nmr_exptl_sample_conditions","conditions_id"),"code"); (("pdbx_nmr_exptl_sample_conditions","temperature"),"float-range"); (("pdbx_nmr_exptl_sample_conditions","pressure_units"),"code"); (("pdbx_nmr_exptl_sample_conditions","pressure"),"line"); (("pdbx_nmr_exptl_sample_conditions","pH"),"float-range"); (("pdbx_nmr_exptl_sample_conditions","ionic_strength"),"line"); (("pdbx_nmr_exptl_sample_conditions","details"),"text"); (("pdbx_nmr_exptl_sample_conditions","ionic_strength_err"),"float"); (("pdbx_nmr_exptl_sample_conditions","ionic_strength_units"),"line"); (("pdbx_nmr_exptl_sample_conditions","label"),"line"); (("pdbx_nmr_exptl_sample_conditions","pH_err"),"float"); (("pdbx_nmr_exptl_sample_conditions","pH_units"),"line"); (("pdbx_nmr_exptl_sample_conditions","pressure_err"),"float"); (("pdbx_nmr_exptl_sample_conditions","temperature_err"),"float"); (("pdbx_nmr_exptl_sample_conditions","temperature_units"),"line"); 
    (("pdbx_nmr_spectrometer","spectrometer_id"),"code"); (("pdbx_nmr_spectrometer","model"),"line"); (("pdbx_nmr_spectrometer","type"),"line"); (("pdbx_nmr_spectrometer","manufacturer"),"line"); (("pdbx_nmr_spectrometer","field_strength"),"float"); (("pdbx_nmr_spectrometer","details"),"text"); (("pdbx_nmr_spectrometer","name"),"line"); 
    (("pdbx_nmr_exptl","experiment_id"),"code"); (("pdbx_nmr_exptl","conditions_id"),"code"); (("pdbx_nmr_exptl","solution_id"),"code"); (("pdbx_nmr_exptl","type"),"line"); (("pdbx_nmr_exptl","spectrometer_id"),"int"); (("pdbx_nmr_exptl","sample_state"),"line"); 
    (("pdbx_nmr_software","ordinal"),"int"); (("pdbx_nmr_software","classification"),"line"); (("pdbx_nmr_software","name"),"line"); (("pdbx_nmr_software","version"),"line"); (("pdbx_nmr_software","authors"),"text"); (("pdbx_nmr_software","details"),"text"); 
    (("pdbx_nmr_constraints","entry_id"),"code"); (("pdbx_nmr_constraints","NOE_constraints_total"),"int"); (("pdbx_nmr_constraints","NOE_intraresidue_total_count"),"int"); (("pdbx_nmr_constraints","NOE_interentity_total_count"),"int"); (("pdbx_nmr_constraints","NOE_sequential_total_count"),"int"); (("pdbx_nmr_constraints","NOE_medium_range_total_count"),"int"); (("pdbx_nmr_constraints","NOE_long_range_total_count"),"int"); (("pdbx_nmr_constraints","protein_phi_angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","protein_psi_angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","protein_chi_angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","protein_other_angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","NOE_interproton_distance_evaluation"),"text"); (("pdbx_nmr_constraints","NOE_pseudoatom_corrections"),"text"); (("pdbx_nmr_constraints","NOE_motional_averaging_correction"),"text"); (("pdbx_nmr_constraints","hydrogen_bond_constraints_total_count"),"int"); (("pdbx_nmr_constraints","disulfide_bond_constraints_total_count"),"int"); (("pdbx_nmr_constraints","NA_alpha-angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","NA_beta-angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","NA_gamma-angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","NA_delta-angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","NA_epsilon-angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","NA_chi-angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","NA_other-angle_constraints_total_count"),"int"); (("pdbx_nmr_constraints","NA_sugar_pucker_constraints_total_count"),"int"); 
    (("pdbx_nmr_ensemble","entry_id"),"code"); (("pdbx_nmr_ensemble","conformers_calculated_total_number"),"int"); (("pdbx_nmr_ensemble","conformers_submitted_total_number"),"int"); (("pdbx_nmr_ensemble","conformer_selection_criteria"),"text"); (("pdbx_nmr_ensemble","representative_conformer"),"int"); (("pdbx_nmr_ensemble","average_constraints_per_residue"),"int"); (("pdbx_nmr_ensemble","average_constraint_violations_per_residue"),"int"); (("pdbx_nmr_ensemble","maximum_distance_constraint_violation"),"float"); (("pdbx_nmr_ensemble","average_distance_constraint_violation"),"float"); (("pdbx_nmr_ensemble","maximum_upper_distance_constraint_violation"),"float"); (("pdbx_nmr_ensemble","maximum_lower_distance_constraint_violation"),"float"); (("pdbx_nmr_ensemble","distance_constraint_violation_method"),"text"); (("pdbx_nmr_ensemble","maximum_torsion_angle_constraint_violation"),"float"); (("pdbx_nmr_ensemble","average_torsion_angle_constraint_violation"),"float"); (("pdbx_nmr_ensemble","torsion_angle_constraint_violation_method"),"text"); 
    (("pdbx_nmr_ensemble_rms","entry_id"),"code"); (("pdbx_nmr_ensemble_rms","residue_range_begin"),"int"); (("pdbx_nmr_ensemble_rms","chain_range_begin"),"code"); (("pdbx_nmr_ensemble_rms","residue_range_end"),"int"); (("pdbx_nmr_ensemble_rms","chain_range_end"),"code"); (("pdbx_nmr_ensemble_rms","atom_type"),"line"); (("pdbx_nmr_ensemble_rms","distance_rms_dev"),"float"); (("pdbx_nmr_ensemble_rms","distance_rms_dev_error"),"float"); (("pdbx_nmr_ensemble_rms","covalent_bond_rms_dev"),"float"); (("pdbx_nmr_ensemble_rms","covalent_bond_rms_dev_error"),"float"); (("pdbx_nmr_ensemble_rms","bond_angle_rms_dev"),"float"); (("pdbx_nmr_ensemble_rms","bond_angle_rms_dev_error"),"float"); (("pdbx_nmr_ensemble_rms","improper_torsion_angle_rms_dev"),"float"); (("pdbx_nmr_ensemble_rms","improper_torsion_angle_rms_dev_error"),"float"); (("pdbx_nmr_ensemble_rms","peptide_planarity_rms_dev"),"float"); (("pdbx_nmr_ensemble_rms","peptide_planarity_rms_dev_error"),"float"); (("pdbx_nmr_ensemble_rms","dihedral_angles_rms_dev"),"float"); (("pdbx_nmr_ensemble_rms","dihedral_angles_rms_dev_error"),"float"); (("pdbx_nmr_ensemble_rms","coord_average_rmsd_method"),"text"); 
    (("pdbx_nmr_representative","entry_id"),"code"); (("pdbx_nmr_representative","conformer_id"),"line"); (("pdbx_nmr_representative","selection_criteria"),"line"); 
    (("pdbx_nmr_refine","entry_id"),"code"); (("pdbx_nmr_refine","method"),"text"); (("pdbx_nmr_refine","details"),"text"); (("pdbx_nmr_refine","software_ordinal"),"int"); 
    (("pdbx_nmr_force_constants","entry_id"),"code"); (("pdbx_nmr_force_constants","exptl_distance_term"),"float"); (("pdbx_nmr_force_constants","exptl_distance_term_units"),"code"); (("pdbx_nmr_force_constants","exptl_torsion_angles_term"),"float"); (("pdbx_nmr_force_constants","exptl_torsion_angles_term_units"),"code"); (("pdbx_nmr_force_constants","exptl_J_coupling_term"),"float"); (("pdbx_nmr_force_constants","exptl_J_coupling_term_units"),"code"); (("pdbx_nmr_force_constants","exptl_13C_shift_term"),"float"); (("pdbx_nmr_force_constants","exptl_13C_shift_term_units"),"code"); (("pdbx_nmr_force_constants","exptl_1H_shift_term"),"float"); (("pdbx_nmr_force_constants","exptl_1H_shift_term_units"),"code"); (("pdbx_nmr_force_constants","exptl_dipolar_coupling_term"),"float"); (("pdbx_nmr_force_constants","exptl_dipolar_coupling_term_units"),"code"); (("pdbx_nmr_force_constants","exptl_D_isotope_shift_term"),"float"); (("pdbx_nmr_force_constants","exptl_D_isotope_shift_term_units"),"code"); (("pdbx_nmr_force_constants","covalent_geom_bond_term"),"float"); (("pdbx_nmr_force_constants","covalent_geom_bond_term_units"),"code"); (("pdbx_nmr_force_constants","covalent_geom_angles_term"),"float"); (("pdbx_nmr_force_constants","covalent_geom_angles_term_units"),"code"); (("pdbx_nmr_force_constants","covalent_geom_impropers_term"),"float"); (("pdbx_nmr_force_constants","covalent_geom_impropers_term_units"),"code"); (("pdbx_nmr_force_constants","non-bonded_inter_van_der_Waals_term_type"),"text"); (("pdbx_nmr_force_constants","non-bonded_inter_van_der_Waals_term"),"float"); (("pdbx_nmr_force_constants","non-bonded_inter_van_der_Waals_term_units"),"code"); (("pdbx_nmr_force_constants","non-bonded_inter_conf_db_potential_term"),"float"); (("pdbx_nmr_force_constants","non-bonded_inter_radius_of_gyration_term"),"float"); (("pdbx_nmr_force_constants","non-bonded_inter_radius_of_gyration_term_units"),"code"); 
    (("ndb_struct_conf_na","entry_id"),"code"); (("ndb_struct_conf_na","feature"),"line"); (("ndb_struct_conf_na","feature_count"),"int"); 
    (("ndb_struct_feature_na","entry_id"),"code"); (("ndb_struct_feature_na","feature"),"line"); (("ndb_struct_feature_na","feature_count"),"int"); 
    (("ndb_struct_na_base_pair","model_number"),"int"); (("ndb_struct_na_base_pair","pair_number"),"int"); (("ndb_struct_na_base_pair","pair_name"),"line"); (("ndb_struct_na_base_pair","i_label_asym_id"),"code"); (("ndb_struct_na_base_pair","i_label_comp_id"),"ucode"); (("ndb_struct_na_base_pair","i_label_seq_id"),"int"); (("ndb_struct_na_base_pair","i_symmetry"),"symop"); (("ndb_struct_na_base_pair","j_label_asym_id"),"code"); (("ndb_struct_na_base_pair","j_label_comp_id"),"ucode"); (("ndb_struct_na_base_pair","j_label_seq_id"),"int"); (("ndb_struct_na_base_pair","j_symmetry"),"symop"); (("ndb_struct_na_base_pair","i_auth_asym_id"),"code"); (("ndb_struct_na_base_pair","i_auth_seq_id"),"code"); (("ndb_struct_na_base_pair","i_PDB_ins_code"),"code"); (("ndb_struct_na_base_pair","j_auth_asym_id"),"code"); (("ndb_struct_na_base_pair","j_auth_seq_id"),"code"); (("ndb_struct_na_base_pair","j_PDB_ins_code"),"code"); (("ndb_struct_na_base_pair","shear"),"float"); (("ndb_struct_na_base_pair","stretch"),"float"); (("ndb_struct_na_base_pair","stagger"),"float"); (("ndb_struct_na_base_pair","buckle"),"float"); (("ndb_struct_na_base_pair","propeller"),"float"); (("ndb_struct_na_base_pair","opening"),"float"); (("ndb_struct_na_base_pair","hbond_type_12"),"int"); (("ndb_struct_na_base_pair","hbond_type_28"),"int"); 
    (("ndb_struct_na_base_pair_step","model_number"),"int"); (("ndb_struct_na_base_pair_step","step_number"),"int"); (("ndb_struct_na_base_pair_step","step_name"),"line"); (("ndb_struct_na_base_pair_step","i_label_asym_id_1"),"code"); (("ndb_struct_na_base_pair_step","i_label_comp_id_1"),"ucode"); (("ndb_struct_na_base_pair_step","i_label_seq_id_1"),"int"); (("ndb_struct_na_base_pair_step","i_symmetry_1"),"symop"); (("ndb_struct_na_base_pair_step","j_label_asym_id_1"),"code"); (("ndb_struct_na_base_pair_step","j_label_comp_id_1"),"ucode"); (("ndb_struct_na_base_pair_step","j_label_seq_id_1"),"int"); (("ndb_struct_na_base_pair_step","j_symmetry_1"),"symop"); (("ndb_struct_na_base_pair_step","i_label_asym_id_2"),"code"); (("ndb_struct_na_base_pair_step","i_label_comp_id_2"),"ucode"); (("ndb_struct_na_base_pair_step","i_label_seq_id_2"),"int"); (("ndb_struct_na_base_pair_step","i_symmetry_2"),"symop"); (("ndb_struct_na_base_pair_step","j_label_asym_id_2"),"code"); (("ndb_struct_na_base_pair_step","j_label_comp_id_2"),"ucode"); (("ndb_struct_na_base_pair_step","j_label_seq_id_2"),"int"); (("ndb_struct_na_base_pair_step","j_symmetry_2"),"symop"); (("ndb_struct_na_base_pair_step","i_auth_asym_id_1"),"code"); (("ndb_struct_na_base_pair_step","i_auth_seq_id_1"),"code"); (("ndb_struct_na_base_pair_step","i_PDB_ins_code_1"),"code"); (("ndb_struct_na_base_pair_step","j_auth_asym_id_1"),"code"); (("ndb_struct_na_base_pair_step","j_auth_seq_id_1"),"code"); (("ndb_struct_na_base_pair_step","j_PDB_ins_code_1"),"code"); (("ndb_struct_na_base_pair_step","i_auth_asym_id_2"),"code"); (("ndb_struct_na_base_pair_step","i_auth_seq_id_2"),"code"); (("ndb_struct_na_base_pair_step","i_PDB_ins_code_2"),"code"); (("ndb_struct_na_base_pair_step","j_auth_asym_id_2"),"code"); (("ndb_struct_na_base_pair_step","j_auth_seq_id_2"),"code"); (("ndb_struct_na_base_pair_step","j_PDB_ins_code_2"),"code"); (("ndb_struct_na_base_pair_step","shift"),"float"); (("ndb_struct_na_base_pair_step","slide"),"float"); (("ndb_struct_na_base_pair_step","rise"),"float"); (("ndb_struct_na_base_pair_step","tilt"),"float"); (("ndb_struct_na_base_pair_step","roll"),"float"); (("ndb_struct_na_base_pair_step","twist"),"float"); (("ndb_struct_na_base_pair_step","x_displacement"),"float"); (("ndb_struct_na_base_pair_step","y_displacement"),"float"); (("ndb_struct_na_base_pair_step","helical_rise"),"float"); (("ndb_struct_na_base_pair_step","inclination"),"float"); (("ndb_struct_na_base_pair_step","tip"),"float"); (("ndb_struct_na_base_pair_step","helical_twist"),"float"); 
    (("ndb_original_ndb_coordinates","coord_section"),"text"); 
    (("pdbx_entity_nonpoly","entity_id"),"code"); (("pdbx_entity_nonpoly","comp_id"),"ucode"); (("pdbx_entity_nonpoly","name"),"text"); 
    (("pdbx_phasing_dm","entry_id"),"code"); (("pdbx_phasing_dm","method"),"line"); (("pdbx_phasing_dm","mask_type"),"line"); (("pdbx_phasing_dm","fom_acentric"),"float"); (("pdbx_phasing_dm","fom_centric"),"float"); (("pdbx_phasing_dm","fom"),"float"); (("pdbx_phasing_dm","reflns_acentric"),"int"); (("pdbx_phasing_dm","reflns_centric"),"int"); (("pdbx_phasing_dm","reflns"),"int"); (("pdbx_phasing_dm","delta_phi_initial"),"float"); (("pdbx_phasing_dm","delta_phi_final"),"float"); 
    (("pdbx_phasing_dm_shell","d_res_high"),"float"); (("pdbx_phasing_dm_shell","d_res_low"),"float"); (("pdbx_phasing_dm_shell","fom_acentric"),"float"); (("pdbx_phasing_dm_shell","fom_centric"),"float"); (("pdbx_phasing_dm_shell","fom"),"float"); (("pdbx_phasing_dm_shell","reflns_acentric"),"int"); (("pdbx_phasing_dm_shell","reflns_centric"),"int"); (("pdbx_phasing_dm_shell","reflns"),"int"); (("pdbx_phasing_dm_shell","delta_phi_initial"),"float"); (("pdbx_phasing_dm_shell","delta_phi_final"),"float"); 
    (("pdbx_phasing_MAD_shell","d_res_low"),"float"); (("pdbx_phasing_MAD_shell","d_res_high"),"float"); (("pdbx_phasing_MAD_shell","reflns_acentric"),"float"); (("pdbx_phasing_MAD_shell","reflns_centric"),"int"); (("pdbx_phasing_MAD_shell","reflns"),"int"); (("pdbx_phasing_MAD_shell","fom_acentric"),"float"); (("pdbx_phasing_MAD_shell","fom_centric"),"float"); (("pdbx_phasing_MAD_shell","fom"),"float"); (("pdbx_phasing_MAD_shell","R_cullis_centric"),"float"); (("pdbx_phasing_MAD_shell","R_cullis_acentric"),"float"); (("pdbx_phasing_MAD_shell","R_cullis"),"float"); (("pdbx_phasing_MAD_shell","R_kraut_centric"),"float"); (("pdbx_phasing_MAD_shell","R_kraut_acentric"),"float"); (("pdbx_phasing_MAD_shell","R_kraut"),"float"); (("pdbx_phasing_MAD_shell","loc_centric"),"float"); (("pdbx_phasing_MAD_shell","loc_acentric"),"float"); (("pdbx_phasing_MAD_shell","loc"),"float"); (("pdbx_phasing_MAD_shell","power_centric"),"float"); (("pdbx_phasing_MAD_shell","power_acentric"),"float"); (("pdbx_phasing_MAD_shell","power"),"float"); 
    (("pdbx_phasing_MAD_set","id"),"code"); (("pdbx_phasing_MAD_set","d_res_low"),"float"); (("pdbx_phasing_MAD_set","d_res_high"),"float"); (("pdbx_phasing_MAD_set","number_of_sites"),"int"); (("pdbx_phasing_MAD_set","reflns_acentric"),"int"); (("pdbx_phasing_MAD_set","reflns_centric"),"int"); (("pdbx_phasing_MAD_set","reflns"),"int"); (("pdbx_phasing_MAD_set","fom_acentric"),"float"); (("pdbx_phasing_MAD_set","fom_centric"),"float"); (("pdbx_phasing_MAD_set","fom"),"float"); (("pdbx_phasing_MAD_set","R_cullis_centric"),"float"); (("pdbx_phasing_MAD_set","R_cullis_acentric"),"float"); (("pdbx_phasing_MAD_set","R_cullis"),"float"); (("pdbx_phasing_MAD_set","R_kraut_centric"),"float"); (("pdbx_phasing_MAD_set","R_kraut_acentric"),"float"); (("pdbx_phasing_MAD_set","R_kraut"),"float"); (("pdbx_phasing_MAD_set","loc_centric"),"float"); (("pdbx_phasing_MAD_set","loc_acentric"),"float"); (("pdbx_phasing_MAD_set","loc"),"float"); (("pdbx_phasing_MAD_set","power_centric"),"float"); (("pdbx_phasing_MAD_set","power_acentric"),"float"); (("pdbx_phasing_MAD_set","power"),"float"); 
    (("pdbx_phasing_MAD_set_shell","id"),"code"); (("pdbx_phasing_MAD_set_shell","d_res_low"),"float"); (("pdbx_phasing_MAD_set_shell","d_res_high"),"float"); (("pdbx_phasing_MAD_set_shell","reflns_acentric"),"int"); (("pdbx_phasing_MAD_set_shell","reflns_centric"),"int"); (("pdbx_phasing_MAD_set_shell","reflns"),"int"); (("pdbx_phasing_MAD_set_shell","fom_acentric"),"float"); (("pdbx_phasing_MAD_set_shell","fom_centric"),"float"); (("pdbx_phasing_MAD_set_shell","fom"),"float"); (("pdbx_phasing_MAD_set_shell","R_cullis_centric"),"float"); (("pdbx_phasing_MAD_set_shell","R_cullis_acentric"),"float"); (("pdbx_phasing_MAD_set_shell","R_cullis"),"float"); (("pdbx_phasing_MAD_set_shell","R_kraut_centric"),"float"); (("pdbx_phasing_MAD_set_shell","R_kraut_acentric"),"float"); (("pdbx_phasing_MAD_set_shell","R_kraut"),"float"); (("pdbx_phasing_MAD_set_shell","loc_centric"),"float"); (("pdbx_phasing_MAD_set_shell","loc_acentric"),"float"); (("pdbx_phasing_MAD_set_shell","loc"),"float"); (("pdbx_phasing_MAD_set_shell","power_centric"),"float"); (("pdbx_phasing_MAD_set_shell","power_acentric"),"float"); (("pdbx_phasing_MAD_set_shell","power"),"float"); 
    (("pdbx_phasing_MAD_set_site","id"),"code"); (("pdbx_phasing_MAD_set_site","atom_type_symbol"),"code"); (("pdbx_phasing_MAD_set_site","Cartn_x"),"float"); (("pdbx_phasing_MAD_set_site","Cartn_y"),"float"); (("pdbx_phasing_MAD_set_site","Cartn_z"),"float"); (("pdbx_phasing_MAD_set_site","Cartn_x_esd"),"float"); (("pdbx_phasing_MAD_set_site","Cartn_y_esd"),"float"); (("pdbx_phasing_MAD_set_site","Cartn_z_esd"),"float"); (("pdbx_phasing_MAD_set_site","fract_x"),"float"); (("pdbx_phasing_MAD_set_site","fract_y"),"float"); (("pdbx_phasing_MAD_set_site","fract_z"),"float"); (("pdbx_phasing_MAD_set_site","fract_x_esd"),"float"); (("pdbx_phasing_MAD_set_site","fract_y_esd"),"float"); (("pdbx_phasing_MAD_set_site","fract_z_esd"),"float"); (("pdbx_phasing_MAD_set_site","b_iso"),"float"); (("pdbx_phasing_MAD_set_site","b_iso_esd"),"float"); (("pdbx_phasing_MAD_set_site","occupancy"),"float"); (("pdbx_phasing_MAD_set_site","occupancy_esd"),"float"); (("pdbx_phasing_MAD_set_site","set_id"),"code"); (("pdbx_phasing_MAD_set_site","occupancy_iso"),"float"); 
    (("pdbx_phasing_MR","entry_id"),"code"); (("pdbx_phasing_MR","method_rotation"),"line"); (("pdbx_phasing_MR","d_res_high_rotation"),"float"); (("pdbx_phasing_MR","d_res_low_rotation"),"float"); (("pdbx_phasing_MR","sigma_F_rotation"),"float"); (("pdbx_phasing_MR","sigma_I_rotation"),"float"); (("pdbx_phasing_MR","reflns_percent_rotation"),"float"); (("pdbx_phasing_MR","method_translation"),"line"); (("pdbx_phasing_MR","d_res_high_translation"),"float"); (("pdbx_phasing_MR","d_res_low_translation"),"float"); (("pdbx_phasing_MR","sigma_F_translation"),"float"); (("pdbx_phasing_MR","sigma_I_translation"),"float"); (("pdbx_phasing_MR","reflns_percent_translation"),"float"); (("pdbx_phasing_MR","correlation_coeff_Io_to_Ic"),"float"); (("pdbx_phasing_MR","correlation_coeff_Fo_to_Fc"),"float"); (("pdbx_phasing_MR","R_factor"),"float"); (("pdbx_phasing_MR","R_rigid_body"),"float"); (("pdbx_phasing_MR","packing"),"float"); (("pdbx_phasing_MR","model_details"),"text"); (("pdbx_phasing_MR","native_set_id"),"line"); (("pdbx_phasing_MR","d_res_high_fit"),"float"); (("pdbx_phasing_MR","d_res_low_fit"),"float"); (("pdbx_phasing_MR","zscore_rotation"),"float"); (("pdbx_phasing_MR","LL_gain_rotation"),"float"); (("pdbx_phasing_MR","zscore_translation"),"float"); (("pdbx_phasing_MR","LL_gain_translation"),"float"); 
    (("pdbx_refine_component","label_alt_id"),"code"); (("pdbx_refine_component","label_asym_id"),"code"); (("pdbx_refine_component","label_comp_id"),"ucode"); (("pdbx_refine_component","label_seq_id"),"int"); (("pdbx_refine_component","auth_asym_id"),"code"); (("pdbx_refine_component","auth_comp_id"),"code"); (("pdbx_refine_component","auth_seq_id"),"code"); (("pdbx_refine_component","PDB_ins_code"),"code"); (("pdbx_refine_component","B_iso"),"float"); (("pdbx_refine_component","B_iso_main_chain"),"float"); (("pdbx_refine_component","B_iso_side_chain"),"float"); (("pdbx_refine_component","shift"),"float"); (("pdbx_refine_component","shift_side_chain"),"float"); (("pdbx_refine_component","shift_main_chain"),"float"); (("pdbx_refine_component","correlation"),"float"); (("pdbx_refine_component","correlation_side_chain"),"float"); (("pdbx_refine_component","correlation_main_chain"),"float"); (("pdbx_refine_component","real_space_R"),"float"); (("pdbx_refine_component","real_space_R_side_chain"),"float"); (("pdbx_refine_component","real_space_R_main_chain"),"float"); (("pdbx_refine_component","connect"),"float"); (("pdbx_refine_component","density_index"),"float"); (("pdbx_refine_component","density_index_main_chain"),"float"); (("pdbx_refine_component","density_index_side_chain"),"float"); (("pdbx_refine_component","density_ratio"),"float"); (("pdbx_refine_component","density_ratio_main_chain"),"float"); (("pdbx_refine_component","density_ratio_side_chain"),"float"); 
    (("pdbx_entity_prod_protocol","entry_id"),"code"); (("pdbx_entity_prod_protocol","entity_id"),"code"); (("pdbx_entity_prod_protocol","protocol"),"text"); (("pdbx_entity_prod_protocol","protocol_type"),"code"); 
    (("pdbx_entity_src_gen_prod_other","entry_id"),"code"); (("pdbx_entity_src_gen_prod_other","entity_id"),"code"); (("pdbx_entity_src_gen_prod_other","step_id"),"int"); (("pdbx_entity_src_gen_prod_other","next_step_id"),"int"); (("pdbx_entity_src_gen_prod_other","end_construct_id"),"code"); (("pdbx_entity_src_gen_prod_other","robot_id"),"code"); (("pdbx_entity_src_gen_prod_other","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_prod_other","process_name"),"text"); (("pdbx_entity_src_gen_prod_other","details"),"text"); 
    (("pdbx_entity_src_gen_prod_other_parameter","entry_id"),"code"); (("pdbx_entity_src_gen_prod_other_parameter","entity_id"),"code"); (("pdbx_entity_src_gen_prod_other_parameter","step_id"),"int"); (("pdbx_entity_src_gen_prod_other_parameter","parameter"),"line"); (("pdbx_entity_src_gen_prod_other_parameter","value"),"text"); (("pdbx_entity_src_gen_prod_other_parameter","details"),"text"); 
    (("pdbx_entity_src_gen_prod_pcr","entry_id"),"code"); (("pdbx_entity_src_gen_prod_pcr","entity_id"),"code"); (("pdbx_entity_src_gen_prod_pcr","step_id"),"int"); (("pdbx_entity_src_gen_prod_pcr","next_step_id"),"int"); (("pdbx_entity_src_gen_prod_pcr","end_construct_id"),"code"); (("pdbx_entity_src_gen_prod_pcr","robot_id"),"code"); (("pdbx_entity_src_gen_prod_pcr","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_prod_pcr","forward_primer_id"),"code"); (("pdbx_entity_src_gen_prod_pcr","reverse_primer_id"),"code"); (("pdbx_entity_src_gen_prod_pcr","reaction_details"),"text"); (("pdbx_entity_src_gen_prod_pcr","purification_details"),"text"); (("pdbx_entity_src_gen_prod_pcr","summary"),"text"); 
    (("pdbx_entity_src_gen_prod_digest","entry_id"),"code"); (("pdbx_entity_src_gen_prod_digest","entity_id"),"code"); (("pdbx_entity_src_gen_prod_digest","step_id"),"int"); (("pdbx_entity_src_gen_prod_digest","next_step_id"),"int"); (("pdbx_entity_src_gen_prod_digest","end_construct_id"),"code"); (("pdbx_entity_src_gen_prod_digest","robot_id"),"code"); (("pdbx_entity_src_gen_prod_digest","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_prod_digest","restriction_enzyme_1"),"text"); (("pdbx_entity_src_gen_prod_digest","restriction_enzyme_2"),"text"); (("pdbx_entity_src_gen_prod_digest","purification_details"),"text"); (("pdbx_entity_src_gen_prod_digest","summary"),"text"); 
    (("pdbx_entity_src_gen_clone","entry_id"),"code"); (("pdbx_entity_src_gen_clone","entity_id"),"code"); (("pdbx_entity_src_gen_clone","step_id"),"int"); (("pdbx_entity_src_gen_clone","next_step_id"),"int"); (("pdbx_entity_src_gen_clone","end_construct_id"),"code"); (("pdbx_entity_src_gen_clone","robot_id"),"code"); (("pdbx_entity_src_gen_clone","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_clone","gene_insert_method"),"code"); (("pdbx_entity_src_gen_clone","vector_name"),"text"); (("pdbx_entity_src_gen_clone","vector_details"),"text"); (("pdbx_entity_src_gen_clone","transformation_method"),"code"); (("pdbx_entity_src_gen_clone","marker"),"code"); (("pdbx_entity_src_gen_clone","verification_method"),"code"); (("pdbx_entity_src_gen_clone","purification_details"),"text"); (("pdbx_entity_src_gen_clone","summary"),"text"); 
    (("pdbx_entity_src_gen_clone_ligation","entry_id"),"code"); (("pdbx_entity_src_gen_clone_ligation","entity_id"),"code"); (("pdbx_entity_src_gen_clone_ligation","step_id"),"int"); (("pdbx_entity_src_gen_clone_ligation","cleavage_enzymes"),"text"); (("pdbx_entity_src_gen_clone_ligation","ligation_enzymes"),"text"); (("pdbx_entity_src_gen_clone_ligation","temperature"),"float"); (("pdbx_entity_src_gen_clone_ligation","time"),"int"); (("pdbx_entity_src_gen_clone_ligation","details"),"text"); 
    (("pdbx_entity_src_gen_clone_recombination","entry_id"),"code"); (("pdbx_entity_src_gen_clone_recombination","entity_id"),"code"); (("pdbx_entity_src_gen_clone_recombination","step_id"),"int"); (("pdbx_entity_src_gen_clone_recombination","system"),"code"); (("pdbx_entity_src_gen_clone_recombination","recombination_enzymes"),"code"); (("pdbx_entity_src_gen_clone_recombination","details"),"text"); 
    (("pdbx_entity_src_gen_express","entry_id"),"code"); (("pdbx_entity_src_gen_express","entity_id"),"code"); (("pdbx_entity_src_gen_express","step_id"),"int"); (("pdbx_entity_src_gen_express","next_step_id"),"int"); (("pdbx_entity_src_gen_express","end_construct_id"),"code"); (("pdbx_entity_src_gen_express","robot_id"),"code"); (("pdbx_entity_src_gen_express","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_express","promoter_type"),"text"); (("pdbx_entity_src_gen_express","plasmid_id"),"code"); (("pdbx_entity_src_gen_express","vector_type"),"code"); (("pdbx_entity_src_gen_express","N_terminal_seq_tag"),"text"); (("pdbx_entity_src_gen_express","C_terminal_seq_tag"),"text"); (("pdbx_entity_src_gen_express","host_org_scientific_name"),"line"); (("pdbx_entity_src_gen_express","host_org_common_name"),"line"); (("pdbx_entity_src_gen_express","host_org_variant"),"line"); (("pdbx_entity_src_gen_express","host_org_strain"),"line"); (("pdbx_entity_src_gen_express","host_org_tissue"),"line"); (("pdbx_entity_src_gen_express","host_org_culture_collection"),"line"); (("pdbx_entity_src_gen_express","host_org_cell_line"),"line"); (("pdbx_entity_src_gen_express","host_org_tax_id"),"line"); (("pdbx_entity_src_gen_express","host_org_details"),"text"); (("pdbx_entity_src_gen_express","culture_base_media"),"text"); (("pdbx_entity_src_gen_express","culture_additives"),"text"); (("pdbx_entity_src_gen_express","culture_volume"),"float"); (("pdbx_entity_src_gen_express","culture_time"),"float"); (("pdbx_entity_src_gen_express","culture_temperature"),"float"); (("pdbx_entity_src_gen_express","inducer"),"line"); (("pdbx_entity_src_gen_express","inducer_concentration"),"float"); (("pdbx_entity_src_gen_express","induction_details"),"text"); (("pdbx_entity_src_gen_express","multiplicity_of_infection"),"float"); (("pdbx_entity_src_gen_express","induction_timepoint"),"float"); (("pdbx_entity_src_gen_express","induction_temperature"),"float"); (("pdbx_entity_src_gen_express","harvesting_details"),"text"); (("pdbx_entity_src_gen_express","storage_details"),"text"); (("pdbx_entity_src_gen_express","summary"),"text"); 
    (("pdbx_entity_src_gen_express_timepoint","entry_id"),"code"); (("pdbx_entity_src_gen_express_timepoint","entity_id"),"code"); (("pdbx_entity_src_gen_express_timepoint","step_id"),"int"); (("pdbx_entity_src_gen_express_timepoint","serial"),"int"); (("pdbx_entity_src_gen_express_timepoint","OD"),"int"); (("pdbx_entity_src_gen_express_timepoint","time"),"int"); 
    (("pdbx_entity_src_gen_lysis","entry_id"),"code"); (("pdbx_entity_src_gen_lysis","entity_id"),"code"); (("pdbx_entity_src_gen_lysis","step_id"),"int"); (("pdbx_entity_src_gen_lysis","next_step_id"),"int"); (("pdbx_entity_src_gen_lysis","end_construct_id"),"code"); (("pdbx_entity_src_gen_lysis","robot_id"),"code"); (("pdbx_entity_src_gen_lysis","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_lysis","method"),"code"); (("pdbx_entity_src_gen_lysis","buffer_id"),"code"); (("pdbx_entity_src_gen_lysis","buffer_volume"),"float"); (("pdbx_entity_src_gen_lysis","temperature"),"float"); (("pdbx_entity_src_gen_lysis","time"),"float"); (("pdbx_entity_src_gen_lysis","details"),"text"); 
    (("pdbx_entity_src_gen_refold","entry_id"),"code"); (("pdbx_entity_src_gen_refold","entity_id"),"code"); (("pdbx_entity_src_gen_refold","step_id"),"int"); (("pdbx_entity_src_gen_refold","next_step_id"),"int"); (("pdbx_entity_src_gen_refold","end_construct_id"),"code"); (("pdbx_entity_src_gen_refold","robot_id"),"code"); (("pdbx_entity_src_gen_refold","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_refold","denature_buffer_id"),"code"); (("pdbx_entity_src_gen_refold","refold_buffer_id"),"code"); (("pdbx_entity_src_gen_refold","temperature"),"float"); (("pdbx_entity_src_gen_refold","time"),"float"); (("pdbx_entity_src_gen_refold","storage_buffer_id"),"code"); (("pdbx_entity_src_gen_refold","details"),"text"); 
    (("pdbx_entity_src_gen_proteolysis","entry_id"),"code"); (("pdbx_entity_src_gen_proteolysis","entity_id"),"code"); (("pdbx_entity_src_gen_proteolysis","step_id"),"int"); (("pdbx_entity_src_gen_proteolysis","next_step_id"),"int"); (("pdbx_entity_src_gen_proteolysis","end_construct_id"),"code"); (("pdbx_entity_src_gen_proteolysis","robot_id"),"code"); (("pdbx_entity_src_gen_proteolysis","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_proteolysis","details"),"text"); (("pdbx_entity_src_gen_proteolysis","protease"),"text"); (("pdbx_entity_src_gen_proteolysis","protein_protease_ratio"),"float"); (("pdbx_entity_src_gen_proteolysis","cleavage_buffer_id"),"code"); (("pdbx_entity_src_gen_proteolysis","cleavage_temperature"),"float"); (("pdbx_entity_src_gen_proteolysis","cleavage_time"),"float"); 
    (("pdbx_entity_src_gen_chrom","entry_id"),"code"); (("pdbx_entity_src_gen_chrom","entity_id"),"code"); (("pdbx_entity_src_gen_chrom","step_id"),"int"); (("pdbx_entity_src_gen_chrom","next_step_id"),"int"); (("pdbx_entity_src_gen_chrom","end_construct_id"),"code"); (("pdbx_entity_src_gen_chrom","robot_id"),"code"); (("pdbx_entity_src_gen_chrom","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_chrom","column_type"),"text"); (("pdbx_entity_src_gen_chrom","column_volume"),"float"); (("pdbx_entity_src_gen_chrom","column_temperature"),"float"); (("pdbx_entity_src_gen_chrom","equilibration_buffer_id"),"code"); (("pdbx_entity_src_gen_chrom","flow_rate"),"float"); (("pdbx_entity_src_gen_chrom","elution_buffer_id"),"code"); (("pdbx_entity_src_gen_chrom","elution_protocol"),"text"); (("pdbx_entity_src_gen_chrom","sample_prep_details"),"text"); (("pdbx_entity_src_gen_chrom","sample_volume"),"float"); (("pdbx_entity_src_gen_chrom","sample_concentration"),"float"); (("pdbx_entity_src_gen_chrom","sample_conc_method"),"text"); (("pdbx_entity_src_gen_chrom","volume_pooled_fractions"),"float"); (("pdbx_entity_src_gen_chrom","yield_pooled_fractions"),"float"); (("pdbx_entity_src_gen_chrom","yield_method"),"text"); (("pdbx_entity_src_gen_chrom","post_treatment"),"text"); 
    (("pdbx_entity_src_gen_fract","entry_id"),"code"); (("pdbx_entity_src_gen_fract","entity_id"),"code"); (("pdbx_entity_src_gen_fract","step_id"),"int"); (("pdbx_entity_src_gen_fract","next_step_id"),"int"); (("pdbx_entity_src_gen_fract","end_construct_id"),"code"); (("pdbx_entity_src_gen_fract","robot_id"),"code"); (("pdbx_entity_src_gen_fract","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_fract","method"),"code"); (("pdbx_entity_src_gen_fract","temperature"),"float"); (("pdbx_entity_src_gen_fract","details"),"text"); (("pdbx_entity_src_gen_fract","protein_location"),"code"); (("pdbx_entity_src_gen_fract","protein_volume"),"float"); (("pdbx_entity_src_gen_fract","protein_yield"),"float"); (("pdbx_entity_src_gen_fract","protein_yield_method"),"text"); 
    (("pdbx_entity_src_gen_pure","entry_id"),"code"); (("pdbx_entity_src_gen_pure","entity_id"),"code"); (("pdbx_entity_src_gen_pure","step_id"),"int"); (("pdbx_entity_src_gen_pure","product_id"),"code"); (("pdbx_entity_src_gen_pure","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_pure","conc_device_id"),"code"); (("pdbx_entity_src_gen_pure","conc_details"),"text"); (("pdbx_entity_src_gen_pure","conc_assay_method"),"text"); (("pdbx_entity_src_gen_pure","protein_concentration"),"float"); (("pdbx_entity_src_gen_pure","protein_yield"),"float"); (("pdbx_entity_src_gen_pure","protein_purity"),"float"); (("pdbx_entity_src_gen_pure","protein_oligomeric_state"),"int"); (("pdbx_entity_src_gen_pure","storage_buffer_id"),"code"); (("pdbx_entity_src_gen_pure","storage_temperature"),"float"); (("pdbx_entity_src_gen_pure","summary"),"text"); 
    (("pdbx_entity_src_gen_character","entry_id"),"code"); (("pdbx_entity_src_gen_character","entity_id"),"code"); (("pdbx_entity_src_gen_character","step_id"),"int"); (("pdbx_entity_src_gen_character","robot_id"),"code"); (("pdbx_entity_src_gen_character","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_entity_src_gen_character","method"),"text"); (("pdbx_entity_src_gen_character","result"),"text"); (("pdbx_entity_src_gen_character","details"),"text"); 
    (("pdbx_construct","entry_id"),"code"); (("pdbx_construct","id"),"code"); (("pdbx_construct","name"),"line"); (("pdbx_construct","organisation"),"line"); (("pdbx_construct","entity_id"),"code"); (("pdbx_construct","robot_id"),"code"); (("pdbx_construct","date"),"yyyy-mm-dd:hh:mm"); (("pdbx_construct","details"),"text"); (("pdbx_construct","class"),"code"); (("pdbx_construct","type"),"code"); (("pdbx_construct","seq"),"text"); 
    (("pdbx_construct_feature","id"),"code"); (("pdbx_construct_feature","construct_id"),"code"); (("pdbx_construct_feature","entry_id"),"code"); (("pdbx_construct_feature","start_seq"),"int"); (("pdbx_construct_feature","end_seq"),"int"); (("pdbx_construct_feature","type"),"line"); (("pdbx_construct_feature","details"),"text"); 
    (("pdbx_robot_system","id"),"code"); (("pdbx_robot_system","model"),"line"); (("pdbx_robot_system","type"),"line"); (("pdbx_robot_system","manufacturer"),"line"); 
    (("pdbx_buffer","id"),"code"); (("pdbx_buffer","name"),"line"); (("pdbx_buffer","details"),"text"); 
    (("pdbx_buffer_components","id"),"code"); (("pdbx_buffer_components","buffer_id"),"code"); (("pdbx_buffer_components","name"),"line"); (("pdbx_buffer_components","volume"),"code"); (("pdbx_buffer_components","conc"),"code"); (("pdbx_buffer_components","details"),"text"); (("pdbx_buffer_components","conc_units"),"code"); (("pdbx_buffer_components","isotopic_labeling"),"line"); 
    (("pdbx_domain","details"),"text"); (("pdbx_domain","id"),"code"); 
    (("pdbx_domain_range","beg_label_alt_id"),"code"); (("pdbx_domain_range","beg_label_asym_id"),"code"); (("pdbx_domain_range","beg_label_comp_id"),"ucode"); (("pdbx_domain_range","beg_label_seq_id"),"int"); (("pdbx_domain_range","beg_auth_asym_id"),"code"); (("pdbx_domain_range","beg_auth_comp_id"),"code"); (("pdbx_domain_range","beg_auth_seq_id"),"code"); (("pdbx_domain_range","domain_id"),"code"); (("pdbx_domain_range","end_label_alt_id"),"code"); (("pdbx_domain_range","end_label_asym_id"),"code"); (("pdbx_domain_range","end_label_comp_id"),"ucode"); (("pdbx_domain_range","end_label_seq_id"),"int"); (("pdbx_domain_range","end_auth_asym_id"),"code"); (("pdbx_domain_range","end_auth_comp_id"),"code"); (("pdbx_domain_range","end_auth_seq_id"),"code"); 
    (("pdbx_sequence_range","beg_label_alt_id"),"code"); (("pdbx_sequence_range","beg_label_asym_id"),"code"); (("pdbx_sequence_range","beg_label_comp_id"),"ucode"); (("pdbx_sequence_range","beg_label_seq_id"),"int"); (("pdbx_sequence_range","beg_auth_asym_id"),"code"); (("pdbx_sequence_range","beg_auth_comp_id"),"code"); (("pdbx_sequence_range","beg_auth_seq_id"),"code"); (("pdbx_sequence_range","seq_range_id"),"code"); (("pdbx_sequence_range","end_label_alt_id"),"code"); (("pdbx_sequence_range","end_label_asym_id"),"code"); (("pdbx_sequence_range","end_label_comp_id"),"ucode"); (("pdbx_sequence_range","end_label_seq_id"),"int"); (("pdbx_sequence_range","end_auth_asym_id"),"code"); (("pdbx_sequence_range","end_auth_comp_id"),"code"); (("pdbx_sequence_range","end_auth_seq_id"),"code"); 
    (("pdbx_feature_entry","id"),"code"); (("pdbx_feature_entry","feature_name"),"text"); (("pdbx_feature_entry","feature_type"),"text"); (("pdbx_feature_entry","feature"),"text"); (("pdbx_feature_entry","feature_identifier"),"text"); (("pdbx_feature_entry","feature_assigned_by"),"text"); (("pdbx_feature_entry","feature_citation_id"),"code"); (("pdbx_feature_entry","feature_software_id"),"text"); 
    (("pdbx_feature_domain","id"),"code"); (("pdbx_feature_domain","domain_id"),"code"); (("pdbx_feature_domain","feature_name"),"text"); (("pdbx_feature_domain","feature_type"),"text"); (("pdbx_feature_domain","feature"),"text"); (("pdbx_feature_domain","feature_identifier"),"text"); (("pdbx_feature_domain","feature_assigned_by"),"text"); (("pdbx_feature_domain","feature_citation_id"),"code"); (("pdbx_feature_domain","feature_software_id"),"text"); 
    (("pdbx_feature_sequence_range","id"),"code"); (("pdbx_feature_sequence_range","seq_range_id"),"code"); (("pdbx_feature_sequence_range","feature_name"),"text"); (("pdbx_feature_sequence_range","feature_type"),"text"); (("pdbx_feature_sequence_range","feature"),"text"); (("pdbx_feature_sequence_range","feature_identifier"),"text"); (("pdbx_feature_sequence_range","feature_assigned_by"),"text"); (("pdbx_feature_sequence_range","feature_citation_id"),"code"); (("pdbx_feature_sequence_range","feature_software_id"),"text"); 
    (("pdbx_feature_assembly","id"),"code"); (("pdbx_feature_assembly","assembly_id"),"line"); (("pdbx_feature_assembly","feature_name"),"text"); (("pdbx_feature_assembly","feature_type"),"text"); (("pdbx_feature_assembly","feature"),"text"); (("pdbx_feature_assembly","feature_identifier"),"text"); (("pdbx_feature_assembly","feature_assigned_by"),"text"); (("pdbx_feature_assembly","feature_citation_id"),"code"); (("pdbx_feature_assembly","feature_software_id"),"text"); 
    (("pdbx_feature_monomer","id"),"code"); (("pdbx_feature_monomer","feature_name"),"text"); (("pdbx_feature_monomer","feature_type"),"text"); (("pdbx_feature_monomer","feature"),"text"); (("pdbx_feature_monomer","feature_identifier"),"text"); (("pdbx_feature_monomer","feature_assigned_by"),"text"); (("pdbx_feature_monomer","feature_citation_id"),"code"); (("pdbx_feature_monomer","feature_software_id"),"text"); (("pdbx_feature_monomer","label_alt_id"),"code"); (("pdbx_feature_monomer","label_asym_id"),"code"); (("pdbx_feature_monomer","label_comp_id"),"ucode"); (("pdbx_feature_monomer","label_seq_id"),"int"); (("pdbx_feature_monomer","auth_asym_id"),"code"); (("pdbx_feature_monomer","auth_comp_id"),"code"); (("pdbx_feature_monomer","auth_seq_id"),"code"); 
    (("pdbx_exptl_pd","entry_id"),"code"); (("pdbx_exptl_pd","spec_preparation_pH"),"float"); (("pdbx_exptl_pd","spec_preparation_pH_range"),"line"); (("pdbx_exptl_pd","spec_preparation"),"text"); 
    (("pdbx_reflns_twin","diffrn_id"),"code"); (("pdbx_reflns_twin","crystal_id"),"code"); (("pdbx_reflns_twin","domain_id"),"code"); (("pdbx_reflns_twin","type"),"line"); (("pdbx_reflns_twin","operator"),"line"); (("pdbx_reflns_twin","fraction"),"float"); (("pdbx_reflns_twin","mean_I2_over_mean_I_square"),"float"); (("pdbx_reflns_twin","mean_F_square_over_mean_F2"),"float"); 
    (("pdbx_struct_info","type"),"line"); (("pdbx_struct_info","value"),"text"); (("pdbx_struct_info","details"),"text"); 
    (("pdbx_re_refinement","entry_id"),"code"); (("pdbx_re_refinement","citation_id"),"code"); (("pdbx_re_refinement","details"),"code"); 
    (("pdbx_struct_assembly_prop","biol_id"),"code"); (("pdbx_struct_assembly_prop","type"),"line"); (("pdbx_struct_assembly_prop","value"),"text"); (("pdbx_struct_assembly_prop","details"),"text"); 
    (("pdbx_struct_ref_seq_feature","feature_id"),"int"); (("pdbx_struct_ref_seq_feature","align_id"),"code"); (("pdbx_struct_ref_seq_feature","type"),"text"); (("pdbx_struct_ref_seq_feature","details"),"text"); (("pdbx_struct_ref_seq_feature","pdb_strand_id"),"code"); (("pdbx_struct_ref_seq_feature","asym_id"),"code"); (("pdbx_struct_ref_seq_feature","beg_auth_seq_id"),"code"); (("pdbx_struct_ref_seq_feature","end_auth_seq_id"),"code"); (("pdbx_struct_ref_seq_feature","beg_seq_num"),"code"); (("pdbx_struct_ref_seq_feature","end_seq_num"),"code"); (("pdbx_struct_ref_seq_feature","beg_auth_mon_id"),"code"); (("pdbx_struct_ref_seq_feature","end_auth_mon_id"),"code"); (("pdbx_struct_ref_seq_feature","beg_pdb_ins_code"),"code"); (("pdbx_struct_ref_seq_feature","end_pdb_ins_code"),"code"); 
    (("pdbx_struct_ref_seq_feature_prop","feature_id"),"int"); (("pdbx_struct_ref_seq_feature_prop","property_id"),"int"); (("pdbx_struct_ref_seq_feature_prop","type"),"text"); (("pdbx_struct_ref_seq_feature_prop","value"),"text"); (("pdbx_struct_ref_seq_feature_prop","details"),"text"); (("pdbx_struct_ref_seq_feature_prop","beg_db_mon_id"),"code"); (("pdbx_struct_ref_seq_feature_prop","end_db_mon_id"),"code"); (("pdbx_struct_ref_seq_feature_prop","beg_db_seq_id"),"int"); (("pdbx_struct_ref_seq_feature_prop","end_db_seq_id"),"int"); 
    (("pdbx_struct_chem_comp_diagnostics","details"),"text"); (("pdbx_struct_chem_comp_diagnostics","type"),"line"); (("pdbx_struct_chem_comp_diagnostics","pdb_strand_id"),"code"); (("pdbx_struct_chem_comp_diagnostics","asym_id"),"code"); (("pdbx_struct_chem_comp_diagnostics","auth_seq_id"),"code"); (("pdbx_struct_chem_comp_diagnostics","seq_num"),"int"); (("pdbx_struct_chem_comp_diagnostics","auth_comp_id"),"code"); (("pdbx_struct_chem_comp_diagnostics","pdb_ins_code"),"code"); (("pdbx_struct_chem_comp_diagnostics","ordinal"),"int"); 
    (("pdbx_chem_comp_feature","comp_id"),"ucode"); (("pdbx_chem_comp_feature","type"),"line"); (("pdbx_chem_comp_feature","support"),"text"); (("pdbx_chem_comp_feature","value"),"text"); (("pdbx_chem_comp_feature","source"),"line"); 
    (("pdbx_coordinate_model","asym_id"),"code"); (("pdbx_coordinate_model","type"),"line"); 
    (("pdbx_struct_chem_comp_feature","details"),"text"); (("pdbx_struct_chem_comp_feature","type"),"line"); (("pdbx_struct_chem_comp_feature","pdb_strand_id"),"code"); (("pdbx_struct_chem_comp_feature","asym_id"),"code"); (("pdbx_struct_chem_comp_feature","auth_seq_id"),"code"); (("pdbx_struct_chem_comp_feature","seq_num"),"int"); (("pdbx_struct_chem_comp_feature","auth_comp_id"),"code"); (("pdbx_struct_chem_comp_feature","pdb_ins_code"),"code"); (("pdbx_struct_chem_comp_feature","ordinal"),"int"); 
    (("pdbx_diffrn_reflns_shell","diffrn_id"),"code"); (("pdbx_diffrn_reflns_shell","d_res_low"),"float"); (("pdbx_diffrn_reflns_shell","d_res_high"),"float"); (("pdbx_diffrn_reflns_shell","percent_possible_obs"),"float"); (("pdbx_diffrn_reflns_shell","Rmerge_I_obs"),"float"); (("pdbx_diffrn_reflns_shell","Rsym_value"),"float"); (("pdbx_diffrn_reflns_shell","chi_squared"),"float"); (("pdbx_diffrn_reflns_shell","redundancy"),"float"); (("pdbx_diffrn_reflns_shell","rejects"),"int"); (("pdbx_diffrn_reflns_shell","number_obs"),"int"); 
    (("pdbx_bond_distance_limits","atom_type_1"),"code"); (("pdbx_bond_distance_limits","atom_type_2"),"code"); (("pdbx_bond_distance_limits","lower_limit"),"float"); (("pdbx_bond_distance_limits","upper_limit"),"float"); 
    (("pdbx_soln_scatter","entry_id"),"code"); (("pdbx_soln_scatter","id"),"code"); (("pdbx_soln_scatter","type"),"code"); (("pdbx_soln_scatter","source_beamline"),"text"); (("pdbx_soln_scatter","source_beamline_instrument"),"text"); (("pdbx_soln_scatter","detector_type"),"text"); (("pdbx_soln_scatter","detector_specific"),"text"); (("pdbx_soln_scatter","source_type"),"text"); (("pdbx_soln_scatter","source_class"),"text"); (("pdbx_soln_scatter","num_time_frames"),"int"); (("pdbx_soln_scatter","sample_pH"),"float"); (("pdbx_soln_scatter","temperature"),"float"); (("pdbx_soln_scatter","concentration_range"),"line"); (("pdbx_soln_scatter","buffer_name"),"line"); (("pdbx_soln_scatter","mean_guiner_radius"),"float"); (("pdbx_soln_scatter","mean_guiner_radius_esd"),"float"); (("pdbx_soln_scatter","min_mean_cross_sectional_radii_gyration"),"float"); (("pdbx_soln_scatter","min_mean_cross_sectional_radii_gyration_esd"),"float"); (("pdbx_soln_scatter","max_mean_cross_sectional_radii_gyration"),"float"); (("pdbx_soln_scatter","max_mean_cross_sectional_radii_gyration_esd"),"float"); (("pdbx_soln_scatter","protein_length"),"line"); (("pdbx_soln_scatter","data_reduction_software_list"),"text"); (("pdbx_soln_scatter","data_analysis_software_list"),"text"); 
    (("pdbx_soln_scatter_model","scatter_id"),"code"); (("pdbx_soln_scatter_model","id"),"code"); (("pdbx_soln_scatter_model","details"),"text"); (("pdbx_soln_scatter_model","method"),"text"); (("pdbx_soln_scatter_model","software_list"),"text"); (("pdbx_soln_scatter_model","software_author_list"),"text"); (("pdbx_soln_scatter_model","entry_fitting_list"),"text"); (("pdbx_soln_scatter_model","num_conformers_calculated"),"int"); (("pdbx_soln_scatter_model","num_conformers_submitted"),"int"); (("pdbx_soln_scatter_model","representative_conformer"),"int"); (("pdbx_soln_scatter_model","conformer_selection_criteria"),"text"); 
    (("pdbx_chem_comp_descriptor","comp_id"),"ucode"); (("pdbx_chem_comp_descriptor","descriptor"),"text"); (("pdbx_chem_comp_descriptor","type"),"uline"); (("pdbx_chem_comp_descriptor","program"),"line"); (("pdbx_chem_comp_descriptor","program_version"),"line"); (("pdbx_chem_comp_descriptor","ordinal"),"int"); 
    (("pdbx_chem_comp_identifier","comp_id"),"ucode"); (("pdbx_chem_comp_identifier","identifier"),"text"); (("pdbx_chem_comp_identifier","type"),"line"); (("pdbx_chem_comp_identifier","program"),"line"); (("pdbx_chem_comp_identifier","program_version"),"line"); (("pdbx_chem_comp_identifier","ordinal"),"int"); 
    (("pdbx_chem_comp_import","comp_id"),"ucode"); 
    (("pdbx_chem_comp_atom_edit","ordinal"),"int"); (("pdbx_chem_comp_atom_edit","comp_id"),"ucode"); (("pdbx_chem_comp_atom_edit","edit_op"),"ucode"); (("pdbx_chem_comp_atom_edit","atom_id"),"atcode"); (("pdbx_chem_comp_atom_edit","edit_atom_id"),"atcode"); (("pdbx_chem_comp_atom_edit","edit_atom_value"),"line"); 
    (("pdbx_chem_comp_bond_edit","ordinal"),"int"); (("pdbx_chem_comp_bond_edit","comp_id"),"ucode"); (("pdbx_chem_comp_bond_edit","edit_op"),"ucode"); (("pdbx_chem_comp_bond_edit","atom_id_1"),"atcode"); (("pdbx_chem_comp_bond_edit","atom_id_2"),"atcode"); (("pdbx_chem_comp_bond_edit","edit_bond_value"),"line"); 
    (("pdbx_chem_comp_audit","comp_id"),"ucode"); (("pdbx_chem_comp_audit","date"),"yyyy-mm-dd"); (("pdbx_chem_comp_audit","annotator"),"code"); (("pdbx_chem_comp_audit","processing_site"),"code"); (("pdbx_chem_comp_audit","details"),"text"); (("pdbx_chem_comp_audit","action_type"),"line"); 
    (("pdbx_validate_close_contact","id"),"int"); (("pdbx_validate_close_contact","PDB_model_num"),"int"); (("pdbx_validate_close_contact","auth_asym_id_1"),"code"); (("pdbx_validate_close_contact","auth_atom_id_1"),"atcode"); (("pdbx_validate_close_contact","auth_comp_id_1"),"code"); (("pdbx_validate_close_contact","auth_seq_id_1"),"code"); (("pdbx_validate_close_contact","auth_atom_id_2"),"atcode"); (("pdbx_validate_close_contact","auth_asym_id_2"),"code"); (("pdbx_validate_close_contact","auth_comp_id_2"),"code"); (("pdbx_validate_close_contact","auth_seq_id_2"),"code"); (("pdbx_validate_close_contact","PDB_ins_code_1"),"code"); (("pdbx_validate_close_contact","PDB_ins_code_2"),"code"); (("pdbx_validate_close_contact","label_alt_id_1"),"code"); (("pdbx_validate_close_contact","label_alt_id_2"),"code"); (("pdbx_validate_close_contact","symm_as_xyz_1"),"line"); (("pdbx_validate_close_contact","symm_as_xyz_2"),"line"); (("pdbx_validate_close_contact","dist"),"float"); 
    (("pdbx_validate_symm_contact","id"),"int"); (("pdbx_validate_symm_contact","PDB_model_num"),"int"); (("pdbx_validate_symm_contact","auth_asym_id_1"),"code"); (("pdbx_validate_symm_contact","auth_atom_id_1"),"atcode"); (("pdbx_validate_symm_contact","auth_comp_id_1"),"code"); (("pdbx_validate_symm_contact","auth_seq_id_1"),"code"); (("pdbx_validate_symm_contact","auth_atom_id_2"),"atcode"); (("pdbx_validate_symm_contact","auth_asym_id_2"),"code"); (("pdbx_validate_symm_contact","auth_comp_id_2"),"code"); (("pdbx_validate_symm_contact","auth_seq_id_2"),"code"); (("pdbx_validate_symm_contact","PDB_ins_code_1"),"code"); (("pdbx_validate_symm_contact","PDB_ins_code_2"),"code"); (("pdbx_validate_symm_contact","label_alt_id_1"),"code"); (("pdbx_validate_symm_contact","label_alt_id_2"),"code"); (("pdbx_validate_symm_contact","site_symmetry_1"),"line"); (("pdbx_validate_symm_contact","site_symmetry_2"),"line"); (("pdbx_validate_symm_contact","dist"),"float"); 
    (("pdbx_validate_rmsd_bond","id"),"int"); (("pdbx_validate_rmsd_bond","PDB_model_num"),"int"); (("pdbx_validate_rmsd_bond","auth_asym_id_1"),"code"); (("pdbx_validate_rmsd_bond","auth_atom_id_1"),"atcode"); (("pdbx_validate_rmsd_bond","auth_comp_id_1"),"code"); (("pdbx_validate_rmsd_bond","auth_seq_id_1"),"code"); (("pdbx_validate_rmsd_bond","auth_atom_id_2"),"atcode"); (("pdbx_validate_rmsd_bond","auth_asym_id_2"),"code"); (("pdbx_validate_rmsd_bond","auth_comp_id_2"),"code"); (("pdbx_validate_rmsd_bond","auth_seq_id_2"),"code"); (("pdbx_validate_rmsd_bond","PDB_ins_code_1"),"code"); (("pdbx_validate_rmsd_bond","PDB_ins_code_2"),"code"); (("pdbx_validate_rmsd_bond","label_alt_id_1"),"code"); (("pdbx_validate_rmsd_bond","label_alt_id_2"),"code"); (("pdbx_validate_rmsd_bond","bond_deviation"),"float"); (("pdbx_validate_rmsd_bond","bond_value"),"float"); (("pdbx_validate_rmsd_bond","bond_target_value"),"float"); (("pdbx_validate_rmsd_bond","bond_standard_deviation"),"float"); (("pdbx_validate_rmsd_bond","linker_flag"),"uline"); 
    (("pdbx_validate_rmsd_angle","id"),"int"); (("pdbx_validate_rmsd_angle","PDB_model_num"),"int"); (("pdbx_validate_rmsd_angle","auth_asym_id_1"),"code"); (("pdbx_validate_rmsd_angle","auth_atom_id_1"),"atcode"); (("pdbx_validate_rmsd_angle","auth_comp_id_1"),"code"); (("pdbx_validate_rmsd_angle","auth_seq_id_1"),"code"); (("pdbx_validate_rmsd_angle","auth_atom_id_2"),"atcode"); (("pdbx_validate_rmsd_angle","auth_asym_id_2"),"code"); (("pdbx_validate_rmsd_angle","auth_comp_id_2"),"code"); (("pdbx_validate_rmsd_angle","auth_seq_id_2"),"code"); (("pdbx_validate_rmsd_angle","auth_atom_id_3"),"atcode"); (("pdbx_validate_rmsd_angle","auth_asym_id_3"),"code"); (("pdbx_validate_rmsd_angle","auth_comp_id_3"),"code"); (("pdbx_validate_rmsd_angle","auth_seq_id_3"),"code"); (("pdbx_validate_rmsd_angle","PDB_ins_code_1"),"code"); (("pdbx_validate_rmsd_angle","PDB_ins_code_2"),"code"); (("pdbx_validate_rmsd_angle","PDB_ins_code_3"),"code"); (("pdbx_validate_rmsd_angle","label_alt_id_1"),"code"); (("pdbx_validate_rmsd_angle","label_alt_id_2"),"code"); (("pdbx_validate_rmsd_angle","label_alt_id_3"),"code"); (("pdbx_validate_rmsd_angle","angle_deviation"),"float"); (("pdbx_validate_rmsd_angle","angle_value"),"float"); (("pdbx_validate_rmsd_angle","angle_target_value"),"float"); (("pdbx_validate_rmsd_angle","angle_standard_deviation"),"float"); (("pdbx_validate_rmsd_angle","linker_flag"),"uline"); 
    (("pdbx_validate_torsion","id"),"int"); (("pdbx_validate_torsion","PDB_model_num"),"int"); (("pdbx_validate_torsion","auth_asym_id"),"code"); (("pdbx_validate_torsion","auth_comp_id"),"code"); (("pdbx_validate_torsion","auth_seq_id"),"code"); (("pdbx_validate_torsion","PDB_ins_code"),"code"); (("pdbx_validate_torsion","label_alt_id"),"code"); (("pdbx_validate_torsion","phi"),"float"); (("pdbx_validate_torsion","psi"),"float"); 
    (("pdbx_validate_peptide_omega","id"),"int"); (("pdbx_validate_peptide_omega","PDB_model_num"),"int"); (("pdbx_validate_peptide_omega","auth_asym_id_1"),"code"); (("pdbx_validate_peptide_omega","auth_asym_id_2"),"code"); (("pdbx_validate_peptide_omega","auth_comp_id_1"),"code"); (("pdbx_validate_peptide_omega","auth_comp_id_2"),"code"); (("pdbx_validate_peptide_omega","auth_seq_id_1"),"code"); (("pdbx_validate_peptide_omega","auth_seq_id_2"),"code"); (("pdbx_validate_peptide_omega","PDB_ins_code_1"),"code"); (("pdbx_validate_peptide_omega","PDB_ins_code_2"),"code"); (("pdbx_validate_peptide_omega","label_alt_id_1"),"code"); (("pdbx_validate_peptide_omega","label_alt_id_2"),"code"); (("pdbx_validate_peptide_omega","omega"),"float"); 
    (("pdbx_validate_chiral","id"),"int"); (("pdbx_validate_chiral","PDB_model_num"),"int"); (("pdbx_validate_chiral","auth_asym_id"),"code"); (("pdbx_validate_chiral","auth_atom_id"),"atcode"); (("pdbx_validate_chiral","label_alt_id"),"code"); (("pdbx_validate_chiral","auth_comp_id"),"code"); (("pdbx_validate_chiral","auth_seq_id"),"code"); (("pdbx_validate_chiral","PDB_ins_code"),"code"); (("pdbx_validate_chiral","omega"),"float"); (("pdbx_validate_chiral","details"),"line"); 
    (("pdbx_validate_planes","id"),"int"); (("pdbx_validate_planes","PDB_model_num"),"int"); (("pdbx_validate_planes","auth_asym_id"),"code"); (("pdbx_validate_planes","auth_comp_id"),"code"); (("pdbx_validate_planes","auth_seq_id"),"code"); (("pdbx_validate_planes","PDB_ins_code"),"code"); (("pdbx_validate_planes","label_alt_id"),"code"); (("pdbx_validate_planes","rmsd"),"float"); (("pdbx_validate_planes","type"),"uline"); 
    (("pdbx_validate_planes_atom","plane_id"),"int"); (("pdbx_validate_planes_atom","id"),"int"); (("pdbx_validate_planes_atom","PDB_model_num"),"int"); (("pdbx_validate_planes_atom","auth_asym_id"),"code"); (("pdbx_validate_planes_atom","auth_comp_id"),"code"); (("pdbx_validate_planes_atom","auth_seq_id"),"code"); (("pdbx_validate_planes_atom","PDB_ins_code"),"code"); (("pdbx_validate_planes_atom","auth_atom_id"),"atcode"); (("pdbx_validate_planes_atom","atom_deviation"),"float"); 
    (("pdbx_validate_main_chain_plane","id"),"int"); (("pdbx_validate_main_chain_plane","PDB_model_num"),"int"); (("pdbx_validate_main_chain_plane","auth_asym_id"),"code"); (("pdbx_validate_main_chain_plane","auth_comp_id"),"code"); (("pdbx_validate_main_chain_plane","auth_seq_id"),"code"); (("pdbx_validate_main_chain_plane","PDB_ins_code"),"code"); (("pdbx_validate_main_chain_plane","label_alt_id"),"code"); (("pdbx_validate_main_chain_plane","improper_torsion_angle"),"float"); 
    (("pdbx_struct_conn_angle","id"),"code"); (("pdbx_struct_conn_angle","ptnr1_label_alt_id"),"code"); (("pdbx_struct_conn_angle","ptnr1_label_asym_id"),"code"); (("pdbx_struct_conn_angle","ptnr1_label_atom_id"),"atcode"); (("pdbx_struct_conn_angle","ptnr1_label_comp_id"),"ucode"); (("pdbx_struct_conn_angle","ptnr1_label_seq_id"),"int"); (("pdbx_struct_conn_angle","ptnr1_auth_asym_id"),"code"); (("pdbx_struct_conn_angle","ptnr1_auth_atom_id"),"atcode"); (("pdbx_struct_conn_angle","ptnr1_auth_comp_id"),"code"); (("pdbx_struct_conn_angle","ptnr1_auth_seq_id"),"code"); (("pdbx_struct_conn_angle","ptnr1_symmetry"),"symop"); (("pdbx_struct_conn_angle","ptnr2_label_alt_id"),"code"); (("pdbx_struct_conn_angle","ptnr2_label_asym_id"),"code"); (("pdbx_struct_conn_angle","ptnr2_label_atom_id"),"atcode"); (("pdbx_struct_conn_angle","ptnr2_label_comp_id"),"ucode"); (("pdbx_struct_conn_angle","ptnr2_label_seq_id"),"int"); (("pdbx_struct_conn_angle","ptnr2_auth_asym_id"),"code"); (("pdbx_struct_conn_angle","ptnr2_auth_atom_id"),"atcode"); (("pdbx_struct_conn_angle","ptnr2_auth_comp_id"),"code"); (("pdbx_struct_conn_angle","ptnr2_auth_seq_id"),"code"); (("pdbx_struct_conn_angle","ptnr2_symmetry"),"symop"); (("pdbx_struct_conn_angle","ptnr1_PDB_ins_code"),"code"); (("pdbx_struct_conn_angle","ptnr1_auth_alt_id"),"code"); (("pdbx_struct_conn_angle","ptnr2_PDB_ins_code"),"code"); (("pdbx_struct_conn_angle","ptnr2_auth_alt_id"),"code"); (("pdbx_struct_conn_angle","ptnr3_auth_alt_id"),"code"); (("pdbx_struct_conn_angle","ptnr3_auth_asym_id"),"code"); (("pdbx_struct_conn_angle","ptnr3_auth_atom_id"),"atcode"); (("pdbx_struct_conn_angle","ptnr3_auth_comp_id"),"code"); (("pdbx_struct_conn_angle","ptnr3_PDB_ins_code"),"code"); (("pdbx_struct_conn_angle","ptnr3_auth_seq_id"),"code"); (("pdbx_struct_conn_angle","ptnr3_label_alt_id"),"code"); (("pdbx_struct_conn_angle","ptnr3_label_asym_id"),"code"); (("pdbx_struct_conn_angle","ptnr3_label_atom_id"),"atcode"); (("pdbx_struct_conn_angle","ptnr3_label_comp_id"),"ucode"); (("pdbx_struct_conn_angle","ptnr3_label_seq_id"),"int"); (("pdbx_struct_conn_angle","ptnr3_symmetry"),"symop"); (("pdbx_struct_conn_angle","value"),"float"); (("pdbx_struct_conn_angle","value_esd"),"float"); 
    (("pdbx_unobs_or_zero_occ_residues","id"),"int"); (("pdbx_unobs_or_zero_occ_residues","polymer_flag"),"ucode"); (("pdbx_unobs_or_zero_occ_residues","occupancy_flag"),"int"); (("pdbx_unobs_or_zero_occ_residues","PDB_model_num"),"int"); (("pdbx_unobs_or_zero_occ_residues","auth_asym_id"),"code"); (("pdbx_unobs_or_zero_occ_residues","auth_comp_id"),"ucode"); (("pdbx_unobs_or_zero_occ_residues","auth_seq_id"),"code"); (("pdbx_unobs_or_zero_occ_residues","PDB_ins_code"),"code"); (("pdbx_unobs_or_zero_occ_residues","label_asym_id"),"code"); (("pdbx_unobs_or_zero_occ_residues","label_comp_id"),"ucode"); (("pdbx_unobs_or_zero_occ_residues","label_seq_id"),"int"); 
    (("pdbx_unobs_or_zero_occ_atoms","id"),"int"); (("pdbx_unobs_or_zero_occ_atoms","polymer_flag"),"ucode"); (("pdbx_unobs_or_zero_occ_atoms","occupancy_flag"),"int"); (("pdbx_unobs_or_zero_occ_atoms","PDB_model_num"),"int"); (("pdbx_unobs_or_zero_occ_atoms","auth_asym_id"),"code"); (("pdbx_unobs_or_zero_occ_atoms","auth_atom_id"),"atcode"); (("pdbx_unobs_or_zero_occ_atoms","auth_comp_id"),"ucode"); (("pdbx_unobs_or_zero_occ_atoms","auth_seq_id"),"code"); (("pdbx_unobs_or_zero_occ_atoms","PDB_ins_code"),"code"); (("pdbx_unobs_or_zero_occ_atoms","label_alt_id"),"code"); (("pdbx_unobs_or_zero_occ_atoms","label_atom_id"),"atcode"); (("pdbx_unobs_or_zero_occ_atoms","label_asym_id"),"code"); (("pdbx_unobs_or_zero_occ_atoms","label_comp_id"),"ucode"); (("pdbx_unobs_or_zero_occ_atoms","label_seq_id"),"int"); 
    (("pdbx_entry_details","entry_id"),"code"); (("pdbx_entry_details","nonpolymer_details"),"text"); (("pdbx_entry_details","sequence_details"),"text"); (("pdbx_entry_details","compound_details"),"text"); (("pdbx_entry_details","source_details"),"text"); 
    (("pdbx_struct_mod_residue","id"),"int"); (("pdbx_struct_mod_residue","PDB_model_num"),"int"); (("pdbx_struct_mod_residue","auth_asym_id"),"code"); (("pdbx_struct_mod_residue","auth_comp_id"),"code"); (("pdbx_struct_mod_residue","auth_seq_id"),"code"); (("pdbx_struct_mod_residue","PDB_ins_code"),"code"); (("pdbx_struct_mod_residue","label_asym_id"),"code"); (("pdbx_struct_mod_residue","label_comp_id"),"ucode"); (("pdbx_struct_mod_residue","label_seq_id"),"int"); (("pdbx_struct_mod_residue","parent_comp_id"),"code"); (("pdbx_struct_mod_residue","details"),"text"); 
    (("pdbx_struct_ref_seq_insertion","id"),"code"); (("pdbx_struct_ref_seq_insertion","comp_id"),"ucode"); (("pdbx_struct_ref_seq_insertion","asym_id"),"code"); (("pdbx_struct_ref_seq_insertion","auth_asym_id"),"code"); (("pdbx_struct_ref_seq_insertion","auth_seq_id"),"code"); (("pdbx_struct_ref_seq_insertion","seq_id"),"int"); (("pdbx_struct_ref_seq_insertion","PDB_ins_code"),"code"); (("pdbx_struct_ref_seq_insertion","details"),"text"); (("pdbx_struct_ref_seq_insertion","db_code"),"line"); (("pdbx_struct_ref_seq_insertion","db_name"),"line"); 
    (("pdbx_struct_ref_seq_deletion","id"),"code"); (("pdbx_struct_ref_seq_deletion","details"),"text"); (("pdbx_struct_ref_seq_deletion","asym_id"),"code"); (("pdbx_struct_ref_seq_deletion","comp_id"),"ucode"); (("pdbx_struct_ref_seq_deletion","db_seq_id"),"int"); (("pdbx_struct_ref_seq_deletion","db_code"),"line"); (("pdbx_struct_ref_seq_deletion","db_name"),"line"); 
    (("pdbx_remediation_atom_site_mapping","id"),"code"); (("pdbx_remediation_atom_site_mapping","group_PDB"),"code"); (("pdbx_remediation_atom_site_mapping","label_alt_id"),"code"); (("pdbx_remediation_atom_site_mapping","label_asym_id"),"code"); (("pdbx_remediation_atom_site_mapping","label_atom_id"),"atcode"); (("pdbx_remediation_atom_site_mapping","label_comp_id"),"ucode"); (("pdbx_remediation_atom_site_mapping","label_seq_id"),"int"); (("pdbx_remediation_atom_site_mapping","pdbx_align"),"int"); (("pdbx_remediation_atom_site_mapping","PDB_ins_code"),"code"); (("pdbx_remediation_atom_site_mapping","pre_auth_asym_id"),"code"); (("pdbx_remediation_atom_site_mapping","pre_auth_atom_id"),"atcode"); (("pdbx_remediation_atom_site_mapping","pre_auth_comp_id"),"code"); (("pdbx_remediation_atom_site_mapping","pre_auth_seq_id"),"code"); (("pdbx_remediation_atom_site_mapping","pre_PDB_ins_code"),"code"); (("pdbx_remediation_atom_site_mapping","pre_group_PDB"),"code"); (("pdbx_remediation_atom_site_mapping","pre_auth_alt_id"),"code"); (("pdbx_remediation_atom_site_mapping","pre_pdbx_align"),"int"); (("pdbx_remediation_atom_site_mapping","auth_asym_id"),"code"); (("pdbx_remediation_atom_site_mapping","auth_atom_id"),"atcode"); (("pdbx_remediation_atom_site_mapping","auth_comp_id"),"code"); (("pdbx_remediation_atom_site_mapping","auth_seq_id"),"code"); (("pdbx_remediation_atom_site_mapping","auth_alt_id"),"code"); (("pdbx_remediation_atom_site_mapping","occupancy"),"float"); (("pdbx_remediation_atom_site_mapping","pre_occupancy"),"float"); 
    (("pdbx_validate_polymer_linkage","id"),"int"); (("pdbx_validate_polymer_linkage","PDB_model_num"),"int"); (("pdbx_validate_polymer_linkage","auth_asym_id_1"),"code"); (("pdbx_validate_polymer_linkage","auth_atom_id_1"),"atcode"); (("pdbx_validate_polymer_linkage","auth_comp_id_1"),"code"); (("pdbx_validate_polymer_linkage","auth_seq_id_1"),"code"); (("pdbx_validate_polymer_linkage","auth_atom_id_2"),"atcode"); (("pdbx_validate_polymer_linkage","auth_asym_id_2"),"code"); (("pdbx_validate_polymer_linkage","auth_comp_id_2"),"code"); (("pdbx_validate_polymer_linkage","auth_seq_id_2"),"code"); (("pdbx_validate_polymer_linkage","PDB_ins_code_1"),"code"); (("pdbx_validate_polymer_linkage","PDB_ins_code_2"),"code"); (("pdbx_validate_polymer_linkage","label_alt_id_1"),"code"); (("pdbx_validate_polymer_linkage","label_alt_id_2"),"code"); (("pdbx_validate_polymer_linkage","dist"),"float"); 
    (("pdbx_helical_symmetry","entry_id"),"code"); (("pdbx_helical_symmetry","number_of_operations"),"int"); (("pdbx_helical_symmetry","rotation_per_n_subunits"),"float"); (("pdbx_helical_symmetry","rise_per_n_subunits"),"float"); (("pdbx_helical_symmetry","n_subunits_divisor"),"int"); (("pdbx_helical_symmetry","dyad_axis"),"code"); (("pdbx_helical_symmetry","circular_symmetry"),"int"); 
    (("pdbx_point_symmetry","entry_id"),"code"); (("pdbx_point_symmetry","Schoenflies_symbol"),"code"); (("pdbx_point_symmetry","circular_symmetry"),"int"); (("pdbx_point_symmetry","H-M_notation"),"code"); 
    (("pdbx_struct_entity_inst","details"),"text"); (("pdbx_struct_entity_inst","entity_id"),"code"); (("pdbx_struct_entity_inst","id"),"code"); 
    (("pdbx_struct_oper_list","id"),"code"); (("pdbx_struct_oper_list","type"),"line"); (("pdbx_struct_oper_list","name"),"line"); (("pdbx_struct_oper_list","symmetry_operation"),"line"); (("pdbx_struct_oper_list","matrix[1][1]"),"float"); (("pdbx_struct_oper_list","matrix[1][2]"),"float"); (("pdbx_struct_oper_list","matrix[1][3]"),"float"); (("pdbx_struct_oper_list","matrix[2][1]"),"float"); (("pdbx_struct_oper_list","matrix[2][2]"),"float"); (("pdbx_struct_oper_list","matrix[2][3]"),"float"); (("pdbx_struct_oper_list","matrix[3][1]"),"float"); (("pdbx_struct_oper_list","matrix[3][2]"),"float"); (("pdbx_struct_oper_list","matrix[3][3]"),"float"); (("pdbx_struct_oper_list","vector[1]"),"float"); (("pdbx_struct_oper_list","vector[2]"),"float"); (("pdbx_struct_oper_list","vector[3]"),"float"); 
    (("pdbx_struct_assembly","method_details"),"text"); (("pdbx_struct_assembly","oligomeric_details"),"line"); (("pdbx_struct_assembly","oligomeric_count"),"int"); (("pdbx_struct_assembly","details"),"text"); (("pdbx_struct_assembly","id"),"line"); 
    (("pdbx_struct_assembly_gen","entity_inst_id"),"code"); (("pdbx_struct_assembly_gen","asym_id_list"),"line"); (("pdbx_struct_assembly_gen","auth_asym_id_list"),"line"); (("pdbx_struct_assembly_gen","assembly_id"),"line"); (("pdbx_struct_assembly_gen","oper_expression"),"operation_expression"); 
    (("pdbx_struct_asym_gen","entity_inst_id"),"code"); (("pdbx_struct_asym_gen","asym_id"),"code"); (("pdbx_struct_asym_gen","oper_expression"),"operation_expression"); 
    (("pdbx_struct_msym_gen","entity_inst_id"),"code"); (("pdbx_struct_msym_gen","msym_id"),"code"); (("pdbx_struct_msym_gen","oper_expression"),"operation_expression"); 
    (("pdbx_struct_legacy_oper_list","id"),"int"); (("pdbx_struct_legacy_oper_list","name"),"line"); (("pdbx_struct_legacy_oper_list","matrix[1][1]"),"float"); (("pdbx_struct_legacy_oper_list","matrix[1][2]"),"float"); (("pdbx_struct_legacy_oper_list","matrix[1][3]"),"float"); (("pdbx_struct_legacy_oper_list","matrix[2][1]"),"float"); (("pdbx_struct_legacy_oper_list","matrix[2][2]"),"float"); (("pdbx_struct_legacy_oper_list","matrix[2][3]"),"float"); (("pdbx_struct_legacy_oper_list","matrix[3][1]"),"float"); (("pdbx_struct_legacy_oper_list","matrix[3][2]"),"float"); (("pdbx_struct_legacy_oper_list","matrix[3][3]"),"float"); (("pdbx_struct_legacy_oper_list","vector[1]"),"float"); (("pdbx_struct_legacy_oper_list","vector[2]"),"float"); (("pdbx_struct_legacy_oper_list","vector[3]"),"float"); 
    (("pdbx_chem_comp_atom_feature","comp_id"),"ucode"); (("pdbx_chem_comp_atom_feature","atom_id"),"atcode"); (("pdbx_chem_comp_atom_feature","feature_type"),"ucode"); 
    (("pdbx_reference_molecule_family","family_prd_id"),"ucode"); (("pdbx_reference_molecule_family","name"),"text"); (("pdbx_reference_molecule_family","release_status"),"uline"); (("pdbx_reference_molecule_family","replaces"),"uline"); (("pdbx_reference_molecule_family","replaced_by"),"uline"); 
    (("pdbx_reference_molecule_list","prd_id"),"ucode"); (("pdbx_reference_molecule_list","family_prd_id"),"ucode"); 
    (("pdbx_reference_molecule","prd_id"),"ucode"); (("pdbx_reference_molecule","formula_weight"),"float"); (("pdbx_reference_molecule","formula"),"text"); (("pdbx_reference_molecule","type"),"uline"); (("pdbx_reference_molecule","type_evidence_code"),"text"); (("pdbx_reference_molecule","class"),"uline"); (("pdbx_reference_molecule","class_evidence_code"),"text"); (("pdbx_reference_molecule","name"),"text"); (("pdbx_reference_molecule","represent_as"),"uline"); (("pdbx_reference_molecule","chem_comp_id"),"ucode"); (("pdbx_reference_molecule","compound_details"),"text"); (("pdbx_reference_molecule","description"),"text"); (("pdbx_reference_molecule","representative_PDB_id_code"),"ucode"); (("pdbx_reference_molecule","release_status"),"uline"); (("pdbx_reference_molecule","replaces"),"uline"); (("pdbx_reference_molecule","replaced_by"),"uline"); 
    (("pdbx_reference_entity_list","prd_id"),"ucode"); (("pdbx_reference_entity_list","ref_entity_id"),"ucode"); (("pdbx_reference_entity_list","type"),"uline"); (("pdbx_reference_entity_list","details"),"text"); (("pdbx_reference_entity_list","component_id"),"int"); 
    (("pdbx_reference_entity_nonpoly","prd_id"),"ucode"); (("pdbx_reference_entity_nonpoly","ref_entity_id"),"ucode"); (("pdbx_reference_entity_nonpoly","details"),"text"); (("pdbx_reference_entity_nonpoly","name"),"text"); (("pdbx_reference_entity_nonpoly","chem_comp_id"),"ucode"); 
    (("pdbx_reference_entity_link","link_id"),"int"); (("pdbx_reference_entity_link","prd_id"),"ucode"); (("pdbx_reference_entity_link","details"),"text"); (("pdbx_reference_entity_link","ref_entity_id_1"),"ucode"); (("pdbx_reference_entity_link","ref_entity_id_2"),"ucode"); (("pdbx_reference_entity_link","entity_seq_num_1"),"int"); (("pdbx_reference_entity_link","entity_seq_num_2"),"int"); (("pdbx_reference_entity_link","comp_id_1"),"code"); (("pdbx_reference_entity_link","comp_id_2"),"code"); (("pdbx_reference_entity_link","atom_id_1"),"atcode"); (("pdbx_reference_entity_link","atom_id_2"),"code"); (("pdbx_reference_entity_link","value_order"),"ucode"); (("pdbx_reference_entity_link","component_1"),"int"); (("pdbx_reference_entity_link","component_2"),"int"); (("pdbx_reference_entity_link","nonpoly_res_num_1"),"code"); (("pdbx_reference_entity_link","nonpoly_res_num_2"),"code"); (("pdbx_reference_entity_link","link_class"),"code"); 
    (("pdbx_reference_entity_poly_link","link_id"),"int"); (("pdbx_reference_entity_poly_link","prd_id"),"ucode"); (("pdbx_reference_entity_poly_link","details"),"text"); (("pdbx_reference_entity_poly_link","ref_entity_id"),"ucode"); (("pdbx_reference_entity_poly_link","component_id"),"int"); (("pdbx_reference_entity_poly_link","entity_seq_num_1"),"int"); (("pdbx_reference_entity_poly_link","entity_seq_num_2"),"int"); (("pdbx_reference_entity_poly_link","comp_id_1"),"code"); (("pdbx_reference_entity_poly_link","comp_id_2"),"code"); (("pdbx_reference_entity_poly_link","atom_id_1"),"atcode"); (("pdbx_reference_entity_poly_link","atom_id_2"),"code"); (("pdbx_reference_entity_poly_link","insert_code_1"),"code"); (("pdbx_reference_entity_poly_link","insert_code_2"),"code"); (("pdbx_reference_entity_poly_link","value_order"),"ucode"); 
    (("pdbx_reference_entity_poly","prd_id"),"ucode"); (("pdbx_reference_entity_poly","ref_entity_id"),"ucode"); (("pdbx_reference_entity_poly","type"),"line"); (("pdbx_reference_entity_poly","db_code"),"text"); (("pdbx_reference_entity_poly","db_name"),"text"); 
    (("pdbx_reference_entity_poly_seq","prd_id"),"ucode"); (("pdbx_reference_entity_poly_seq","ref_entity_id"),"ucode"); (("pdbx_reference_entity_poly_seq","mon_id"),"code"); (("pdbx_reference_entity_poly_seq","parent_mon_id"),"code"); (("pdbx_reference_entity_poly_seq","num"),"int"); (("pdbx_reference_entity_poly_seq","observed"),"ucode"); (("pdbx_reference_entity_poly_seq","hetero"),"ucode"); 
    (("pdbx_reference_entity_sequence","prd_id"),"ucode"); (("pdbx_reference_entity_sequence","ref_entity_id"),"ucode"); (("pdbx_reference_entity_sequence","type"),"line"); (("pdbx_reference_entity_sequence","NRP_flag"),"code"); (("pdbx_reference_entity_sequence","one_letter_codes"),"line"); 
    (("pdbx_reference_entity_src_nat","prd_id"),"ucode"); (("pdbx_reference_entity_src_nat","ref_entity_id"),"ucode"); (("pdbx_reference_entity_src_nat","ordinal"),"int"); (("pdbx_reference_entity_src_nat","organism_scientific"),"text"); (("pdbx_reference_entity_src_nat","strain"),"text"); (("pdbx_reference_entity_src_nat","taxid"),"text"); (("pdbx_reference_entity_src_nat","atcc"),"text"); (("pdbx_reference_entity_src_nat","db_code"),"text"); (("pdbx_reference_entity_src_nat","db_name"),"text"); (("pdbx_reference_entity_src_nat","source"),"text"); (("pdbx_reference_entity_src_nat","source_id"),"text"); 
    (("pdbx_reference_molecule_details","family_prd_id"),"ucode"); (("pdbx_reference_molecule_details","prd_id"),"ucode"); (("pdbx_reference_molecule_details","ordinal"),"int"); (("pdbx_reference_molecule_details","source"),"text"); (("pdbx_reference_molecule_details","source_id"),"text"); (("pdbx_reference_molecule_details","text"),"text"); 
    (("pdbx_reference_molecule_synonyms","family_prd_id"),"ucode"); (("pdbx_reference_molecule_synonyms","prd_id"),"ucode"); (("pdbx_reference_molecule_synonyms","ordinal"),"int"); (("pdbx_reference_molecule_synonyms","name"),"text"); (("pdbx_reference_molecule_synonyms","source"),"text"); (("pdbx_reference_molecule_synonyms","chem_comp_id"),"ucode"); 
    (("pdbx_reference_entity_subcomponents","prd_id"),"ucode"); (("pdbx_reference_entity_subcomponents","seq"),"text"); (("pdbx_reference_entity_subcomponents","chem_comp_id"),"ucode"); 
    (("pdbx_reference_molecule_annotation","family_prd_id"),"ucode"); (("pdbx_reference_molecule_annotation","prd_id"),"ucode"); (("pdbx_reference_molecule_annotation","ordinal"),"int"); (("pdbx_reference_molecule_annotation","text"),"text"); (("pdbx_reference_molecule_annotation","type"),"line"); (("pdbx_reference_molecule_annotation","support"),"text"); (("pdbx_reference_molecule_annotation","source"),"text"); (("pdbx_reference_molecule_annotation","chem_comp_id"),"ucode"); 
    (("pdbx_reference_molecule_features","family_prd_id"),"ucode"); (("pdbx_reference_molecule_features","prd_id"),"ucode"); (("pdbx_reference_molecule_features","ordinal"),"int"); (("pdbx_reference_molecule_features","source_ordinal"),"int"); (("pdbx_reference_molecule_features","type"),"line"); (("pdbx_reference_molecule_features","value"),"text"); (("pdbx_reference_molecule_features","source"),"line"); (("pdbx_reference_molecule_features","chem_comp_id"),"ucode"); 
    (("pdbx_reference_molecule_related_structures","family_prd_id"),"ucode"); (("pdbx_reference_molecule_related_structures","ordinal"),"int"); (("pdbx_reference_molecule_related_structures","db_name"),"text"); (("pdbx_reference_molecule_related_structures","db_code"),"text"); (("pdbx_reference_molecule_related_structures","db_accession"),"text"); (("pdbx_reference_molecule_related_structures","name"),"text"); (("pdbx_reference_molecule_related_structures","formula"),"text"); (("pdbx_reference_molecule_related_structures","citation_id"),"code"); 
    (("pdbx_struct_group_list","struct_group_id"),"ucode"); (("pdbx_struct_group_list","name"),"line"); (("pdbx_struct_group_list","type"),"line"); (("pdbx_struct_group_list","group_enumeration_type"),"ucode-alphanum-csv"); (("pdbx_struct_group_list","description"),"text"); (("pdbx_struct_group_list","selection"),"line"); (("pdbx_struct_group_list","selection_details"),"text"); 
    (("pdbx_struct_group_components","ordinal"),"int"); (("pdbx_struct_group_components","struct_group_id"),"ucode"); (("pdbx_struct_group_components","PDB_model_num"),"int"); (("pdbx_struct_group_components","auth_asym_id"),"code"); (("pdbx_struct_group_components","auth_comp_id"),"code"); (("pdbx_struct_group_components","auth_seq_id"),"code"); (("pdbx_struct_group_components","PDB_ins_code"),"code"); (("pdbx_struct_group_components","label_asym_id"),"code"); (("pdbx_struct_group_components","label_comp_id"),"ucode"); (("pdbx_struct_group_components","label_seq_id"),"int"); (("pdbx_struct_group_components","label_alt_id"),"code"); 
    (("pdbx_struct_group_component_range","ordinal"),"int"); (("pdbx_struct_group_component_range","struct_group_id"),"ucode"); (("pdbx_struct_group_component_range","PDB_model_num"),"int"); (("pdbx_struct_group_component_range","beg_auth_asym_id"),"code"); (("pdbx_struct_group_component_range","beg_auth_comp_id"),"code"); (("pdbx_struct_group_component_range","beg_auth_seq_id"),"code"); (("pdbx_struct_group_component_range","beg_PDB_ins_code"),"code"); (("pdbx_struct_group_component_range","beg_label_asym_id"),"code"); (("pdbx_struct_group_component_range","beg_label_comp_id"),"ucode"); (("pdbx_struct_group_component_range","beg_label_seq_id"),"int"); (("pdbx_struct_group_component_range","beg_label_alt_id"),"code"); (("pdbx_struct_group_component_range","end_auth_asym_id"),"code"); (("pdbx_struct_group_component_range","end_auth_comp_id"),"code"); (("pdbx_struct_group_component_range","end_auth_seq_id"),"code"); (("pdbx_struct_group_component_range","end_PDB_ins_code"),"code"); (("pdbx_struct_group_component_range","end_label_asym_id"),"code"); (("pdbx_struct_group_component_range","end_label_comp_id"),"ucode"); (("pdbx_struct_group_component_range","end_label_seq_id"),"int"); (("pdbx_struct_group_component_range","end_label_alt_id"),"code"); 
    (("pdbx_prd_audit","prd_id"),"ucode"); (("pdbx_prd_audit","date"),"yyyy-mm-dd"); (("pdbx_prd_audit","annotator"),"code"); (("pdbx_prd_audit","processing_site"),"code"); (("pdbx_prd_audit","details"),"text"); (("pdbx_prd_audit","action_type"),"line"); 
    (("pdbx_family_prd_audit","family_prd_id"),"ucode"); (("pdbx_family_prd_audit","date"),"yyyy-mm-dd"); (("pdbx_family_prd_audit","annotator"),"code"); (("pdbx_family_prd_audit","processing_site"),"code"); (("pdbx_family_prd_audit","details"),"text"); (("pdbx_family_prd_audit","action_type"),"line"); 
    (("pdbx_molecule","prd_id"),"ucode"); (("pdbx_molecule","instance_id"),"int"); (("pdbx_molecule","asym_id"),"code"); (("pdbx_molecule","linked_entity_id"),"code"); 
    (("pdbx_molecule_features","prd_id"),"ucode"); (("pdbx_molecule_features","class"),"uline"); (("pdbx_molecule_features","type"),"uline"); (("pdbx_molecule_features","name"),"text"); (("pdbx_molecule_features","details"),"text"); 
    (("pdbx_family_group_index","id"),"ucode"); (("pdbx_family_group_index","family_prd_id"),"ucode"); 
    (("pdbx_distant_solvent_atoms","id"),"int"); (("pdbx_distant_solvent_atoms","PDB_model_num"),"int"); (("pdbx_distant_solvent_atoms","auth_asym_id"),"code"); (("pdbx_distant_solvent_atoms","auth_atom_id"),"atcode"); (("pdbx_distant_solvent_atoms","auth_comp_id"),"ucode"); (("pdbx_distant_solvent_atoms","auth_seq_id"),"code"); (("pdbx_distant_solvent_atoms","PDB_ins_code"),"code"); (("pdbx_distant_solvent_atoms","label_alt_id"),"code"); (("pdbx_distant_solvent_atoms","label_atom_id"),"atcode"); (("pdbx_distant_solvent_atoms","label_asym_id"),"code"); (("pdbx_distant_solvent_atoms","label_comp_id"),"ucode"); (("pdbx_distant_solvent_atoms","label_seq_id"),"int"); (("pdbx_distant_solvent_atoms","neighbor_macromolecule_distance"),"float"); (("pdbx_distant_solvent_atoms","neighbor_ligand_distance"),"float"); 
    (("pdbx_struct_special_symmetry","id"),"int"); (("pdbx_struct_special_symmetry","PDB_model_num"),"int"); (("pdbx_struct_special_symmetry","auth_asym_id"),"code"); (("pdbx_struct_special_symmetry","auth_comp_id"),"ucode"); (("pdbx_struct_special_symmetry","auth_seq_id"),"code"); (("pdbx_struct_special_symmetry","PDB_ins_code"),"code"); (("pdbx_struct_special_symmetry","label_alt_id"),"code"); (("pdbx_struct_special_symmetry","label_asym_id"),"code"); (("pdbx_struct_special_symmetry","label_comp_id"),"ucode"); (("pdbx_struct_special_symmetry","label_seq_id"),"int"); 
    (("pdbx_reference_publication_list","publication_abbrev"),"line"); (("pdbx_reference_publication_list","ASTM_code_type"),"line"); (("pdbx_reference_publication_list","ASTM_code_value"),"line"); (("pdbx_reference_publication_list","ISSN_code_type"),"line"); (("pdbx_reference_publication_list","ISSN_code_value"),"line"); (("pdbx_reference_publication_list","country"),"line"); (("pdbx_reference_publication_list","start_year"),"line"); (("pdbx_reference_publication_list","end_year"),"line"); 
    (("pdbx_nmr_assigned_chem_shift_list","chem_shift_13C_err"),"float"); (("pdbx_nmr_assigned_chem_shift_list","chem_shift_15N_err"),"float"); (("pdbx_nmr_assigned_chem_shift_list","chem_shift_19F_err"),"float"); (("pdbx_nmr_assigned_chem_shift_list","chem_shift_1H_err"),"float"); (("pdbx_nmr_assigned_chem_shift_list","chem_shift_2H_err"),"float"); (("pdbx_nmr_assigned_chem_shift_list","chem_shift_31P_err"),"float"); (("pdbx_nmr_assigned_chem_shift_list","chem_shift_reference_id"),"int"); (("pdbx_nmr_assigned_chem_shift_list","conditions_id"),"int"); (("pdbx_nmr_assigned_chem_shift_list","data_file_name"),"line"); (("pdbx_nmr_assigned_chem_shift_list","details"),"text"); (("pdbx_nmr_assigned_chem_shift_list","entry_id"),"code"); (("pdbx_nmr_assigned_chem_shift_list","error_derivation_method"),"text"); (("pdbx_nmr_assigned_chem_shift_list","id"),"int"); (("pdbx_nmr_assigned_chem_shift_list","label"),"line"); (("pdbx_nmr_assigned_chem_shift_list","conditions_label"),"line"); 
    (("pdbx_nmr_chem_shift_experiment","assigned_chem_shift_list_id"),"int"); (("pdbx_nmr_chem_shift_experiment","entry_id"),"code"); (("pdbx_nmr_chem_shift_experiment","experiment_id"),"int"); (("pdbx_nmr_chem_shift_experiment","experiment_name"),"line"); (("pdbx_nmr_chem_shift_experiment","sample_state"),"line"); (("pdbx_nmr_chem_shift_experiment","solution_id"),"int"); 
    (("pdbx_nmr_chem_shift_ref","atom_group"),"line"); (("pdbx_nmr_chem_shift_ref","atom_isotope_number"),"int"); (("pdbx_nmr_chem_shift_ref","atom_type"),"code"); (("pdbx_nmr_chem_shift_ref","chem_shift_reference_id"),"int"); (("pdbx_nmr_chem_shift_ref","chem_shift_units"),"line"); (("pdbx_nmr_chem_shift_ref","chem_shift_val"),"float"); (("pdbx_nmr_chem_shift_ref","correction_val"),"float"); (("pdbx_nmr_chem_shift_ref","entry_id"),"code"); (("pdbx_nmr_chem_shift_ref","external_ref_axis"),"line"); (("pdbx_nmr_chem_shift_ref","external_ref_loc"),"line"); (("pdbx_nmr_chem_shift_ref","external_ref_sample_geometry"),"line"); (("pdbx_nmr_chem_shift_ref","indirect_shift_ratio"),"float"); (("pdbx_nmr_chem_shift_ref","mol_common_name"),"line"); (("pdbx_nmr_chem_shift_ref","rank"),"code"); (("pdbx_nmr_chem_shift_ref","ref_correction_type"),"line"); (("pdbx_nmr_chem_shift_ref","ref_method"),"line"); (("pdbx_nmr_chem_shift_ref","ref_type"),"line"); (("pdbx_nmr_chem_shift_ref","solvent"),"line"); 
    (("pdbx_nmr_chem_shift_reference","carbon_shifts_flag"),"line"); (("pdbx_nmr_chem_shift_reference","details"),"text"); (("pdbx_nmr_chem_shift_reference","entry_id"),"code"); (("pdbx_nmr_chem_shift_reference","id"),"int"); (("pdbx_nmr_chem_shift_reference","label"),"line"); (("pdbx_nmr_chem_shift_reference","nitrogen_shifts_flag"),"line"); (("pdbx_nmr_chem_shift_reference","other_shifts_flag"),"line"); (("pdbx_nmr_chem_shift_reference","phosphorus_shifts_flag"),"line"); (("pdbx_nmr_chem_shift_reference","proton_shifts_flag"),"line"); 
    (("pdbx_nmr_chem_shift_software","assigned_chem_shift_list_id"),"int"); (("pdbx_nmr_chem_shift_software","entry_id"),"code"); (("pdbx_nmr_chem_shift_software","software_id"),"int"); (("pdbx_nmr_chem_shift_software","software_label"),"code"); 
    (("pdbx_nmr_constraint_file","constraint_filename"),"line"); (("pdbx_nmr_constraint_file","constraint_number"),"int"); (("pdbx_nmr_constraint_file","constraint_subtype"),"line"); (("pdbx_nmr_constraint_file","constraint_type"),"line"); (("pdbx_nmr_constraint_file","entry_id"),"code"); (("pdbx_nmr_constraint_file","id"),"int"); (("pdbx_nmr_constraint_file","software_name"),"line"); (("pdbx_nmr_constraint_file","software_ordinal"),"int"); 
    (("pdbx_nmr_software_task","entry_id"),"code"); (("pdbx_nmr_software_task","software_ordinal"),"int"); (("pdbx_nmr_software_task","task"),"line"); 
    (("pdbx_nmr_spectral_dim","id"),"int"); (("pdbx_nmr_spectral_dim","atom_type"),"code"); (("pdbx_nmr_spectral_dim","atom_isotope_number"),"int"); (("pdbx_nmr_spectral_dim","spectral_region"),"code"); (("pdbx_nmr_spectral_dim","magnetization_linkage_id"),"int"); (("pdbx_nmr_spectral_dim","sweep_width"),"float"); (("pdbx_nmr_spectral_dim","encoding_code"),"line"); (("pdbx_nmr_spectral_dim","encoded_source_dimension_id"),"int"); (("pdbx_nmr_spectral_dim","entry_id"),"code"); (("pdbx_nmr_spectral_dim","spectral_peak_list_id"),"int"); (("pdbx_nmr_spectral_dim","sweep_width_units"),"code"); (("pdbx_nmr_spectral_dim","center_frequency_offset"),"float"); (("pdbx_nmr_spectral_dim","under_sampling_type"),"line"); 
    (("pdbx_nmr_spectral_peak_list","entry_id"),"code"); (("pdbx_nmr_spectral_peak_list","id"),"int"); (("pdbx_nmr_spectral_peak_list","data_file_name"),"line"); (("pdbx_nmr_spectral_peak_list","solution_id"),"int"); (("pdbx_nmr_spectral_peak_list","conditions_id"),"int"); (("pdbx_nmr_spectral_peak_list","experiment_id"),"int"); (("pdbx_nmr_spectral_peak_list","number_of_spectral_dimensions"),"int"); (("pdbx_nmr_spectral_peak_list","details"),"text"); (("pdbx_nmr_spectral_peak_list","text_data_format"),"line"); (("pdbx_nmr_spectral_peak_list","label"),"line"); (("pdbx_nmr_spectral_peak_list","conditions_label"),"line"); 
    (("pdbx_nmr_spectral_peak_software","software_id"),"int"); (("pdbx_nmr_spectral_peak_software","entry_id"),"code"); (("pdbx_nmr_spectral_peak_software","spectral_peak_list_id"),"int"); 
    (("pdbx_nmr_systematic_chem_shift_offset","type"),"line"); (("pdbx_nmr_systematic_chem_shift_offset","atom_type"),"line"); (("pdbx_nmr_systematic_chem_shift_offset","atom_isotope_number"),"int"); (("pdbx_nmr_systematic_chem_shift_offset","val"),"float"); (("pdbx_nmr_systematic_chem_shift_offset","val_err"),"float"); (("pdbx_nmr_systematic_chem_shift_offset","entry_id"),"code"); (("pdbx_nmr_systematic_chem_shift_offset","assigned_chem_shift_list_id"),"int"); (("pdbx_nmr_systematic_chem_shift_offset","ordinal"),"int"); 
    (("pdbx_nmr_upload","data_file_id"),"int"); (("pdbx_nmr_upload","data_file_name"),"line"); (("pdbx_nmr_upload","data_file_category"),"line"); (("pdbx_nmr_upload","data_file_syntax"),"line"); (("pdbx_nmr_upload","entry_id"),"code"); 
    (("pdbx_audit_support","funding_organization"),"text"); (("pdbx_audit_support","country"),"line"); (("pdbx_audit_support","grant_number"),"line"); (("pdbx_audit_support","ordinal"),"int"); 
    (("pdbx_chem_comp_subcomponent_struct_conn","id"),"int"); (("pdbx_chem_comp_subcomponent_struct_conn","type"),"ucode"); (("pdbx_chem_comp_subcomponent_struct_conn","entity_id_1"),"int"); (("pdbx_chem_comp_subcomponent_struct_conn","entity_id_2"),"int"); (("pdbx_chem_comp_subcomponent_struct_conn","atom_id_1"),"atcode"); (("pdbx_chem_comp_subcomponent_struct_conn","atom_id_2"),"atcode"); (("pdbx_chem_comp_subcomponent_struct_conn","comp_id_1"),"ucode"); (("pdbx_chem_comp_subcomponent_struct_conn","comp_id_2"),"ucode"); (("pdbx_chem_comp_subcomponent_struct_conn","seq_id_1"),"int"); (("pdbx_chem_comp_subcomponent_struct_conn","seq_id_2"),"int"); 
    (("pdbx_chem_comp_subcomponent_entity_list","id"),"int"); (("pdbx_chem_comp_subcomponent_entity_list","parent_comp_id"),"ucode"); (("pdbx_chem_comp_subcomponent_entity_list","type"),"uline"); (("pdbx_chem_comp_subcomponent_entity_list","class"),"ucode"); 
    (("entity_src_nat","common_name"),"text"); (("entity_src_nat","details"),"text"); (("entity_src_nat","entity_id"),"code"); (("entity_src_nat","genus"),"text"); (("entity_src_nat","species"),"text"); (("entity_src_nat","strain"),"text"); (("entity_src_nat","tissue"),"text"); (("entity_src_nat","tissue_fraction"),"text"); (("entity_src_nat","pdbx_organism_scientific"),"text"); (("entity_src_nat","pdbx_secretion"),"text"); (("entity_src_nat","pdbx_fragment"),"text"); (("entity_src_nat","pdbx_variant"),"text"); (("entity_src_nat","pdbx_cell_line"),"text"); (("entity_src_nat","pdbx_atcc"),"text"); (("entity_src_nat","pdbx_cellular_location"),"text"); (("entity_src_nat","pdbx_organ"),"text"); (("entity_src_nat","pdbx_organelle"),"text"); (("entity_src_nat","pdbx_cell"),"text"); (("entity_src_nat","pdbx_plasmid_name"),"text"); (("entity_src_nat","pdbx_plasmid_details"),"text"); (("entity_src_nat","pdbx_ncbi_taxonomy_id"),"line"); (("entity_src_nat","pdbx_src_id"),"int"); (("entity_src_nat","pdbx_alt_source_flag"),"code"); (("entity_src_nat","pdbx_beg_seq_num"),"int"); (("entity_src_nat","pdbx_end_seq_num"),"int"); (("entity_src_nat","pdbx_culture_collection"),"text"); 
    (("entity_src_gen","entity_id"),"code"); (("entity_src_gen","gene_src_common_name"),"text"); (("entity_src_gen","gene_src_details"),"text"); (("entity_src_gen","gene_src_genus"),"text"); (("entity_src_gen","gene_src_species"),"text"); (("entity_src_gen","gene_src_strain"),"text"); (("entity_src_gen","gene_src_tissue"),"text"); (("entity_src_gen","gene_src_tissue_fraction"),"text"); (("entity_src_gen","host_org_genus"),"text"); (("entity_src_gen","host_org_species"),"text"); (("entity_src_gen","pdbx_gene_src_fragment"),"text"); (("entity_src_gen","pdbx_gene_src_gene"),"text"); (("entity_src_gen","pdbx_gene_src_scientific_name"),"text"); (("entity_src_gen","pdbx_gene_src_variant"),"text"); (("entity_src_gen","pdbx_gene_src_cell_line"),"text"); (("entity_src_gen","pdbx_gene_src_atcc"),"text"); (("entity_src_gen","pdbx_gene_src_organ"),"text"); (("entity_src_gen","pdbx_gene_src_organelle"),"text"); (("entity_src_gen","pdbx_gene_src_plasmid"),"text"); (("entity_src_gen","pdbx_gene_src_plasmid_name"),"text"); (("entity_src_gen","pdbx_gene_src_cell"),"text"); (("entity_src_gen","pdbx_gene_src_cellular_location"),"text"); (("entity_src_gen","pdbx_host_org_gene"),"text"); (("entity_src_gen","pdbx_host_org_organ"),"text"); (("entity_src_gen","pdbx_host_org_organelle"),"text"); (("entity_src_gen","pdbx_host_org_cellular_location"),"text"); (("entity_src_gen","pdbx_host_org_strain"),"text"); (("entity_src_gen","pdbx_host_org_tissue_fraction"),"text"); (("entity_src_gen","pdbx_description"),"text"); (("entity_src_gen","host_org_common_name"),"text"); (("entity_src_gen","host_org_details"),"text"); (("entity_src_gen","host_org_strain"),"text"); (("entity_src_gen","plasmid_details"),"text"); (("entity_src_gen","plasmid_name"),"text"); (("entity_src_gen","pdbx_host_org_variant"),"text"); (("entity_src_gen","pdbx_host_org_cell_line"),"text"); (("entity_src_gen","pdbx_host_org_atcc"),"text"); (("entity_src_gen","pdbx_host_org_culture_collection"),"text"); (("entity_src_gen","pdbx_host_org_cell"),"text"); (("entity_src_gen","pdbx_host_org_scientific_name"),"text"); (("entity_src_gen","pdbx_host_org_tissue"),"text"); (("entity_src_gen","pdbx_host_org_vector"),"text"); (("entity_src_gen","pdbx_host_org_vector_type"),"text"); (("entity_src_gen","expression_system_id"),"uline"); (("entity_src_gen","gene_src_dev_stage"),"text"); (("entity_src_gen","start_construct_id"),"code"); (("entity_src_gen","pdbx_gene_src_ncbi_taxonomy_id"),"line"); (("entity_src_gen","pdbx_host_org_ncbi_taxonomy_id"),"line"); (("entity_src_gen","pdbx_src_id"),"int"); (("entity_src_gen","pdbx_alt_source_flag"),"code"); (("entity_src_gen","pdbx_seq_type"),"line"); (("entity_src_gen","pdbx_beg_seq_num"),"int"); (("entity_src_gen","pdbx_end_seq_num"),"int"); (("entity_src_gen","pdbx_gene_src_culture_collection"),"text"); 
    (("pdbx_entity_src_syn","details"),"text"); (("pdbx_entity_src_syn","organism_scientific"),"text"); (("pdbx_entity_src_syn","organism_common_name"),"text"); (("pdbx_entity_src_syn","strain"),"text"); (("pdbx_entity_src_syn","ncbi_taxonomy_id"),"line"); (("pdbx_entity_src_syn","entity_id"),"code"); (("pdbx_entity_src_syn","pdbx_src_id"),"int"); (("pdbx_entity_src_syn","pdbx_alt_source_flag"),"code"); (("pdbx_entity_src_syn","pdbx_beg_seq_num"),"int"); (("pdbx_entity_src_syn","pdbx_end_seq_num"),"int"); 
    (("pdbx_entity_poly_comp_link_list","link_id"),"int"); (("pdbx_entity_poly_comp_link_list","details"),"text"); (("pdbx_entity_poly_comp_link_list","entity_id"),"code"); (("pdbx_entity_poly_comp_link_list","entity_comp_num_1"),"int"); (("pdbx_entity_poly_comp_link_list","entity_comp_num_2"),"int"); (("pdbx_entity_poly_comp_link_list","comp_id_1"),"ucode"); (("pdbx_entity_poly_comp_link_list","comp_id_2"),"ucode"); (("pdbx_entity_poly_comp_link_list","atom_id_1"),"atcode"); (("pdbx_entity_poly_comp_link_list","leaving_atom_id_1"),"atcode"); (("pdbx_entity_poly_comp_link_list","atom_stereo_config_1"),"ucode"); (("pdbx_entity_poly_comp_link_list","atom_id_2"),"atcode"); (("pdbx_entity_poly_comp_link_list","leaving_atom_id_2"),"atcode"); (("pdbx_entity_poly_comp_link_list","atom_stereo_config_2"),"ucode"); (("pdbx_entity_poly_comp_link_list","value_order"),"ucode"); 
    (("pdbx_linked_entity","linked_entity_id"),"ucode"); (("pdbx_linked_entity","type"),"uline"); (("pdbx_linked_entity","class"),"text"); (("pdbx_linked_entity","name"),"text"); (("pdbx_linked_entity","description"),"text"); (("pdbx_linked_entity","prd_id"),"ucode"); 
    (("pdbx_linked_entity_instance_list","linked_entity_id"),"ucode"); (("pdbx_linked_entity_instance_list","instance_id"),"int"); (("pdbx_linked_entity_instance_list","asym_id"),"code"); 
    (("pdbx_linked_entity_list","linked_entity_id"),"ucode"); (("pdbx_linked_entity_list","entity_id"),"code"); (("pdbx_linked_entity_list","component_id"),"int"); (("pdbx_linked_entity_list","details"),"text"); 
    (("pdbx_linked_entity_link_list","link_id"),"int"); (("pdbx_linked_entity_link_list","linked_entity_id"),"ucode"); (("pdbx_linked_entity_link_list","details"),"text"); (("pdbx_linked_entity_link_list","entity_id_1"),"code"); (("pdbx_linked_entity_link_list","entity_id_2"),"code"); (("pdbx_linked_entity_link_list","entity_seq_num_1"),"int"); (("pdbx_linked_entity_link_list","entity_seq_num_2"),"int"); (("pdbx_linked_entity_link_list","comp_id_1"),"code"); (("pdbx_linked_entity_link_list","comp_id_2"),"code"); (("pdbx_linked_entity_link_list","atom_id_1"),"atcode"); (("pdbx_linked_entity_link_list","atom_id_2"),"atcode"); (("pdbx_linked_entity_link_list","value_order"),"ucode"); (("pdbx_linked_entity_link_list","component_1"),"int"); (("pdbx_linked_entity_link_list","component_2"),"int"); (("pdbx_linked_entity_link_list","link_class"),"code"); 
    (("pdbx_entity_descriptor","entity_id"),"code"); (("pdbx_entity_descriptor","descriptor"),"text"); (("pdbx_entity_descriptor","type"),"uline"); (("pdbx_entity_descriptor","program"),"line"); (("pdbx_entity_descriptor","program_version"),"line"); (("pdbx_entity_descriptor","ordinal"),"int"); 
    (("pdbx_reference_linked_entity","id"),"int"); (("pdbx_reference_linked_entity","class"),"text"); (("pdbx_reference_linked_entity","name"),"text"); (("pdbx_reference_linked_entity","taxonomy_id"),"text"); (("pdbx_reference_linked_entity","taxonomy_class"),"text"); (("pdbx_reference_linked_entity","link_to_entity_type"),"line"); (("pdbx_reference_linked_entity","link_to_comp_id"),"ucode"); (("pdbx_reference_linked_entity","link_from_entity_type"),"line"); 
    (("pdbx_reference_linked_entity_comp_list","linked_entity_id"),"int"); (("pdbx_reference_linked_entity_comp_list","list_id"),"int"); (("pdbx_reference_linked_entity_comp_list","name"),"text"); (("pdbx_reference_linked_entity_comp_list","comp_id"),"ucode"); 
    (("pdbx_reference_linked_entity_comp_link","linked_entity_id"),"int"); (("pdbx_reference_linked_entity_comp_link","link_id"),"int"); (("pdbx_reference_linked_entity_comp_link","list_id_1"),"int"); (("pdbx_reference_linked_entity_comp_link","list_id_2"),"int"); (("pdbx_reference_linked_entity_comp_link","details"),"text"); (("pdbx_reference_linked_entity_comp_link","comp_id_1"),"code"); (("pdbx_reference_linked_entity_comp_link","comp_id_2"),"code"); (("pdbx_reference_linked_entity_comp_link","atom_id_1"),"atcode"); (("pdbx_reference_linked_entity_comp_link","atom_id_2"),"atcode"); (("pdbx_reference_linked_entity_comp_link","leaving_atom_id_1"),"atcode"); (("pdbx_reference_linked_entity_comp_link","atom_stereo_config_1"),"ucode"); (("pdbx_reference_linked_entity_comp_link","leaving_atom_id_2"),"atcode"); (("pdbx_reference_linked_entity_comp_link","atom_stereo_config_2"),"ucode"); (("pdbx_reference_linked_entity_comp_link","value_order"),"ucode"); 
    (("pdbx_reference_linked_entity_link","linked_entity_id"),"int"); (("pdbx_reference_linked_entity_link","link_id"),"int"); (("pdbx_reference_linked_entity_link","from_list_id"),"int"); (("pdbx_reference_linked_entity_link","details"),"text"); (("pdbx_reference_linked_entity_link","to_comp_id"),"code"); (("pdbx_reference_linked_entity_link","from_comp_id"),"code"); (("pdbx_reference_linked_entity_link","to_atom_id"),"atcode"); (("pdbx_reference_linked_entity_link","from_atom_id"),"atcode"); (("pdbx_reference_linked_entity_link","from_leaving_atom_id"),"atcode"); (("pdbx_reference_linked_entity_link","from_atom_stereo_config"),"ucode"); (("pdbx_reference_linked_entity_link","value_order"),"ucode"); 
    (("pdbx_related_exp_data_set","ordinal"),"int"); (("pdbx_related_exp_data_set","data_reference"),"line"); (("pdbx_related_exp_data_set","metadata_reference"),"line"); (("pdbx_related_exp_data_set","data_set_type"),"line"); (("pdbx_related_exp_data_set","details"),"text"); 
    (("pdbx_database_status_history","entry_id"),"code"); (("pdbx_database_status_history","ordinal"),"code"); (("pdbx_database_status_history","date_begin"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status_history","date_end"),"yyyy-mm-dd:hh:mm"); (("pdbx_database_status_history","status_code"),"code"); (("pdbx_database_status_history","details"),"text"); 
    (("em_assembly","id"),"code"); (("em_assembly","entry_id"),"code"); (("em_assembly","name"),"text"); (("em_assembly","aggregation_state"),"line"); (("em_assembly","composition"),"text"); (("em_assembly","num_components"),"int"); (("em_assembly","mol_wt_exp"),"float"); (("em_assembly","mol_wt_theo"),"float"); (("em_assembly","mol_wt_method"),"text"); (("em_assembly","details"),"text"); 
    (("em_entity_assembly","id"),"code"); (("em_entity_assembly","assembly_id"),"code"); (("em_entity_assembly","parent_id"),"non_negative_int"); (("em_entity_assembly","source"),"line"); (("em_entity_assembly","type"),"line"); (("em_entity_assembly","name"),"text"); (("em_entity_assembly","details"),"text"); (("em_entity_assembly","go_id"),"line"); (("em_entity_assembly","ipr_id"),"line"); (("em_entity_assembly","synonym"),"line"); (("em_entity_assembly","number_of_copies"),"int"); (("em_entity_assembly","oligomeric_details"),"text"); (("em_entity_assembly","entity_id_list"),"line"); (("em_entity_assembly","ebi_organism_scientific"),"line"); (("em_entity_assembly","ebi_organism_common"),"text"); (("em_entity_assembly","ebi_strain"),"text"); (("em_entity_assembly","ebi_tissue"),"text"); (("em_entity_assembly","ebi_cell"),"text"); (("em_entity_assembly","ebi_organelle"),"text"); (("em_entity_assembly","ebi_cellular_location"),"text"); (("em_entity_assembly","ebi_engineered"),"line"); (("em_entity_assembly","ebi_expression_system"),"line"); (("em_entity_assembly","ebi_expression_system_plasmid"),"line"); (("em_entity_assembly","mutant_flag"),"line"); 
    (("em_virus_entity","id"),"code"); (("em_virus_entity","virus_host_category"),"line"); (("em_virus_entity","virus_host_species"),"line"); (("em_virus_entity","virus_host_growth_cell"),"line"); (("em_virus_entity","virus_type"),"line"); (("em_virus_entity","virus_isolate"),"line"); (("em_virus_entity","ictvdb_id"),"line"); (("em_virus_entity","entity_assembly_id"),"code"); (("em_virus_entity","enveloped"),"code"); (("em_virus_entity","empty"),"code"); (("em_virus_entity","details"),"text"); 
    (("em_sample_preparation","entry_id"),"code"); (("em_sample_preparation","id"),"code"); (("em_sample_preparation","ph"),"float"); (("em_sample_preparation","buffer_id"),"code"); (("em_sample_preparation","sample_concentration"),"float"); (("em_sample_preparation","2d_crystal_grow_id"),"code"); (("em_sample_preparation","support_id"),"code"); (("em_sample_preparation","entity_assembly_id"),"code"); (("em_sample_preparation","details"),"text"); 
    (("em_sample_support","id"),"code"); (("em_sample_support","film_material"),"line"); (("em_sample_support","method"),"text"); (("em_sample_support","grid_material"),"line"); (("em_sample_support","grid_mesh_size"),"int"); (("em_sample_support","grid_type"),"line"); (("em_sample_support","pretreatment"),"text"); (("em_sample_support","details"),"text"); (("em_sample_support","specimen_id"),"code"); (("em_sample_support","citation_id"),"code"); 
    (("em_buffer","id"),"code"); (("em_buffer","specimen_id"),"code"); (("em_buffer","name"),"text"); (("em_buffer","details"),"text"); (("em_buffer","pH"),"float"); 
    (("em_vitrification","entry_id"),"code"); (("em_vitrification","id"),"code"); (("em_vitrification","sample_preparation_id"),"code"); (("em_vitrification","specimen_id"),"code"); (("em_vitrification","cryogen_name"),"line"); (("em_vitrification","humidity"),"float"); (("em_vitrification","temp"),"float"); (("em_vitrification","chamber_temperature"),"float"); (("em_vitrification","instrument"),"line"); (("em_vitrification","method"),"text"); (("em_vitrification","time_resolved_state"),"text"); (("em_vitrification","citation_id"),"code"); (("em_vitrification","details"),"text"); 
    (("em_imaging","entry_id"),"code"); (("em_imaging","id"),"code"); (("em_imaging","astigmatism"),"text"); (("em_imaging","electron_beam_tilt_params"),"text"); (("em_imaging","residual_tilt"),"float"); (("em_imaging","sample_support_id"),"code"); (("em_imaging","detector_id"),"code"); (("em_imaging","scans_id"),"code"); (("em_imaging","microscope_id"),"code"); (("em_imaging","microscope_model"),"line"); (("em_imaging","specimen_holder_type"),"text"); (("em_imaging","specimen_holder_model"),"line"); (("em_imaging","details"),"text"); (("em_imaging","date"),"yyyy-mm-dd"); (("em_imaging","accelerating_voltage"),"int"); (("em_imaging","illumination_mode"),"line"); (("em_imaging","mode"),"line"); (("em_imaging","nominal_cs"),"float"); (("em_imaging","nominal_defocus_min"),"float"); (("em_imaging","nominal_defocus_max"),"float"); (("em_imaging","calibrated_defocus_min"),"float"); (("em_imaging","calibrated_defocus_max"),"float"); (("em_imaging","tilt_angle_min"),"float"); (("em_imaging","tilt_angle_max"),"float"); (("em_imaging","nominal_magnification"),"int"); (("em_imaging","calibrated_magnification"),"int"); (("em_imaging","electron_source"),"line"); (("em_imaging","electron_dose"),"float"); (("em_imaging","energy_filter"),"line"); (("em_imaging","energy_window"),"line"); (("em_imaging","citation_id"),"code"); (("em_imaging","temperature"),"float"); (("em_imaging","detector_distance"),"float"); (("em_imaging","recording_temperature_minimum"),"float"); (("em_imaging","recording_temperature_maximum"),"float"); (("em_imaging","alignment_procedure"),"line"); (("em_imaging","c2_aperture_diameter"),"float"); (("em_imaging","specimen_id"),"code"); (("em_imaging","cryogen"),"text"); 
    (("em_detector","entry_id"),"code"); (("em_detector","id"),"code"); (("em_detector","details"),"text"); (("em_detector","type"),"line"); (("em_detector","detective_quantum_efficiency"),"float"); (("em_detector","mode"),"line"); 
    (("em_image_scans","entry_id"),"code"); (("em_image_scans","id"),"code"); (("em_image_scans","number_digital_images"),"int"); (("em_image_scans","details"),"text"); (("em_image_scans","scanner_model"),"line"); (("em_image_scans","sampling_size"),"float"); (("em_image_scans","od_range"),"float"); (("em_image_scans","quant_bit_size"),"int"); (("em_image_scans","citation_id"),"code"); (("em_image_scans","dimension_height"),"positive_int"); (("em_image_scans","dimension_width"),"positive_int"); (("em_image_scans","frames_per_image"),"positive_int"); (("em_image_scans","image_recording_id"),"code"); (("em_image_scans","used_frames_per_image"),"int-range"); 
    (("em_2d_projection_selection","entry_id"),"code"); (("em_2d_projection_selection","id"),"code"); (("em_2d_projection_selection","num_particles"),"int"); (("em_2d_projection_selection","software_name"),"line"); (("em_2d_projection_selection","method"),"text"); (("em_2d_projection_selection","details"),"text"); (("em_2d_projection_selection","citation_id"),"code"); 
    (("em_3d_reconstruction","entry_id"),"code"); (("em_3d_reconstruction","id"),"code"); (("em_3d_reconstruction","method"),"text"); (("em_3d_reconstruction","algorithm"),"text"); (("em_3d_reconstruction","citation_id"),"code"); (("em_3d_reconstruction","details"),"text"); (("em_3d_reconstruction","resolution"),"float"); (("em_3d_reconstruction","resolution_method"),"text"); (("em_3d_reconstruction","magnification_calibration"),"text"); (("em_3d_reconstruction","ctf_correction_method"),"text"); (("em_3d_reconstruction","nominal_pixel_size"),"float"); (("em_3d_reconstruction","actual_pixel_size"),"float"); (("em_3d_reconstruction","num_particles"),"int"); (("em_3d_reconstruction","euler_angles_details"),"text"); (("em_3d_reconstruction","num_class_averages"),"int"); (("em_3d_reconstruction","software"),"text"); (("em_3d_reconstruction","fsc_type"),"text"); (("em_3d_reconstruction","refinement_type"),"text"); (("em_3d_reconstruction","image_processing_id"),"code"); (("em_3d_reconstruction","symmetry_type"),"line"); 
    (("em_3d_fitting","id"),"code"); (("em_3d_fitting","entry_id"),"code"); (("em_3d_fitting","method"),"line"); (("em_3d_fitting","target_criteria"),"text"); (("em_3d_fitting","software_name"),"text"); (("em_3d_fitting","details"),"text"); (("em_3d_fitting","overall_b_value"),"float"); (("em_3d_fitting","ref_space"),"line"); (("em_3d_fitting","ref_protocol"),"line"); 
    (("em_3d_fitting_list","id"),"code"); (("em_3d_fitting_list","3d_fitting_id"),"code"); (("em_3d_fitting_list","pdb_entry_id"),"pdb_id"); (("em_3d_fitting_list","pdb_chain_id"),"code"); (("em_3d_fitting_list","pdb_chain_residue_range"),"int-range"); (("em_3d_fitting_list","details"),"text"); 
    (("em_helical_entity","id"),"code"); (("em_helical_entity","entity_assembly_id"),"code"); (("em_helical_entity","image_processing_id"),"code"); (("em_helical_entity","details"),"text"); (("em_helical_entity","dyad"),"line"); (("em_helical_entity","axial_symmetry"),"point_group_helical"); (("em_helical_entity","angular_rotation_per_subunit"),"float"); (("em_helical_entity","axial_rise_per_subunit"),"float"); (("em_helical_entity","hand"),"text"); 
    (("em_experiment","entry_id"),"code"); (("em_experiment","id"),"code"); (("em_experiment","reconstruction_method"),"line"); (("em_experiment","aggregation_state"),"line"); (("em_experiment","specimen_type"),"text"); (("em_experiment","entity_assembly_id"),"code"); 
    (("em_single_particle_entity","entry_id"),"code"); (("em_single_particle_entity","id"),"code"); (("em_single_particle_entity","symmetry_type"),"line"); (("em_single_particle_entity","image_processing_id"),"code"); (("em_single_particle_entity","point_symmetry"),"point_group"); 
    (("em_admin","current_status"),"code"); (("em_admin","deposition_date"),"yyyy-mm-dd"); (("em_admin","deposition_site"),"code"); (("em_admin","details"),"text"); (("em_admin","entry_id"),"code"); (("em_admin","last_update"),"yyyy-mm-dd"); (("em_admin","map_release_date"),"yyyy-mm-dd"); (("em_admin","map_hold_date"),"yyyy-mm-dd"); (("em_admin","header_release_date"),"yyyy-mm-dd"); (("em_admin","obsoleted_date"),"yyyy-mm-dd"); (("em_admin","replace_existing_entry_flag"),"code"); (("em_admin","title"),"line"); 
    (("em_author_list","author"),"author"); (("em_author_list","ordinal"),"positive_int"); 
    (("em_db_reference","access_code"),"code"); (("em_db_reference","db_name"),"code"); (("em_db_reference","details"),"text"); (("em_db_reference","id"),"code"); (("em_db_reference","relationship"),"line"); 
    (("em_db_reference_auxiliary","id"),"code"); (("em_db_reference_auxiliary","link"),"code"); (("em_db_reference_auxiliary","link_type"),"text"); 
    (("em_depui","depositor_hold_instructions"),"line"); (("em_depui","entry_id"),"code"); (("em_depui","macromolecule_description"),"ucode"); (("em_depui","obsolete_instructions"),"text"); (("em_depui","same_authors_as_pdb"),"ucode"); (("em_depui","same_title_as_pdb"),"ucode"); 
    (("em_obsolete","date"),"yyyy-mm-dd"); (("em_obsolete","details"),"text"); (("em_obsolete","entry"),"emd_id"); (("em_obsolete","id"),"emd_id"); 
    (("em_supersede","date"),"yyyy-mm-dd"); (("em_supersede","details"),"text"); (("em_supersede","entry"),"emd_id"); (("em_supersede","id"),"emd_id"); 
    (("em_entity_assembly_molwt","entity_assembly_id"),"code"); (("em_entity_assembly_molwt","experimental_flag"),"code"); (("em_entity_assembly_molwt","id"),"code"); (("em_entity_assembly_molwt","units"),"code"); (("em_entity_assembly_molwt","value"),"float"); (("em_entity_assembly_molwt","method"),"text"); 
    (("em_entity_assembly_naturalsource","cell"),"text"); (("em_entity_assembly_naturalsource","cellular_location"),"text"); (("em_entity_assembly_naturalsource","entity_assembly_id"),"code"); (("em_entity_assembly_naturalsource","id"),"code"); (("em_entity_assembly_naturalsource","ncbi_tax_id"),"positive_int"); (("em_entity_assembly_naturalsource","organism"),"line"); (("em_entity_assembly_naturalsource","organelle"),"text"); (("em_entity_assembly_naturalsource","organ"),"line"); (("em_entity_assembly_naturalsource","strain"),"text"); (("em_entity_assembly_naturalsource","tissue"),"text"); 
    (("em_entity_assembly_recombinant","cell"),"line"); (("em_entity_assembly_recombinant","entity_assembly_id"),"code"); (("em_entity_assembly_recombinant","id"),"code"); (("em_entity_assembly_recombinant","ncbi_tax_id"),"positive_int"); (("em_entity_assembly_recombinant","organism"),"line"); (("em_entity_assembly_recombinant","plasmid"),"line"); (("em_entity_assembly_recombinant","strain"),"line"); 
    (("em_virus_natural_host","entity_assembly_id"),"code"); (("em_virus_natural_host","id"),"code"); (("em_virus_natural_host","ncbi_tax_id"),"positive_int"); (("em_virus_natural_host","organism"),"line"); (("em_virus_natural_host","strain"),"text"); 
    (("em_virus_shell","diameter"),"float"); (("em_virus_shell","entity_assembly_id"),"code"); (("em_virus_shell","id"),"code"); (("em_virus_shell","name"),"line"); (("em_virus_shell","triangulation"),"positive_int"); 
    (("em_specimen","concentration"),"float"); (("em_specimen","details"),"text"); (("em_specimen","embedding_applied"),"boolean"); (("em_specimen","experiment_id"),"code"); (("em_specimen","id"),"code"); (("em_specimen","shadowing_applied"),"boolean"); (("em_specimen","staining_applied"),"boolean"); (("em_specimen","vitrification_applied"),"boolean"); 
    (("em_embedding","details"),"text"); (("em_embedding","id"),"code"); (("em_embedding","material"),"line"); (("em_embedding","specimen_id"),"code"); 
    (("em_fiducial_markers","diameter"),"positive_int"); (("em_fiducial_markers","em_tomography_specimen_id"),"code"); (("em_fiducial_markers","id"),"code"); (("em_fiducial_markers","manufacturer"),"line"); 
    (("em_focused_ion_beam","current"),"float"); (("em_focused_ion_beam","details"),"text"); (("em_focused_ion_beam","dose_rate"),"positive_int"); (("em_focused_ion_beam","duration"),"positive_int"); (("em_focused_ion_beam","em_tomography_specimen_id"),"code"); (("em_focused_ion_beam","final_thickness"),"positive_int"); (("em_focused_ion_beam","id"),"code"); (("em_focused_ion_beam","initial_thickness"),"positive_int"); (("em_focused_ion_beam","instrument"),"line"); (("em_focused_ion_beam","ion"),"line"); (("em_focused_ion_beam","temperature"),"positive_int"); (("em_focused_ion_beam","voltage"),"positive_int"); 
    (("em_grid_pretreatment","atmosphere"),"line"); (("em_grid_pretreatment","id"),"code"); (("em_grid_pretreatment","pressure"),"float"); (("em_grid_pretreatment","sample_support_id"),"code"); (("em_grid_pretreatment","time"),"positive_int"); (("em_grid_pretreatment","type"),"line"); 
    (("em_ultramicrotomy","details"),"text"); (("em_ultramicrotomy","em_tomography_specimen_id"),"code"); (("em_ultramicrotomy","final_thickness"),"positive_int"); (("em_ultramicrotomy","id"),"code"); (("em_ultramicrotomy","instrument"),"line"); (("em_ultramicrotomy","temperature"),"positive_int"); 
    (("em_high_pressure_freezing","details"),"text"); (("em_high_pressure_freezing","em_tomography_specimen_id"),"code"); (("em_high_pressure_freezing","id"),"code"); (("em_high_pressure_freezing","instrument"),"line"); 
    (("em_shadowing","angle"),"float"); (("em_shadowing","details"),"text"); (("em_shadowing","id"),"code"); (("em_shadowing","material"),"line"); (("em_shadowing","specimen_id"),"code"); (("em_shadowing","thickness"),"float"); 
    (("em_tomography_specimen","cryo_protectant"),"line"); (("em_tomography_specimen","details"),"text"); (("em_tomography_specimen","fiducial_markers"),"code"); (("em_tomography_specimen","high_pressure_freezing"),"code"); (("em_tomography_specimen","id"),"code"); (("em_tomography_specimen","sectioning"),"line"); (("em_tomography_specimen","specimen_id"),"code"); 
    (("em_crystal_formation","atmosphere"),"text"); (("em_crystal_formation","details"),"text"); (("em_crystal_formation","id"),"code"); (("em_crystal_formation","instrument"),"line"); (("em_crystal_formation","lipid_mixture"),"text"); (("em_crystal_formation","lipid_protein_ratio"),"float"); (("em_crystal_formation","specimen_id"),"code"); (("em_crystal_formation","temperature"),"positive_int"); (("em_crystal_formation","time"),"positive_int"); (("em_crystal_formation","time_unit"),"code"); 
    (("em_staining","details"),"text"); (("em_staining","id"),"code"); (("em_staining","material"),"line"); (("em_staining","specimen_id"),"code"); (("em_staining","type"),"code"); 
    (("em_support_film","id"),"code"); (("em_support_film","material"),"line"); (("em_support_film","sample_support_id"),"code"); (("em_support_film","thickness"),"float"); (("em_support_film","topology"),"line"); 
    (("em_buffer_component","buffer_id"),"code"); (("em_buffer_component","concentration"),"float"); (("em_buffer_component","concentration_units"),"line"); (("em_buffer_component","formula"),"code"); (("em_buffer_component","id"),"code"); (("em_buffer_component","name"),"line"); 
    (("em_diffraction","camera_length"),"float"); (("em_diffraction","id"),"code"); (("em_diffraction","imaging_id"),"code"); (("em_diffraction","tilt_angle_list"),"line"); 
    (("em_diffraction_shell","em_diffraction_stats_id"),"code"); (("em_diffraction_shell","fourier_space_coverage"),"float"); (("em_diffraction_shell","high_resolution"),"float"); (("em_diffraction_shell","id"),"code"); (("em_diffraction_shell","low_resolution"),"float"); (("em_diffraction_shell","multiplicity"),"float"); (("em_diffraction_shell","num_structure_factors"),"positive_int"); (("em_diffraction_shell","phase_residual"),"float"); 
    (("em_diffraction_stats","details"),"text"); (("em_diffraction_stats","fourier_space_coverage"),"float"); (("em_diffraction_stats","high_resolution"),"float"); (("em_diffraction_stats","id"),"code"); (("em_diffraction_stats","image_processing_id"),"code"); (("em_diffraction_stats","num_intensities_measured"),"positive_int"); (("em_diffraction_stats","num_structure_factors"),"positive_int"); (("em_diffraction_stats","overall_phase_error"),"float"); (("em_diffraction_stats","overall_phase_residual"),"float"); (("em_diffraction_stats","phase_error_rejection_criteria"),"line"); (("em_diffraction_stats","r_merge"),"float"); (("em_diffraction_stats","r_sym"),"float"); 
    (("em_tomography","axis1_angle_increment"),"float"); (("em_tomography","axis1_max_angle"),"float"); (("em_tomography","axis1_min_angle"),"float"); (("em_tomography","axis2_angle_increment"),"float"); (("em_tomography","axis2_max_angle"),"float"); (("em_tomography","axis2_min_angle"),"float"); (("em_tomography","dual_tilt_axis_rotation"),"float"); (("em_tomography","id"),"code"); (("em_tomography","imaging_id"),"code"); 
    (("em_image_recording","average_exposure_time"),"float"); (("em_image_recording","avg_electron_dose_per_image"),"float"); (("em_image_recording","details"),"text"); (("em_image_recording","detector_mode"),"line"); (("em_image_recording","film_or_detector_model"),"line"); (("em_image_recording","id"),"code"); (("em_image_recording","imaging_id"),"code"); (("em_image_recording","num_diffraction_images"),"positive_int"); (("em_image_recording","num_grids_imaged"),"positive_int"); (("em_image_recording","num_real_images"),"positive_int"); 
    (("em_imaging_optics","chr_aberration_corrector"),"text"); (("em_imaging_optics","energyfilter_lower"),"line"); (("em_imaging_optics","energyfilter_name"),"line"); (("em_imaging_optics","energyfilter_upper"),"line"); (("em_imaging_optics","id"),"code"); (("em_imaging_optics","imaging_id"),"code"); (("em_imaging_optics","phase_plate"),"text"); (("em_imaging_optics","sph_aberration_corrector"),"text"); 
    (("em_final_classification","avg_num_images_per_class"),"positive_int"); (("em_final_classification","details"),"text"); (("em_final_classification","id"),"code"); (("em_final_classification","image_processing_id"),"code"); (("em_final_classification","num_classes"),"positive_int"); (("em_final_classification","type"),"code"); 
    (("em_start_model","details"),"text"); (("em_start_model","emdb_id"),"emd_id"); (("em_start_model","id"),"code"); (("em_start_model","image_processing_id"),"code"); (("em_start_model","insilico_model"),"text"); (("em_start_model","orthogonal_tilt_angle1"),"float"); (("em_start_model","orthogonal_tilt_angle2"),"float"); (("em_start_model","orthogonal_tilt_num_images"),"positive_int"); (("em_start_model","other"),"text"); (("em_start_model","pdb_id"),"pdb_id"); (("em_start_model","random_conical_tilt_angle"),"float"); (("em_start_model","random_conical_tilt_num_images"),"positive_int"); (("em_start_model","type"),"line"); 
    (("em_software","category"),"line"); (("em_software","details"),"text"); (("em_software","id"),"code"); (("em_software","image_processing_id"),"code"); (("em_software","fitting_id"),"code"); (("em_software","imaging_id"),"code"); (("em_software","name"),"line"); (("em_software","version"),"line"); 
    (("em_euler_angle_assignment","details"),"text"); (("em_euler_angle_assignment","id"),"code"); (("em_euler_angle_assignment","image_processing_id"),"code"); (("em_euler_angle_assignment","order"),"code"); (("em_euler_angle_assignment","proj_matching_angular_sampling"),"float"); (("em_euler_angle_assignment","proj_matching_merit_function"),"line"); (("em_euler_angle_assignment","proj_matching_num_projections"),"positive_int"); (("em_euler_angle_assignment","type"),"line"); 
    (("em_ctf_correction","amplitude_correction"),"code"); (("em_ctf_correction","amplitude_correction_factor"),"float"); (("em_ctf_correction","amplitude_correction_space"),"code"); (("em_ctf_correction","correction_operation"),"code"); (("em_ctf_correction","details"),"text"); (("em_ctf_correction","em_image_processing_id"),"code"); (("em_ctf_correction","id"),"code"); (("em_ctf_correction","phase_reversal"),"code"); (("em_ctf_correction","phase_reversal_anisotropic"),"code"); (("em_ctf_correction","phase_reversal_correction_space"),"code"); (("em_ctf_correction","type"),"line"); 
    (("em_volume_selection","details"),"text"); (("em_volume_selection","id"),"code"); (("em_volume_selection","image_processing_id"),"code"); (("em_volume_selection","method"),"text"); (("em_volume_selection","num_tomograms"),"positive_int"); (("em_volume_selection","num_volumes_extracted"),"positive_int"); (("em_volume_selection","reference_model"),"text"); 
    (("em_3d_crystal_entity","angle_alpha"),"float"); (("em_3d_crystal_entity","angle_beta"),"float"); (("em_3d_crystal_entity","angle_gamma"),"float"); (("em_3d_crystal_entity","image_processing_id"),"code"); (("em_3d_crystal_entity","id"),"code"); (("em_3d_crystal_entity","length_a"),"float"); (("em_3d_crystal_entity","length_b"),"float"); (("em_3d_crystal_entity","length_c"),"float"); (("em_3d_crystal_entity","space_group_name"),"line"); (("em_3d_crystal_entity","space_group_num"),"int"); 
    (("em_2d_crystal_entity","angle_gamma"),"float"); (("em_2d_crystal_entity","c_sampling_length"),"float"); (("em_2d_crystal_entity","image_processing_id"),"code"); (("em_2d_crystal_entity","id"),"code"); (("em_2d_crystal_entity","entity_assembly_id"),"code"); (("em_2d_crystal_entity","length_a"),"float"); (("em_2d_crystal_entity","length_b"),"float"); (("em_2d_crystal_entity","length_c"),"float"); (("em_2d_crystal_entity","space_group_name_H-M"),"line"); 
    (("em_image_processing","details"),"text"); (("em_image_processing","id"),"code"); (("em_image_processing","image_recording_id"),"code"); 
    (("em_particle_selection","details"),"text"); (("em_particle_selection","id"),"code"); (("em_particle_selection","image_processing_id"),"code"); (("em_particle_selection","method"),"text"); (("em_particle_selection","num_particles_selected"),"positive_int"); (("em_particle_selection","reference_model"),"text"); 
    (("em_map","annotation_details"),"text"); (("em_map","axis_order_fast"),"code"); (("em_map","axis_order_medium"),"code"); (("em_map","axis_order_slow"),"code"); (("em_map","cell_a"),"float"); (("em_map","cell_b"),"float"); (("em_map","cell_c"),"float"); (("em_map","cell_alpha"),"float"); (("em_map","cell_beta"),"float"); (("em_map","cell_gamma"),"float"); (("em_map","contour_level"),"float"); (("em_map","contour_level_source"),"line"); (("em_map","data_type"),"line"); (("em_map","dimensions_col"),"positive_int"); (("em_map","dimensions_row"),"positive_int"); (("em_map","dimensions_sec"),"positive_int"); (("em_map","endian_type"),"code"); (("em_map","file"),"line"); (("em_map","format"),"code"); (("em_map","id"),"positive_int"); (("em_map","partition"),"positive_int"); (("em_map","entry_id"),"code"); (("em_map","label"),"text"); (("em_map","limit_col"),"int"); (("em_map","limit_row"),"int"); (("em_map","limit_sec"),"int"); (("em_map","origin_col"),"int"); (("em_map","origin_row"),"int"); (("em_map","origin_sec"),"int"); (("em_map","pixel_spacing_x"),"float"); (("em_map","pixel_spacing_y"),"float"); (("em_map","pixel_spacing_z"),"float"); (("em_map","size_kb"),"positive_int"); (("em_map","spacing_x"),"positive_int"); (("em_map","spacing_y"),"positive_int"); (("em_map","spacing_z"),"positive_int"); (("em_map","statistics_average"),"float"); (("em_map","statistics_maximum"),"float"); (("em_map","statistics_minimum"),"float"); (("em_map","statistics_std"),"float"); (("em_map","symmetry_space_group"),"line"); (("em_map","type"),"line"); 
    (("em_fsc_curve","details"),"text"); (("em_fsc_curve","file"),"line"); (("em_fsc_curve","id"),"code"); 
    (("em_interpret_figure","details"),"text"); (("em_interpret_figure","file"),"line"); (("em_interpret_figure","id"),"code"); 
    (("em_layer_lines","details"),"text"); (("em_layer_lines","experiment_id"),"code"); (("em_layer_lines","file"),"line"); (("em_layer_lines","id"),"code"); 
    (("em_structure_factors","details"),"text"); (("em_structure_factors","experiment_id"),"code"); (("em_structure_factors","file"),"line"); (("em_structure_factors","id"),"code"); 
    (("em_depositor_info","entry_id"),"code"); (("em_depositor_info","em_method_selection"),"line"); (("em_depositor_info","molecular_description_flag"),"code"); 
    (("em_map_depositor_info","entry_id"),"code"); (("em_map_depositor_info","experiment_id"),"code"); (("em_map_depositor_info","id"),"code"); (("em_map_depositor_info","map_type"),"code"); (("em_map_depositor_info","upload_file_name"),"line"); (("em_map_depositor_info","upload_format"),"code"); (("em_map_depositor_info","contour_level"),"float"); (("em_map_depositor_info","annotation_details"),"text"); (("em_map_depositor_info","pixel_spacing_x"),"float"); (("em_map_depositor_info","pixel_spacing_y"),"float"); (("em_map_depositor_info","pixel_spacing_z"),"float"); 
    (("em_mask_depositor_info","id"),"code"); (("em_mask_depositor_info","upload_file_name"),"line"); (("em_mask_depositor_info","upload_format"),"code"); (("em_mask_depositor_info","contour_level"),"float"); (("em_mask_depositor_info","annotation_details"),"text"); (("em_mask_depositor_info","pixel_spacing_x"),"float"); (("em_mask_depositor_info","pixel_spacing_y"),"float"); (("em_mask_depositor_info","pixel_spacing_z"),"float"); 
    (("em_figure_depositor_info","id"),"code"); (("em_figure_depositor_info","experiment_id"),"code"); (("em_figure_depositor_info","upload_file_name"),"line"); (("em_figure_depositor_info","details"),"text"); 
    (("em_layer_lines_depositor_info","id"),"code"); (("em_layer_lines_depositor_info","experiment_id"),"code"); (("em_layer_lines_depositor_info","upload_file_name"),"line"); (("em_layer_lines_depositor_info","details"),"text"); 
    (("em_structure_factors_depositor_info","id"),"code"); (("em_structure_factors_depositor_info","experiment_id"),"code"); (("em_structure_factors_depositor_info","upload_file_name"),"line"); (("em_structure_factors_depositor_info","details"),"text"); 
    (("pdbx_seq_map_depositor_info","entity_id"),"code"); (("pdbx_seq_map_depositor_info","auth_asym_id"),"code"); (("pdbx_seq_map_depositor_info","one_letter_code"),"text"); (("pdbx_seq_map_depositor_info","one_letter_code_mod"),"text"); 
    (("pdbx_chem_comp_depositor_info","ordinal"),"int"); (("pdbx_chem_comp_depositor_info","comp_id"),"ucode"); (("pdbx_chem_comp_depositor_info","alt_comp_id"),"ucode"); (("pdbx_chem_comp_depositor_info","name"),"text"); (("pdbx_chem_comp_depositor_info","formula"),"text"); (("pdbx_chem_comp_depositor_info","type"),"line"); (("pdbx_chem_comp_depositor_info","descriptor"),"text"); (("pdbx_chem_comp_depositor_info","descriptor_type"),"uline"); (("pdbx_chem_comp_depositor_info","in_dictionary_flag"),"code"); (("pdbx_chem_comp_depositor_info","details"),"text"); 
    (("pdbx_struct_ref_seq_depositor_info","ref_id"),"code"); (("pdbx_struct_ref_seq_depositor_info","entity_id"),"code"); (("pdbx_struct_ref_seq_depositor_info","db_align_beg"),"int"); (("pdbx_struct_ref_seq_depositor_info","db_align_end"),"int"); (("pdbx_struct_ref_seq_depositor_info","details"),"text"); (("pdbx_struct_ref_seq_depositor_info","db_accession"),"code"); (("pdbx_struct_ref_seq_depositor_info","db_code"),"line"); (("pdbx_struct_ref_seq_depositor_info","db_name"),"line"); (("pdbx_struct_ref_seq_depositor_info","db_seq_one_letter_code"),"text"); (("pdbx_struct_ref_seq_depositor_info","seq_align_begin"),"code"); (("pdbx_struct_ref_seq_depositor_info","seq_align_end"),"code"); 
    (("pdbx_struct_ref_seq_dif_depositor_info","ordinal"),"int"); (("pdbx_struct_ref_seq_dif_depositor_info","ref_id"),"code"); (("pdbx_struct_ref_seq_dif_depositor_info","entity_id"),"code"); (("pdbx_struct_ref_seq_dif_depositor_info","db_mon_id"),"ucode"); (("pdbx_struct_ref_seq_dif_depositor_info","db_seq_id"),"int"); (("pdbx_struct_ref_seq_dif_depositor_info","details"),"text"); (("pdbx_struct_ref_seq_dif_depositor_info","auth_mon_id"),"ucode"); (("pdbx_struct_ref_seq_dif_depositor_info","auth_seq_id"),"int"); (("pdbx_struct_ref_seq_dif_depositor_info","db_accession"),"code"); (("pdbx_struct_ref_seq_dif_depositor_info","db_code"),"line"); (("pdbx_struct_ref_seq_dif_depositor_info","db_name"),"line"); (("pdbx_struct_ref_seq_dif_depositor_info","annotation"),"uline"); 
    (("pdbx_struct_assembly_prop_depositor_info","biol_id"),"code"); (("pdbx_struct_assembly_prop_depositor_info","type"),"line"); (("pdbx_struct_assembly_prop_depositor_info","value"),"text"); (("pdbx_struct_assembly_prop_depositor_info","details"),"text"); 
    (("pdbx_struct_assembly_depositor_info","details"),"text"); (("pdbx_struct_assembly_depositor_info","id"),"line"); (("pdbx_struct_assembly_depositor_info","method_details"),"text"); (("pdbx_struct_assembly_depositor_info","oligomeric_details"),"line"); (("pdbx_struct_assembly_depositor_info","oligomeric_count"),"line"); (("pdbx_struct_assembly_depositor_info","matrix_flag"),"code"); (("pdbx_struct_assembly_depositor_info","upload_file_name"),"text"); 
    (("pdbx_struct_assembly_gen_depositor_info","id"),"line"); (("pdbx_struct_assembly_gen_depositor_info","asym_id_list"),"line"); (("pdbx_struct_assembly_gen_depositor_info","assembly_id"),"line"); (("pdbx_struct_assembly_gen_depositor_info","oper_expression"),"operation_expression"); (("pdbx_struct_assembly_gen_depositor_info","full_matrices"),"4x3_matrix"); (("pdbx_struct_assembly_gen_depositor_info","symmetry_operation"),"symmetry_operation"); (("pdbx_struct_assembly_gen_depositor_info","at_unit_matrix"),"uchar1"); (("pdbx_struct_assembly_gen_depositor_info","chain_id_list"),"id_list"); (("pdbx_struct_assembly_gen_depositor_info","all_chains"),"uchar1"); (("pdbx_struct_assembly_gen_depositor_info","helical_rotation"),"float"); (("pdbx_struct_assembly_gen_depositor_info","helical_rise"),"float"); 
    (("pdbx_struct_oper_list_depositor_info","id"),"code"); (("pdbx_struct_oper_list_depositor_info","type"),"line"); (("pdbx_struct_oper_list_depositor_info","name"),"line"); (("pdbx_struct_oper_list_depositor_info","symmetry_operation"),"line"); (("pdbx_struct_oper_list_depositor_info","matrix[1][1]"),"float"); (("pdbx_struct_oper_list_depositor_info","matrix[1][2]"),"float"); (("pdbx_struct_oper_list_depositor_info","matrix[1][3]"),"float"); (("pdbx_struct_oper_list_depositor_info","matrix[2][1]"),"float"); (("pdbx_struct_oper_list_depositor_info","matrix[2][2]"),"float"); (("pdbx_struct_oper_list_depositor_info","matrix[2][3]"),"float"); (("pdbx_struct_oper_list_depositor_info","matrix[3][1]"),"float"); (("pdbx_struct_oper_list_depositor_info","matrix[3][2]"),"float"); (("pdbx_struct_oper_list_depositor_info","matrix[3][3]"),"float"); (("pdbx_struct_oper_list_depositor_info","vector[1]"),"float"); (("pdbx_struct_oper_list_depositor_info","vector[2]"),"float"); (("pdbx_struct_oper_list_depositor_info","vector[3]"),"float"); 
    (("pdbx_point_symmetry_depositor_info","entry_id"),"code"); (("pdbx_point_symmetry_depositor_info","Schoenflies_symbol"),"code"); (("pdbx_point_symmetry_depositor_info","circular_symmetry"),"int"); (("pdbx_point_symmetry_depositor_info","H-M_notation"),"code"); (("pdbx_point_symmetry_depositor_info","status_flag"),"code"); 
    (("pdbx_helical_symmetry_depositor_info","entry_id"),"code"); (("pdbx_helical_symmetry_depositor_info","number_of_operations"),"int"); (("pdbx_helical_symmetry_depositor_info","rotation_per_n_subunits"),"float"); (("pdbx_helical_symmetry_depositor_info","rise_per_n_subunits"),"float"); (("pdbx_helical_symmetry_depositor_info","n_subunits_divisor"),"int"); (("pdbx_helical_symmetry_depositor_info","dyad_axis"),"code"); (("pdbx_helical_symmetry_depositor_info","circular_symmetry"),"int"); (("pdbx_helical_symmetry_depositor_info","status_flag"),"code"); 
    (("pdbx_struct_assembly_auth_evidence_depositor_info","id"),"code"); (("pdbx_struct_assembly_auth_evidence_depositor_info","assembly_id"),"line"); (("pdbx_struct_assembly_auth_evidence_depositor_info","experimental_support"),"line"); (("pdbx_struct_assembly_auth_evidence_depositor_info","details"),"text"); 
    (("pdbx_solvent_atom_site_mapping","id"),"code"); (("pdbx_solvent_atom_site_mapping","label_alt_id"),"code"); (("pdbx_solvent_atom_site_mapping","label_asym_id"),"code"); (("pdbx_solvent_atom_site_mapping","label_atom_id"),"atcode"); (("pdbx_solvent_atom_site_mapping","label_comp_id"),"ucode"); (("pdbx_solvent_atom_site_mapping","label_seq_id"),"int"); (("pdbx_solvent_atom_site_mapping","PDB_ins_code"),"code"); (("pdbx_solvent_atom_site_mapping","pre_auth_asym_id"),"code"); (("pdbx_solvent_atom_site_mapping","pre_auth_atom_id"),"atcode"); (("pdbx_solvent_atom_site_mapping","pre_auth_comp_id"),"code"); (("pdbx_solvent_atom_site_mapping","pre_auth_seq_id"),"code"); (("pdbx_solvent_atom_site_mapping","pre_PDB_ins_code"),"code"); (("pdbx_solvent_atom_site_mapping","pre_auth_alt_id"),"code"); (("pdbx_solvent_atom_site_mapping","auth_asym_id"),"code"); (("pdbx_solvent_atom_site_mapping","auth_atom_id"),"atcode"); (("pdbx_solvent_atom_site_mapping","auth_comp_id"),"code"); (("pdbx_solvent_atom_site_mapping","auth_seq_id"),"code"); (("pdbx_solvent_atom_site_mapping","auth_alt_id"),"code"); (("pdbx_solvent_atom_site_mapping","occupancy"),"float"); (("pdbx_solvent_atom_site_mapping","Cartn_x"),"float"); (("pdbx_solvent_atom_site_mapping","Cartn_y"),"float"); (("pdbx_solvent_atom_site_mapping","Cartn_z"),"float"); (("pdbx_solvent_atom_site_mapping","pre_Cartn_x"),"float"); (("pdbx_solvent_atom_site_mapping","pre_Cartn_y"),"float"); (("pdbx_solvent_atom_site_mapping","pre_Cartn_z"),"float"); (("pdbx_solvent_atom_site_mapping","symmetry"),"symop"); (("pdbx_solvent_atom_site_mapping","symmetry_as_xyz"),"line"); 
    (("pdbx_molecule_features_depositor_info","entity_id"),"ucode"); (("pdbx_molecule_features_depositor_info","class"),"uline"); (("pdbx_molecule_features_depositor_info","type"),"uline"); (("pdbx_molecule_features_depositor_info","name"),"text"); (("pdbx_molecule_features_depositor_info","details"),"text"); 
    (("pdbx_chem_comp_instance_depositor_info","ordinal"),"int"); (("pdbx_chem_comp_instance_depositor_info","label_alt_id"),"code"); (("pdbx_chem_comp_instance_depositor_info","comp_id"),"ucode"); (("pdbx_chem_comp_instance_depositor_info","PDB_ins_code"),"code"); (("pdbx_chem_comp_instance_depositor_info","auth_asym_id"),"code"); (("pdbx_chem_comp_instance_depositor_info","auth_seq_id"),"code"); (("pdbx_chem_comp_instance_depositor_info","in_polymer_flag"),"code"); (("pdbx_chem_comp_instance_depositor_info","author_provided_flag"),"code"); (("pdbx_chem_comp_instance_depositor_info","formula"),"text"); 
    (("pdbx_depui_status_flags","dep_dataset_id"),"code"); (("pdbx_depui_status_flags","primary_citation_status"),"code"); (("pdbx_depui_status_flags","corresponding_author_status"),"code"); (("pdbx_depui_status_flags","reference_citation_status"),"code"); (("pdbx_depui_status_flags","is_grant_funded"),"code"); (("pdbx_depui_status_flags","has_ncs_data"),"code"); (("pdbx_depui_status_flags","prediction_target"),"code"); (("pdbx_depui_status_flags","has_helical_symmetry"),"code"); (("pdbx_depui_status_flags","has_point_symmetry"),"code"); (("pdbx_depui_status_flags","has_cyclic_symmetry"),"code"); (("pdbx_depui_status_flags","has_accepted_terms_and_conditions"),"code"); (("pdbx_depui_status_flags","has_viewed_validation_report"),"code"); (("pdbx_depui_status_flags","validated_model_file_name"),"line"); (("pdbx_depui_status_flags","merge_prior_model_file_name"),"line"); (("pdbx_depui_status_flags","merge_replace_model_file_name"),"line"); (("pdbx_depui_status_flags","merge_output_model_file_name"),"line"); (("pdbx_depui_status_flags","is_ligand_processing_complete"),"text"); (("pdbx_depui_status_flags","sample_xyz_sequence_alignments_valid"),"text"); (("pdbx_depui_status_flags","has_sas_data"),"code"); (("pdbx_depui_status_flags","is_sas_deposited"),"code"); (("pdbx_depui_status_flags","use_sas_refine"),"code"); 
    (("pdbx_depui_upload","ordinal"),"int"); (("pdbx_depui_upload","file_content_type"),"line"); (("pdbx_depui_upload","file_type"),"line"); (("pdbx_depui_upload","file_name"),"line"); (("pdbx_depui_upload","file_size"),"int"); (("pdbx_depui_upload","valid_flag"),"code"); (("pdbx_depui_upload","diagnostic_message"),"text"); (("pdbx_depui_upload","sequence_align"),"text"); 
    (("pdbx_depui_validation_status_flags","dep_dataset_id"),"code"); (("pdbx_depui_validation_status_flags","residual_B_factors_flag"),"code"); (("pdbx_depui_validation_status_flags","occupancy_outliers_low"),"int"); (("pdbx_depui_validation_status_flags","occupancy_outliers_high"),"int"); (("pdbx_depui_validation_status_flags","adp_outliers_low"),"int"); (("pdbx_depui_validation_status_flags","solvent_outliers"),"int"); 
    (("pdbx_chem_comp_upload_depositor_info","ordinal"),"int"); (("pdbx_chem_comp_upload_depositor_info","comp_id"),"ucode"); (("pdbx_chem_comp_upload_depositor_info","upload_file_type"),"line"); (("pdbx_chem_comp_upload_depositor_info","upload_file_name"),"line"); 
    (("pdbx_depui_entity_status_flags","dep_dataset_id"),"code"); (("pdbx_depui_entity_status_flags","entity_id"),"code"); (("pdbx_depui_entity_status_flags","has_mutation"),"code"); (("pdbx_depui_entity_status_flags","sample_xyz_sequence_alignments_valid"),"text"); 
    (("pdbx_depui_entity_features","dep_dataset_id"),"code"); (("pdbx_depui_entity_features","entity_id"),"code"); (("pdbx_depui_entity_features","type"),"uline"); 
    (("pdbx_deposition_message_info","ordinal"),"int"); (("pdbx_deposition_message_info","deposition_data_set_id"),"code"); (("pdbx_deposition_message_info","message_id"),"code"); (("pdbx_deposition_message_info","timestamp"),"line"); (("pdbx_deposition_message_info","sender"),"line"); (("pdbx_deposition_message_info","content_type"),"line"); (("pdbx_deposition_message_info","content_value"),"line"); (("pdbx_deposition_message_info","parent_message_id"),"code"); (("pdbx_deposition_message_info","message_subject"),"text"); (("pdbx_deposition_message_info","message_text"),"text"); (("pdbx_deposition_message_info","message_type"),"code"); (("pdbx_deposition_message_info","send_status"),"code"); 
    (("pdbx_deposition_message_file_reference","ordinal"),"int"); (("pdbx_deposition_message_file_reference","deposition_data_set_id"),"code"); (("pdbx_deposition_message_file_reference","message_id"),"code"); (("pdbx_deposition_message_file_reference","content_type"),"code"); (("pdbx_deposition_message_file_reference","content_format"),"line"); (("pdbx_deposition_message_file_reference","partition_number"),"code"); (("pdbx_deposition_message_file_reference","version_id"),"code"); (("pdbx_deposition_message_file_reference","storage_type"),"code"); 
    (("pdbx_depui_entry_details","dep_dataset_id"),"code"); (("pdbx_depui_entry_details","wwpdb_site_id"),"code"); (("pdbx_depui_entry_details","experimental_methods"),"text"); (("pdbx_depui_entry_details","requested_accession_types"),"line"); (("pdbx_depui_entry_details","validated_contact_email"),"line"); (("pdbx_depui_entry_details","country"),"line"); (("pdbx_depui_entry_details","structural_genomics_flag"),"code"); (("pdbx_depui_entry_details","related_database_name"),"line"); (("pdbx_depui_entry_details","related_database_code"),"line"); (("pdbx_depui_entry_details","replace_pdb_id"),"code"); 
    (("pdbx_data_processing_status","task_name"),"line"); (("pdbx_data_processing_status","status"),"line"); 
    (("pdbx_entity_instance_feature","details"),"text"); (("pdbx_entity_instance_feature","feature_type"),"line"); (("pdbx_entity_instance_feature","auth_asym_id"),"code"); (("pdbx_entity_instance_feature","asym_id"),"code"); (("pdbx_entity_instance_feature","auth_seq_num"),"code"); (("pdbx_entity_instance_feature","seq_num"),"int"); (("pdbx_entity_instance_feature","comp_id"),"ucode"); (("pdbx_entity_instance_feature","auth_comp_id"),"code"); (("pdbx_entity_instance_feature","ordinal"),"int"); 
    (("pdbx_entity_src_gen_depositor_info","src_id"),"int"); (("pdbx_entity_src_gen_depositor_info","entity_id"),"code"); (("pdbx_entity_src_gen_depositor_info","seq_type"),"line"); (("pdbx_entity_src_gen_depositor_info","beg_seq_num"),"int"); (("pdbx_entity_src_gen_depositor_info","end_seq_num"),"int"); (("pdbx_entity_src_gen_depositor_info","gene_src_gene"),"text"); (("pdbx_entity_src_gen_depositor_info","gene_src_scientific_name"),"text"); (("pdbx_entity_src_gen_depositor_info","host_org_gene"),"text"); (("pdbx_entity_src_gen_depositor_info","host_org_scientific_name"),"text"); (("pdbx_entity_src_gen_depositor_info","host_org_strain"),"text"); (("pdbx_entity_src_gen_depositor_info","gene_src_ncbi_taxonomy_id"),"int"); (("pdbx_entity_src_gen_depositor_info","host_org_ncbi_taxonomy_id"),"int"); (("pdbx_entity_src_gen_depositor_info","host_org_vector_type"),"text"); (("pdbx_entity_src_gen_depositor_info","plasmid_name"),"text"); 
    (("pdbx_chem_comp_model","id"),"ucode"); (("pdbx_chem_comp_model","comp_id"),"ucode"); 
    (("pdbx_chem_comp_model_atom","atom_id"),"atcode"); (("pdbx_chem_comp_model_atom","ordinal_id"),"int"); (("pdbx_chem_comp_model_atom","model_id"),"ucode"); (("pdbx_chem_comp_model_atom","charge"),"int"); (("pdbx_chem_comp_model_atom","model_Cartn_x"),"float"); (("pdbx_chem_comp_model_atom","model_Cartn_y"),"float"); (("pdbx_chem_comp_model_atom","model_Cartn_z"),"float"); (("pdbx_chem_comp_model_atom","type_symbol"),"code"); 
    (("pdbx_chem_comp_model_bond","atom_id_1"),"atcode"); (("pdbx_chem_comp_model_bond","atom_id_2"),"atcode"); (("pdbx_chem_comp_model_bond","model_id"),"ucode"); (("pdbx_chem_comp_model_bond","value_order"),"ucode"); (("pdbx_chem_comp_model_bond","ordinal_id"),"int"); 
    (("pdbx_chem_comp_model_feature","model_id"),"ucode"); (("pdbx_chem_comp_model_feature","feature_name"),"line"); (("pdbx_chem_comp_model_feature","feature_value"),"text"); 
    (("pdbx_chem_comp_model_descriptor","model_id"),"ucode"); (("pdbx_chem_comp_model_descriptor","descriptor"),"text"); (("pdbx_chem_comp_model_descriptor","type"),"uline"); 
    (("pdbx_chem_comp_model_audit","model_id"),"ucode"); (("pdbx_chem_comp_model_audit","date"),"yyyy-mm-dd"); (("pdbx_chem_comp_model_audit","annotator"),"code"); (("pdbx_chem_comp_model_audit","processing_site"),"code"); (("pdbx_chem_comp_model_audit","details"),"text"); (("pdbx_chem_comp_model_audit","action_type"),"line"); 
    (("pdbx_chem_comp_model_reference","model_id"),"ucode"); (("pdbx_chem_comp_model_reference","db_name"),"line"); (("pdbx_chem_comp_model_reference","db_code"),"line"); 
    (("pdbx_view_category_group","view_group_id"),"code"); (("pdbx_view_category_group","description"),"text"); 
    (("pdbx_view_category","view_group_id"),"code"); (("pdbx_view_category","category_id"),"code"); (("pdbx_view_category","category_view_name"),"line"); 
    (("pdbx_view_item","item_name"),"name"); (("pdbx_view_item","category_id"),"code"); (("pdbx_view_item","item_view_name"),"line"); (("pdbx_view_item","item_view_mandatory_code"),"code"); (("pdbx_view_item","item_view_allow_alternate_value"),"code"); 
    (("pdbx_coord","entry_id"),"code"); (("pdbx_coord","chain_atoms_Y_P"),"code"); (("pdbx_coord","hydrogen_atoms_Y_N"),"code"); (("pdbx_coord","solvent_atoms_Y_N"),"code"); (("pdbx_coord","structure_factors_Y_N"),"code"); 
    (("pdbx_connect","res_name"),"code"); (("pdbx_connect","hetgroup_name"),"line"); (("pdbx_connect","formul"),"line"); (("pdbx_connect","hetgroup_chemical_name"),"text"); (("pdbx_connect","parent_residue"),"code"); (("pdbx_connect","formal_charge"),"int"); (("pdbx_connect","class_1"),"text"); (("pdbx_connect","class_2"),"text"); (("pdbx_connect","type"),"text"); (("pdbx_connect","status"),"code"); (("pdbx_connect","date"),"yyyy-mm-dd"); (("pdbx_connect","modified_date"),"yyyy-mm-dd"); 
    (("pdbx_connect_type","res_name"),"code"); (("pdbx_connect_type","ndbTokenType"),"code"); (("pdbx_connect_type","modified"),"code"); 
    (("pdbx_connect_modification","res_name"),"code"); (("pdbx_connect_modification","modification"),"line"); 
    (("pdbx_connect_atom","res_name"),"code"); (("pdbx_connect_atom","atom_name"),"code"); (("pdbx_connect_atom","connect_to"),"code"); (("pdbx_connect_atom","type_symbol"),"code"); (("pdbx_connect_atom","charge"),"int"); (("pdbx_connect_atom","bond_type"),"code"); (("pdbx_connect_atom","align_pos"),"int"); 
    (("pdbx_database_PDB_master","entry_id"),"code"); (("pdbx_database_PDB_master","num_remark"),"int"); (("pdbx_database_PDB_master","num_ftnote"),"int"); (("pdbx_database_PDB_master","num_het"),"int"); (("pdbx_database_PDB_master","num_helix"),"int"); (("pdbx_database_PDB_master","num_sheet"),"int"); (("pdbx_database_PDB_master","num_turn"),"int"); (("pdbx_database_PDB_master","num_site"),"int"); (("pdbx_database_PDB_master","num_trans"),"int"); (("pdbx_database_PDB_master","num_coord"),"int"); (("pdbx_database_PDB_master","num_ter"),"int"); (("pdbx_database_PDB_master","num_conect"),"int"); (("pdbx_database_PDB_master","num_seqres"),"int"); 
    (("pdbx_database_pdb_omit","entry_id"),"code"); (("pdbx_database_pdb_omit","record_name"),"line"); 
    (("pdbx_dbref","pdb_id_code"),"code"); (("pdbx_dbref","chain_id"),"code"); (("pdbx_dbref","begin_res_number"),"code"); (("pdbx_dbref","begin_ins_code"),"code"); (("pdbx_dbref","end_res_number"),"code"); (("pdbx_dbref","end_ins_code"),"code"); (("pdbx_dbref","database_name"),"code"); (("pdbx_dbref","database_accession"),"code"); (("pdbx_dbref","database_id_code"),"code"); (("pdbx_dbref","database_begin_res_number"),"code"); (("pdbx_dbref","database_begin_ins_code"),"code"); (("pdbx_dbref","database_end_res_number"),"code"); (("pdbx_dbref","database_end_ins_code"),"code"); 
    (("pdbx_drug_info","id"),"code"); (("pdbx_drug_info","name"),"line"); (("pdbx_drug_info","num_per_asym_unit"),"int"); (("pdbx_drug_info","num_of_whole_molecule"),"int"); (("pdbx_drug_info","size_of_molecule_per_asym_unit"),"code"); 
    (("pdbx_inhibitor_info","id"),"int"); (("pdbx_inhibitor_info","name"),"line"); (("pdbx_inhibitor_info","num_per_asym_unit"),"int"); 
    (("pdbx_ion_info","id"),"code"); (("pdbx_ion_info","name"),"line"); (("pdbx_ion_info","numb_per_asym_unit"),"int"); 
    (("pdbx_hybrid","id"),"code"); (("pdbx_hybrid","sugar_name"),"line"); (("pdbx_hybrid","strand_id"),"code"); (("pdbx_hybrid","residue_names"),"line"); 
    (("pdbx_na_strand_info","id"),"code"); (("pdbx_na_strand_info","num_of_NA_strands_per_asym_unit"),"int"); (("pdbx_na_strand_info","num_of_NA_strands_per_biol_unit"),"int"); (("pdbx_na_strand_info","fract_NA_strand_per_asym_unit"),"code"); 
    (("pdbx_nonstandard_list","id"),"code"); (("pdbx_nonstandard_list","auth_asym_id"),"code"); (("pdbx_nonstandard_list","auth_seq_id"),"code"); (("pdbx_nonstandard_list","label_asym_id"),"code"); (("pdbx_nonstandard_list","label_seq_num"),"code"); (("pdbx_nonstandard_list","label_seq_id"),"int"); (("pdbx_nonstandard_list","ins_code"),"code"); (("pdbx_nonstandard_list","number_atoms_nh"),"int"); 
    (("pdbx_pdb_compnd","id"),"code"); (("pdbx_pdb_compnd","text"),"text"); 
    (("pdbx_pdb_source","id"),"code"); (("pdbx_pdb_source","text"),"text"); 
    (("pdbx_protein_info","id"),"code"); (("pdbx_protein_info","name"),"line"); (("pdbx_protein_info","num_per_asym_unit"),"int"); 
    (("pdbx_solvent_info","id"),"code"); (("pdbx_solvent_info","name"),"line"); (("pdbx_solvent_info","numb_per_asym_unit"),"int"); 
    (("pdbx_source","src_method"),"text"); 
    (("pdbx_struct_biol_func","id"),"code"); (("pdbx_struct_biol_func","biol_id"),"line"); (("pdbx_struct_biol_func","function"),"text"); 
    (("pdbx_struct_pack_gen","id"),"code"); (("pdbx_struct_pack_gen","asym_id"),"code"); (("pdbx_struct_pack_gen","symmetry"),"symop"); (("pdbx_struct_pack_gen","color_red"),"float"); (("pdbx_struct_pack_gen","color_green"),"float"); (("pdbx_struct_pack_gen","color_blue"),"float"); (("pdbx_struct_pack_gen","crystal_type"),"int"); (("pdbx_struct_pack_gen","packing_type"),"int"); 
    (("pdbx_trna_info","id"),"code"); (("pdbx_trna_info","name"),"line"); (("pdbx_trna_info","num_per_asym_unit"),"int"); 
    (("pdbx_unpair","chain_id"),"code"); (("pdbx_unpair","residue_name"),"code"); (("pdbx_unpair","residue_number"),"code"); 
    (("pdbx_refine_ls_restr_ncs","dom_id"),"line"); (("pdbx_refine_ls_restr_ncs","type"),"line"); (("pdbx_refine_ls_restr_ncs","number"),"int"); (("pdbx_refine_ls_restr_ncs","rms_dev"),"float"); (("pdbx_refine_ls_restr_ncs","weight"),"float"); 
    (("pdbx_struct_ncs_virus_gen","id"),"code"); (("pdbx_struct_ncs_virus_gen","oper_id"),"code"); (("pdbx_struct_ncs_virus_gen","asym_id"),"code"); (("pdbx_struct_ncs_virus_gen","pdb_chain_id"),"code"); 
    (("pdbx_sequence_annotation","pdb_chain_id"),"code"); (("pdbx_sequence_annotation","ncbi_taxid"),"code"); 
    (("pdbx_chem_comp_synonyms","name"),"text"); (("pdbx_chem_comp_synonyms","synonym"),"text"); 
    (("pdbx_post_process_details","entry_id"),"code"); (("pdbx_post_process_details","text"),"text"); (("pdbx_post_process_details","seq_details"),"text"); 
    (("pdbx_post_process_status","entry_id"),"code"); (("pdbx_post_process_status","cycle_id"),"code"); (("pdbx_post_process_status","date_begin"),"yyyy-mm-dd:hh:mm"); (("pdbx_post_process_status","date_end"),"yyyy-mm-dd:hh:mm"); (("pdbx_post_process_status","details"),"text"); (("pdbx_post_process_status","annotator"),"line"); 
    (("pdbx_struct_link","id"),"code"); (("pdbx_struct_link","type"),"ucode"); (("pdbx_struct_link","ptnr1_label_alt_id"),"code"); (("pdbx_struct_link","ptnr1_label_asym_id"),"code"); (("pdbx_struct_link","ptnr1_label_atom_id"),"atcode"); (("pdbx_struct_link","ptnr1_label_comp_id"),"ucode"); (("pdbx_struct_link","ptnr1_label_seq_id"),"int"); (("pdbx_struct_link","ptnr1_label_ins_code"),"code"); (("pdbx_struct_link","ptnr1_symmetry"),"symop"); (("pdbx_struct_link","ptnr2_label_alt_id"),"code"); (("pdbx_struct_link","ptnr2_label_asym_id"),"code"); (("pdbx_struct_link","ptnr2_label_atom_id"),"atcode"); (("pdbx_struct_link","ptnr2_label_comp_id"),"ucode"); (("pdbx_struct_link","ptnr2_label_seq_id"),"int"); (("pdbx_struct_link","ptnr2_label_ins_code"),"code"); (("pdbx_struct_link","ptnr2_symmetry"),"symop"); (("pdbx_struct_link","details"),"line"); (("pdbx_struct_link","pdbx_dist_value"),"float"); 
    (("pdbx_missing_residue_list","pdb_model_id"),"int"); (("pdbx_missing_residue_list","pdb_chain_id"),"code"); (("pdbx_missing_residue_list","pdb_residue_name"),"code"); (("pdbx_missing_residue_list","pdb_residue_number"),"code"); (("pdbx_missing_residue_list","pdb_insertion_code"),"code"); (("pdbx_missing_residue_list","label_seq_id"),"int"); 
    (("pdbx_data_processing_cell","entry_id"),"code"); (("pdbx_data_processing_cell","a"),"float"); (("pdbx_data_processing_cell","a_tolerance"),"float"); (("pdbx_data_processing_cell","b"),"float"); (("pdbx_data_processing_cell","b_tolerance"),"float"); (("pdbx_data_processing_cell","c"),"float"); (("pdbx_data_processing_cell","c_tolerance"),"float"); (("pdbx_data_processing_cell","alpha"),"float"); (("pdbx_data_processing_cell","alpha_tolerance"),"float"); (("pdbx_data_processing_cell","beta"),"float"); (("pdbx_data_processing_cell","beta_tolerance"),"float"); (("pdbx_data_processing_cell","gamma"),"float"); (("pdbx_data_processing_cell","gamma_tolerance"),"float"); (("pdbx_data_processing_cell","volume"),"float"); (("pdbx_data_processing_cell","mosaicity"),"float"); (("pdbx_data_processing_cell","resolution_range"),"line"); (("pdbx_data_processing_cell","space_group"),"line"); 
    (("pdbx_data_processing_reflns","entry_id"),"code"); (("pdbx_data_processing_reflns","number_all"),"int"); (("pdbx_data_processing_reflns","number_marked_reject"),"int"); (("pdbx_data_processing_reflns","percent_marked_reject"),"float"); (("pdbx_data_processing_reflns","percent_rejected"),"float"); (("pdbx_data_processing_reflns","R_factor_all_linear"),"float"); 
    (("pdbx_data_processing_detector","entry_id"),"code"); (("pdbx_data_processing_detector","name"),"line"); (("pdbx_data_processing_detector","wavelength"),"float"); (("pdbx_data_processing_detector","polarization"),"float"); (("pdbx_data_processing_detector","beam_position_x"),"float"); (("pdbx_data_processing_detector","beam_position_y"),"float"); (("pdbx_data_processing_detector","cassette_rot_x"),"float"); (("pdbx_data_processing_detector","cassette_rot_y"),"float"); (("pdbx_data_processing_detector","cassette_rot_z"),"float"); (("pdbx_data_processing_detector","scale_y"),"float"); (("pdbx_data_processing_detector","skew"),"float"); (("pdbx_data_processing_detector","crossfire_x"),"float"); (("pdbx_data_processing_detector","crossfire_y"),"float"); (("pdbx_data_processing_detector","crossfire_xy"),"float"); (("pdbx_data_processing_detector","date"),"line"); (("pdbx_data_processing_detector","experimentor"),"text"); (("pdbx_data_processing_detector","crystal_data_id"),"text"); (("pdbx_data_processing_detector","processing_path"),"text"); (("pdbx_data_processing_detector","processing_files"),"text"); 
    (("pdbx_chem_comp_nonstandard","comp_id"),"ucode"); (("pdbx_chem_comp_nonstandard","type"),"line"); 
    (("pdbx_entity_poly_protein_class","entity_id"),"code"); (("pdbx_entity_poly_protein_class","class"),"line"); 
    (("pdbx_entity_name_taxonomy_tree","id"),"text"); (("pdbx_entity_name_taxonomy_tree","parent_id"),"text"); 
    (("pdbx_entity_name_taxonomy","id"),"text"); (("pdbx_entity_name_taxonomy","name"),"text"); (("pdbx_entity_name_taxonomy","name_type"),"line"); 
    (("pdbx_entity_name_instance","name"),"text"); (("pdbx_entity_name_instance","pdb_id"),"code"); (("pdbx_entity_name_instance","rcsb_id"),"code"); (("pdbx_entity_name_instance","entity_id"),"code"); (("pdbx_entity_name_instance","pdb_chain_id"),"code"); (("pdbx_entity_name_instance","pdb_mol_id"),"code"); 
    (("pdbx_tableinfo","tablename"),"code30"); (("pdbx_tableinfo","description"),"text"); (("pdbx_tableinfo","type"),"int"); (("pdbx_tableinfo","table_serial_no"),"int"); (("pdbx_tableinfo","group_name"),"line"); (("pdbx_tableinfo","WWW_Selection_Criteria"),"int"); (("pdbx_tableinfo","WWW_Report_Criteria"),"int"); 
    (("pdbx_columninfo","columnname"),"code30"); (("pdbx_columninfo","tablename"),"code30"); (("pdbx_columninfo","description"),"text"); (("pdbx_columninfo","example"),"text"); (("pdbx_columninfo","type"),"int"); (("pdbx_columninfo","table_serial_no"),"int"); (("pdbx_columninfo","column_serial_no"),"int"); (("pdbx_columninfo","WWW_Selection_Criteria"),"int"); (("pdbx_columninfo","WWW_Report_Criteria"),"int"); 
    (("pdbx_val_angle","id"),"int"); (("pdbx_val_angle","model_id"),"int"); (("pdbx_val_angle","auth_asym_id_1"),"code"); (("pdbx_val_angle","auth_atom_id_1"),"atcode"); (("pdbx_val_angle","auth_comp_id_1"),"code"); (("pdbx_val_angle","auth_seq_id_1"),"code"); (("pdbx_val_angle","auth_atom_id_2"),"atcode"); (("pdbx_val_angle","auth_asym_id_2"),"code"); (("pdbx_val_angle","auth_comp_id_2"),"code"); (("pdbx_val_angle","auth_seq_id_2"),"code"); (("pdbx_val_angle","auth_atom_id_3"),"atcode"); (("pdbx_val_angle","auth_asym_id_3"),"code"); (("pdbx_val_angle","auth_comp_id_3"),"code"); (("pdbx_val_angle","auth_seq_id_3"),"code"); (("pdbx_val_angle","auth_PDB_insert_id_1"),"code"); (("pdbx_val_angle","auth_PDB_insert_id_2"),"code"); (("pdbx_val_angle","auth_PDB_insert_id_3"),"code"); (("pdbx_val_angle","label_alt_id_1"),"code"); (("pdbx_val_angle","label_asym_id_1"),"code"); (("pdbx_val_angle","label_atom_id_1"),"atcode"); (("pdbx_val_angle","label_comp_id_1"),"ucode"); (("pdbx_val_angle","label_seq_id_1"),"int"); (("pdbx_val_angle","label_alt_id_2"),"code"); (("pdbx_val_angle","label_asym_id_2"),"code"); (("pdbx_val_angle","label_atom_id_2"),"atcode"); (("pdbx_val_angle","label_comp_id_2"),"ucode"); (("pdbx_val_angle","label_seq_id_2"),"int"); (("pdbx_val_angle","label_alt_id_3"),"code"); (("pdbx_val_angle","label_asym_id_3"),"code"); (("pdbx_val_angle","label_atom_id_3"),"atcode"); (("pdbx_val_angle","label_comp_id_3"),"ucode"); (("pdbx_val_angle","label_seq_id_3"),"int"); (("pdbx_val_angle","angle"),"float"); (("pdbx_val_angle","angle_deviation"),"float"); 
    (("pdbx_val_bond","id"),"int"); (("pdbx_val_bond","model_id"),"int"); (("pdbx_val_bond","auth_asym_id_1"),"code"); (("pdbx_val_bond","auth_atom_id_1"),"atcode"); (("pdbx_val_bond","auth_comp_id_1"),"code"); (("pdbx_val_bond","auth_seq_id_1"),"code"); (("pdbx_val_bond","auth_atom_id_2"),"atcode"); (("pdbx_val_bond","auth_asym_id_2"),"code"); (("pdbx_val_bond","auth_comp_id_2"),"code"); (("pdbx_val_bond","auth_seq_id_2"),"code"); (("pdbx_val_bond","auth_PDB_insert_id_1"),"code"); (("pdbx_val_bond","auth_PDB_insert_id_2"),"code"); (("pdbx_val_bond","label_alt_id_1"),"code"); (("pdbx_val_bond","label_asym_id_1"),"code"); (("pdbx_val_bond","label_atom_id_1"),"atcode"); (("pdbx_val_bond","label_comp_id_1"),"ucode"); (("pdbx_val_bond","label_seq_id_1"),"int"); (("pdbx_val_bond","label_alt_id_2"),"code"); (("pdbx_val_bond","label_asym_id_2"),"code"); (("pdbx_val_bond","label_atom_id_2"),"atcode"); (("pdbx_val_bond","label_comp_id_2"),"ucode"); (("pdbx_val_bond","label_seq_id_2"),"int"); (("pdbx_val_bond","bond"),"float"); (("pdbx_val_bond","bond_deviation"),"float"); 
    (("pdbx_val_contact","id"),"int"); (("pdbx_val_contact","model_id"),"int"); (("pdbx_val_contact","auth_asym_id_1"),"code"); (("pdbx_val_contact","auth_atom_id_1"),"atcode"); (("pdbx_val_contact","auth_comp_id_1"),"code"); (("pdbx_val_contact","auth_seq_id_1"),"code"); (("pdbx_val_contact","auth_atom_id_2"),"atcode"); (("pdbx_val_contact","auth_asym_id_2"),"code"); (("pdbx_val_contact","auth_comp_id_2"),"code"); (("pdbx_val_contact","auth_seq_id_2"),"code"); (("pdbx_val_contact","auth_PDB_insert_id_1"),"code"); (("pdbx_val_contact","auth_PDB_insert_id_2"),"code"); (("pdbx_val_contact","label_alt_id_1"),"code"); (("pdbx_val_contact","label_asym_id_1"),"code"); (("pdbx_val_contact","label_atom_id_1"),"atcode"); (("pdbx_val_contact","label_comp_id_1"),"ucode"); (("pdbx_val_contact","label_seq_id_1"),"int"); (("pdbx_val_contact","label_alt_id_2"),"code"); (("pdbx_val_contact","label_asym_id_2"),"code"); (("pdbx_val_contact","label_atom_id_2"),"atcode"); (("pdbx_val_contact","label_comp_id_2"),"ucode"); (("pdbx_val_contact","label_seq_id_2"),"int"); (("pdbx_val_contact","dist"),"float"); 
    (("pdbx_val_sym_contact","id"),"int"); (("pdbx_val_sym_contact","model_id"),"int"); (("pdbx_val_sym_contact","auth_asym_id_1"),"code"); (("pdbx_val_sym_contact","auth_atom_id_1"),"atcode"); (("pdbx_val_sym_contact","auth_comp_id_1"),"code"); (("pdbx_val_sym_contact","auth_seq_id_1"),"code"); (("pdbx_val_sym_contact","auth_atom_id_2"),"atcode"); (("pdbx_val_sym_contact","auth_asym_id_2"),"code"); (("pdbx_val_sym_contact","auth_comp_id_2"),"code"); (("pdbx_val_sym_contact","auth_seq_id_2"),"code"); (("pdbx_val_sym_contact","auth_PDB_insert_id_1"),"code"); (("pdbx_val_sym_contact","auth_PDB_insert_id_2"),"code"); (("pdbx_val_sym_contact","label_alt_id_1"),"code"); (("pdbx_val_sym_contact","label_asym_id_1"),"code"); (("pdbx_val_sym_contact","label_atom_id_1"),"atcode"); (("pdbx_val_sym_contact","label_comp_id_1"),"ucode"); (("pdbx_val_sym_contact","label_seq_id_1"),"int"); (("pdbx_val_sym_contact","label_alt_id_2"),"code"); (("pdbx_val_sym_contact","label_asym_id_2"),"code"); (("pdbx_val_sym_contact","label_atom_id_2"),"atcode"); (("pdbx_val_sym_contact","label_comp_id_2"),"ucode"); (("pdbx_val_sym_contact","label_seq_id_2"),"int"); (("pdbx_val_sym_contact","site_symmetry_1"),"code"); (("pdbx_val_sym_contact","site_symmetry_2"),"code"); (("pdbx_val_sym_contact","dist"),"float"); 
    (("pdbx_rmch_outlier","id"),"int"); (("pdbx_rmch_outlier","model_id"),"int"); (("pdbx_rmch_outlier","auth_asym_id"),"code"); (("pdbx_rmch_outlier","auth_comp_id"),"code"); (("pdbx_rmch_outlier","auth_seq_id"),"code"); (("pdbx_rmch_outlier","auth_PDB_insert_id"),"code"); (("pdbx_rmch_outlier","label_asym_id"),"code"); (("pdbx_rmch_outlier","label_comp_id"),"ucode"); (("pdbx_rmch_outlier","label_seq_id"),"int"); (("pdbx_rmch_outlier","phi"),"float"); (("pdbx_rmch_outlier","psi"),"float"); 
    (("pdbx_missing_atom_poly","id"),"int"); (("pdbx_missing_atom_poly","model_id"),"int"); (("pdbx_missing_atom_poly","auth_asym_id"),"code"); (("pdbx_missing_atom_poly","auth_comp_id"),"code"); (("pdbx_missing_atom_poly","auth_seq_id"),"code"); (("pdbx_missing_atom_poly","auth_PDB_insert_id"),"code"); (("pdbx_missing_atom_poly","label_asym_id"),"code"); (("pdbx_missing_atom_poly","label_comp_id"),"ucode"); (("pdbx_missing_atom_poly","label_seq_id"),"int"); (("pdbx_missing_atom_poly","atom_name"),"code"); 
    (("pdbx_missing_atom_nonpoly","id"),"int"); (("pdbx_missing_atom_nonpoly","model_id"),"int"); (("pdbx_missing_atom_nonpoly","auth_asym_id"),"code"); (("pdbx_missing_atom_nonpoly","auth_comp_id"),"code"); (("pdbx_missing_atom_nonpoly","auth_seq_id"),"code"); (("pdbx_missing_atom_nonpoly","auth_PDB_insert_id"),"code"); (("pdbx_missing_atom_nonpoly","label_asym_id"),"code"); (("pdbx_missing_atom_nonpoly","label_comp_id"),"ucode"); (("pdbx_missing_atom_nonpoly","atom_name"),"code"); 
    (("pdbx_val_chiral","id"),"int"); (("pdbx_val_chiral","model_id"),"int"); (("pdbx_val_chiral","auth_asym_id"),"code"); (("pdbx_val_chiral","auth_comp_id"),"code"); (("pdbx_val_chiral","auth_seq_id"),"code"); (("pdbx_val_chiral","auth_PDB_insert_id"),"code"); (("pdbx_val_chiral","label_asym_id"),"code"); (("pdbx_val_chiral","label_comp_id"),"ucode"); (("pdbx_val_chiral","label_seq_id"),"int"); (("pdbx_val_chiral","chiral_center_atom_name"),"code"); (("pdbx_val_chiral","chiral_neighbor_atom_name"),"code"); (("pdbx_val_chiral","chiral_center_atom_alt_id"),"code"); (("pdbx_val_chiral","chiral_neighbor_atom_alt_id"),"code"); 
    (("pdbx_atlas","entry_id"),"code"); (("pdbx_atlas","page_id"),"int"); (("pdbx_atlas","page_name"),"text"); 
    (("pdbx_summary_flags","entry_id"),"code"); (("pdbx_summary_flags","flag_id"),"line"); (("pdbx_summary_flags","flag_value"),"code"); 
    (("pdbx_entity_func_bind_mode","id"),"code"); (("pdbx_entity_func_bind_mode","domain_id"),"code"); (("pdbx_entity_func_bind_mode","entity_id"),"code"); (("pdbx_entity_func_bind_mode","protein_binds_to"),"code"); (("pdbx_entity_func_bind_mode","type"),"ucode"); 
    (("pdbx_entity_func_enzyme","bind_mode_id"),"code"); (("pdbx_entity_func_enzyme","type"),"uline"); 
    (("pdbx_entity_func_regulatory","bind_mode_id"),"code"); (("pdbx_entity_func_regulatory","type"),"uline"); 
    (("pdbx_entity_func_structural","bind_mode_id"),"code"); (("pdbx_entity_func_structural","type"),"uline"); 
    (("pdbx_entity_func_other","bind_mode_id"),"code"); (("pdbx_entity_func_other","type"),"uline"); 
    (("pdbx_entity_poly_domain","id"),"code"); (("pdbx_entity_poly_domain","entity_id"),"code"); (("pdbx_entity_poly_domain","begin_mon_id"),"ucode"); (("pdbx_entity_poly_domain","begin_seq_num"),"int"); (("pdbx_entity_poly_domain","end_mon_id"),"ucode"); (("pdbx_entity_poly_domain","end_seq_num"),"int"); 
    (("pdbx_na_struct_keywds","entry_id"),"code"); (("pdbx_na_struct_keywds","conformation_type"),"line"); (("pdbx_na_struct_keywds","strand_description"),"line"); (("pdbx_na_struct_keywds","special_feature"),"line"); 
    (("pdbx_entity_poly_na_type","entity_id"),"code"); (("pdbx_entity_poly_na_type","type"),"line"); 
    (("pdbx_entity_poly_na_nonstandard","entity_id"),"code"); (("pdbx_entity_poly_na_nonstandard","feature"),"line"); 
    (("pdbx_virtual_angle","model_id"),"int"); (("pdbx_virtual_angle","atom_site_id_1"),"code"); (("pdbx_virtual_angle","atom_site_label_alt_id_1"),"code"); (("pdbx_virtual_angle","atom_site_label_atom_id_1"),"atcode"); (("pdbx_virtual_angle","atom_site_label_comp_id_1"),"ucode"); (("pdbx_virtual_angle","atom_site_label_seq_id_1"),"int"); (("pdbx_virtual_angle","atom_site_label_asym_id_1"),"code"); (("pdbx_virtual_angle","atom_site_id_2"),"code"); (("pdbx_virtual_angle","atom_site_label_alt_id_2"),"code"); (("pdbx_virtual_angle","atom_site_label_atom_id_2"),"atcode"); (("pdbx_virtual_angle","atom_site_label_comp_id_2"),"ucode"); (("pdbx_virtual_angle","atom_site_label_seq_id_2"),"int"); (("pdbx_virtual_angle","atom_site_label_asym_id_2"),"code"); (("pdbx_virtual_angle","atom_site_id_3"),"code"); (("pdbx_virtual_angle","atom_site_label_alt_id_3"),"code"); (("pdbx_virtual_angle","atom_site_label_atom_id_3"),"atcode"); (("pdbx_virtual_angle","atom_site_label_comp_id_3"),"ucode"); (("pdbx_virtual_angle","atom_site_label_seq_id_3"),"int"); (("pdbx_virtual_angle","atom_site_label_asym_id_3"),"code"); (("pdbx_virtual_angle","atom_site_auth_asym_id_1"),"code"); (("pdbx_virtual_angle","atom_site_auth_atom_id_1"),"atcode"); (("pdbx_virtual_angle","atom_site_auth_comp_id_1"),"code"); (("pdbx_virtual_angle","atom_site_auth_seq_id_1"),"code"); (("pdbx_virtual_angle","atom_site_auth_atom_id_2"),"atcode"); (("pdbx_virtual_angle","atom_site_auth_asym_id_2"),"code"); (("pdbx_virtual_angle","atom_site_auth_comp_id_2"),"code"); (("pdbx_virtual_angle","atom_site_auth_seq_id_2"),"code"); (("pdbx_virtual_angle","atom_site_auth_atom_id_3"),"atcode"); (("pdbx_virtual_angle","atom_site_auth_asym_id_3"),"code"); (("pdbx_virtual_angle","atom_site_auth_comp_id_3"),"code"); (("pdbx_virtual_angle","atom_site_auth_seq_id_3"),"code"); (("pdbx_virtual_angle","site_symmetry_1"),"symop"); (("pdbx_virtual_angle","site_symmetry_2"),"symop"); (("pdbx_virtual_angle","site_symmetry_3"),"symop"); (("pdbx_virtual_angle","value"),"float"); (("pdbx_virtual_angle","value_esd"),"float"); 
    (("pdbx_virtual_bond","model_id"),"int"); (("pdbx_virtual_bond","atom_site_id_1"),"code"); (("pdbx_virtual_bond","atom_site_label_alt_id_1"),"code"); (("pdbx_virtual_bond","atom_site_label_atom_id_1"),"atcode"); (("pdbx_virtual_bond","atom_site_label_comp_id_1"),"ucode"); (("pdbx_virtual_bond","atom_site_label_seq_id_1"),"int"); (("pdbx_virtual_bond","atom_site_label_asym_id_1"),"code"); (("pdbx_virtual_bond","atom_site_id_2"),"code"); (("pdbx_virtual_bond","atom_site_label_alt_id_2"),"code"); (("pdbx_virtual_bond","atom_site_label_atom_id_2"),"atcode"); (("pdbx_virtual_bond","atom_site_label_comp_id_2"),"ucode"); (("pdbx_virtual_bond","atom_site_label_seq_id_2"),"int"); (("pdbx_virtual_bond","atom_site_label_asym_id_2"),"code"); (("pdbx_virtual_bond","atom_site_auth_atom_id_1"),"atcode"); (("pdbx_virtual_bond","atom_site_auth_asym_id_1"),"code"); (("pdbx_virtual_bond","atom_site_auth_comp_id_1"),"code"); (("pdbx_virtual_bond","atom_site_auth_seq_id_1"),"code"); (("pdbx_virtual_bond","atom_site_auth_atom_id_2"),"atcode"); (("pdbx_virtual_bond","atom_site_auth_asym_id_2"),"code"); (("pdbx_virtual_bond","atom_site_auth_comp_id_2"),"code"); (("pdbx_virtual_bond","atom_site_auth_seq_id_2"),"int"); (("pdbx_virtual_bond","dist"),"float"); (("pdbx_virtual_bond","dist_esd"),"float"); (("pdbx_virtual_bond","site_symmetry_1"),"symop"); (("pdbx_virtual_bond","site_symmetry_2"),"symop"); 
    (("pdbx_virtual_torsion","model_id"),"int"); (("pdbx_virtual_torsion","atom_site_id_1"),"code"); (("pdbx_virtual_torsion","atom_site_label_alt_id_1"),"code"); (("pdbx_virtual_torsion","atom_site_label_atom_id_1"),"atcode"); (("pdbx_virtual_torsion","atom_site_label_comp_id_1"),"ucode"); (("pdbx_virtual_torsion","atom_site_label_seq_id_1"),"int"); (("pdbx_virtual_torsion","atom_site_label_asym_id_1"),"code"); (("pdbx_virtual_torsion","atom_site_id_2"),"code"); (("pdbx_virtual_torsion","atom_site_label_alt_id_2"),"code"); (("pdbx_virtual_torsion","atom_site_label_atom_id_2"),"atcode"); (("pdbx_virtual_torsion","atom_site_label_comp_id_2"),"ucode"); (("pdbx_virtual_torsion","atom_site_label_seq_id_2"),"int"); (("pdbx_virtual_torsion","atom_site_label_asym_id_2"),"code"); (("pdbx_virtual_torsion","atom_site_id_3"),"code"); (("pdbx_virtual_torsion","atom_site_label_alt_id_3"),"code"); (("pdbx_virtual_torsion","atom_site_label_atom_id_3"),"atcode"); (("pdbx_virtual_torsion","atom_site_label_comp_id_3"),"ucode"); (("pdbx_virtual_torsion","atom_site_label_seq_id_3"),"int"); (("pdbx_virtual_torsion","atom_site_label_asym_id_3"),"code"); (("pdbx_virtual_torsion","atom_site_id_4"),"code"); (("pdbx_virtual_torsion","atom_site_label_alt_id_4"),"code"); (("pdbx_virtual_torsion","atom_site_label_atom_id_4"),"atcode"); (("pdbx_virtual_torsion","atom_site_label_comp_id_4"),"ucode"); (("pdbx_virtual_torsion","atom_site_label_seq_id_4"),"int"); (("pdbx_virtual_torsion","atom_site_label_asym_id_4"),"code"); (("pdbx_virtual_torsion","atom_site_auth_atom_id_1"),"atcode"); (("pdbx_virtual_torsion","atom_site_auth_asym_id_1"),"code"); (("pdbx_virtual_torsion","atom_site_auth_comp_id_1"),"code"); (("pdbx_virtual_torsion","atom_site_auth_seq_id_1"),"code"); (("pdbx_virtual_torsion","atom_site_auth_atom_id_2"),"atcode"); (("pdbx_virtual_torsion","atom_site_auth_asym_id_2"),"code"); (("pdbx_virtual_torsion","atom_site_auth_comp_id_2"),"code"); (("pdbx_virtual_torsion","atom_site_auth_seq_id_2"),"code"); (("pdbx_virtual_torsion","atom_site_auth_atom_id_3"),"atcode"); (("pdbx_virtual_torsion","atom_site_auth_asym_id_3"),"code"); (("pdbx_virtual_torsion","atom_site_auth_comp_id_3"),"code"); (("pdbx_virtual_torsion","atom_site_auth_seq_id_3"),"code"); (("pdbx_virtual_torsion","atom_site_auth_atom_id_4"),"atcode"); (("pdbx_virtual_torsion","atom_site_auth_asym_id_4"),"code"); (("pdbx_virtual_torsion","atom_site_auth_comp_id_4"),"code"); (("pdbx_virtual_torsion","atom_site_auth_seq_id_4"),"code"); (("pdbx_virtual_torsion","site_symmetry_1"),"symop"); (("pdbx_virtual_torsion","site_symmetry_2"),"symop"); (("pdbx_virtual_torsion","site_symmetry_3"),"symop"); (("pdbx_virtual_torsion","site_symmetry_4"),"symop"); (("pdbx_virtual_torsion","value"),"float"); (("pdbx_virtual_torsion","value_esd"),"float"); 
    (("pdbx_sequence_pattern","label_asym_id"),"code"); (("pdbx_sequence_pattern","auth_asym_id"),"code"); (("pdbx_sequence_pattern","pattern_count"),"int"); (("pdbx_sequence_pattern","sequence_pattern"),"code"); 
    (("pdbx_stereochemistry","id"),"int"); (("pdbx_stereochemistry","model_id"),"int"); (("pdbx_stereochemistry","auth_asym_id"),"code"); (("pdbx_stereochemistry","label_asym_id"),"code"); (("pdbx_stereochemistry","label_comp_id"),"ucode"); (("pdbx_stereochemistry","auth_seq_id"),"code"); (("pdbx_stereochemistry","label_seq_id"),"int"); (("pdbx_stereochemistry","label_atom_id"),"atcode"); (("pdbx_stereochemistry","label_alt_id"),"code"); (("pdbx_stereochemistry","label_atom_id_u"),"atcode"); (("pdbx_stereochemistry","label_alt_id_u"),"code"); (("pdbx_stereochemistry","label_atom_id_v"),"atcode"); (("pdbx_stereochemistry","label_alt_id_v"),"code"); (("pdbx_stereochemistry","label_atom_id_w"),"atcode"); (("pdbx_stereochemistry","label_alt_id_w"),"code"); (("pdbx_stereochemistry","volume3"),"float"); (("pdbx_stereochemistry","angle_out_of_plane"),"float"); 
    (("pdbx_rms_devs_covalent","entry_id"),"code"); (("pdbx_rms_devs_covalent","rms_bonds"),"float"); (("pdbx_rms_devs_covalent","num_bonds"),"int"); (("pdbx_rms_devs_covalent","rms_bonds_base"),"float"); (("pdbx_rms_devs_covalent","num_bonds_base"),"int"); (("pdbx_rms_devs_covalent","rms_bonds_sugar"),"float"); (("pdbx_rms_devs_covalent","num_bonds_sugar"),"int"); (("pdbx_rms_devs_covalent","rms_bonds_phosphate"),"float"); (("pdbx_rms_devs_covalent","num_bonds_phosphate"),"int"); (("pdbx_rms_devs_covalent","rms_angles"),"float"); (("pdbx_rms_devs_covalent","num_angles"),"int"); (("pdbx_rms_devs_covalent","rms_angles_base"),"float"); (("pdbx_rms_devs_covalent","num_angles_base"),"int"); (("pdbx_rms_devs_covalent","rms_angles_sugar"),"float"); (("pdbx_rms_devs_covalent","num_angles_sugar"),"int"); (("pdbx_rms_devs_covalent","rms_angles_phosphate"),"float"); (("pdbx_rms_devs_covalent","num_angles_phosphate"),"int"); 
    (("pdbx_rms_devs_cov_by_monomer","id"),"int"); (("pdbx_rms_devs_cov_by_monomer","model_id"),"int"); (("pdbx_rms_devs_cov_by_monomer","auth_asym_id"),"code"); (("pdbx_rms_devs_cov_by_monomer","label_asym_id"),"code"); (("pdbx_rms_devs_cov_by_monomer","label_comp_id"),"ucode"); (("pdbx_rms_devs_cov_by_monomer","auth_seq_id"),"code"); (("pdbx_rms_devs_cov_by_monomer","label_seq_id"),"int"); (("pdbx_rms_devs_cov_by_monomer","rms_bonds"),"float"); (("pdbx_rms_devs_cov_by_monomer","num_bonds"),"int"); (("pdbx_rms_devs_cov_by_monomer","rms_angles"),"float"); (("pdbx_rms_devs_cov_by_monomer","num_angles"),"int"); 
    (("pdbx_sugar_phosphate_geometry","id"),"int"); (("pdbx_sugar_phosphate_geometry","model_id"),"int"); (("pdbx_sugar_phosphate_geometry","auth_asym_id"),"code"); (("pdbx_sugar_phosphate_geometry","label_asym_id"),"code"); (("pdbx_sugar_phosphate_geometry","label_comp_id"),"ucode"); (("pdbx_sugar_phosphate_geometry","auth_seq_id"),"code"); (("pdbx_sugar_phosphate_geometry","label_seq_id"),"int"); (("pdbx_sugar_phosphate_geometry","neighbor_comp_id_5prime"),"ucode"); (("pdbx_sugar_phosphate_geometry","neighbor_comp_id_3prime"),"ucode"); (("pdbx_sugar_phosphate_geometry","o3_p_o5_c5"),"float"); (("pdbx_sugar_phosphate_geometry","p_o5_c5_c4"),"float"); (("pdbx_sugar_phosphate_geometry","o5_c5_c4_c3"),"float"); (("pdbx_sugar_phosphate_geometry","c5_c4_c3_o3"),"float"); (("pdbx_sugar_phosphate_geometry","c4_c3_o3_p"),"float"); (("pdbx_sugar_phosphate_geometry","c3_o3_p_o5"),"float"); (("pdbx_sugar_phosphate_geometry","c4_o4_c1_n1_9"),"float"); (("pdbx_sugar_phosphate_geometry","o4_c1_n1_9_c2_4"),"float"); (("pdbx_sugar_phosphate_geometry","o4_c1_n1_9_c6_8"),"float"); (("pdbx_sugar_phosphate_geometry","c4_o4_c1_c2"),"float"); (("pdbx_sugar_phosphate_geometry","o4_c1_c2_c3"),"float"); (("pdbx_sugar_phosphate_geometry","c1_c2_c3_c4"),"float"); (("pdbx_sugar_phosphate_geometry","c2_c3_c4_o4"),"float"); (("pdbx_sugar_phosphate_geometry","c3_c4_o4_c1"),"float"); (("pdbx_sugar_phosphate_geometry","c5_c4_c3_c2"),"float"); (("pdbx_sugar_phosphate_geometry","o4_c4_c3_o3"),"float"); (("pdbx_sugar_phosphate_geometry","o3_c3_c2_o2"),"float"); (("pdbx_sugar_phosphate_geometry","o5_c5_c4_o4"),"float"); (("pdbx_sugar_phosphate_geometry","pseudorot"),"float"); (("pdbx_sugar_phosphate_geometry","maxtorsion"),"float"); (("pdbx_sugar_phosphate_geometry","next_label_comp_id"),"ucode"); (("pdbx_sugar_phosphate_geometry","next_label_seq_id"),"int"); (("pdbx_sugar_phosphate_geometry","next_o3_p_o5_c5"),"float"); (("pdbx_sugar_phosphate_geometry","next_p_o5_c5_c4"),"float"); (("pdbx_sugar_phosphate_geometry","next_o5_c5_c4_c3"),"float"); (("pdbx_sugar_phosphate_geometry","next_c5_c4_c3_o3"),"float"); (("pdbx_sugar_phosphate_geometry","next_c4_c3_o3_p"),"float"); (("pdbx_sugar_phosphate_geometry","next_c3_o3_p_o5"),"float"); (("pdbx_sugar_phosphate_geometry","next_c4_o4_c1_n1_9"),"float"); (("pdbx_sugar_phosphate_geometry","next_o4_c1_n1_9_c2_4"),"float"); (("pdbx_sugar_phosphate_geometry","c1_c2"),"float"); (("pdbx_sugar_phosphate_geometry","c2_c3"),"float"); (("pdbx_sugar_phosphate_geometry","c3_c4"),"float"); (("pdbx_sugar_phosphate_geometry","c4_o4"),"float"); (("pdbx_sugar_phosphate_geometry","o4_c1"),"float"); (("pdbx_sugar_phosphate_geometry","p_o5"),"float"); (("pdbx_sugar_phosphate_geometry","o5_c5"),"float"); (("pdbx_sugar_phosphate_geometry","c5_c4"),"float"); (("pdbx_sugar_phosphate_geometry","c3_o3"),"float"); (("pdbx_sugar_phosphate_geometry","o3_p"),"float"); (("pdbx_sugar_phosphate_geometry","p_o1p"),"float"); (("pdbx_sugar_phosphate_geometry","p_o2p"),"float"); (("pdbx_sugar_phosphate_geometry","c1_n9_1"),"float"); (("pdbx_sugar_phosphate_geometry","n1_c2"),"float"); (("pdbx_sugar_phosphate_geometry","n1_c6"),"float"); (("pdbx_sugar_phosphate_geometry","n9_c4"),"float"); (("pdbx_sugar_phosphate_geometry","n9_c8"),"float"); (("pdbx_sugar_phosphate_geometry","c1_c2_c3"),"float"); (("pdbx_sugar_phosphate_geometry","c2_c3_c4"),"float"); (("pdbx_sugar_phosphate_geometry","c3_c4_o4"),"float"); (("pdbx_sugar_phosphate_geometry","c4_o4_c1"),"float"); (("pdbx_sugar_phosphate_geometry","o4_c1_c2"),"float"); (("pdbx_sugar_phosphate_geometry","p_o5_c5"),"float"); (("pdbx_sugar_phosphate_geometry","o5_c5_c4"),"float"); (("pdbx_sugar_phosphate_geometry","c5_c4_c3"),"float"); (("pdbx_sugar_phosphate_geometry","c4_c3_o3"),"float"); (("pdbx_sugar_phosphate_geometry","c3_o3_p"),"float"); (("pdbx_sugar_phosphate_geometry","o3_p_o5"),"float"); (("pdbx_sugar_phosphate_geometry","o4_c1_n1_9"),"float"); (("pdbx_sugar_phosphate_geometry","c1_n1_9_c2_4"),"float"); (("pdbx_sugar_phosphate_geometry","c5_c4_o4"),"float"); (("pdbx_sugar_phosphate_geometry","c2_c3_o3"),"float"); (("pdbx_sugar_phosphate_geometry","o1p_p_o2p"),"float"); (("pdbx_sugar_phosphate_geometry","c2_c1_n1_9"),"float"); (("pdbx_sugar_phosphate_geometry","c1_n1_9_c6_8"),"float"); 
    (("pdbx_nmr_computing","entry_id"),"code"); (("pdbx_nmr_computing","collection"),"line"); (("pdbx_nmr_computing","collection_version"),"code"); (("pdbx_nmr_computing","processing"),"line"); (("pdbx_nmr_computing","processing_version"),"code"); (("pdbx_nmr_computing","data_analysis"),"line"); (("pdbx_nmr_computing","data_analysis_version"),"code"); (("pdbx_nmr_computing","structure_solution"),"line"); (("pdbx_nmr_computing","structure_solution_version"),"code"); (("pdbx_nmr_computing","refinement"),"line"); (("pdbx_nmr_computing","refinement_version"),"code"); (("pdbx_nmr_computing","iterative_relaxation_matrix"),"line"); (("pdbx_nmr_computing","iterative_relaxation_matrix_version"),"code"); 
    (("pdbx_audit_conform_extension","extension_dict_location"),"text"); (("pdbx_audit_conform_extension","extension_dict_name"),"line"); (("pdbx_audit_conform_extension","extension_dict_version"),"line"); 
    (("pdbx_dcc_mapman","pdbid"),"code"); (("pdbx_dcc_mapman","details"),"text"); 
    (("pdbx_dcc_rscc_mapman","id"),"int"); (("pdbx_dcc_rscc_mapman","model_id"),"code"); (("pdbx_dcc_rscc_mapman","pdb_id"),"code"); (("pdbx_dcc_rscc_mapman","auth_asym_id"),"code"); (("pdbx_dcc_rscc_mapman","auth_comp_id"),"code"); (("pdbx_dcc_rscc_mapman","auth_seq_id"),"code"); (("pdbx_dcc_rscc_mapman","label_alt_id"),"code"); (("pdbx_dcc_rscc_mapman","label_ins_code"),"code"); (("pdbx_dcc_rscc_mapman","correlation"),"float"); (("pdbx_dcc_rscc_mapman","real_space_R"),"float"); (("pdbx_dcc_rscc_mapman","weighted_real_space_R"),"float"); (("pdbx_dcc_rscc_mapman","real_space_Zscore"),"float"); (("pdbx_dcc_rscc_mapman","Biso_mean"),"float"); (("pdbx_dcc_rscc_mapman","occupancy_mean"),"float"); (("pdbx_dcc_rscc_mapman","flag"),"line"); 
    (("pdbx_dcc_rscc_mapman_overall","pdbid"),"code"); (("pdbx_dcc_rscc_mapman_overall","correlation"),"float"); (("pdbx_dcc_rscc_mapman_overall","correlation_sigma"),"float"); (("pdbx_dcc_rscc_mapman_overall","real_space_R"),"float"); (("pdbx_dcc_rscc_mapman_overall","real_space_R_sigma"),"float"); 
    (("pdbx_dcc_density","DCC_version"),"line"); (("pdbx_dcc_density","pdbid"),"code"); (("pdbx_dcc_density","pdbtype"),"line"); (("pdbx_dcc_density","unit_cell"),"line"); (("pdbx_dcc_density","space_group_name_H-M"),"line"); (("pdbx_dcc_density","space_group_pointless"),"line"); (("pdbx_dcc_density","ls_d_res_high"),"float"); (("pdbx_dcc_density","ls_d_res_high_sf"),"float"); (("pdbx_dcc_density","ls_d_res_low_sf"),"float"); (("pdbx_dcc_density","R_value_R_work"),"float"); (("pdbx_dcc_density","R_value_R_free"),"float"); (("pdbx_dcc_density","working_set_count"),"int"); (("pdbx_dcc_density","free_set_count"),"int"); (("pdbx_dcc_density","occupancy_min"),"float"); (("pdbx_dcc_density","occupancy_max"),"float"); (("pdbx_dcc_density","occupancy_mean"),"float"); (("pdbx_dcc_density","Biso_min"),"float"); (("pdbx_dcc_density","Biso_max"),"float"); (("pdbx_dcc_density","Biso_mean"),"float"); (("pdbx_dcc_density","B_wilson"),"float"); (("pdbx_dcc_density","B_wilson_scale"),"float"); (("pdbx_dcc_density","mean_I2_over_mean_I_square"),"float"); (("pdbx_dcc_density","mean_F_square_over_mean_F2"),"float"); (("pdbx_dcc_density","mean_E2_1_abs"),"float"); (("pdbx_dcc_density","Padilla-Yeates_L_mean"),"float"); (("pdbx_dcc_density","Padilla-Yeates_L2_mean"),"float"); (("pdbx_dcc_density","Padilla-Yeates_L2_mean_pointless"),"float"); (("pdbx_dcc_density","Z_score_L_test"),"float"); (("pdbx_dcc_density","twin_type"),"line"); (("pdbx_dcc_density","twin_operator_xtriage"),"text"); (("pdbx_dcc_density","twin_fraction_xtriage"),"float"); (("pdbx_dcc_density","twin_Rfactor"),"float"); (("pdbx_dcc_density","I_over_sigI_resh"),"float"); (("pdbx_dcc_density","I_over_sigI_diff"),"float"); (("pdbx_dcc_density","I_over_sigI_mean"),"float"); (("pdbx_dcc_density","ice_ring"),"line"); (("pdbx_dcc_density","anisotropy"),"float"); (("pdbx_dcc_density","Z-score"),"float"); (("pdbx_dcc_density","prob_peak_value"),"float"); (("pdbx_dcc_density","translational_pseudo_symmetry"),"line"); (("pdbx_dcc_density","wavelength"),"float"); (("pdbx_dcc_density","B_solvent"),"float"); (("pdbx_dcc_density","K_solvent"),"float"); (("pdbx_dcc_density","TLS_refinement_reported"),"line"); (("pdbx_dcc_density","partial_B_value_correction_attempted"),"line"); (("pdbx_dcc_density","partial_B_value_correction_success"),"line"); (("pdbx_dcc_density","reflection_status_archived"),"line"); (("pdbx_dcc_density","reflection_status_used"),"line"); (("pdbx_dcc_density","iso_B_value_type"),"line"); (("pdbx_dcc_density","reflns_twin"),"line"); (("pdbx_dcc_density","twin_by_xtriage"),"line"); (("pdbx_dcc_density","twin_operator"),"line"); (("pdbx_dcc_density","twin_fraction"),"line"); (("pdbx_dcc_density","tls_group_number"),"int"); (("pdbx_dcc_density","ncs_group_number"),"int"); (("pdbx_dcc_density","mtrix_number"),"int"); (("pdbx_dcc_density","Matthew_coeff"),"float"); (("pdbx_dcc_density","solvent_content"),"float"); (("pdbx_dcc_density","Cruickshank_dpi_xyz"),"float"); (("pdbx_dcc_density","dpi_free_R"),"float"); (("pdbx_dcc_density","fom"),"float"); (("pdbx_dcc_density","correlation_overall"),"float"); (("pdbx_dcc_density","real_space_R_overall"),"float"); (("pdbx_dcc_density","mFo-DFc-3sigma_positive"),"int"); (("pdbx_dcc_density","mFo-DFc-6sigma_positive"),"int"); (("pdbx_dcc_density","mFo-DFc-3sigma_negative"),"int"); (("pdbx_dcc_density","mFo-DFc-6sigma_negative"),"int"); (("pdbx_dcc_density","Bmean-Bwilson"),"float"); (("pdbx_dcc_density","Rfree-Rwork"),"float"); (("pdbx_dcc_density","error"),"text"); 
    (("pdbx_dcc_geometry","pdbid"),"code"); (("pdbx_dcc_geometry","Ramachandran_outlier_percent"),"float"); (("pdbx_dcc_geometry","Ramachandran_outlier_number"),"int"); (("pdbx_dcc_geometry","Ramachandran_allowed_percent"),"float"); (("pdbx_dcc_geometry","Ramachandran_allowed_number"),"int"); (("pdbx_dcc_geometry","Ramachandran_favored_percent"),"float"); (("pdbx_dcc_geometry","Ramachandran_favored_number"),"int"); (("pdbx_dcc_geometry","rotamer_outliers_percent"),"float"); (("pdbx_dcc_geometry","rotamer_outliers_number"),"int"); (("pdbx_dcc_geometry","cbeta_deviations"),"int"); (("pdbx_dcc_geometry","all_atom_clashscore"),"float"); (("pdbx_dcc_geometry","overall_score"),"float"); (("pdbx_dcc_geometry","bond_overall_rms"),"float"); (("pdbx_dcc_geometry","bond_overall_max"),"float"); (("pdbx_dcc_geometry","bond_ligand_rms"),"float"); (("pdbx_dcc_geometry","bond_ligand_max"),"float"); (("pdbx_dcc_geometry","angle_overall_rms"),"float"); (("pdbx_dcc_geometry","angle_overall_max"),"float"); (("pdbx_dcc_geometry","angle_ligand_rms"),"float"); (("pdbx_dcc_geometry","angle_ligand_max"),"float"); (("pdbx_dcc_geometry","dihedral_overall_rms"),"float"); (("pdbx_dcc_geometry","dihedral_overall_max"),"float"); (("pdbx_dcc_geometry","chirality_overall_rms"),"float"); (("pdbx_dcc_geometry","chirality_overall_max"),"float"); (("pdbx_dcc_geometry","planarity_overall_rms"),"float"); (("pdbx_dcc_geometry","planarity_overall_max"),"float"); (("pdbx_dcc_geometry","non-bonded_rms"),"float"); 
    (("pdbx_dcc_density_corr","ordinal"),"int"); (("pdbx_dcc_density_corr","program"),"line"); (("pdbx_dcc_density_corr","ls_d_res_high"),"float"); (("pdbx_dcc_density_corr","ls_d_res_low"),"float"); (("pdbx_dcc_density_corr","ls_R_factor_R_all"),"float"); (("pdbx_dcc_density_corr","ls_R_factor_R_work"),"float"); (("pdbx_dcc_density_corr","ls_R_factor_R_free"),"float"); (("pdbx_dcc_density_corr","ls_number_reflns_obs"),"int"); (("pdbx_dcc_density_corr","ls_percent_reflns_obs"),"float"); (("pdbx_dcc_density_corr","ls_number_reflns_R_free"),"int"); (("pdbx_dcc_density_corr","correlation_coeff_Fo_to_Fc"),"float"); (("pdbx_dcc_density_corr","real_space_R"),"float"); (("pdbx_dcc_density_corr","correlation"),"float"); (("pdbx_dcc_density_corr","details"),"line"); 
    (("pdbx_dcc_map","id"),"int"); (("pdbx_dcc_map","model_id"),"code"); (("pdbx_dcc_map","pdb_id"),"code"); (("pdbx_dcc_map","auth_asym_id"),"code"); (("pdbx_dcc_map","auth_comp_id"),"code"); (("pdbx_dcc_map","auth_seq_id"),"code"); (("pdbx_dcc_map","label_alt_id"),"code"); (("pdbx_dcc_map","label_ins_code"),"code"); (("pdbx_dcc_map","RSCC"),"float"); (("pdbx_dcc_map","RSR"),"float"); (("pdbx_dcc_map","weighted_RSR"),"float"); (("pdbx_dcc_map","RSRZ"),"float"); (("pdbx_dcc_map","weighted_RSRZ"),"float"); (("pdbx_dcc_map","Biso_mean"),"float"); (("pdbx_dcc_map","occupancy_mean"),"float"); (("pdbx_dcc_map","RSCC_main_chain"),"float"); (("pdbx_dcc_map","RSR_main_chain"),"float"); (("pdbx_dcc_map","wRSR_main_chain"),"float"); (("pdbx_dcc_map","RSRZ_main_chain"),"float"); (("pdbx_dcc_map","wRSRZ_main_chain"),"float"); (("pdbx_dcc_map","Biso_mean_main_chain"),"float"); (("pdbx_dcc_map","occupancy_mean_main_chain"),"float"); (("pdbx_dcc_map","RSCC_side_chain"),"float"); (("pdbx_dcc_map","RSR_side_chain"),"float"); (("pdbx_dcc_map","wRSR_side_chain"),"float"); (("pdbx_dcc_map","RSRZ_side_chain"),"float"); (("pdbx_dcc_map","wRSRZ_side_chain"),"float"); (("pdbx_dcc_map","Biso_mean_side_chain"),"float"); (("pdbx_dcc_map","occupancy_mean_side_chain"),"float"); (("pdbx_dcc_map","RSCC_phosphate_group"),"float"); (("pdbx_dcc_map","RSR_phosphate_group"),"float"); (("pdbx_dcc_map","wRSR_phosphate_group"),"float"); (("pdbx_dcc_map","RSRZ_phosphate_group"),"float"); (("pdbx_dcc_map","wRSRZ_phosphate_group"),"float"); (("pdbx_dcc_map","Biso_mean_phosphate_group"),"float"); (("pdbx_dcc_map","occupancy_mean_phosphate_group"),"float"); (("pdbx_dcc_map","shift"),"float"); (("pdbx_dcc_map","shift_main_chain"),"float"); (("pdbx_dcc_map","shift_side_chain"),"float"); (("pdbx_dcc_map","density_connectivity"),"float"); (("pdbx_dcc_map","density_index_main_chain"),"float"); (("pdbx_dcc_map","density_index_side_chain"),"float"); (("pdbx_dcc_map","RSZD"),"float"); (("pdbx_dcc_map","RSZO"),"float"); (("pdbx_dcc_map","RSZO_Zscore"),"float"); (("pdbx_dcc_map","LLDF"),"float"); (("pdbx_dcc_map","RSZD_main_chain"),"float"); (("pdbx_dcc_map","RSZO_main_chain"),"float"); (("pdbx_dcc_map","RSZD_side_chain"),"float"); (("pdbx_dcc_map","RSZO_side_chain"),"float"); (("pdbx_dcc_map","RSZD_phosphate_group"),"float"); (("pdbx_dcc_map","RSZO_phosphate_group"),"float"); (("pdbx_dcc_map","quality_indicator"),"line"); 
    (("pdbx_deposit_group","group_id"),"code"); (("pdbx_deposit_group","group_title"),"text"); (("pdbx_deposit_group","group_description"),"text"); (("pdbx_deposit_group","group_type"),"text"); 
    (("pdbx_deposit_group_index","group_id"),"code"); (("pdbx_deposit_group_index","ordinal_id"),"int"); (("pdbx_deposit_group_index","dep_set_id"),"code"); (("pdbx_deposit_group_index","pdb_id_code"),"code"); (("pdbx_deposit_group_index","group_file_name"),"code"); (("pdbx_deposit_group_index","group_file_timestamp"),"yyyy-mm-dd:hh:mm"); (("pdbx_deposit_group_index","auth_file_label"),"line"); (("pdbx_deposit_group_index","auth_file_content_type"),"line"); (("pdbx_deposit_group_index","auth_file_format_type"),"code"); (("pdbx_deposit_group_index","auth_file_name"),"line"); (("pdbx_deposit_group_index","auth_file_size"),"int"); 
    (("pdbx_struct_assembly_auth_evidence","id"),"code"); (("pdbx_struct_assembly_auth_evidence","assembly_id"),"line"); (("pdbx_struct_assembly_auth_evidence","experimental_support"),"line"); (("pdbx_struct_assembly_auth_evidence","details"),"text"); 
    (("pdbx_struct_assembly_auth_classification","assembly_id"),"line"); (("pdbx_struct_assembly_auth_classification","reason_for_interest"),"line"); 
    (("pdbx_crystal_alignment","crystal_id"),"code"); (("pdbx_crystal_alignment","oscillation_range"),"float"); (("pdbx_crystal_alignment","oscillation_start"),"float"); (("pdbx_crystal_alignment","oscillation_end"),"float"); (("pdbx_crystal_alignment","xbeam"),"float"); (("pdbx_crystal_alignment","xbeam_esd"),"float"); (("pdbx_crystal_alignment","ybeam"),"float"); (("pdbx_crystal_alignment","ybeam_esd"),"float"); (("pdbx_crystal_alignment","crysx_spindle"),"float"); (("pdbx_crystal_alignment","crysx_spindle_esd"),"float"); (("pdbx_crystal_alignment","crysy_vertical"),"float"); (("pdbx_crystal_alignment","crysy_vertical_esd"),"float"); (("pdbx_crystal_alignment","crysz_beam"),"float"); (("pdbx_crystal_alignment","crysz_beam_esd"),"float"); (("pdbx_crystal_alignment","crystal_to_detector_distance"),"float"); (("pdbx_crystal_alignment","crystal_to_detector_distance_esd"),"float"); (("pdbx_crystal_alignment","crossfire_x"),"float"); (("pdbx_crystal_alignment","crossfire_x_esd"),"float"); (("pdbx_crystal_alignment","crossfire_y"),"float"); (("pdbx_crystal_alignment","crossfire_y_esd"),"float"); (("pdbx_crystal_alignment","crossfire_xy"),"float"); (("pdbx_crystal_alignment","crossfire_xy_esd"),"float"); 
    (("pdbx_audit_revision_history","ordinal"),"int"); (("pdbx_audit_revision_history","data_content_type"),"line"); (("pdbx_audit_revision_history","major_revision"),"int"); (("pdbx_audit_revision_history","minor_revision"),"int"); (("pdbx_audit_revision_history","revision_date"),"yyyy-mm-dd"); (("pdbx_audit_revision_history","internal_version"),"int"); (("pdbx_audit_revision_history","internal_deposition_id"),"code"); 
    (("pdbx_audit_revision_group","ordinal"),"int"); (("pdbx_audit_revision_group","revision_ordinal"),"int"); (("pdbx_audit_revision_group","data_content_type"),"line"); (("pdbx_audit_revision_group","group"),"line"); 
    (("pdbx_audit_revision_category","ordinal"),"int"); (("pdbx_audit_revision_category","revision_ordinal"),"int"); (("pdbx_audit_revision_category","data_content_type"),"line"); (("pdbx_audit_revision_category","category"),"code"); 
    (("pdbx_audit_revision_details","ordinal"),"int"); (("pdbx_audit_revision_details","revision_ordinal"),"int"); (("pdbx_audit_revision_details","data_content_type"),"line"); (("pdbx_audit_revision_details","provider"),"line"); (("pdbx_audit_revision_details","type"),"line"); (("pdbx_audit_revision_details","description"),"text"); 
    (("pdbx_audit_revision_item","ordinal"),"int"); (("pdbx_audit_revision_item","revision_ordinal"),"int"); (("pdbx_audit_revision_item","data_content_type"),"line"); (("pdbx_audit_revision_item","item"),"code"); 
    (("pdbx_supporting_exp_data_set","ordinal"),"int"); (("pdbx_supporting_exp_data_set","data_content_type"),"line"); (("pdbx_supporting_exp_data_set","data_version_major"),"int"); (("pdbx_supporting_exp_data_set","data_version_minor"),"int"); (("pdbx_supporting_exp_data_set","details"),"text"); 
    ];
    fun (cat,item) -> Hashtbl.find ht (cat,item)

  let item_is_pkey = 
    let ht = Hashtbl.create 100 in
    List.iter (fun k -> Hashtbl.add ht k ()) [
    ("jV_command","name"); 
    ("atom_site","id"); 
    ("atom_site_anisotrop","id"); 
    ("atom_sites","entry_id"); 
    ("atom_sites_alt","id"); 
    ("atom_sites_alt_ens","id"); 
    ("atom_sites_alt_gen","ens_id"); ("atom_sites_alt_gen","alt_id"); 
    ("atom_sites_footnote","id"); 
    ("atom_type","symbol"); 
    ("audit","revision_id"); 
    ("audit_author","pdbx_ordinal"); 
    ("audit_conform","dict_name"); ("audit_conform","dict_version"); 
    ("audit_contact_author","name"); 
    ("cell","entry_id"); 
    ("cell_measurement","entry_id"); 
    ("cell_measurement_refln","index_h"); ("cell_measurement_refln","index_k"); ("cell_measurement_refln","index_l"); 
    ("chem_comp","id"); 
    ("chem_comp_angle","comp_id"); ("chem_comp_angle","atom_id_1"); ("chem_comp_angle","atom_id_2"); ("chem_comp_angle","atom_id_3"); 
    ("chem_comp_atom","comp_id"); ("chem_comp_atom","atom_id"); 
    ("chem_comp_bond","comp_id"); ("chem_comp_bond","atom_id_1"); ("chem_comp_bond","atom_id_2"); 
    ("chem_comp_chir","comp_id"); ("chem_comp_chir","id"); 
    ("chem_comp_chir_atom","chir_id"); ("chem_comp_chir_atom","atom_id"); ("chem_comp_chir_atom","comp_id"); 
    ("chem_comp_link","link_id"); 
    ("chem_comp_plane","comp_id"); ("chem_comp_plane","id"); 
    ("chem_comp_plane_atom","plane_id"); ("chem_comp_plane_atom","atom_id"); ("chem_comp_plane_atom","comp_id"); 
    ("chem_comp_tor","comp_id"); ("chem_comp_tor","id"); 
    ("chem_comp_tor_value","tor_id"); ("chem_comp_tor_value","comp_id"); 
    ("chem_link","id"); 
    ("chem_link_angle","link_id"); ("chem_link_angle","atom_id_1"); ("chem_link_angle","atom_id_2"); ("chem_link_angle","atom_id_3"); 
    ("chem_link_bond","link_id"); ("chem_link_bond","atom_id_1"); ("chem_link_bond","atom_id_2"); 
    ("chem_link_chir","link_id"); ("chem_link_chir","id"); 
    ("chem_link_chir_atom","chir_id"); ("chem_link_chir_atom","atom_id"); 
    ("chem_link_plane","link_id"); ("chem_link_plane","id"); 
    ("chem_link_plane_atom","plane_id"); ("chem_link_plane_atom","atom_id"); 
    ("chem_link_tor","link_id"); ("chem_link_tor","id"); 
    ("chem_link_tor_value","tor_id"); 
    ("chemical","entry_id"); 
    ("chemical_conn_atom","number"); 
    ("chemical_conn_bond","atom_1"); ("chemical_conn_bond","atom_2"); 
    ("chemical_formula","entry_id"); 
    ("citation","id"); 
    ("citation_author","citation_id"); ("citation_author","name"); ("citation_author","ordinal"); 
    ("citation_editor","citation_id"); ("citation_editor","name"); 
    ("computing","entry_id"); 
    ("database","entry_id"); 
    ("database_2","database_id"); ("database_2","database_code"); 
    ("database_PDB_caveat","id"); 
    ("database_PDB_matrix","entry_id"); 
    ("database_PDB_remark","id"); 
    ("database_PDB_rev","num"); 
    ("database_PDB_rev_record","rev_num"); ("database_PDB_rev_record","type"); 
    ("database_PDB_tvect","id"); 
    ("diffrn","id"); 
    ("diffrn_attenuator","code"); 
    ("diffrn_detector","diffrn_id"); 
    ("diffrn_measurement","diffrn_id"); 
    ("diffrn_orient_matrix","diffrn_id"); 
    ("diffrn_orient_refln","diffrn_id"); ("diffrn_orient_refln","index_h"); ("diffrn_orient_refln","index_k"); ("diffrn_orient_refln","index_l"); 
    ("diffrn_radiation","diffrn_id"); 
    ("diffrn_radiation_wavelength","id"); 
    ("diffrn_refln","diffrn_id"); ("diffrn_refln","id"); 
    ("diffrn_reflns","diffrn_id"); 
    ("diffrn_scale_group","code"); 
    ("diffrn_source","diffrn_id"); 
    ("diffrn_standard_refln","diffrn_id"); ("diffrn_standard_refln","code"); 
    ("diffrn_standards","diffrn_id"); 
    ("entity","id"); 
    ("entity_keywords","entity_id"); 
    ("entity_link","link_id"); 
    ("entity_name_com","entity_id"); 
    ("entity_name_sys","entity_id"); 
    ("entity_poly","entity_id"); 
    ("entity_poly_seq","entity_id"); ("entity_poly_seq","num"); ("entity_poly_seq","mon_id"); 
    ("entry","id"); 
    ("entry_link","id"); ("entry_link","entry_id"); 
    ("exptl","entry_id"); ("exptl","method"); 
    ("exptl_crystal","id"); 
    ("exptl_crystal_face","crystal_id"); ("exptl_crystal_face","index_h"); ("exptl_crystal_face","index_k"); ("exptl_crystal_face","index_l"); 
    ("exptl_crystal_grow","crystal_id"); 
    ("exptl_crystal_grow_comp","id"); ("exptl_crystal_grow_comp","crystal_id"); 
    ("geom","entry_id"); 
    ("geom_angle","atom_site_id_1"); ("geom_angle","atom_site_id_2"); ("geom_angle","atom_site_id_3"); ("geom_angle","site_symmetry_1"); ("geom_angle","site_symmetry_2"); ("geom_angle","site_symmetry_3"); 
    ("geom_bond","atom_site_id_1"); ("geom_bond","atom_site_id_2"); ("geom_bond","site_symmetry_1"); ("geom_bond","site_symmetry_2"); 
    ("geom_contact","atom_site_id_1"); ("geom_contact","atom_site_id_2"); ("geom_contact","site_symmetry_1"); ("geom_contact","site_symmetry_2"); 
    ("geom_hbond","atom_site_id_A"); ("geom_hbond","atom_site_id_D"); ("geom_hbond","atom_site_id_H"); ("geom_hbond","site_symmetry_A"); ("geom_hbond","site_symmetry_D"); ("geom_hbond","site_symmetry_H"); 
    ("geom_torsion","atom_site_id_1"); ("geom_torsion","atom_site_id_2"); ("geom_torsion","atom_site_id_3"); ("geom_torsion","atom_site_id_4"); ("geom_torsion","site_symmetry_1"); ("geom_torsion","site_symmetry_2"); ("geom_torsion","site_symmetry_3"); ("geom_torsion","site_symmetry_4"); 
    ("journal","entry_id"); 
    ("journal_index","type"); ("journal_index","term"); 
    ("phasing","method"); 
    ("phasing_averaging","entry_id"); 
    ("phasing_isomorphous","entry_id"); 
    ("phasing_MAD","entry_id"); 
    ("phasing_MAD_clust","expt_id"); ("phasing_MAD_clust","id"); 
    ("phasing_MAD_expt","id"); 
    ("phasing_MAD_ratio","clust_id"); ("phasing_MAD_ratio","expt_id"); ("phasing_MAD_ratio","wavelength_1"); ("phasing_MAD_ratio","wavelength_2"); 
    ("phasing_MAD_set","expt_id"); ("phasing_MAD_set","clust_id"); ("phasing_MAD_set","set_id"); ("phasing_MAD_set","wavelength"); 
    ("phasing_MIR","entry_id"); 
    ("phasing_MIR_der","id"); 
    ("phasing_MIR_der_refln","index_h"); ("phasing_MIR_der_refln","index_k"); ("phasing_MIR_der_refln","index_l"); ("phasing_MIR_der_refln","der_id"); ("phasing_MIR_der_refln","set_id"); 
    ("phasing_MIR_der_shell","der_id"); ("phasing_MIR_der_shell","d_res_low"); ("phasing_MIR_der_shell","d_res_high"); 
    ("phasing_MIR_der_site","der_id"); ("phasing_MIR_der_site","id"); 
    ("phasing_MIR_shell","d_res_low"); ("phasing_MIR_shell","d_res_high"); 
    ("phasing_set","id"); 
    ("phasing_set_refln","index_h"); ("phasing_set_refln","index_k"); ("phasing_set_refln","index_l"); ("phasing_set_refln","set_id"); 
    ("publ","entry_id"); 
    ("publ_author","name"); 
    ("publ_body","element"); ("publ_body","label"); 
    ("publ_manuscript_incl","entry_id"); 
    ("refine","entry_id"); ("refine","pdbx_refine_id"); 
    ("refine_analyze","entry_id"); ("refine_analyze","pdbx_refine_id"); 
    ("refine_B_iso","class"); ("refine_B_iso","pdbx_refine_id"); 
    ("refine_funct_minimized","type"); ("refine_funct_minimized","pdbx_refine_id"); 
    ("refine_hist","cycle_id"); ("refine_hist","pdbx_refine_id"); 
    ("refine_ls_restr","type"); ("refine_ls_restr","pdbx_refine_id"); 
    ("refine_ls_restr_ncs","pdbx_ordinal"); 
    ("refine_ls_restr_type","type"); 
    ("refine_ls_shell","d_res_high"); ("refine_ls_shell","pdbx_refine_id"); 
    ("refine_occupancy","class"); ("refine_occupancy","pdbx_refine_id"); 
    ("refln","index_h"); ("refln","index_k"); ("refln","index_l"); 
    ("refln_sys_abs","index_h"); ("refln_sys_abs","index_k"); ("refln_sys_abs","index_l"); 
    ("reflns","pdbx_ordinal"); 
    ("reflns_scale","group_code"); 
    ("reflns_shell","pdbx_ordinal"); 
    ("software","pdbx_ordinal"); 
    ("struct","entry_id"); 
    ("struct_asym","id"); 
    ("struct_biol","id"); 
    ("struct_biol_gen","biol_id"); ("struct_biol_gen","asym_id"); ("struct_biol_gen","symmetry"); 
    ("struct_biol_keywords","biol_id"); ("struct_biol_keywords","text"); 
    ("struct_biol_view","biol_id"); ("struct_biol_view","id"); 
    ("struct_conf","id"); 
    ("struct_conf_type","id"); 
    ("struct_conn","id"); 
    ("struct_conn_type","id"); 
    ("struct_keywords","entry_id"); 
    ("struct_mon_details","entry_id"); 
    ("struct_mon_nucl","label_alt_id"); ("struct_mon_nucl","label_asym_id"); ("struct_mon_nucl","label_comp_id"); ("struct_mon_nucl","label_seq_id"); 
    ("struct_mon_prot","label_alt_id"); ("struct_mon_prot","label_asym_id"); ("struct_mon_prot","label_comp_id"); ("struct_mon_prot","label_seq_id"); 
    ("struct_mon_prot_cis","pdbx_id"); 
    ("struct_ncs_dom","id"); ("struct_ncs_dom","pdbx_ens_id"); 
    ("struct_ncs_dom_lim","dom_id"); ("struct_ncs_dom_lim","pdbx_ens_id"); ("struct_ncs_dom_lim","pdbx_component_id"); 
    ("struct_ncs_ens","id"); 
    ("struct_ncs_ens_gen","ens_id"); ("struct_ncs_ens_gen","dom_id_1"); ("struct_ncs_ens_gen","dom_id_2"); ("struct_ncs_ens_gen","oper_id"); 
    ("struct_ncs_oper","id"); 
    ("struct_ref","id"); 
    ("struct_ref_seq","align_id"); 
    ("struct_ref_seq_dif","pdbx_ordinal"); 
    ("struct_sheet","id"); 
    ("struct_sheet_hbond","sheet_id"); ("struct_sheet_hbond","range_id_1"); ("struct_sheet_hbond","range_id_2"); 
    ("struct_sheet_order","sheet_id"); ("struct_sheet_order","range_id_1"); ("struct_sheet_order","range_id_2"); 
    ("struct_sheet_range","sheet_id"); ("struct_sheet_range","id"); 
    ("struct_sheet_topology","sheet_id"); ("struct_sheet_topology","range_id_1"); ("struct_sheet_topology","range_id_2"); 
    ("struct_site","id"); 
    ("struct_site_gen","id"); ("struct_site_gen","site_id"); 
    ("struct_site_keywords","site_id"); ("struct_site_keywords","text"); 
    ("struct_site_view","id"); 
    ("symmetry","entry_id"); 
    ("symmetry_equiv","id"); 
    ("audit_link","block_code"); ("audit_link","block_description"); 
    ("diffrn_reflns_class","code"); 
    ("refine_ls_class","code"); 
    ("reflns_class","code"); 
    ("space_group","id"); 
    ("space_group_symop","id"); 
    ("valence_param","atom_1"); ("valence_param","atom_1_valence"); ("valence_param","atom_2"); ("valence_param","atom_2_valence"); 
    ("valence_ref","id"); 
    ("pdbx_audit","entry_id"); 
    ("pdbx_version","entry_id"); ("pdbx_version","major_version"); ("pdbx_version","minor_version"); ("pdbx_version","revision_type"); 
    ("pdbx_audit_author","ordinal"); 
    ("pdbx_database_message","message_id"); ("pdbx_database_message","entry_id"); 
    ("pdbx_database_PDB_obs_spr","pdb_id"); ("pdbx_database_PDB_obs_spr","replace_pdb_id"); 
    ("pdbx_database_proc","cycle_id"); ("pdbx_database_proc","entry_id"); 
    ("pdbx_database_remark","id"); 
    ("pdbx_database_status","entry_id"); 
    ("pdbx_entity_name","entity_id"); ("pdbx_entity_name","name"); ("pdbx_entity_name","name_type"); 
    ("pdbx_prerelease_seq","entity_id"); 
    ("pdbx_poly_seq_scheme","asym_id"); ("pdbx_poly_seq_scheme","entity_id"); ("pdbx_poly_seq_scheme","seq_id"); ("pdbx_poly_seq_scheme","mon_id"); 
    ("pdbx_nonpoly_scheme","asym_id"); ("pdbx_nonpoly_scheme","ndb_seq_num"); 
    ("pdbx_refine","entry_id"); ("pdbx_refine","pdbx_refine_id"); 
    ("pdbx_struct_sheet_hbond","sheet_id"); ("pdbx_struct_sheet_hbond","range_id_1"); ("pdbx_struct_sheet_hbond","range_id_2"); 
    ("pdbx_xplor_file","serial_no"); ("pdbx_xplor_file","pdbx_refine_id"); 
    ("pdbx_refine_aux_file","serial_no"); ("pdbx_refine_aux_file","pdbx_refine_id"); 
    ("pdbx_database_related","db_name"); ("pdbx_database_related","db_id"); ("pdbx_database_related","content_type"); 
    ("pdbx_entity_assembly","id"); ("pdbx_entity_assembly","entity_id"); 
    ("pdbx_exptl_crystal_grow_comp","comp_id"); ("pdbx_exptl_crystal_grow_comp","crystal_id"); 
    ("pdbx_exptl_crystal_grow_sol","sol_id"); ("pdbx_exptl_crystal_grow_sol","crystal_id"); 
    ("pdbx_exptl_crystal_cryo_treatment","crystal_id"); 
    ("pdbx_refine_tls","id"); 
    ("pdbx_refine_tls_group","id"); 
    ("pdbx_contact_author","id"); 
    ("pdbx_SG_project","id"); 
    ("pdbx_atom_site_aniso_tls","id"); ("pdbx_atom_site_aniso_tls","tls_group_id"); 
    ("pdbx_nmr_details","entry_id"); 
    ("pdbx_nmr_sample_details","solution_id"); 
    ("pdbx_nmr_exptl_sample","solution_id"); ("pdbx_nmr_exptl_sample","component"); 
    ("pdbx_nmr_exptl_sample_conditions","conditions_id"); 
    ("pdbx_nmr_spectrometer","spectrometer_id"); 
    ("pdbx_nmr_exptl","experiment_id"); ("pdbx_nmr_exptl","conditions_id"); ("pdbx_nmr_exptl","solution_id"); 
    ("pdbx_nmr_software","ordinal"); 
    ("pdbx_nmr_constraints","entry_id"); 
    ("pdbx_nmr_ensemble","entry_id"); 
    ("pdbx_nmr_ensemble_rms","entry_id"); 
    ("pdbx_nmr_representative","entry_id"); 
    ("pdbx_nmr_refine","entry_id"); ("pdbx_nmr_refine","software_ordinal"); 
    ("pdbx_nmr_force_constants","entry_id"); 
    ("ndb_struct_conf_na","entry_id"); ("ndb_struct_conf_na","feature"); 
    ("ndb_struct_feature_na","entry_id"); ("ndb_struct_feature_na","feature"); 
    ("ndb_struct_na_base_pair","model_number"); ("ndb_struct_na_base_pair","i_label_comp_id"); ("ndb_struct_na_base_pair","i_label_asym_id"); ("ndb_struct_na_base_pair","i_label_seq_id"); ("ndb_struct_na_base_pair","i_symmetry"); ("ndb_struct_na_base_pair","j_label_comp_id"); ("ndb_struct_na_base_pair","j_label_asym_id"); ("ndb_struct_na_base_pair","j_label_seq_id"); ("ndb_struct_na_base_pair","j_symmetry"); 
    ("ndb_struct_na_base_pair_step","model_number"); ("ndb_struct_na_base_pair_step","i_label_comp_id_1"); ("ndb_struct_na_base_pair_step","i_label_asym_id_1"); ("ndb_struct_na_base_pair_step","i_label_seq_id_1"); ("ndb_struct_na_base_pair_step","i_symmetry_1"); ("ndb_struct_na_base_pair_step","j_label_comp_id_1"); ("ndb_struct_na_base_pair_step","j_label_asym_id_1"); ("ndb_struct_na_base_pair_step","j_label_seq_id_1"); ("ndb_struct_na_base_pair_step","j_symmetry_1"); ("ndb_struct_na_base_pair_step","i_label_comp_id_2"); ("ndb_struct_na_base_pair_step","i_label_asym_id_2"); ("ndb_struct_na_base_pair_step","i_label_seq_id_2"); ("ndb_struct_na_base_pair_step","i_symmetry_2"); ("ndb_struct_na_base_pair_step","j_label_comp_id_2"); ("ndb_struct_na_base_pair_step","j_label_asym_id_2"); ("ndb_struct_na_base_pair_step","j_label_seq_id_2"); ("ndb_struct_na_base_pair_step","j_symmetry_2"); 
    ("ndb_original_ndb_coordinates","coord_section"); 
    ("pdbx_entity_nonpoly","entity_id"); 
    ("pdbx_phasing_dm","entry_id"); 
    ("pdbx_phasing_dm_shell","d_res_low"); ("pdbx_phasing_dm_shell","d_res_high"); 
    ("pdbx_phasing_MAD_shell","d_res_low"); ("pdbx_phasing_MAD_shell","d_res_high"); 
    ("pdbx_phasing_MAD_set","id"); 
    ("pdbx_phasing_MAD_set_shell","id"); ("pdbx_phasing_MAD_set_shell","d_res_low"); ("pdbx_phasing_MAD_set_shell","d_res_high"); 
    ("pdbx_phasing_MAD_set_site","id"); 
    ("pdbx_phasing_MR","entry_id"); 
    ("pdbx_refine_component","label_alt_id"); ("pdbx_refine_component","label_asym_id"); ("pdbx_refine_component","label_comp_id"); ("pdbx_refine_component","label_seq_id"); 
    ("pdbx_entity_prod_protocol","entry_id"); ("pdbx_entity_prod_protocol","entity_id"); ("pdbx_entity_prod_protocol","protocol_type"); 
    ("pdbx_entity_src_gen_prod_other","entry_id"); ("pdbx_entity_src_gen_prod_other","entity_id"); ("pdbx_entity_src_gen_prod_other","step_id"); 
    ("pdbx_entity_src_gen_prod_other_parameter","entry_id"); ("pdbx_entity_src_gen_prod_other_parameter","entity_id"); ("pdbx_entity_src_gen_prod_other_parameter","step_id"); ("pdbx_entity_src_gen_prod_other_parameter","parameter"); 
    ("pdbx_entity_src_gen_prod_pcr","entry_id"); ("pdbx_entity_src_gen_prod_pcr","entity_id"); ("pdbx_entity_src_gen_prod_pcr","step_id"); 
    ("pdbx_entity_src_gen_prod_digest","entry_id"); ("pdbx_entity_src_gen_prod_digest","entity_id"); ("pdbx_entity_src_gen_prod_digest","step_id"); 
    ("pdbx_entity_src_gen_clone","entry_id"); ("pdbx_entity_src_gen_clone","entity_id"); ("pdbx_entity_src_gen_clone","step_id"); 
    ("pdbx_entity_src_gen_clone_ligation","entry_id"); ("pdbx_entity_src_gen_clone_ligation","entity_id"); ("pdbx_entity_src_gen_clone_ligation","step_id"); 
    ("pdbx_entity_src_gen_clone_recombination","entry_id"); ("pdbx_entity_src_gen_clone_recombination","entity_id"); ("pdbx_entity_src_gen_clone_recombination","step_id"); 
    ("pdbx_entity_src_gen_express","entry_id"); ("pdbx_entity_src_gen_express","entity_id"); ("pdbx_entity_src_gen_express","step_id"); 
    ("pdbx_entity_src_gen_express_timepoint","entry_id"); ("pdbx_entity_src_gen_express_timepoint","entity_id"); ("pdbx_entity_src_gen_express_timepoint","step_id"); ("pdbx_entity_src_gen_express_timepoint","serial"); 
    ("pdbx_entity_src_gen_lysis","entry_id"); ("pdbx_entity_src_gen_lysis","entity_id"); ("pdbx_entity_src_gen_lysis","step_id"); 
    ("pdbx_entity_src_gen_refold","entry_id"); ("pdbx_entity_src_gen_refold","entity_id"); ("pdbx_entity_src_gen_refold","step_id"); 
    ("pdbx_entity_src_gen_proteolysis","entry_id"); ("pdbx_entity_src_gen_proteolysis","entity_id"); ("pdbx_entity_src_gen_proteolysis","step_id"); 
    ("pdbx_entity_src_gen_chrom","entry_id"); ("pdbx_entity_src_gen_chrom","entity_id"); ("pdbx_entity_src_gen_chrom","step_id"); 
    ("pdbx_entity_src_gen_fract","entry_id"); ("pdbx_entity_src_gen_fract","entity_id"); ("pdbx_entity_src_gen_fract","step_id"); 
    ("pdbx_entity_src_gen_pure","entry_id"); ("pdbx_entity_src_gen_pure","entity_id"); ("pdbx_entity_src_gen_pure","step_id"); 
    ("pdbx_entity_src_gen_character","entry_id"); ("pdbx_entity_src_gen_character","entity_id"); ("pdbx_entity_src_gen_character","step_id"); 
    ("pdbx_construct","id"); 
    ("pdbx_construct_feature","construct_id"); ("pdbx_construct_feature","id"); 
    ("pdbx_robot_system","id"); 
    ("pdbx_buffer","id"); 
    ("pdbx_buffer_components","buffer_id"); ("pdbx_buffer_components","id"); 
    ("pdbx_domain","id"); 
    ("pdbx_domain_range","domain_id"); ("pdbx_domain_range","beg_label_alt_id"); ("pdbx_domain_range","beg_label_asym_id"); ("pdbx_domain_range","beg_label_comp_id"); ("pdbx_domain_range","beg_label_seq_id"); ("pdbx_domain_range","end_label_alt_id"); ("pdbx_domain_range","end_label_asym_id"); ("pdbx_domain_range","end_label_comp_id"); ("pdbx_domain_range","end_label_seq_id"); 
    ("pdbx_sequence_range","seq_range_id"); ("pdbx_sequence_range","beg_label_alt_id"); ("pdbx_sequence_range","beg_label_asym_id"); ("pdbx_sequence_range","beg_label_comp_id"); ("pdbx_sequence_range","beg_label_seq_id"); ("pdbx_sequence_range","end_label_alt_id"); ("pdbx_sequence_range","end_label_asym_id"); ("pdbx_sequence_range","end_label_comp_id"); ("pdbx_sequence_range","end_label_seq_id"); 
    ("pdbx_feature_entry","id"); 
    ("pdbx_feature_domain","id"); 
    ("pdbx_feature_sequence_range","id"); 
    ("pdbx_feature_assembly","id"); 
    ("pdbx_feature_monomer","id"); 
    ("pdbx_exptl_pd","entry_id"); 
    ("pdbx_reflns_twin","crystal_id"); ("pdbx_reflns_twin","diffrn_id"); ("pdbx_reflns_twin","operator"); 
    ("pdbx_struct_info","type"); ("pdbx_struct_info","value"); 
    ("pdbx_re_refinement","entry_id"); 
    ("pdbx_struct_assembly_prop","type"); ("pdbx_struct_assembly_prop","biol_id"); 
    ("pdbx_struct_ref_seq_feature","feature_id"); 
    ("pdbx_struct_ref_seq_feature_prop","feature_id"); ("pdbx_struct_ref_seq_feature_prop","property_id"); 
    ("pdbx_struct_chem_comp_diagnostics","ordinal"); 
    ("pdbx_chem_comp_feature","comp_id"); ("pdbx_chem_comp_feature","type"); ("pdbx_chem_comp_feature","value"); ("pdbx_chem_comp_feature","source"); 
    ("pdbx_coordinate_model","asym_id"); 
    ("pdbx_struct_chem_comp_feature","ordinal"); 
    ("pdbx_diffrn_reflns_shell","d_res_high"); ("pdbx_diffrn_reflns_shell","d_res_low"); ("pdbx_diffrn_reflns_shell","diffrn_id"); 
    ("pdbx_bond_distance_limits","atom_type_1"); ("pdbx_bond_distance_limits","atom_type_2"); 
    ("pdbx_soln_scatter","entry_id"); ("pdbx_soln_scatter","id"); 
    ("pdbx_soln_scatter_model","id"); ("pdbx_soln_scatter_model","scatter_id"); 
    ("pdbx_chem_comp_descriptor","comp_id"); ("pdbx_chem_comp_descriptor","type"); ("pdbx_chem_comp_descriptor","program"); ("pdbx_chem_comp_descriptor","program_version"); 
    ("pdbx_chem_comp_identifier","comp_id"); ("pdbx_chem_comp_identifier","type"); ("pdbx_chem_comp_identifier","program"); ("pdbx_chem_comp_identifier","program_version"); 
    ("pdbx_chem_comp_import","comp_id"); 
    ("pdbx_chem_comp_atom_edit","ordinal"); 
    ("pdbx_chem_comp_bond_edit","comp_id"); ("pdbx_chem_comp_bond_edit","edit_op"); ("pdbx_chem_comp_bond_edit","atom_id_1"); ("pdbx_chem_comp_bond_edit","atom_id_2"); 
    ("pdbx_chem_comp_audit","comp_id"); ("pdbx_chem_comp_audit","date"); ("pdbx_chem_comp_audit","action_type"); 
    ("pdbx_validate_close_contact","id"); 
    ("pdbx_validate_symm_contact","id"); 
    ("pdbx_validate_rmsd_bond","id"); 
    ("pdbx_validate_rmsd_angle","id"); 
    ("pdbx_validate_torsion","id"); 
    ("pdbx_validate_peptide_omega","id"); 
    ("pdbx_validate_chiral","id"); 
    ("pdbx_validate_planes","id"); 
    ("pdbx_validate_planes_atom","id"); 
    ("pdbx_validate_main_chain_plane","id"); 
    ("pdbx_struct_conn_angle","id"); 
    ("pdbx_unobs_or_zero_occ_residues","id"); 
    ("pdbx_unobs_or_zero_occ_atoms","id"); 
    ("pdbx_entry_details","entry_id"); 
    ("pdbx_struct_mod_residue","id"); 
    ("pdbx_struct_ref_seq_insertion","id"); 
    ("pdbx_struct_ref_seq_deletion","id"); 
    ("pdbx_remediation_atom_site_mapping","id"); 
    ("pdbx_validate_polymer_linkage","id"); 
    ("pdbx_helical_symmetry","entry_id"); 
    ("pdbx_point_symmetry","entry_id"); 
    ("pdbx_struct_entity_inst","id"); 
    ("pdbx_struct_oper_list","id"); 
    ("pdbx_struct_assembly","id"); 
    ("pdbx_struct_assembly_gen","assembly_id"); ("pdbx_struct_assembly_gen","asym_id_list"); ("pdbx_struct_assembly_gen","oper_expression"); 
    ("pdbx_struct_asym_gen","entity_inst_id"); ("pdbx_struct_asym_gen","oper_expression"); 
    ("pdbx_struct_msym_gen","msym_id"); ("pdbx_struct_msym_gen","entity_inst_id"); ("pdbx_struct_msym_gen","oper_expression"); 
    ("pdbx_struct_legacy_oper_list","id"); 
    ("pdbx_chem_comp_atom_feature","comp_id"); ("pdbx_chem_comp_atom_feature","atom_id"); ("pdbx_chem_comp_atom_feature","feature_type"); 
    ("pdbx_reference_molecule_family","family_prd_id"); 
    ("pdbx_reference_molecule_list","family_prd_id"); ("pdbx_reference_molecule_list","prd_id"); 
    ("pdbx_reference_molecule","prd_id"); 
    ("pdbx_reference_entity_list","prd_id"); ("pdbx_reference_entity_list","ref_entity_id"); ("pdbx_reference_entity_list","component_id"); 
    ("pdbx_reference_entity_nonpoly","prd_id"); ("pdbx_reference_entity_nonpoly","ref_entity_id"); 
    ("pdbx_reference_entity_link","prd_id"); ("pdbx_reference_entity_link","link_id"); 
    ("pdbx_reference_entity_poly_link","prd_id"); ("pdbx_reference_entity_poly_link","ref_entity_id"); ("pdbx_reference_entity_poly_link","link_id"); ("pdbx_reference_entity_poly_link","component_id"); 
    ("pdbx_reference_entity_poly","prd_id"); ("pdbx_reference_entity_poly","ref_entity_id"); 
    ("pdbx_reference_entity_poly_seq","prd_id"); ("pdbx_reference_entity_poly_seq","ref_entity_id"); ("pdbx_reference_entity_poly_seq","num"); ("pdbx_reference_entity_poly_seq","mon_id"); ("pdbx_reference_entity_poly_seq","hetero"); 
    ("pdbx_reference_entity_sequence","prd_id"); ("pdbx_reference_entity_sequence","ref_entity_id"); 
    ("pdbx_reference_entity_src_nat","prd_id"); ("pdbx_reference_entity_src_nat","ref_entity_id"); ("pdbx_reference_entity_src_nat","ordinal"); 
    ("pdbx_reference_molecule_details","family_prd_id"); ("pdbx_reference_molecule_details","ordinal"); 
    ("pdbx_reference_molecule_synonyms","family_prd_id"); ("pdbx_reference_molecule_synonyms","prd_id"); ("pdbx_reference_molecule_synonyms","ordinal"); 
    ("pdbx_reference_entity_subcomponents","prd_id"); ("pdbx_reference_entity_subcomponents","seq"); 
    ("pdbx_reference_molecule_annotation","family_prd_id"); ("pdbx_reference_molecule_annotation","ordinal"); 
    ("pdbx_reference_molecule_features","family_prd_id"); ("pdbx_reference_molecule_features","prd_id"); ("pdbx_reference_molecule_features","ordinal"); 
    ("pdbx_reference_molecule_related_structures","family_prd_id"); ("pdbx_reference_molecule_related_structures","ordinal"); 
    ("pdbx_struct_group_list","struct_group_id"); 
    ("pdbx_struct_group_components","ordinal"); 
    ("pdbx_struct_group_component_range","ordinal"); 
    ("pdbx_prd_audit","prd_id"); ("pdbx_prd_audit","date"); ("pdbx_prd_audit","action_type"); 
    ("pdbx_family_prd_audit","family_prd_id"); ("pdbx_family_prd_audit","date"); ("pdbx_family_prd_audit","action_type"); 
    ("pdbx_molecule","prd_id"); ("pdbx_molecule","instance_id"); ("pdbx_molecule","asym_id"); 
    ("pdbx_molecule_features","prd_id"); 
    ("pdbx_family_group_index","id"); ("pdbx_family_group_index","family_prd_id"); 
    ("pdbx_distant_solvent_atoms","id"); 
    ("pdbx_struct_special_symmetry","id"); 
    ("pdbx_reference_publication_list","publication_abbrev"); 
    ("pdbx_nmr_assigned_chem_shift_list","entry_id"); ("pdbx_nmr_assigned_chem_shift_list","id"); 
    ("pdbx_nmr_chem_shift_experiment","experiment_id"); ("pdbx_nmr_chem_shift_experiment","entry_id"); ("pdbx_nmr_chem_shift_experiment","assigned_chem_shift_list_id"); 
    ("pdbx_nmr_chem_shift_ref","atom_type"); ("pdbx_nmr_chem_shift_ref","atom_isotope_number"); ("pdbx_nmr_chem_shift_ref","mol_common_name"); ("pdbx_nmr_chem_shift_ref","entry_id"); ("pdbx_nmr_chem_shift_ref","chem_shift_reference_id"); 
    ("pdbx_nmr_chem_shift_reference","entry_id"); ("pdbx_nmr_chem_shift_reference","id"); 
    ("pdbx_nmr_chem_shift_software","software_id"); ("pdbx_nmr_chem_shift_software","entry_id"); ("pdbx_nmr_chem_shift_software","assigned_chem_shift_list_id"); 
    ("pdbx_nmr_constraint_file","constraint_filename"); ("pdbx_nmr_constraint_file","constraint_type"); ("pdbx_nmr_constraint_file","constraint_subtype"); ("pdbx_nmr_constraint_file","entry_id"); 
    ("pdbx_nmr_software_task","entry_id"); ("pdbx_nmr_software_task","software_ordinal"); ("pdbx_nmr_software_task","task"); 
    ("pdbx_nmr_spectral_dim","id"); ("pdbx_nmr_spectral_dim","atom_type"); ("pdbx_nmr_spectral_dim","spectral_region"); ("pdbx_nmr_spectral_dim","entry_id"); ("pdbx_nmr_spectral_dim","spectral_peak_list_id"); 
    ("pdbx_nmr_spectral_peak_list","entry_id"); ("pdbx_nmr_spectral_peak_list","id"); 
    ("pdbx_nmr_spectral_peak_software","software_id"); ("pdbx_nmr_spectral_peak_software","entry_id"); ("pdbx_nmr_spectral_peak_software","spectral_peak_list_id"); 
    ("pdbx_nmr_systematic_chem_shift_offset","ordinal"); 
    ("pdbx_nmr_upload","entry_id"); ("pdbx_nmr_upload","data_file_id"); 
    ("pdbx_audit_support","ordinal"); 
    ("pdbx_chem_comp_subcomponent_struct_conn","id"); 
    ("pdbx_chem_comp_subcomponent_entity_list","id"); 
    ("entity_src_nat","entity_id"); ("entity_src_nat","pdbx_src_id"); 
    ("entity_src_gen","entity_id"); ("entity_src_gen","pdbx_src_id"); 
    ("pdbx_entity_src_syn","entity_id"); ("pdbx_entity_src_syn","pdbx_src_id"); 
    ("pdbx_entity_poly_comp_link_list","link_id"); 
    ("pdbx_linked_entity","linked_entity_id"); 
    ("pdbx_linked_entity_instance_list","linked_entity_id"); ("pdbx_linked_entity_instance_list","instance_id"); ("pdbx_linked_entity_instance_list","asym_id"); 
    ("pdbx_linked_entity_list","linked_entity_id"); ("pdbx_linked_entity_list","entity_id"); ("pdbx_linked_entity_list","component_id"); 
    ("pdbx_linked_entity_link_list","linked_entity_id"); ("pdbx_linked_entity_link_list","link_id"); 
    ("pdbx_entity_descriptor","ordinal"); 
    ("pdbx_reference_linked_entity","id"); 
    ("pdbx_reference_linked_entity_comp_list","linked_entity_id"); ("pdbx_reference_linked_entity_comp_list","list_id"); 
    ("pdbx_reference_linked_entity_comp_link","linked_entity_id"); ("pdbx_reference_linked_entity_comp_link","link_id"); 
    ("pdbx_reference_linked_entity_link","linked_entity_id"); ("pdbx_reference_linked_entity_link","link_id"); 
    ("pdbx_related_exp_data_set","ordinal"); 
    ("pdbx_database_status_history","ordinal"); ("pdbx_database_status_history","entry_id"); 
    ("em_assembly","id"); ("em_assembly","entry_id"); 
    ("em_entity_assembly","id"); 
    ("em_virus_entity","id"); ("em_virus_entity","entity_assembly_id"); 
    ("em_sample_preparation","id"); ("em_sample_preparation","entry_id"); 
    ("em_sample_support","id"); ("em_sample_support","specimen_id"); 
    ("em_buffer","id"); ("em_buffer","specimen_id"); 
    ("em_vitrification","id"); ("em_vitrification","specimen_id"); 
    ("em_imaging","entry_id"); ("em_imaging","id"); 
    ("em_detector","entry_id"); ("em_detector","id"); 
    ("em_image_scans","id"); ("em_image_scans","image_recording_id"); 
    ("em_2d_projection_selection","entry_id"); 
    ("em_3d_reconstruction","id"); ("em_3d_reconstruction","image_processing_id"); 
    ("em_3d_fitting","id"); ("em_3d_fitting","entry_id"); 
    ("em_3d_fitting_list","id"); ("em_3d_fitting_list","3d_fitting_id"); 
    ("em_helical_entity","id"); ("em_helical_entity","image_processing_id"); 
    ("em_experiment","entry_id"); 
    ("em_single_particle_entity","id"); ("em_single_particle_entity","image_processing_id"); 
    ("em_admin","entry_id"); 
    ("em_author_list","ordinal"); 
    ("em_db_reference","id"); 
    ("em_db_reference_auxiliary","id"); 
    ("em_depui","entry_id"); 
    ("em_obsolete","id"); 
    ("em_supersede","id"); 
    ("em_entity_assembly_molwt","entity_assembly_id"); ("em_entity_assembly_molwt","id"); 
    ("em_entity_assembly_naturalsource","id"); ("em_entity_assembly_naturalsource","entity_assembly_id"); 
    ("em_entity_assembly_recombinant","id"); ("em_entity_assembly_recombinant","entity_assembly_id"); 
    ("em_virus_natural_host","entity_assembly_id"); ("em_virus_natural_host","id"); 
    ("em_virus_shell","entity_assembly_id"); ("em_virus_shell","id"); 
    ("em_specimen","id"); ("em_specimen","experiment_id"); 
    ("em_embedding","id"); 
    ("em_fiducial_markers","id"); 
    ("em_focused_ion_beam","id"); 
    ("em_grid_pretreatment","id"); 
    ("em_ultramicrotomy","id"); 
    ("em_high_pressure_freezing","id"); 
    ("em_shadowing","id"); ("em_shadowing","specimen_id"); 
    ("em_tomography_specimen","id"); 
    ("em_crystal_formation","id"); 
    ("em_staining","id"); 
    ("em_support_film","id"); 
    ("em_buffer_component","id"); ("em_buffer_component","buffer_id"); 
    ("em_diffraction","id"); 
    ("em_diffraction_shell","id"); 
    ("em_diffraction_stats","id"); 
    ("em_tomography","id"); ("em_tomography","imaging_id"); 
    ("em_image_recording","id"); ("em_image_recording","imaging_id"); 
    ("em_imaging_optics","id"); ("em_imaging_optics","imaging_id"); 
    ("em_final_classification","id"); 
    ("em_start_model","id"); ("em_start_model","image_processing_id"); 
    ("em_software","id"); 
    ("em_euler_angle_assignment","id"); 
    ("em_ctf_correction","id"); 
    ("em_volume_selection","id"); ("em_volume_selection","image_processing_id"); 
    ("em_3d_crystal_entity","id"); ("em_3d_crystal_entity","image_processing_id"); 
    ("em_2d_crystal_entity","id"); ("em_2d_crystal_entity","image_processing_id"); 
    ("em_image_processing","image_recording_id"); ("em_image_processing","id"); 
    ("em_particle_selection","id"); ("em_particle_selection","image_processing_id"); 
    ("em_map","id"); ("em_map","entry_id"); 
    ("em_fsc_curve","id"); 
    ("em_interpret_figure","id"); 
    ("em_layer_lines","id"); ("em_layer_lines","experiment_id"); 
    ("em_structure_factors","id"); ("em_structure_factors","experiment_id"); 
    ("em_depositor_info","entry_id"); 
    ("em_map_depositor_info","entry_id"); ("em_map_depositor_info","id"); 
    ("em_mask_depositor_info","id"); 
    ("em_figure_depositor_info","id"); 
    ("em_layer_lines_depositor_info","id"); 
    ("em_structure_factors_depositor_info","id"); 
    ("pdbx_seq_map_depositor_info","entity_id"); ("pdbx_seq_map_depositor_info","auth_asym_id"); 
    ("pdbx_chem_comp_depositor_info","ordinal"); 
    ("pdbx_struct_ref_seq_depositor_info","ref_id"); 
    ("pdbx_struct_ref_seq_dif_depositor_info","ordinal"); 
    ("pdbx_struct_assembly_prop_depositor_info","type"); ("pdbx_struct_assembly_prop_depositor_info","biol_id"); 
    ("pdbx_struct_assembly_depositor_info","id"); 
    ("pdbx_struct_assembly_gen_depositor_info","id"); 
    ("pdbx_struct_oper_list_depositor_info","id"); 
    ("pdbx_point_symmetry_depositor_info","entry_id"); 
    ("pdbx_helical_symmetry_depositor_info","entry_id"); 
    ("pdbx_struct_assembly_auth_evidence_depositor_info","id"); ("pdbx_struct_assembly_auth_evidence_depositor_info","assembly_id"); 
    ("pdbx_solvent_atom_site_mapping","id"); 
    ("pdbx_molecule_features_depositor_info","entity_id"); 
    ("pdbx_chem_comp_instance_depositor_info","ordinal"); 
    ("pdbx_depui_status_flags","dep_dataset_id"); 
    ("pdbx_depui_upload","ordinal"); 
    ("pdbx_depui_validation_status_flags","dep_dataset_id"); 
    ("pdbx_chem_comp_upload_depositor_info","ordinal"); 
    ("pdbx_depui_entity_status_flags","dep_dataset_id"); ("pdbx_depui_entity_status_flags","entity_id"); 
    ("pdbx_depui_entity_features","dep_dataset_id"); ("pdbx_depui_entity_features","entity_id"); ("pdbx_depui_entity_features","type"); 
    ("pdbx_deposition_message_info","ordinal"); 
    ("pdbx_deposition_message_file_reference","ordinal"); 
    ("pdbx_depui_entry_details","dep_dataset_id"); 
    ("pdbx_data_processing_status","task_name"); ("pdbx_data_processing_status","status"); 
    ("pdbx_entity_instance_feature","ordinal"); 
    ("pdbx_entity_src_gen_depositor_info","src_id"); 
    ("pdbx_chem_comp_model","id"); 
    ("pdbx_chem_comp_model_atom","model_id"); ("pdbx_chem_comp_model_atom","atom_id"); 
    ("pdbx_chem_comp_model_bond","model_id"); ("pdbx_chem_comp_model_bond","atom_id_1"); ("pdbx_chem_comp_model_bond","atom_id_2"); 
    ("pdbx_chem_comp_model_feature","model_id"); ("pdbx_chem_comp_model_feature","feature_name"); 
    ("pdbx_chem_comp_model_descriptor","model_id"); ("pdbx_chem_comp_model_descriptor","type"); 
    ("pdbx_chem_comp_model_audit","model_id"); ("pdbx_chem_comp_model_audit","date"); ("pdbx_chem_comp_model_audit","action_type"); 
    ("pdbx_chem_comp_model_reference","model_id"); ("pdbx_chem_comp_model_reference","db_name"); ("pdbx_chem_comp_model_reference","db_code"); 
    ("pdbx_view_category_group","view_group_id"); 
    ("pdbx_view_category","category_id"); 
    ("pdbx_view_item","item_name"); 
    ("pdbx_coord","entry_id"); 
    ("pdbx_connect","res_name"); 
    ("pdbx_connect_type","res_name"); 
    ("pdbx_connect_modification","res_name"); 
    ("pdbx_connect_atom","res_name"); ("pdbx_connect_atom","atom_name"); ("pdbx_connect_atom","connect_to"); 
    ("pdbx_database_PDB_master","entry_id"); 
    ("pdbx_database_pdb_omit","entry_id"); ("pdbx_database_pdb_omit","record_name"); 
    ("pdbx_dbref","pdb_id_code"); ("pdbx_dbref","chain_id"); ("pdbx_dbref","begin_res_number"); ("pdbx_dbref","end_res_number"); ("pdbx_dbref","database_name"); 
    ("pdbx_drug_info","id"); ("pdbx_drug_info","name"); 
    ("pdbx_inhibitor_info","id"); 
    ("pdbx_ion_info","id"); 
    ("pdbx_hybrid","id"); 
    ("pdbx_na_strand_info","id"); 
    ("pdbx_nonstandard_list","id"); ("pdbx_nonstandard_list","label_asym_id"); ("pdbx_nonstandard_list","label_seq_id"); 
    ("pdbx_pdb_compnd","id"); 
    ("pdbx_pdb_source","id"); 
    ("pdbx_protein_info","id"); 
    ("pdbx_solvent_info","id"); 
    ("pdbx_source","src_method"); 
    ("pdbx_struct_biol_func","id"); ("pdbx_struct_biol_func","biol_id"); 
    ("pdbx_struct_pack_gen","id"); ("pdbx_struct_pack_gen","asym_id"); ("pdbx_struct_pack_gen","symmetry"); 
    ("pdbx_trna_info","id"); 
    ("pdbx_unpair","chain_id"); 
    ("pdbx_refine_ls_restr_ncs","dom_id"); 
    ("pdbx_struct_ncs_virus_gen","id"); 
    ("pdbx_sequence_annotation","pdb_chain_id"); 
    ("pdbx_chem_comp_synonyms","name"); ("pdbx_chem_comp_synonyms","synonym"); 
    ("pdbx_post_process_details","entry_id"); 
    ("pdbx_post_process_status","entry_id"); ("pdbx_post_process_status","cycle_id"); 
    ("pdbx_struct_link","id"); 
    ("pdbx_missing_residue_list","pdb_chain_id"); ("pdbx_missing_residue_list","pdb_residue_name"); ("pdbx_missing_residue_list","pdb_residue_number"); 
    ("pdbx_data_processing_cell","entry_id"); 
    ("pdbx_data_processing_reflns","entry_id"); 
    ("pdbx_data_processing_detector","entry_id"); 
    ("pdbx_chem_comp_nonstandard","comp_id"); ("pdbx_chem_comp_nonstandard","type"); 
    ("pdbx_entity_poly_protein_class","entity_id"); ("pdbx_entity_poly_protein_class","class"); 
    ("pdbx_entity_name_taxonomy_tree","id"); ("pdbx_entity_name_taxonomy_tree","parent_id"); 
    ("pdbx_entity_name_taxonomy","id"); ("pdbx_entity_name_taxonomy","name"); 
    ("pdbx_entity_name_instance","pdb_id"); ("pdbx_entity_name_instance","name"); ("pdbx_entity_name_instance","entity_id"); 
    ("pdbx_tableinfo","tablename"); 
    ("pdbx_columninfo","tablename"); ("pdbx_columninfo","columnname"); 
    ("pdbx_val_angle","id"); 
    ("pdbx_val_bond","id"); 
    ("pdbx_val_contact","id"); 
    ("pdbx_val_sym_contact","id"); 
    ("pdbx_rmch_outlier","id"); 
    ("pdbx_missing_atom_poly","id"); 
    ("pdbx_missing_atom_nonpoly","id"); 
    ("pdbx_val_chiral","id"); 
    ("pdbx_atlas","entry_id"); ("pdbx_atlas","page_id"); 
    ("pdbx_summary_flags","entry_id"); ("pdbx_summary_flags","flag_id"); 
    ("pdbx_entity_func_bind_mode","id"); ("pdbx_entity_func_bind_mode","domain_id"); ("pdbx_entity_func_bind_mode","entity_id"); 
    ("pdbx_entity_func_enzyme","bind_mode_id"); 
    ("pdbx_entity_func_regulatory","bind_mode_id"); 
    ("pdbx_entity_func_structural","bind_mode_id"); 
    ("pdbx_entity_func_other","bind_mode_id"); 
    ("pdbx_entity_poly_domain","entity_id"); ("pdbx_entity_poly_domain","id"); 
    ("pdbx_na_struct_keywds","entry_id"); 
    ("pdbx_entity_poly_na_type","entity_id"); ("pdbx_entity_poly_na_type","type"); 
    ("pdbx_entity_poly_na_nonstandard","entity_id"); ("pdbx_entity_poly_na_nonstandard","feature"); 
    ("pdbx_virtual_angle","atom_site_id_1"); ("pdbx_virtual_angle","atom_site_id_2"); ("pdbx_virtual_angle","atom_site_id_3"); ("pdbx_virtual_angle","model_id"); ("pdbx_virtual_angle","site_symmetry_1"); ("pdbx_virtual_angle","site_symmetry_2"); ("pdbx_virtual_angle","site_symmetry_3"); 
    ("pdbx_virtual_bond","atom_site_id_1"); ("pdbx_virtual_bond","atom_site_id_2"); ("pdbx_virtual_bond","model_id"); ("pdbx_virtual_bond","site_symmetry_1"); ("pdbx_virtual_bond","site_symmetry_2"); 
    ("pdbx_virtual_torsion","atom_site_id_1"); ("pdbx_virtual_torsion","atom_site_id_2"); ("pdbx_virtual_torsion","atom_site_id_3"); ("pdbx_virtual_torsion","atom_site_id_4"); ("pdbx_virtual_torsion","model_id"); ("pdbx_virtual_torsion","site_symmetry_1"); ("pdbx_virtual_torsion","site_symmetry_2"); ("pdbx_virtual_torsion","site_symmetry_3"); ("pdbx_virtual_torsion","site_symmetry_4"); 
    ("pdbx_sequence_pattern","label_asym_id"); ("pdbx_sequence_pattern","sequence_pattern"); 
    ("pdbx_stereochemistry","id"); 
    ("pdbx_rms_devs_covalent","entry_id"); 
    ("pdbx_rms_devs_cov_by_monomer","id"); 
    ("pdbx_sugar_phosphate_geometry","id"); 
    ("pdbx_nmr_computing","entry_id"); 
    ("pdbx_audit_conform_extension","extension_dict_name"); ("pdbx_audit_conform_extension","extension_dict_version"); 
    ("pdbx_dcc_mapman","pdbid"); 
    ("pdbx_dcc_rscc_mapman","id"); 
    ("pdbx_dcc_rscc_mapman_overall","pdbid"); 
    ("pdbx_dcc_density","pdbid"); 
    ("pdbx_dcc_geometry","pdbid"); 
    ("pdbx_dcc_density_corr","ordinal"); 
    ("pdbx_dcc_map","id"); 
    ("pdbx_deposit_group","group_id"); 
    ("pdbx_deposit_group_index","group_id"); ("pdbx_deposit_group_index","ordinal_id"); 
    ("pdbx_struct_assembly_auth_evidence","id"); ("pdbx_struct_assembly_auth_evidence","assembly_id"); 
    ("pdbx_struct_assembly_auth_classification","assembly_id"); 
    ("pdbx_crystal_alignment","crystal_id"); 
    ("pdbx_audit_revision_history","ordinal"); ("pdbx_audit_revision_history","data_content_type"); 
    ("pdbx_audit_revision_group","ordinal"); ("pdbx_audit_revision_group","revision_ordinal"); ("pdbx_audit_revision_group","data_content_type"); 
    ("pdbx_audit_revision_category","ordinal"); ("pdbx_audit_revision_category","revision_ordinal"); ("pdbx_audit_revision_category","data_content_type"); 
    ("pdbx_audit_revision_details","ordinal"); ("pdbx_audit_revision_details","revision_ordinal"); ("pdbx_audit_revision_details","data_content_type"); 
    ("pdbx_audit_revision_item","ordinal"); ("pdbx_audit_revision_item","revision_ordinal"); ("pdbx_audit_revision_item","data_content_type"); 
    ("pdbx_supporting_exp_data_set","ordinal"); 
    ];
    fun s -> Hashtbl.mem ht s

  let item_is_mandatory =
    let ht = Hashtbl.create 100 in
    List.iter (fun k -> Hashtbl.add ht k ()) [
    ("jV_command","name"); 
    ("atom_site","auth_asym_id"); ("atom_site","id"); ("atom_site","label_alt_id"); ("atom_site","label_asym_id"); ("atom_site","label_atom_id"); ("atom_site","label_comp_id"); ("atom_site","label_entity_id"); ("atom_site","label_seq_id"); ("atom_site","type_symbol"); 
    ("atom_site_anisotrop","id"); ("atom_site_anisotrop","type_symbol"); 
    ("atom_sites","entry_id"); 
    ("atom_sites_alt","id"); 
    ("atom_sites_alt_ens","id"); 
    ("atom_sites_alt_gen","alt_id"); ("atom_sites_alt_gen","ens_id"); 
    ("atom_sites_footnote","id"); 
    ("atom_type","symbol"); 
    ("audit","revision_id"); 
    ("audit_author","name"); ("audit_author","pdbx_ordinal"); 
    ("audit_conform","dict_name"); ("audit_conform","dict_version"); 
    ("audit_contact_author","name"); 
    ("cell","entry_id"); 
    ("cell_measurement","entry_id"); 
    ("cell_measurement_refln","index_h"); ("cell_measurement_refln","index_k"); ("cell_measurement_refln","index_l"); 
    ("chem_comp","id"); ("chem_comp","type"); 
    ("chem_comp_angle","atom_id_1"); ("chem_comp_angle","atom_id_2"); ("chem_comp_angle","atom_id_3"); ("chem_comp_angle","comp_id"); 
    ("chem_comp_atom","atom_id"); ("chem_comp_atom","comp_id"); ("chem_comp_atom","type_symbol"); 
    ("chem_comp_bond","atom_id_1"); ("chem_comp_bond","atom_id_2"); ("chem_comp_bond","comp_id"); 
    ("chem_comp_chir","atom_id"); ("chem_comp_chir","id"); ("chem_comp_chir","comp_id"); 
    ("chem_comp_chir_atom","atom_id"); ("chem_comp_chir_atom","chir_id"); ("chem_comp_chir_atom","comp_id"); 
    ("chem_comp_link","link_id"); ("chem_comp_link","type_comp_1"); ("chem_comp_link","type_comp_2"); 
    ("chem_comp_plane","id"); ("chem_comp_plane","comp_id"); 
    ("chem_comp_plane_atom","atom_id"); ("chem_comp_plane_atom","comp_id"); ("chem_comp_plane_atom","plane_id"); 
    ("chem_comp_tor","atom_id_1"); ("chem_comp_tor","atom_id_2"); ("chem_comp_tor","atom_id_3"); ("chem_comp_tor","atom_id_4"); ("chem_comp_tor","id"); ("chem_comp_tor","comp_id"); 
    ("chem_comp_tor_value","comp_id"); ("chem_comp_tor_value","tor_id"); ("chem_comp_tor_value","angle"); ("chem_comp_tor_value","angle_esd"); 
    ("chem_link","id"); 
    ("chem_link_angle","atom_id_1"); ("chem_link_angle","atom_id_2"); ("chem_link_angle","atom_id_3"); ("chem_link_angle","link_id"); 
    ("chem_link_bond","atom_id_1"); ("chem_link_bond","atom_id_2"); ("chem_link_bond","link_id"); 
    ("chem_link_chir","atom_id"); ("chem_link_chir","id"); ("chem_link_chir","link_id"); 
    ("chem_link_chir_atom","atom_id"); ("chem_link_chir_atom","chir_id"); 
    ("chem_link_plane","id"); ("chem_link_plane","link_id"); 
    ("chem_link_plane_atom","atom_id"); ("chem_link_plane_atom","plane_id"); 
    ("chem_link_tor","atom_id_1"); ("chem_link_tor","atom_id_2"); ("chem_link_tor","atom_id_3"); ("chem_link_tor","atom_id_4"); ("chem_link_tor","id"); ("chem_link_tor","link_id"); 
    ("chem_link_tor_value","tor_id"); ("chem_link_tor_value","angle"); ("chem_link_tor_value","angle_esd"); 
    ("chemical","entry_id"); 
    ("chemical_conn_atom","number"); ("chemical_conn_atom","type_symbol"); 
    ("chemical_conn_bond","atom_1"); ("chemical_conn_bond","atom_2"); 
    ("chemical_formula","entry_id"); 
    ("citation","id"); 
    ("citation_author","citation_id"); ("citation_author","name"); ("citation_author","ordinal"); 
    ("citation_editor","citation_id"); ("citation_editor","name"); 
    ("computing","entry_id"); 
    ("database","entry_id"); 
    ("database_2","database_id"); ("database_2","database_code"); 
    ("database_PDB_caveat","id"); 
    ("database_PDB_matrix","entry_id"); 
    ("database_PDB_remark","id"); 
    ("database_PDB_rev","num"); 
    ("database_PDB_rev_record","rev_num"); ("database_PDB_rev_record","type"); 
    ("database_PDB_tvect","id"); 
    ("diffrn","crystal_id"); ("diffrn","id"); 
    ("diffrn_attenuator","code"); 
    ("diffrn_detector","diffrn_id"); 
    ("diffrn_measurement","diffrn_id"); 
    ("diffrn_orient_matrix","diffrn_id"); 
    ("diffrn_orient_refln","diffrn_id"); ("diffrn_orient_refln","index_h"); ("diffrn_orient_refln","index_k"); ("diffrn_orient_refln","index_l"); 
    ("diffrn_radiation","diffrn_id"); 
    ("diffrn_radiation_wavelength","id"); ("diffrn_radiation_wavelength","wavelength"); 
    ("diffrn_refln","diffrn_id"); ("diffrn_refln","id"); ("diffrn_refln","index_h"); ("diffrn_refln","index_k"); ("diffrn_refln","index_l"); ("diffrn_refln","scale_group_code"); ("diffrn_refln","standard_code"); 
    ("diffrn_reflns","diffrn_id"); 
    ("diffrn_scale_group","code"); 
    ("diffrn_source","diffrn_id"); 
    ("diffrn_standard_refln","code"); ("diffrn_standard_refln","diffrn_id"); ("diffrn_standard_refln","index_h"); ("diffrn_standard_refln","index_k"); ("diffrn_standard_refln","index_l"); 
    ("diffrn_standards","diffrn_id"); 
    ("entity","id"); 
    ("entity_keywords","entity_id"); 
    ("entity_link","link_id"); ("entity_link","entity_id_1"); ("entity_link","entity_id_2"); 
    ("entity_name_com","entity_id"); 
    ("entity_name_sys","entity_id"); 
    ("entity_poly","entity_id"); 
    ("entity_poly_seq","entity_id"); ("entity_poly_seq","mon_id"); ("entity_poly_seq","num"); 
    ("entry","id"); 
    ("entry_link","entry_id"); ("entry_link","id"); 
    ("exptl","entry_id"); ("exptl","method"); 
    ("exptl_crystal","id"); 
    ("exptl_crystal_face","crystal_id"); ("exptl_crystal_face","index_h"); ("exptl_crystal_face","index_k"); ("exptl_crystal_face","index_l"); 
    ("exptl_crystal_grow","crystal_id"); 
    ("exptl_crystal_grow_comp","crystal_id"); ("exptl_crystal_grow_comp","id"); 
    ("geom","entry_id"); 
    ("geom_angle","atom_site_id_1"); ("geom_angle","atom_site_id_2"); ("geom_angle","atom_site_id_3"); ("geom_angle","site_symmetry_1"); ("geom_angle","site_symmetry_2"); ("geom_angle","site_symmetry_3"); 
    ("geom_bond","atom_site_id_1"); ("geom_bond","atom_site_id_2"); ("geom_bond","site_symmetry_1"); ("geom_bond","site_symmetry_2"); 
    ("geom_contact","atom_site_id_1"); ("geom_contact","atom_site_id_2"); ("geom_contact","site_symmetry_1"); ("geom_contact","site_symmetry_2"); 
    ("geom_hbond","atom_site_id_A"); ("geom_hbond","atom_site_id_D"); ("geom_hbond","atom_site_id_H"); ("geom_hbond","site_symmetry_A"); ("geom_hbond","site_symmetry_D"); ("geom_hbond","site_symmetry_H"); 
    ("geom_torsion","atom_site_id_1"); ("geom_torsion","atom_site_id_2"); ("geom_torsion","atom_site_id_3"); ("geom_torsion","atom_site_id_4"); ("geom_torsion","site_symmetry_1"); ("geom_torsion","site_symmetry_2"); ("geom_torsion","site_symmetry_3"); ("geom_torsion","site_symmetry_4"); 
    ("journal","entry_id"); 
    ("journal_index","term"); ("journal_index","type"); 
    ("phasing","method"); 
    ("phasing_averaging","entry_id"); 
    ("phasing_isomorphous","entry_id"); 
    ("phasing_MAD","entry_id"); 
    ("phasing_MAD_clust","expt_id"); ("phasing_MAD_clust","id"); 
    ("phasing_MAD_expt","id"); 
    ("phasing_MAD_ratio","expt_id"); ("phasing_MAD_ratio","clust_id"); ("phasing_MAD_ratio","wavelength_1"); ("phasing_MAD_ratio","wavelength_2"); 
    ("phasing_MAD_set","clust_id"); ("phasing_MAD_set","expt_id"); ("phasing_MAD_set","set_id"); ("phasing_MAD_set","wavelength"); 
    ("phasing_MIR","d_res_high"); ("phasing_MIR","d_res_low"); ("phasing_MIR","entry_id"); 
    ("phasing_MIR_der","d_res_high"); ("phasing_MIR_der","d_res_low"); ("phasing_MIR_der","der_set_id"); ("phasing_MIR_der","id"); ("phasing_MIR_der","native_set_id"); 
    ("phasing_MIR_der_refln","der_id"); ("phasing_MIR_der_refln","index_h"); ("phasing_MIR_der_refln","index_k"); ("phasing_MIR_der_refln","index_l"); ("phasing_MIR_der_refln","set_id"); 
    ("phasing_MIR_der_shell","d_res_high"); ("phasing_MIR_der_shell","d_res_low"); ("phasing_MIR_der_shell","der_id"); 
    ("phasing_MIR_der_site","atom_type_symbol"); ("phasing_MIR_der_site","der_id"); ("phasing_MIR_der_site","id"); 
    ("phasing_MIR_shell","d_res_high"); ("phasing_MIR_shell","d_res_low"); 
    ("phasing_set","id"); ("phasing_set","pdbx_d_res_high"); ("phasing_set","pdbx_d_res_low"); 
    ("phasing_set_refln","set_id"); ("phasing_set_refln","index_h"); ("phasing_set_refln","index_k"); ("phasing_set_refln","index_l"); 
    ("publ","entry_id"); 
    ("publ_author","name"); 
    ("publ_body","element"); ("publ_body","label"); 
    ("publ_manuscript_incl","entry_id"); 
    ("refine","entry_id"); ("refine","pdbx_refine_id"); ("refine","ls_d_res_high"); 
    ("refine_analyze","entry_id"); ("refine_analyze","pdbx_refine_id"); 
    ("refine_B_iso","pdbx_refine_id"); ("refine_B_iso","class"); 
    ("refine_funct_minimized","pdbx_refine_id"); ("refine_funct_minimized","type"); 
    ("refine_hist","pdbx_refine_id"); ("refine_hist","cycle_id"); ("refine_hist","d_res_high"); ("refine_hist","d_res_low"); 
    ("refine_ls_restr","pdbx_refine_id"); ("refine_ls_restr","type"); 
    ("refine_ls_restr_ncs","pdbx_refine_id"); ("refine_ls_restr_ncs","dom_id"); ("refine_ls_restr_ncs","pdbx_ordinal"); ("refine_ls_restr_ncs","pdbx_type"); ("refine_ls_restr_ncs","pdbx_auth_asym_id"); ("refine_ls_restr_ncs","pdbx_ens_id"); 
    ("refine_ls_restr_type","type"); 
    ("refine_ls_shell","pdbx_refine_id"); ("refine_ls_shell","d_res_high"); 
    ("refine_occupancy","pdbx_refine_id"); ("refine_occupancy","class"); 
    ("refln","index_h"); ("refln","index_k"); ("refln","index_l"); 
    ("refln_sys_abs","index_h"); ("refln_sys_abs","index_k"); ("refln_sys_abs","index_l"); 
    ("reflns","entry_id"); ("reflns","pdbx_diffrn_id"); ("reflns","pdbx_ordinal"); 
    ("reflns_scale","group_code"); 
    ("reflns_shell","d_res_high"); ("reflns_shell","pdbx_ordinal"); 
    ("software","classification"); ("software","name"); ("software","pdbx_ordinal"); 
    ("struct","entry_id"); 
    ("struct_asym","entity_id"); ("struct_asym","id"); 
    ("struct_biol","id"); 
    ("struct_biol_gen","asym_id"); ("struct_biol_gen","biol_id"); ("struct_biol_gen","symmetry"); ("struct_biol_gen","pdbx_new_asym_id"); ("struct_biol_gen","pdbx_new_pdb_asym_id"); 
    ("struct_biol_keywords","biol_id"); ("struct_biol_keywords","text"); 
    ("struct_biol_view","biol_id"); ("struct_biol_view","id"); 
    ("struct_conf","beg_label_asym_id"); ("struct_conf","beg_label_comp_id"); ("struct_conf","beg_label_seq_id"); ("struct_conf","conf_type_id"); ("struct_conf","end_label_asym_id"); ("struct_conf","end_label_comp_id"); ("struct_conf","end_label_seq_id"); ("struct_conf","id"); 
    ("struct_conf_type","id"); 
    ("struct_conn","conn_type_id"); ("struct_conn","id"); ("struct_conn","ptnr1_label_asym_id"); ("struct_conn","ptnr1_label_comp_id"); ("struct_conn","ptnr1_label_seq_id"); ("struct_conn","ptnr2_label_asym_id"); ("struct_conn","ptnr2_label_comp_id"); ("struct_conn","ptnr2_label_seq_id"); 
    ("struct_conn_type","id"); 
    ("struct_keywords","entry_id"); 
    ("struct_mon_details","entry_id"); 
    ("struct_mon_nucl","label_alt_id"); ("struct_mon_nucl","label_asym_id"); ("struct_mon_nucl","label_comp_id"); ("struct_mon_nucl","label_seq_id"); 
    ("struct_mon_prot","label_alt_id"); ("struct_mon_prot","label_asym_id"); ("struct_mon_prot","label_comp_id"); ("struct_mon_prot","label_seq_id"); 
    ("struct_mon_prot_cis","label_alt_id"); ("struct_mon_prot_cis","label_asym_id"); ("struct_mon_prot_cis","label_comp_id"); ("struct_mon_prot_cis","label_seq_id"); ("struct_mon_prot_cis","pdbx_PDB_model_num"); ("struct_mon_prot_cis","pdbx_id"); 
    ("struct_ncs_dom","id"); ("struct_ncs_dom","pdbx_ens_id"); 
    ("struct_ncs_dom_lim","dom_id"); ("struct_ncs_dom_lim","pdbx_component_id"); ("struct_ncs_dom_lim","pdbx_ens_id"); 
    ("struct_ncs_ens","id"); 
    ("struct_ncs_ens_gen","dom_id_1"); ("struct_ncs_ens_gen","dom_id_2"); ("struct_ncs_ens_gen","ens_id"); ("struct_ncs_ens_gen","oper_id"); 
    ("struct_ncs_oper","id"); 
    ("struct_ref","db_code"); ("struct_ref","db_name"); ("struct_ref","entity_id"); ("struct_ref","id"); 
    ("struct_ref_seq","align_id"); ("struct_ref_seq","db_align_beg"); ("struct_ref_seq","db_align_end"); ("struct_ref_seq","ref_id"); ("struct_ref_seq","seq_align_beg"); ("struct_ref_seq","seq_align_end"); 
    ("struct_ref_seq_dif","align_id"); ("struct_ref_seq_dif","pdbx_ordinal"); 
    ("struct_sheet","id"); 
    ("struct_sheet_hbond","range_1_beg_label_atom_id"); ("struct_sheet_hbond","range_1_beg_label_seq_id"); ("struct_sheet_hbond","range_1_end_label_atom_id"); ("struct_sheet_hbond","range_1_end_label_seq_id"); ("struct_sheet_hbond","range_2_beg_label_atom_id"); ("struct_sheet_hbond","range_2_beg_label_seq_id"); ("struct_sheet_hbond","range_2_end_label_atom_id"); ("struct_sheet_hbond","range_2_end_label_seq_id"); ("struct_sheet_hbond","range_id_1"); ("struct_sheet_hbond","range_id_2"); ("struct_sheet_hbond","sheet_id"); 
    ("struct_sheet_order","range_id_1"); ("struct_sheet_order","range_id_2"); ("struct_sheet_order","sheet_id"); 
    ("struct_sheet_range","beg_label_asym_id"); ("struct_sheet_range","beg_label_comp_id"); ("struct_sheet_range","beg_label_seq_id"); ("struct_sheet_range","end_label_asym_id"); ("struct_sheet_range","end_label_comp_id"); ("struct_sheet_range","end_label_seq_id"); ("struct_sheet_range","id"); ("struct_sheet_range","sheet_id"); 
    ("struct_sheet_topology","range_id_1"); ("struct_sheet_topology","range_id_2"); ("struct_sheet_topology","sheet_id"); 
    ("struct_site","id"); 
    ("struct_site_gen","id"); ("struct_site_gen","label_asym_id"); ("struct_site_gen","label_atom_id"); ("struct_site_gen","label_comp_id"); ("struct_site_gen","label_seq_id"); ("struct_site_gen","site_id"); 
    ("struct_site_keywords","site_id"); ("struct_site_keywords","text"); 
    ("struct_site_view","id"); ("struct_site_view","site_id"); 
    ("symmetry","entry_id"); 
    ("symmetry_equiv","id"); 
    ("audit_link","block_code"); ("audit_link","block_description"); 
    ("diffrn_reflns_class","code"); 
    ("refine_ls_class","code"); 
    ("reflns_class","code"); 
    ("space_group","id"); 
    ("space_group_symop","id"); 
    ("valence_param","atom_1"); ("valence_param","atom_1_valence"); ("valence_param","atom_2"); ("valence_param","atom_2_valence"); 
    ("valence_ref","id"); 
    ("pdbx_audit","entry_id"); ("pdbx_audit","current_version"); 
    ("pdbx_version","entry_id"); ("pdbx_version","revision_date"); ("pdbx_version","major_version"); ("pdbx_version","minor_version"); ("pdbx_version","revision_type"); 
    ("pdbx_audit_author","name"); ("pdbx_audit_author","ordinal"); 
    ("pdbx_database_message","entry_id"); ("pdbx_database_message","message_id"); ("pdbx_database_message","date"); ("pdbx_database_message","content_type"); ("pdbx_database_message","message_type"); 
    ("pdbx_database_PDB_obs_spr","id"); ("pdbx_database_PDB_obs_spr","date"); ("pdbx_database_PDB_obs_spr","pdb_id"); ("pdbx_database_PDB_obs_spr","replace_pdb_id"); 
    ("pdbx_database_proc","entry_id"); ("pdbx_database_proc","cycle_id"); ("pdbx_database_proc","date_begin_cycle"); ("pdbx_database_proc","date_end_cycle"); 
    ("pdbx_database_remark","id"); 
    ("pdbx_database_status","status_code"); ("pdbx_database_status","entry_id"); 
    ("pdbx_entity_name","entity_id"); ("pdbx_entity_name","name"); ("pdbx_entity_name","name_type"); 
    ("pdbx_prerelease_seq","entity_id"); 
    ("pdbx_poly_seq_scheme","asym_id"); ("pdbx_poly_seq_scheme","entity_id"); ("pdbx_poly_seq_scheme","seq_id"); ("pdbx_poly_seq_scheme","mon_id"); 
    ("pdbx_nonpoly_scheme","asym_id"); ("pdbx_nonpoly_scheme","ndb_seq_num"); 
    ("pdbx_refine","entry_id"); ("pdbx_refine","pdbx_refine_id"); 
    ("pdbx_struct_sheet_hbond","range_id_1"); ("pdbx_struct_sheet_hbond","range_id_2"); ("pdbx_struct_sheet_hbond","sheet_id"); ("pdbx_struct_sheet_hbond","range_1_label_atom_id"); ("pdbx_struct_sheet_hbond","range_1_label_seq_id"); ("pdbx_struct_sheet_hbond","range_2_label_atom_id"); ("pdbx_struct_sheet_hbond","range_2_label_seq_id"); 
    ("pdbx_xplor_file","serial_no"); ("pdbx_xplor_file","pdbx_refine_id"); 
    ("pdbx_refine_aux_file","serial_no"); ("pdbx_refine_aux_file","pdbx_refine_id"); 
    ("pdbx_database_related","db_name"); ("pdbx_database_related","db_id"); ("pdbx_database_related","content_type"); 
    ("pdbx_entity_assembly","id"); ("pdbx_entity_assembly","entity_id"); ("pdbx_entity_assembly","biol_id"); ("pdbx_entity_assembly","num_copies"); 
    ("pdbx_exptl_crystal_grow_comp","crystal_id"); ("pdbx_exptl_crystal_grow_comp","comp_id"); 
    ("pdbx_exptl_crystal_grow_sol","crystal_id"); ("pdbx_exptl_crystal_grow_sol","sol_id"); 
    ("pdbx_exptl_crystal_cryo_treatment","crystal_id"); 
    ("pdbx_refine_tls","id"); 
    ("pdbx_refine_tls_group","id"); ("pdbx_refine_tls_group","refine_tls_id"); 
    ("pdbx_contact_author","id"); ("pdbx_contact_author","email"); ("pdbx_contact_author","name_first"); ("pdbx_contact_author","name_last"); ("pdbx_contact_author","name_salutation"); ("pdbx_contact_author","country"); 
    ("pdbx_SG_project","id"); 
    ("pdbx_atom_site_aniso_tls","id"); ("pdbx_atom_site_aniso_tls","type_symbol"); ("pdbx_atom_site_aniso_tls","tls_group_id"); ("pdbx_atom_site_aniso_tls","auth_comp_id"); ("pdbx_atom_site_aniso_tls","auth_seq_id"); ("pdbx_atom_site_aniso_tls","auth_atom_id"); ("pdbx_atom_site_aniso_tls","auth_asym_id"); ("pdbx_atom_site_aniso_tls","label_alt_id"); ("pdbx_atom_site_aniso_tls","U_tls[1][1]"); ("pdbx_atom_site_aniso_tls","U_tls[2][2]"); ("pdbx_atom_site_aniso_tls","U_tls[3][3]"); ("pdbx_atom_site_aniso_tls","U_tls[1][2]"); ("pdbx_atom_site_aniso_tls","U_tls[1][3]"); ("pdbx_atom_site_aniso_tls","U_tls[2][3]"); 
    ("pdbx_nmr_details","entry_id"); 
    ("pdbx_nmr_sample_details","solution_id"); 
    ("pdbx_nmr_exptl_sample","solution_id"); ("pdbx_nmr_exptl_sample","component"); 
    ("pdbx_nmr_exptl_sample_conditions","conditions_id"); 
    ("pdbx_nmr_spectrometer","spectrometer_id"); 
    ("pdbx_nmr_exptl","experiment_id"); ("pdbx_nmr_exptl","conditions_id"); ("pdbx_nmr_exptl","solution_id"); 
    ("pdbx_nmr_software","ordinal"); ("pdbx_nmr_software","classification"); ("pdbx_nmr_software","name"); 
    ("pdbx_nmr_constraints","entry_id"); 
    ("pdbx_nmr_ensemble","entry_id"); 
    ("pdbx_nmr_ensemble_rms","entry_id"); 
    ("pdbx_nmr_representative","entry_id"); 
    ("pdbx_nmr_refine","entry_id"); ("pdbx_nmr_refine","software_ordinal"); 
    ("pdbx_nmr_force_constants","entry_id"); 
    ("ndb_struct_conf_na","entry_id"); ("ndb_struct_conf_na","feature"); 
    ("ndb_struct_feature_na","entry_id"); ("ndb_struct_feature_na","feature"); 
    ("ndb_struct_na_base_pair","model_number"); ("ndb_struct_na_base_pair","pair_number"); ("ndb_struct_na_base_pair","pair_name"); ("ndb_struct_na_base_pair","i_label_asym_id"); ("ndb_struct_na_base_pair","i_label_comp_id"); ("ndb_struct_na_base_pair","i_label_seq_id"); ("ndb_struct_na_base_pair","i_symmetry"); ("ndb_struct_na_base_pair","j_label_asym_id"); ("ndb_struct_na_base_pair","j_label_comp_id"); ("ndb_struct_na_base_pair","j_label_seq_id"); ("ndb_struct_na_base_pair","j_symmetry"); ("ndb_struct_na_base_pair","i_auth_asym_id"); ("ndb_struct_na_base_pair","i_auth_seq_id"); ("ndb_struct_na_base_pair","j_auth_asym_id"); ("ndb_struct_na_base_pair","j_auth_seq_id"); 
    ("ndb_struct_na_base_pair_step","model_number"); ("ndb_struct_na_base_pair_step","step_number"); ("ndb_struct_na_base_pair_step","step_name"); ("ndb_struct_na_base_pair_step","i_label_asym_id_1"); ("ndb_struct_na_base_pair_step","i_label_comp_id_1"); ("ndb_struct_na_base_pair_step","i_label_seq_id_1"); ("ndb_struct_na_base_pair_step","i_symmetry_1"); ("ndb_struct_na_base_pair_step","j_label_asym_id_1"); ("ndb_struct_na_base_pair_step","j_label_comp_id_1"); ("ndb_struct_na_base_pair_step","j_label_seq_id_1"); ("ndb_struct_na_base_pair_step","j_symmetry_1"); ("ndb_struct_na_base_pair_step","i_label_asym_id_2"); ("ndb_struct_na_base_pair_step","i_label_comp_id_2"); ("ndb_struct_na_base_pair_step","i_label_seq_id_2"); ("ndb_struct_na_base_pair_step","i_symmetry_2"); ("ndb_struct_na_base_pair_step","j_label_asym_id_2"); ("ndb_struct_na_base_pair_step","j_label_comp_id_2"); ("ndb_struct_na_base_pair_step","j_label_seq_id_2"); ("ndb_struct_na_base_pair_step","j_symmetry_2"); ("ndb_struct_na_base_pair_step","i_auth_asym_id_1"); ("ndb_struct_na_base_pair_step","i_auth_seq_id_1"); ("ndb_struct_na_base_pair_step","j_auth_asym_id_1"); ("ndb_struct_na_base_pair_step","j_auth_seq_id_1"); ("ndb_struct_na_base_pair_step","i_auth_asym_id_2"); ("ndb_struct_na_base_pair_step","i_auth_seq_id_2"); ("ndb_struct_na_base_pair_step","j_auth_asym_id_2"); ("ndb_struct_na_base_pair_step","j_auth_seq_id_2"); 
    ("ndb_original_ndb_coordinates","coord_section"); 
    ("pdbx_entity_nonpoly","entity_id"); 
    ("pdbx_phasing_dm","entry_id"); 
    ("pdbx_phasing_dm_shell","d_res_high"); ("pdbx_phasing_dm_shell","d_res_low"); 
    ("pdbx_phasing_MAD_shell","d_res_low"); ("pdbx_phasing_MAD_shell","d_res_high"); 
    ("pdbx_phasing_MAD_set","id"); 
    ("pdbx_phasing_MAD_set_shell","id"); ("pdbx_phasing_MAD_set_shell","d_res_low"); ("pdbx_phasing_MAD_set_shell","d_res_high"); 
    ("pdbx_phasing_MAD_set_site","id"); 
    ("pdbx_phasing_MR","entry_id"); 
    ("pdbx_refine_component","label_alt_id"); ("pdbx_refine_component","label_asym_id"); ("pdbx_refine_component","label_comp_id"); ("pdbx_refine_component","label_seq_id"); 
    ("pdbx_entity_prod_protocol","entry_id"); ("pdbx_entity_prod_protocol","entity_id"); ("pdbx_entity_prod_protocol","protocol"); ("pdbx_entity_prod_protocol","protocol_type"); 
    ("pdbx_entity_src_gen_prod_other","entry_id"); ("pdbx_entity_src_gen_prod_other","entity_id"); ("pdbx_entity_src_gen_prod_other","step_id"); ("pdbx_entity_src_gen_prod_other","next_step_id"); 
    ("pdbx_entity_src_gen_prod_other_parameter","entry_id"); ("pdbx_entity_src_gen_prod_other_parameter","entity_id"); ("pdbx_entity_src_gen_prod_other_parameter","step_id"); ("pdbx_entity_src_gen_prod_other_parameter","parameter"); ("pdbx_entity_src_gen_prod_other_parameter","value"); ("pdbx_entity_src_gen_prod_other_parameter","details"); 
    ("pdbx_entity_src_gen_prod_pcr","entry_id"); ("pdbx_entity_src_gen_prod_pcr","entity_id"); ("pdbx_entity_src_gen_prod_pcr","step_id"); ("pdbx_entity_src_gen_prod_pcr","next_step_id"); ("pdbx_entity_src_gen_prod_pcr","forward_primer_id"); ("pdbx_entity_src_gen_prod_pcr","reverse_primer_id"); 
    ("pdbx_entity_src_gen_prod_digest","entry_id"); ("pdbx_entity_src_gen_prod_digest","entity_id"); ("pdbx_entity_src_gen_prod_digest","step_id"); ("pdbx_entity_src_gen_prod_digest","next_step_id"); ("pdbx_entity_src_gen_prod_digest","restriction_enzyme_1"); 
    ("pdbx_entity_src_gen_clone","entry_id"); ("pdbx_entity_src_gen_clone","entity_id"); ("pdbx_entity_src_gen_clone","step_id"); ("pdbx_entity_src_gen_clone","next_step_id"); ("pdbx_entity_src_gen_clone","gene_insert_method"); 
    ("pdbx_entity_src_gen_clone_ligation","entry_id"); ("pdbx_entity_src_gen_clone_ligation","entity_id"); ("pdbx_entity_src_gen_clone_ligation","step_id"); ("pdbx_entity_src_gen_clone_ligation","cleavage_enzymes"); ("pdbx_entity_src_gen_clone_ligation","ligation_enzymes"); ("pdbx_entity_src_gen_clone_ligation","temperature"); ("pdbx_entity_src_gen_clone_ligation","time"); 
    ("pdbx_entity_src_gen_clone_recombination","entry_id"); ("pdbx_entity_src_gen_clone_recombination","entity_id"); ("pdbx_entity_src_gen_clone_recombination","step_id"); ("pdbx_entity_src_gen_clone_recombination","system"); ("pdbx_entity_src_gen_clone_recombination","recombination_enzymes"); 
    ("pdbx_entity_src_gen_express","entry_id"); ("pdbx_entity_src_gen_express","entity_id"); ("pdbx_entity_src_gen_express","step_id"); ("pdbx_entity_src_gen_express","next_step_id"); ("pdbx_entity_src_gen_express","promoter_type"); ("pdbx_entity_src_gen_express","plasmid_id"); ("pdbx_entity_src_gen_express","vector_type"); ("pdbx_entity_src_gen_express","N_terminal_seq_tag"); ("pdbx_entity_src_gen_express","C_terminal_seq_tag"); ("pdbx_entity_src_gen_express","culture_volume"); ("pdbx_entity_src_gen_express","culture_time"); ("pdbx_entity_src_gen_express","culture_temperature"); ("pdbx_entity_src_gen_express","induction_temperature"); 
    ("pdbx_entity_src_gen_express_timepoint","entry_id"); ("pdbx_entity_src_gen_express_timepoint","entity_id"); ("pdbx_entity_src_gen_express_timepoint","step_id"); ("pdbx_entity_src_gen_express_timepoint","serial"); ("pdbx_entity_src_gen_express_timepoint","OD"); ("pdbx_entity_src_gen_express_timepoint","time"); 
    ("pdbx_entity_src_gen_lysis","entry_id"); ("pdbx_entity_src_gen_lysis","entity_id"); ("pdbx_entity_src_gen_lysis","step_id"); ("pdbx_entity_src_gen_lysis","next_step_id"); ("pdbx_entity_src_gen_lysis","method"); ("pdbx_entity_src_gen_lysis","buffer_id"); ("pdbx_entity_src_gen_lysis","buffer_volume"); ("pdbx_entity_src_gen_lysis","temperature"); ("pdbx_entity_src_gen_lysis","time"); 
    ("pdbx_entity_src_gen_refold","entry_id"); ("pdbx_entity_src_gen_refold","entity_id"); ("pdbx_entity_src_gen_refold","step_id"); ("pdbx_entity_src_gen_refold","next_step_id"); ("pdbx_entity_src_gen_refold","denature_buffer_id"); ("pdbx_entity_src_gen_refold","refold_buffer_id"); ("pdbx_entity_src_gen_refold","temperature"); ("pdbx_entity_src_gen_refold","time"); ("pdbx_entity_src_gen_refold","storage_buffer_id"); 
    ("pdbx_entity_src_gen_proteolysis","entry_id"); ("pdbx_entity_src_gen_proteolysis","entity_id"); ("pdbx_entity_src_gen_proteolysis","step_id"); ("pdbx_entity_src_gen_proteolysis","next_step_id"); ("pdbx_entity_src_gen_proteolysis","protease"); 
    ("pdbx_entity_src_gen_chrom","entry_id"); ("pdbx_entity_src_gen_chrom","entity_id"); ("pdbx_entity_src_gen_chrom","step_id"); ("pdbx_entity_src_gen_chrom","next_step_id"); ("pdbx_entity_src_gen_chrom","column_type"); ("pdbx_entity_src_gen_chrom","column_volume"); ("pdbx_entity_src_gen_chrom","column_temperature"); ("pdbx_entity_src_gen_chrom","equilibration_buffer_id"); ("pdbx_entity_src_gen_chrom","elution_buffer_id"); ("pdbx_entity_src_gen_chrom","sample_volume"); ("pdbx_entity_src_gen_chrom","volume_pooled_fractions"); ("pdbx_entity_src_gen_chrom","yield_pooled_fractions"); ("pdbx_entity_src_gen_chrom","yield_method"); 
    ("pdbx_entity_src_gen_fract","entry_id"); ("pdbx_entity_src_gen_fract","entity_id"); ("pdbx_entity_src_gen_fract","step_id"); ("pdbx_entity_src_gen_fract","next_step_id"); ("pdbx_entity_src_gen_fract","method"); ("pdbx_entity_src_gen_fract","temperature"); ("pdbx_entity_src_gen_fract","protein_location"); ("pdbx_entity_src_gen_fract","protein_yield"); ("pdbx_entity_src_gen_fract","protein_yield_method"); 
    ("pdbx_entity_src_gen_pure","entry_id"); ("pdbx_entity_src_gen_pure","entity_id"); ("pdbx_entity_src_gen_pure","step_id"); ("pdbx_entity_src_gen_pure","conc_assay_method"); ("pdbx_entity_src_gen_pure","protein_concentration"); ("pdbx_entity_src_gen_pure","storage_buffer_id"); 
    ("pdbx_entity_src_gen_character","entry_id"); ("pdbx_entity_src_gen_character","entity_id"); ("pdbx_entity_src_gen_character","step_id"); ("pdbx_entity_src_gen_character","method"); ("pdbx_entity_src_gen_character","result"); 
    ("pdbx_construct","entry_id"); ("pdbx_construct","id"); ("pdbx_construct","name"); ("pdbx_construct","organisation"); ("pdbx_construct","type"); ("pdbx_construct","seq"); 
    ("pdbx_construct_feature","id"); ("pdbx_construct_feature","construct_id"); ("pdbx_construct_feature","entry_id"); 
    ("pdbx_robot_system","id"); 
    ("pdbx_buffer","id"); 
    ("pdbx_buffer_components","id"); ("pdbx_buffer_components","buffer_id"); 
    ("pdbx_domain","id"); 
    ("pdbx_domain_range","beg_label_alt_id"); ("pdbx_domain_range","beg_label_asym_id"); ("pdbx_domain_range","beg_label_comp_id"); ("pdbx_domain_range","beg_label_seq_id"); ("pdbx_domain_range","domain_id"); ("pdbx_domain_range","end_label_alt_id"); ("pdbx_domain_range","end_label_asym_id"); ("pdbx_domain_range","end_label_comp_id"); ("pdbx_domain_range","end_label_seq_id"); 
    ("pdbx_sequence_range","beg_label_alt_id"); ("pdbx_sequence_range","beg_label_asym_id"); ("pdbx_sequence_range","beg_label_comp_id"); ("pdbx_sequence_range","beg_label_seq_id"); ("pdbx_sequence_range","seq_range_id"); ("pdbx_sequence_range","end_label_alt_id"); ("pdbx_sequence_range","end_label_asym_id"); ("pdbx_sequence_range","end_label_comp_id"); ("pdbx_sequence_range","end_label_seq_id"); 
    ("pdbx_feature_entry","id"); ("pdbx_feature_entry","feature_name"); ("pdbx_feature_entry","feature_type"); ("pdbx_feature_entry","feature"); ("pdbx_feature_entry","feature_assigned_by"); 
    ("pdbx_feature_domain","id"); ("pdbx_feature_domain","domain_id"); ("pdbx_feature_domain","feature_name"); ("pdbx_feature_domain","feature_type"); ("pdbx_feature_domain","feature"); ("pdbx_feature_domain","feature_assigned_by"); 
    ("pdbx_feature_sequence_range","id"); ("pdbx_feature_sequence_range","seq_range_id"); ("pdbx_feature_sequence_range","feature_name"); ("pdbx_feature_sequence_range","feature_type"); ("pdbx_feature_sequence_range","feature"); ("pdbx_feature_sequence_range","feature_assigned_by"); 
    ("pdbx_feature_assembly","id"); ("pdbx_feature_assembly","assembly_id"); ("pdbx_feature_assembly","feature_name"); ("pdbx_feature_assembly","feature_type"); ("pdbx_feature_assembly","feature"); ("pdbx_feature_assembly","feature_assigned_by"); 
    ("pdbx_feature_monomer","id"); ("pdbx_feature_monomer","feature_name"); ("pdbx_feature_monomer","feature_type"); ("pdbx_feature_monomer","feature"); ("pdbx_feature_monomer","feature_assigned_by"); ("pdbx_feature_monomer","label_alt_id"); ("pdbx_feature_monomer","label_asym_id"); ("pdbx_feature_monomer","label_comp_id"); ("pdbx_feature_monomer","label_seq_id"); 
    ("pdbx_exptl_pd","entry_id"); 
    ("pdbx_reflns_twin","diffrn_id"); ("pdbx_reflns_twin","crystal_id"); ("pdbx_reflns_twin","operator"); ("pdbx_reflns_twin","fraction"); 
    ("pdbx_struct_info","type"); ("pdbx_struct_info","value"); 
    ("pdbx_re_refinement","entry_id"); ("pdbx_re_refinement","citation_id"); ("pdbx_re_refinement","details"); 
    ("pdbx_struct_assembly_prop","biol_id"); ("pdbx_struct_assembly_prop","type"); ("pdbx_struct_assembly_prop","value"); 
    ("pdbx_struct_ref_seq_feature","feature_id"); ("pdbx_struct_ref_seq_feature","align_id"); 
    ("pdbx_struct_ref_seq_feature_prop","feature_id"); ("pdbx_struct_ref_seq_feature_prop","property_id"); ("pdbx_struct_ref_seq_feature_prop","type"); ("pdbx_struct_ref_seq_feature_prop","value"); 
    ("pdbx_struct_chem_comp_diagnostics","ordinal"); 
    ("pdbx_chem_comp_feature","comp_id"); ("pdbx_chem_comp_feature","type"); ("pdbx_chem_comp_feature","value"); ("pdbx_chem_comp_feature","source"); 
    ("pdbx_coordinate_model","asym_id"); ("pdbx_coordinate_model","type"); 
    ("pdbx_struct_chem_comp_feature","ordinal"); 
    ("pdbx_diffrn_reflns_shell","diffrn_id"); ("pdbx_diffrn_reflns_shell","d_res_low"); ("pdbx_diffrn_reflns_shell","d_res_high"); 
    ("pdbx_bond_distance_limits","atom_type_1"); ("pdbx_bond_distance_limits","atom_type_2"); ("pdbx_bond_distance_limits","lower_limit"); ("pdbx_bond_distance_limits","upper_limit"); 
    ("pdbx_soln_scatter","entry_id"); ("pdbx_soln_scatter","id"); ("pdbx_soln_scatter","type"); 
    ("pdbx_soln_scatter_model","scatter_id"); ("pdbx_soln_scatter_model","id"); 
    ("pdbx_chem_comp_descriptor","comp_id"); ("pdbx_chem_comp_descriptor","descriptor"); ("pdbx_chem_comp_descriptor","type"); ("pdbx_chem_comp_descriptor","program"); ("pdbx_chem_comp_descriptor","program_version"); 
    ("pdbx_chem_comp_identifier","comp_id"); ("pdbx_chem_comp_identifier","identifier"); ("pdbx_chem_comp_identifier","type"); ("pdbx_chem_comp_identifier","program"); ("pdbx_chem_comp_identifier","program_version"); 
    ("pdbx_chem_comp_import","comp_id"); 
    ("pdbx_chem_comp_atom_edit","ordinal"); ("pdbx_chem_comp_atom_edit","comp_id"); ("pdbx_chem_comp_atom_edit","edit_op"); ("pdbx_chem_comp_atom_edit","atom_id"); ("pdbx_chem_comp_atom_edit","edit_atom_id"); 
    ("pdbx_chem_comp_bond_edit","ordinal"); ("pdbx_chem_comp_bond_edit","comp_id"); ("pdbx_chem_comp_bond_edit","edit_op"); ("pdbx_chem_comp_bond_edit","atom_id_1"); ("pdbx_chem_comp_bond_edit","atom_id_2"); 
    ("pdbx_chem_comp_audit","comp_id"); ("pdbx_chem_comp_audit","date"); ("pdbx_chem_comp_audit","action_type"); 
    ("pdbx_validate_close_contact","id"); ("pdbx_validate_close_contact","PDB_model_num"); ("pdbx_validate_close_contact","auth_asym_id_1"); ("pdbx_validate_close_contact","auth_atom_id_1"); ("pdbx_validate_close_contact","auth_comp_id_1"); ("pdbx_validate_close_contact","auth_seq_id_1"); ("pdbx_validate_close_contact","auth_atom_id_2"); ("pdbx_validate_close_contact","auth_asym_id_2"); ("pdbx_validate_close_contact","auth_comp_id_2"); ("pdbx_validate_close_contact","auth_seq_id_2"); ("pdbx_validate_close_contact","dist"); 
    ("pdbx_validate_symm_contact","id"); ("pdbx_validate_symm_contact","PDB_model_num"); ("pdbx_validate_symm_contact","auth_asym_id_1"); ("pdbx_validate_symm_contact","auth_atom_id_1"); ("pdbx_validate_symm_contact","auth_comp_id_1"); ("pdbx_validate_symm_contact","auth_seq_id_1"); ("pdbx_validate_symm_contact","auth_atom_id_2"); ("pdbx_validate_symm_contact","auth_asym_id_2"); ("pdbx_validate_symm_contact","auth_comp_id_2"); ("pdbx_validate_symm_contact","auth_seq_id_2"); ("pdbx_validate_symm_contact","site_symmetry_1"); ("pdbx_validate_symm_contact","site_symmetry_2"); ("pdbx_validate_symm_contact","dist"); 
    ("pdbx_validate_rmsd_bond","id"); ("pdbx_validate_rmsd_bond","PDB_model_num"); ("pdbx_validate_rmsd_bond","auth_asym_id_1"); ("pdbx_validate_rmsd_bond","auth_atom_id_1"); ("pdbx_validate_rmsd_bond","auth_comp_id_1"); ("pdbx_validate_rmsd_bond","auth_seq_id_1"); ("pdbx_validate_rmsd_bond","auth_atom_id_2"); ("pdbx_validate_rmsd_bond","auth_asym_id_2"); ("pdbx_validate_rmsd_bond","auth_comp_id_2"); ("pdbx_validate_rmsd_bond","auth_seq_id_2"); ("pdbx_validate_rmsd_bond","bond_deviation"); 
    ("pdbx_validate_rmsd_angle","id"); ("pdbx_validate_rmsd_angle","PDB_model_num"); ("pdbx_validate_rmsd_angle","auth_asym_id_1"); ("pdbx_validate_rmsd_angle","auth_atom_id_1"); ("pdbx_validate_rmsd_angle","auth_comp_id_1"); ("pdbx_validate_rmsd_angle","auth_seq_id_1"); ("pdbx_validate_rmsd_angle","auth_atom_id_2"); ("pdbx_validate_rmsd_angle","auth_asym_id_2"); ("pdbx_validate_rmsd_angle","auth_comp_id_2"); ("pdbx_validate_rmsd_angle","auth_seq_id_2"); ("pdbx_validate_rmsd_angle","auth_atom_id_3"); ("pdbx_validate_rmsd_angle","auth_asym_id_3"); ("pdbx_validate_rmsd_angle","auth_comp_id_3"); ("pdbx_validate_rmsd_angle","auth_seq_id_3"); ("pdbx_validate_rmsd_angle","angle_deviation"); 
    ("pdbx_validate_torsion","id"); ("pdbx_validate_torsion","PDB_model_num"); ("pdbx_validate_torsion","auth_asym_id"); ("pdbx_validate_torsion","auth_comp_id"); ("pdbx_validate_torsion","auth_seq_id"); ("pdbx_validate_torsion","phi"); ("pdbx_validate_torsion","psi"); 
    ("pdbx_validate_peptide_omega","id"); ("pdbx_validate_peptide_omega","PDB_model_num"); ("pdbx_validate_peptide_omega","auth_asym_id_1"); ("pdbx_validate_peptide_omega","auth_asym_id_2"); ("pdbx_validate_peptide_omega","auth_comp_id_1"); ("pdbx_validate_peptide_omega","auth_comp_id_2"); ("pdbx_validate_peptide_omega","auth_seq_id_1"); ("pdbx_validate_peptide_omega","auth_seq_id_2"); ("pdbx_validate_peptide_omega","omega"); 
    ("pdbx_validate_chiral","id"); ("pdbx_validate_chiral","PDB_model_num"); ("pdbx_validate_chiral","auth_asym_id"); ("pdbx_validate_chiral","auth_comp_id"); ("pdbx_validate_chiral","auth_seq_id"); ("pdbx_validate_chiral","omega"); 
    ("pdbx_validate_planes","id"); ("pdbx_validate_planes","PDB_model_num"); ("pdbx_validate_planes","auth_asym_id"); ("pdbx_validate_planes","auth_comp_id"); ("pdbx_validate_planes","auth_seq_id"); ("pdbx_validate_planes","rmsd"); ("pdbx_validate_planes","type"); 
    ("pdbx_validate_planes_atom","plane_id"); ("pdbx_validate_planes_atom","id"); ("pdbx_validate_planes_atom","PDB_model_num"); ("pdbx_validate_planes_atom","auth_asym_id"); ("pdbx_validate_planes_atom","auth_comp_id"); ("pdbx_validate_planes_atom","auth_seq_id"); ("pdbx_validate_planes_atom","auth_atom_id"); ("pdbx_validate_planes_atom","atom_deviation"); 
    ("pdbx_validate_main_chain_plane","id"); ("pdbx_validate_main_chain_plane","PDB_model_num"); ("pdbx_validate_main_chain_plane","auth_asym_id"); ("pdbx_validate_main_chain_plane","auth_comp_id"); ("pdbx_validate_main_chain_plane","auth_seq_id"); ("pdbx_validate_main_chain_plane","improper_torsion_angle"); 
    ("pdbx_struct_conn_angle","id"); ("pdbx_struct_conn_angle","ptnr1_label_asym_id"); ("pdbx_struct_conn_angle","ptnr1_label_atom_id"); ("pdbx_struct_conn_angle","ptnr1_label_comp_id"); ("pdbx_struct_conn_angle","ptnr2_label_asym_id"); ("pdbx_struct_conn_angle","ptnr2_label_atom_id"); ("pdbx_struct_conn_angle","ptnr2_label_comp_id"); 
    ("pdbx_unobs_or_zero_occ_residues","id"); ("pdbx_unobs_or_zero_occ_residues","polymer_flag"); ("pdbx_unobs_or_zero_occ_residues","occupancy_flag"); ("pdbx_unobs_or_zero_occ_residues","PDB_model_num"); ("pdbx_unobs_or_zero_occ_residues","auth_asym_id"); ("pdbx_unobs_or_zero_occ_residues","auth_comp_id"); ("pdbx_unobs_or_zero_occ_residues","auth_seq_id"); 
    ("pdbx_unobs_or_zero_occ_atoms","id"); ("pdbx_unobs_or_zero_occ_atoms","polymer_flag"); ("pdbx_unobs_or_zero_occ_atoms","occupancy_flag"); ("pdbx_unobs_or_zero_occ_atoms","PDB_model_num"); ("pdbx_unobs_or_zero_occ_atoms","auth_asym_id"); ("pdbx_unobs_or_zero_occ_atoms","auth_atom_id"); ("pdbx_unobs_or_zero_occ_atoms","auth_comp_id"); ("pdbx_unobs_or_zero_occ_atoms","auth_seq_id"); 
    ("pdbx_entry_details","entry_id"); 
    ("pdbx_struct_mod_residue","id"); ("pdbx_struct_mod_residue","auth_asym_id"); ("pdbx_struct_mod_residue","auth_comp_id"); ("pdbx_struct_mod_residue","auth_seq_id"); 
    ("pdbx_struct_ref_seq_insertion","id"); ("pdbx_struct_ref_seq_insertion","comp_id"); ("pdbx_struct_ref_seq_insertion","asym_id"); ("pdbx_struct_ref_seq_insertion","auth_seq_id"); ("pdbx_struct_ref_seq_insertion","seq_id"); ("pdbx_struct_ref_seq_insertion","db_code"); ("pdbx_struct_ref_seq_insertion","db_name"); 
    ("pdbx_struct_ref_seq_deletion","id"); ("pdbx_struct_ref_seq_deletion","asym_id"); ("pdbx_struct_ref_seq_deletion","comp_id"); ("pdbx_struct_ref_seq_deletion","db_seq_id"); ("pdbx_struct_ref_seq_deletion","db_code"); ("pdbx_struct_ref_seq_deletion","db_name"); 
    ("pdbx_remediation_atom_site_mapping","id"); ("pdbx_remediation_atom_site_mapping","label_asym_id"); ("pdbx_remediation_atom_site_mapping","label_atom_id"); ("pdbx_remediation_atom_site_mapping","label_comp_id"); ("pdbx_remediation_atom_site_mapping","label_seq_id"); 
    ("pdbx_validate_polymer_linkage","id"); ("pdbx_validate_polymer_linkage","PDB_model_num"); ("pdbx_validate_polymer_linkage","auth_asym_id_1"); ("pdbx_validate_polymer_linkage","auth_atom_id_1"); ("pdbx_validate_polymer_linkage","auth_comp_id_1"); ("pdbx_validate_polymer_linkage","auth_seq_id_1"); ("pdbx_validate_polymer_linkage","auth_atom_id_2"); ("pdbx_validate_polymer_linkage","auth_asym_id_2"); ("pdbx_validate_polymer_linkage","auth_comp_id_2"); ("pdbx_validate_polymer_linkage","auth_seq_id_2"); ("pdbx_validate_polymer_linkage","dist"); 
    ("pdbx_helical_symmetry","entry_id"); ("pdbx_helical_symmetry","number_of_operations"); ("pdbx_helical_symmetry","rotation_per_n_subunits"); ("pdbx_helical_symmetry","rise_per_n_subunits"); ("pdbx_helical_symmetry","n_subunits_divisor"); ("pdbx_helical_symmetry","dyad_axis"); ("pdbx_helical_symmetry","circular_symmetry"); 
    ("pdbx_point_symmetry","entry_id"); ("pdbx_point_symmetry","Schoenflies_symbol"); 
    ("pdbx_struct_entity_inst","id"); 
    ("pdbx_struct_oper_list","id"); ("pdbx_struct_oper_list","type"); 
    ("pdbx_struct_assembly","id"); 
    ("pdbx_struct_assembly_gen","asym_id_list"); ("pdbx_struct_assembly_gen","assembly_id"); ("pdbx_struct_assembly_gen","oper_expression"); 
    ("pdbx_struct_asym_gen","entity_inst_id"); ("pdbx_struct_asym_gen","oper_expression"); 
    ("pdbx_struct_msym_gen","entity_inst_id"); ("pdbx_struct_msym_gen","msym_id"); ("pdbx_struct_msym_gen","oper_expression"); 
    ("pdbx_struct_legacy_oper_list","id"); 
    ("pdbx_chem_comp_atom_feature","comp_id"); ("pdbx_chem_comp_atom_feature","atom_id"); ("pdbx_chem_comp_atom_feature","feature_type"); 
    ("pdbx_reference_molecule_family","family_prd_id"); 
    ("pdbx_reference_molecule_list","prd_id"); ("pdbx_reference_molecule_list","family_prd_id"); 
    ("pdbx_reference_molecule","prd_id"); 
    ("pdbx_reference_entity_list","prd_id"); ("pdbx_reference_entity_list","ref_entity_id"); ("pdbx_reference_entity_list","component_id"); 
    ("pdbx_reference_entity_nonpoly","prd_id"); ("pdbx_reference_entity_nonpoly","ref_entity_id"); 
    ("pdbx_reference_entity_link","link_id"); ("pdbx_reference_entity_link","prd_id"); ("pdbx_reference_entity_link","ref_entity_id_1"); ("pdbx_reference_entity_link","ref_entity_id_2"); ("pdbx_reference_entity_link","comp_id_1"); ("pdbx_reference_entity_link","comp_id_2"); ("pdbx_reference_entity_link","atom_id_1"); ("pdbx_reference_entity_link","atom_id_2"); ("pdbx_reference_entity_link","component_1"); ("pdbx_reference_entity_link","component_2"); 
    ("pdbx_reference_entity_poly_link","link_id"); ("pdbx_reference_entity_poly_link","prd_id"); ("pdbx_reference_entity_poly_link","ref_entity_id"); ("pdbx_reference_entity_poly_link","component_id"); ("pdbx_reference_entity_poly_link","comp_id_1"); ("pdbx_reference_entity_poly_link","comp_id_2"); ("pdbx_reference_entity_poly_link","atom_id_1"); ("pdbx_reference_entity_poly_link","atom_id_2"); 
    ("pdbx_reference_entity_poly","prd_id"); ("pdbx_reference_entity_poly","ref_entity_id"); 
    ("pdbx_reference_entity_poly_seq","prd_id"); ("pdbx_reference_entity_poly_seq","ref_entity_id"); ("pdbx_reference_entity_poly_seq","mon_id"); ("pdbx_reference_entity_poly_seq","num"); ("pdbx_reference_entity_poly_seq","hetero"); 
    ("pdbx_reference_entity_sequence","prd_id"); ("pdbx_reference_entity_sequence","ref_entity_id"); ("pdbx_reference_entity_sequence","type"); ("pdbx_reference_entity_sequence","NRP_flag"); ("pdbx_reference_entity_sequence","one_letter_codes"); 
    ("pdbx_reference_entity_src_nat","prd_id"); ("pdbx_reference_entity_src_nat","ref_entity_id"); ("pdbx_reference_entity_src_nat","ordinal"); 
    ("pdbx_reference_molecule_details","family_prd_id"); ("pdbx_reference_molecule_details","ordinal"); ("pdbx_reference_molecule_details","text"); 
    ("pdbx_reference_molecule_synonyms","family_prd_id"); ("pdbx_reference_molecule_synonyms","prd_id"); ("pdbx_reference_molecule_synonyms","ordinal"); ("pdbx_reference_molecule_synonyms","name"); ("pdbx_reference_molecule_synonyms","source"); 
    ("pdbx_reference_entity_subcomponents","prd_id"); ("pdbx_reference_entity_subcomponents","seq"); 
    ("pdbx_reference_molecule_annotation","family_prd_id"); ("pdbx_reference_molecule_annotation","ordinal"); ("pdbx_reference_molecule_annotation","text"); ("pdbx_reference_molecule_annotation","type"); ("pdbx_reference_molecule_annotation","source"); 
    ("pdbx_reference_molecule_features","family_prd_id"); ("pdbx_reference_molecule_features","prd_id"); ("pdbx_reference_molecule_features","ordinal"); ("pdbx_reference_molecule_features","type"); ("pdbx_reference_molecule_features","value"); ("pdbx_reference_molecule_features","source"); 
    ("pdbx_reference_molecule_related_structures","family_prd_id"); ("pdbx_reference_molecule_related_structures","ordinal"); 
    ("pdbx_struct_group_list","struct_group_id"); ("pdbx_struct_group_list","name"); ("pdbx_struct_group_list","type"); ("pdbx_struct_group_list","group_enumeration_type"); ("pdbx_struct_group_list","description"); 
    ("pdbx_struct_group_components","ordinal"); ("pdbx_struct_group_components","struct_group_id"); ("pdbx_struct_group_components","auth_asym_id"); ("pdbx_struct_group_components","auth_comp_id"); ("pdbx_struct_group_components","auth_seq_id"); 
    ("pdbx_struct_group_component_range","ordinal"); ("pdbx_struct_group_component_range","struct_group_id"); ("pdbx_struct_group_component_range","beg_auth_asym_id"); ("pdbx_struct_group_component_range","beg_auth_comp_id"); ("pdbx_struct_group_component_range","beg_auth_seq_id"); ("pdbx_struct_group_component_range","end_auth_asym_id"); ("pdbx_struct_group_component_range","end_auth_comp_id"); ("pdbx_struct_group_component_range","end_auth_seq_id"); 
    ("pdbx_prd_audit","prd_id"); ("pdbx_prd_audit","date"); ("pdbx_prd_audit","action_type"); 
    ("pdbx_family_prd_audit","family_prd_id"); ("pdbx_family_prd_audit","date"); ("pdbx_family_prd_audit","action_type"); 
    ("pdbx_molecule","prd_id"); ("pdbx_molecule","instance_id"); ("pdbx_molecule","asym_id"); 
    ("pdbx_molecule_features","prd_id"); 
    ("pdbx_family_group_index","id"); ("pdbx_family_group_index","family_prd_id"); 
    ("pdbx_distant_solvent_atoms","id"); ("pdbx_distant_solvent_atoms","PDB_model_num"); ("pdbx_distant_solvent_atoms","auth_asym_id"); ("pdbx_distant_solvent_atoms","auth_atom_id"); ("pdbx_distant_solvent_atoms","auth_comp_id"); ("pdbx_distant_solvent_atoms","auth_seq_id"); 
    ("pdbx_struct_special_symmetry","id"); ("pdbx_struct_special_symmetry","PDB_model_num"); ("pdbx_struct_special_symmetry","auth_asym_id"); ("pdbx_struct_special_symmetry","auth_comp_id"); ("pdbx_struct_special_symmetry","auth_seq_id"); 
    ("pdbx_reference_publication_list","publication_abbrev"); 
    ("pdbx_nmr_assigned_chem_shift_list","chem_shift_reference_id"); ("pdbx_nmr_assigned_chem_shift_list","conditions_id"); ("pdbx_nmr_assigned_chem_shift_list","data_file_name"); ("pdbx_nmr_assigned_chem_shift_list","entry_id"); ("pdbx_nmr_assigned_chem_shift_list","id"); 
    ("pdbx_nmr_chem_shift_experiment","assigned_chem_shift_list_id"); ("pdbx_nmr_chem_shift_experiment","entry_id"); ("pdbx_nmr_chem_shift_experiment","experiment_id"); 
    ("pdbx_nmr_chem_shift_ref","atom_group"); ("pdbx_nmr_chem_shift_ref","atom_isotope_number"); ("pdbx_nmr_chem_shift_ref","atom_type"); ("pdbx_nmr_chem_shift_ref","chem_shift_reference_id"); ("pdbx_nmr_chem_shift_ref","chem_shift_units"); ("pdbx_nmr_chem_shift_ref","chem_shift_val"); ("pdbx_nmr_chem_shift_ref","entry_id"); ("pdbx_nmr_chem_shift_ref","mol_common_name"); 
    ("pdbx_nmr_chem_shift_reference","entry_id"); ("pdbx_nmr_chem_shift_reference","id"); ("pdbx_nmr_chem_shift_reference","label"); 
    ("pdbx_nmr_chem_shift_software","assigned_chem_shift_list_id"); ("pdbx_nmr_chem_shift_software","entry_id"); ("pdbx_nmr_chem_shift_software","software_id"); ("pdbx_nmr_chem_shift_software","software_label"); 
    ("pdbx_nmr_constraint_file","constraint_filename"); ("pdbx_nmr_constraint_file","constraint_subtype"); ("pdbx_nmr_constraint_file","constraint_type"); ("pdbx_nmr_constraint_file","entry_id"); 
    ("pdbx_nmr_software_task","entry_id"); ("pdbx_nmr_software_task","software_ordinal"); ("pdbx_nmr_software_task","task"); 
    ("pdbx_nmr_spectral_dim","id"); ("pdbx_nmr_spectral_dim","atom_type"); ("pdbx_nmr_spectral_dim","atom_isotope_number"); ("pdbx_nmr_spectral_dim","spectral_region"); ("pdbx_nmr_spectral_dim","entry_id"); ("pdbx_nmr_spectral_dim","spectral_peak_list_id"); ("pdbx_nmr_spectral_dim","sweep_width_units"); ("pdbx_nmr_spectral_dim","center_frequency_offset"); ("pdbx_nmr_spectral_dim","under_sampling_type"); 
    ("pdbx_nmr_spectral_peak_list","entry_id"); ("pdbx_nmr_spectral_peak_list","id"); ("pdbx_nmr_spectral_peak_list","solution_id"); ("pdbx_nmr_spectral_peak_list","conditions_id"); ("pdbx_nmr_spectral_peak_list","experiment_id"); ("pdbx_nmr_spectral_peak_list","number_of_spectral_dimensions"); 
    ("pdbx_nmr_spectral_peak_software","software_id"); ("pdbx_nmr_spectral_peak_software","entry_id"); ("pdbx_nmr_spectral_peak_software","spectral_peak_list_id"); 
    ("pdbx_nmr_systematic_chem_shift_offset","entry_id"); ("pdbx_nmr_systematic_chem_shift_offset","assigned_chem_shift_list_id"); ("pdbx_nmr_systematic_chem_shift_offset","ordinal"); 
    ("pdbx_nmr_upload","data_file_id"); ("pdbx_nmr_upload","data_file_name"); ("pdbx_nmr_upload","data_file_category"); ("pdbx_nmr_upload","entry_id"); 
    ("pdbx_audit_support","ordinal"); 
    ("pdbx_chem_comp_subcomponent_struct_conn","id"); ("pdbx_chem_comp_subcomponent_struct_conn","type"); ("pdbx_chem_comp_subcomponent_struct_conn","entity_id_1"); ("pdbx_chem_comp_subcomponent_struct_conn","entity_id_2"); ("pdbx_chem_comp_subcomponent_struct_conn","atom_id_1"); ("pdbx_chem_comp_subcomponent_struct_conn","atom_id_2"); ("pdbx_chem_comp_subcomponent_struct_conn","comp_id_1"); ("pdbx_chem_comp_subcomponent_struct_conn","comp_id_2"); ("pdbx_chem_comp_subcomponent_struct_conn","seq_id_1"); ("pdbx_chem_comp_subcomponent_struct_conn","seq_id_2"); 
    ("pdbx_chem_comp_subcomponent_entity_list","id"); ("pdbx_chem_comp_subcomponent_entity_list","parent_comp_id"); ("pdbx_chem_comp_subcomponent_entity_list","type"); ("pdbx_chem_comp_subcomponent_entity_list","class"); 
    ("entity_src_nat","entity_id"); ("entity_src_nat","pdbx_src_id"); 
    ("entity_src_gen","entity_id"); ("entity_src_gen","pdbx_src_id"); 
    ("pdbx_entity_src_syn","entity_id"); ("pdbx_entity_src_syn","pdbx_src_id"); 
    ("pdbx_entity_poly_comp_link_list","link_id"); ("pdbx_entity_poly_comp_link_list","entity_id"); ("pdbx_entity_poly_comp_link_list","entity_comp_num_1"); ("pdbx_entity_poly_comp_link_list","entity_comp_num_2"); ("pdbx_entity_poly_comp_link_list","comp_id_1"); ("pdbx_entity_poly_comp_link_list","comp_id_2"); ("pdbx_entity_poly_comp_link_list","atom_id_1"); ("pdbx_entity_poly_comp_link_list","leaving_atom_id_1"); ("pdbx_entity_poly_comp_link_list","atom_id_2"); ("pdbx_entity_poly_comp_link_list","leaving_atom_id_2"); 
    ("pdbx_linked_entity","linked_entity_id"); 
    ("pdbx_linked_entity_instance_list","linked_entity_id"); ("pdbx_linked_entity_instance_list","instance_id"); ("pdbx_linked_entity_instance_list","asym_id"); 
    ("pdbx_linked_entity_list","linked_entity_id"); ("pdbx_linked_entity_list","entity_id"); ("pdbx_linked_entity_list","component_id"); 
    ("pdbx_linked_entity_link_list","link_id"); ("pdbx_linked_entity_link_list","linked_entity_id"); ("pdbx_linked_entity_link_list","entity_id_1"); ("pdbx_linked_entity_link_list","entity_id_2"); ("pdbx_linked_entity_link_list","comp_id_1"); ("pdbx_linked_entity_link_list","comp_id_2"); ("pdbx_linked_entity_link_list","atom_id_1"); ("pdbx_linked_entity_link_list","atom_id_2"); ("pdbx_linked_entity_link_list","component_1"); ("pdbx_linked_entity_link_list","component_2"); 
    ("pdbx_entity_descriptor","entity_id"); ("pdbx_entity_descriptor","descriptor"); ("pdbx_entity_descriptor","type"); ("pdbx_entity_descriptor","ordinal"); 
    ("pdbx_reference_linked_entity","id"); 
    ("pdbx_reference_linked_entity_comp_list","linked_entity_id"); ("pdbx_reference_linked_entity_comp_list","list_id"); 
    ("pdbx_reference_linked_entity_comp_link","linked_entity_id"); ("pdbx_reference_linked_entity_comp_link","link_id"); ("pdbx_reference_linked_entity_comp_link","list_id_1"); ("pdbx_reference_linked_entity_comp_link","list_id_2"); ("pdbx_reference_linked_entity_comp_link","comp_id_1"); ("pdbx_reference_linked_entity_comp_link","comp_id_2"); ("pdbx_reference_linked_entity_comp_link","atom_id_1"); ("pdbx_reference_linked_entity_comp_link","atom_id_2"); ("pdbx_reference_linked_entity_comp_link","leaving_atom_id_1"); ("pdbx_reference_linked_entity_comp_link","leaving_atom_id_2"); 
    ("pdbx_reference_linked_entity_link","linked_entity_id"); ("pdbx_reference_linked_entity_link","link_id"); ("pdbx_reference_linked_entity_link","from_list_id"); ("pdbx_reference_linked_entity_link","to_comp_id"); ("pdbx_reference_linked_entity_link","from_comp_id"); ("pdbx_reference_linked_entity_link","to_atom_id"); ("pdbx_reference_linked_entity_link","from_atom_id"); ("pdbx_reference_linked_entity_link","from_leaving_atom_id"); 
    ("pdbx_related_exp_data_set","ordinal"); ("pdbx_related_exp_data_set","data_reference"); ("pdbx_related_exp_data_set","data_set_type"); 
    ("pdbx_database_status_history","entry_id"); ("pdbx_database_status_history","ordinal"); ("pdbx_database_status_history","date_begin"); ("pdbx_database_status_history","status_code"); 
    ("em_assembly","id"); ("em_assembly","entry_id"); 
    ("em_entity_assembly","id"); ("em_entity_assembly","parent_id"); ("em_entity_assembly","name"); 
    ("em_virus_entity","id"); ("em_virus_entity","entity_assembly_id"); 
    ("em_sample_preparation","entry_id"); ("em_sample_preparation","id"); 
    ("em_sample_support","id"); ("em_sample_support","specimen_id"); 
    ("em_buffer","id"); ("em_buffer","specimen_id"); 
    ("em_vitrification","entry_id"); ("em_vitrification","id"); ("em_vitrification","specimen_id"); 
    ("em_imaging","entry_id"); ("em_imaging","id"); ("em_imaging","microscope_model"); ("em_imaging","illumination_mode"); ("em_imaging","mode"); ("em_imaging","specimen_id"); 
    ("em_detector","entry_id"); ("em_detector","id"); 
    ("em_image_scans","entry_id"); ("em_image_scans","id"); ("em_image_scans","image_recording_id"); 
    ("em_2d_projection_selection","entry_id"); ("em_2d_projection_selection","id"); 
    ("em_3d_reconstruction","entry_id"); ("em_3d_reconstruction","id"); ("em_3d_reconstruction","image_processing_id"); 
    ("em_3d_fitting","id"); ("em_3d_fitting","entry_id"); 
    ("em_3d_fitting_list","id"); ("em_3d_fitting_list","3d_fitting_id"); 
    ("em_helical_entity","id"); ("em_helical_entity","image_processing_id"); ("em_helical_entity","axial_symmetry"); 
    ("em_experiment","entry_id"); ("em_experiment","id"); ("em_experiment","reconstruction_method"); ("em_experiment","aggregation_state"); ("em_experiment","entity_assembly_id"); 
    ("em_single_particle_entity","entry_id"); ("em_single_particle_entity","id"); ("em_single_particle_entity","image_processing_id"); 
    ("em_admin","current_status"); ("em_admin","deposition_date"); ("em_admin","deposition_site"); ("em_admin","entry_id"); ("em_admin","last_update"); ("em_admin","replace_existing_entry_flag"); ("em_admin","title"); 
    ("em_author_list","author"); ("em_author_list","ordinal"); 
    ("em_db_reference","access_code"); ("em_db_reference","db_name"); ("em_db_reference","id"); 
    ("em_db_reference_auxiliary","id"); ("em_db_reference_auxiliary","link"); ("em_db_reference_auxiliary","link_type"); 
    ("em_depui","depositor_hold_instructions"); ("em_depui","entry_id"); ("em_depui","macromolecule_description"); ("em_depui","obsolete_instructions"); ("em_depui","same_authors_as_pdb"); ("em_depui","same_title_as_pdb"); 
    ("em_obsolete","date"); ("em_obsolete","entry"); ("em_obsolete","id"); 
    ("em_supersede","date"); ("em_supersede","entry"); ("em_supersede","id"); 
    ("em_entity_assembly_molwt","entity_assembly_id"); ("em_entity_assembly_molwt","id"); 
    ("em_entity_assembly_naturalsource","entity_assembly_id"); ("em_entity_assembly_naturalsource","id"); ("em_entity_assembly_naturalsource","ncbi_tax_id"); ("em_entity_assembly_naturalsource","organism"); 
    ("em_entity_assembly_recombinant","entity_assembly_id"); ("em_entity_assembly_recombinant","id"); ("em_entity_assembly_recombinant","ncbi_tax_id"); ("em_entity_assembly_recombinant","organism"); 
    ("em_virus_natural_host","entity_assembly_id"); ("em_virus_natural_host","id"); 
    ("em_virus_shell","entity_assembly_id"); ("em_virus_shell","id"); 
    ("em_specimen","embedding_applied"); ("em_specimen","experiment_id"); ("em_specimen","id"); ("em_specimen","shadowing_applied"); ("em_specimen","staining_applied"); ("em_specimen","vitrification_applied"); 
    ("em_embedding","id"); ("em_embedding","material"); ("em_embedding","specimen_id"); 
    ("em_fiducial_markers","diameter"); ("em_fiducial_markers","em_tomography_specimen_id"); ("em_fiducial_markers","id"); ("em_fiducial_markers","manufacturer"); 
    ("em_focused_ion_beam","current"); ("em_focused_ion_beam","dose_rate"); ("em_focused_ion_beam","duration"); ("em_focused_ion_beam","em_tomography_specimen_id"); ("em_focused_ion_beam","final_thickness"); ("em_focused_ion_beam","id"); ("em_focused_ion_beam","initial_thickness"); ("em_focused_ion_beam","instrument"); ("em_focused_ion_beam","ion"); ("em_focused_ion_beam","temperature"); ("em_focused_ion_beam","voltage"); 
    ("em_grid_pretreatment","id"); ("em_grid_pretreatment","sample_support_id"); 
    ("em_ultramicrotomy","em_tomography_specimen_id"); ("em_ultramicrotomy","final_thickness"); ("em_ultramicrotomy","id"); ("em_ultramicrotomy","instrument"); ("em_ultramicrotomy","temperature"); 
    ("em_high_pressure_freezing","em_tomography_specimen_id"); ("em_high_pressure_freezing","id"); ("em_high_pressure_freezing","instrument"); 
    ("em_shadowing","angle"); ("em_shadowing","id"); ("em_shadowing","material"); ("em_shadowing","specimen_id"); ("em_shadowing","thickness"); 
    ("em_tomography_specimen","id"); ("em_tomography_specimen","specimen_id"); 
    ("em_crystal_formation","id"); ("em_crystal_formation","specimen_id"); 
    ("em_staining","id"); ("em_staining","material"); ("em_staining","specimen_id"); ("em_staining","type"); 
    ("em_support_film","id"); ("em_support_film","sample_support_id"); 
    ("em_buffer_component","buffer_id"); ("em_buffer_component","id"); 
    ("em_diffraction","camera_length"); ("em_diffraction","id"); ("em_diffraction","imaging_id"); 
    ("em_diffraction_shell","fourier_space_coverage"); ("em_diffraction_shell","high_resolution"); ("em_diffraction_shell","id"); ("em_diffraction_shell","low_resolution"); ("em_diffraction_shell","multiplicity"); ("em_diffraction_shell","num_structure_factors"); ("em_diffraction_shell","phase_residual"); 
    ("em_diffraction_stats","fourier_space_coverage"); ("em_diffraction_stats","high_resolution"); ("em_diffraction_stats","id"); ("em_diffraction_stats","num_intensities_measured"); ("em_diffraction_stats","num_structure_factors"); ("em_diffraction_stats","overall_phase_error"); ("em_diffraction_stats","overall_phase_residual"); ("em_diffraction_stats","phase_error_rejection_criteria"); ("em_diffraction_stats","r_merge"); ("em_diffraction_stats","r_sym"); 
    ("em_tomography","id"); ("em_tomography","imaging_id"); 
    ("em_image_recording","id"); ("em_image_recording","imaging_id"); 
    ("em_imaging_optics","id"); ("em_imaging_optics","imaging_id"); 
    ("em_final_classification","id"); ("em_final_classification","image_processing_id"); 
    ("em_start_model","id"); ("em_start_model","image_processing_id"); ("em_start_model","type"); 
    ("em_software","id"); 
    ("em_euler_angle_assignment","id"); ("em_euler_angle_assignment","image_processing_id"); ("em_euler_angle_assignment","order"); ("em_euler_angle_assignment","type"); 
    ("em_ctf_correction","id"); 
    ("em_volume_selection","id"); ("em_volume_selection","image_processing_id"); ("em_volume_selection","num_tomograms"); ("em_volume_selection","num_volumes_extracted"); 
    ("em_3d_crystal_entity","angle_alpha"); ("em_3d_crystal_entity","angle_beta"); ("em_3d_crystal_entity","angle_gamma"); ("em_3d_crystal_entity","image_processing_id"); ("em_3d_crystal_entity","id"); ("em_3d_crystal_entity","length_a"); ("em_3d_crystal_entity","length_b"); ("em_3d_crystal_entity","length_c"); ("em_3d_crystal_entity","space_group_name"); ("em_3d_crystal_entity","space_group_num"); 
    ("em_2d_crystal_entity","angle_gamma"); ("em_2d_crystal_entity","image_processing_id"); ("em_2d_crystal_entity","id"); ("em_2d_crystal_entity","length_a"); ("em_2d_crystal_entity","length_b"); ("em_2d_crystal_entity","length_c"); ("em_2d_crystal_entity","space_group_name_H-M"); 
    ("em_image_processing","id"); ("em_image_processing","image_recording_id"); 
    ("em_particle_selection","id"); ("em_particle_selection","image_processing_id"); 
    ("em_map","axis_order_fast"); ("em_map","axis_order_medium"); ("em_map","axis_order_slow"); ("em_map","cell_a"); ("em_map","cell_b"); ("em_map","cell_c"); ("em_map","cell_alpha"); ("em_map","cell_beta"); ("em_map","cell_gamma"); ("em_map","data_type"); ("em_map","dimensions_col"); ("em_map","dimensions_row"); ("em_map","dimensions_sec"); ("em_map","endian_type"); ("em_map","format"); ("em_map","id"); ("em_map","partition"); ("em_map","entry_id"); ("em_map","origin_col"); ("em_map","origin_row"); ("em_map","origin_sec"); ("em_map","pixel_spacing_x"); ("em_map","pixel_spacing_y"); ("em_map","pixel_spacing_z"); ("em_map","size_kb"); ("em_map","spacing_x"); ("em_map","spacing_y"); ("em_map","spacing_z"); ("em_map","symmetry_space_group"); ("em_map","type"); 
    ("em_fsc_curve","id"); 
    ("em_interpret_figure","file"); ("em_interpret_figure","id"); 
    ("em_layer_lines","experiment_id"); ("em_layer_lines","file"); ("em_layer_lines","id"); 
    ("em_structure_factors","experiment_id"); ("em_structure_factors","file"); ("em_structure_factors","id"); 
    ("em_depositor_info","entry_id"); ("em_depositor_info","em_method_selection"); 
    ("em_map_depositor_info","entry_id"); ("em_map_depositor_info","id"); ("em_map_depositor_info","map_type"); ("em_map_depositor_info","upload_file_name"); ("em_map_depositor_info","upload_format"); ("em_map_depositor_info","pixel_spacing_x"); ("em_map_depositor_info","pixel_spacing_y"); ("em_map_depositor_info","pixel_spacing_z"); 
    ("em_mask_depositor_info","id"); ("em_mask_depositor_info","upload_file_name"); ("em_mask_depositor_info","upload_format"); ("em_mask_depositor_info","pixel_spacing_x"); ("em_mask_depositor_info","pixel_spacing_y"); ("em_mask_depositor_info","pixel_spacing_z"); 
    ("em_figure_depositor_info","id"); ("em_figure_depositor_info","upload_file_name"); 
    ("em_layer_lines_depositor_info","id"); ("em_layer_lines_depositor_info","upload_file_name"); 
    ("em_structure_factors_depositor_info","id"); ("em_structure_factors_depositor_info","upload_file_name"); 
    ("pdbx_seq_map_depositor_info","entity_id"); ("pdbx_seq_map_depositor_info","auth_asym_id"); ("pdbx_seq_map_depositor_info","one_letter_code"); 
    ("pdbx_chem_comp_depositor_info","ordinal"); ("pdbx_chem_comp_depositor_info","comp_id"); 
    ("pdbx_struct_ref_seq_depositor_info","ref_id"); ("pdbx_struct_ref_seq_depositor_info","entity_id"); 
    ("pdbx_struct_ref_seq_dif_depositor_info","ordinal"); ("pdbx_struct_ref_seq_dif_depositor_info","ref_id"); ("pdbx_struct_ref_seq_dif_depositor_info","entity_id"); 
    ("pdbx_struct_assembly_prop_depositor_info","biol_id"); ("pdbx_struct_assembly_prop_depositor_info","type"); ("pdbx_struct_assembly_prop_depositor_info","value"); 
    ("pdbx_struct_assembly_depositor_info","id"); 
    ("pdbx_struct_assembly_gen_depositor_info","id"); ("pdbx_struct_assembly_gen_depositor_info","asym_id_list"); ("pdbx_struct_assembly_gen_depositor_info","assembly_id"); ("pdbx_struct_assembly_gen_depositor_info","oper_expression"); 
    ("pdbx_struct_oper_list_depositor_info","id"); ("pdbx_struct_oper_list_depositor_info","type"); 
    ("pdbx_point_symmetry_depositor_info","entry_id"); ("pdbx_point_symmetry_depositor_info","Schoenflies_symbol"); 
    ("pdbx_helical_symmetry_depositor_info","entry_id"); 
    ("pdbx_struct_assembly_auth_evidence_depositor_info","id"); ("pdbx_struct_assembly_auth_evidence_depositor_info","assembly_id"); ("pdbx_struct_assembly_auth_evidence_depositor_info","experimental_support"); 
    ("pdbx_solvent_atom_site_mapping","id"); 
    ("pdbx_molecule_features_depositor_info","entity_id"); 
    ("pdbx_chem_comp_instance_depositor_info","ordinal"); ("pdbx_chem_comp_instance_depositor_info","comp_id"); ("pdbx_chem_comp_instance_depositor_info","auth_asym_id"); ("pdbx_chem_comp_instance_depositor_info","auth_seq_id"); 
    ("pdbx_depui_status_flags","dep_dataset_id"); ("pdbx_depui_status_flags","has_accepted_terms_and_conditions"); ("pdbx_depui_status_flags","is_ligand_processing_complete"); ("pdbx_depui_status_flags","sample_xyz_sequence_alignments_valid"); 
    ("pdbx_depui_upload","ordinal"); 
    ("pdbx_depui_validation_status_flags","dep_dataset_id"); 
    ("pdbx_chem_comp_upload_depositor_info","ordinal"); ("pdbx_chem_comp_upload_depositor_info","comp_id"); ("pdbx_chem_comp_upload_depositor_info","upload_file_type"); ("pdbx_chem_comp_upload_depositor_info","upload_file_name"); 
    ("pdbx_depui_entity_status_flags","dep_dataset_id"); ("pdbx_depui_entity_status_flags","entity_id"); ("pdbx_depui_entity_status_flags","sample_xyz_sequence_alignments_valid"); 
    ("pdbx_depui_entity_features","dep_dataset_id"); ("pdbx_depui_entity_features","entity_id"); ("pdbx_depui_entity_features","type"); 
    ("pdbx_deposition_message_info","ordinal"); ("pdbx_deposition_message_info","deposition_data_set_id"); ("pdbx_deposition_message_info","message_id"); ("pdbx_deposition_message_info","timestamp"); ("pdbx_deposition_message_info","sender"); ("pdbx_deposition_message_info","content_type"); ("pdbx_deposition_message_info","content_value"); ("pdbx_deposition_message_info","parent_message_id"); ("pdbx_deposition_message_info","message_subject"); ("pdbx_deposition_message_info","message_text"); ("pdbx_deposition_message_info","message_type"); ("pdbx_deposition_message_info","send_status"); 
    ("pdbx_deposition_message_file_reference","ordinal"); ("pdbx_deposition_message_file_reference","deposition_data_set_id"); ("pdbx_deposition_message_file_reference","message_id"); ("pdbx_deposition_message_file_reference","content_type"); ("pdbx_deposition_message_file_reference","content_format"); ("pdbx_deposition_message_file_reference","partition_number"); ("pdbx_deposition_message_file_reference","version_id"); ("pdbx_deposition_message_file_reference","storage_type"); 
    ("pdbx_depui_entry_details","dep_dataset_id"); ("pdbx_depui_entry_details","experimental_methods"); ("pdbx_depui_entry_details","requested_accession_types"); ("pdbx_depui_entry_details","validated_contact_email"); ("pdbx_depui_entry_details","country"); 
    ("pdbx_data_processing_status","task_name"); ("pdbx_data_processing_status","status"); 
    ("pdbx_entity_instance_feature","ordinal"); 
    ("pdbx_entity_src_gen_depositor_info","src_id"); ("pdbx_entity_src_gen_depositor_info","entity_id"); ("pdbx_entity_src_gen_depositor_info","beg_seq_num"); ("pdbx_entity_src_gen_depositor_info","end_seq_num"); 
    ("pdbx_chem_comp_model","id"); ("pdbx_chem_comp_model","comp_id"); 
    ("pdbx_chem_comp_model_atom","atom_id"); ("pdbx_chem_comp_model_atom","ordinal_id"); ("pdbx_chem_comp_model_atom","model_id"); ("pdbx_chem_comp_model_atom","type_symbol"); 
    ("pdbx_chem_comp_model_bond","atom_id_1"); ("pdbx_chem_comp_model_bond","atom_id_2"); ("pdbx_chem_comp_model_bond","model_id"); ("pdbx_chem_comp_model_bond","ordinal_id"); 
    ("pdbx_chem_comp_model_feature","model_id"); ("pdbx_chem_comp_model_feature","feature_name"); ("pdbx_chem_comp_model_feature","feature_value"); 
    ("pdbx_chem_comp_model_descriptor","model_id"); ("pdbx_chem_comp_model_descriptor","descriptor"); ("pdbx_chem_comp_model_descriptor","type"); 
    ("pdbx_chem_comp_model_audit","model_id"); ("pdbx_chem_comp_model_audit","date"); ("pdbx_chem_comp_model_audit","action_type"); 
    ("pdbx_chem_comp_model_reference","model_id"); ("pdbx_chem_comp_model_reference","db_name"); ("pdbx_chem_comp_model_reference","db_code"); 
    ("pdbx_view_category_group","view_group_id"); ("pdbx_view_category_group","description"); 
    ("pdbx_view_category","view_group_id"); ("pdbx_view_category","category_id"); ("pdbx_view_category","category_view_name"); 
    ("pdbx_view_item","item_name"); ("pdbx_view_item","category_id"); ("pdbx_view_item","item_view_name"); ("pdbx_view_item","item_view_mandatory_code"); 
    ("pdbx_coord","entry_id"); ("pdbx_coord","chain_atoms_Y_P"); ("pdbx_coord","hydrogen_atoms_Y_N"); ("pdbx_coord","solvent_atoms_Y_N"); ("pdbx_coord","structure_factors_Y_N"); 
    ("pdbx_connect","res_name"); 
    ("pdbx_connect_type","res_name"); 
    ("pdbx_connect_modification","res_name"); ("pdbx_connect_modification","modification"); 
    ("pdbx_connect_atom","res_name"); ("pdbx_connect_atom","atom_name"); ("pdbx_connect_atom","connect_to"); ("pdbx_connect_atom","type_symbol"); ("pdbx_connect_atom","charge"); 
    ("pdbx_database_PDB_master","entry_id"); 
    ("pdbx_database_pdb_omit","entry_id"); ("pdbx_database_pdb_omit","record_name"); 
    ("pdbx_dbref","pdb_id_code"); ("pdbx_dbref","chain_id"); ("pdbx_dbref","begin_res_number"); ("pdbx_dbref","end_res_number"); ("pdbx_dbref","database_name"); 
    ("pdbx_drug_info","id"); ("pdbx_drug_info","name"); ("pdbx_drug_info","num_per_asym_unit"); 
    ("pdbx_inhibitor_info","id"); ("pdbx_inhibitor_info","name"); ("pdbx_inhibitor_info","num_per_asym_unit"); 
    ("pdbx_ion_info","id"); ("pdbx_ion_info","name"); ("pdbx_ion_info","numb_per_asym_unit"); 
    ("pdbx_hybrid","id"); ("pdbx_hybrid","sugar_name"); ("pdbx_hybrid","strand_id"); ("pdbx_hybrid","residue_names"); 
    ("pdbx_na_strand_info","id"); ("pdbx_na_strand_info","num_of_NA_strands_per_asym_unit"); 
    ("pdbx_nonstandard_list","id"); ("pdbx_nonstandard_list","label_asym_id"); ("pdbx_nonstandard_list","label_seq_id"); 
    ("pdbx_pdb_compnd","id"); 
    ("pdbx_pdb_source","id"); 
    ("pdbx_protein_info","id"); ("pdbx_protein_info","name"); ("pdbx_protein_info","num_per_asym_unit"); 
    ("pdbx_solvent_info","id"); ("pdbx_solvent_info","name"); ("pdbx_solvent_info","numb_per_asym_unit"); 
    ("pdbx_source","src_method"); 
    ("pdbx_struct_biol_func","id"); ("pdbx_struct_biol_func","biol_id"); ("pdbx_struct_biol_func","function"); 
    ("pdbx_struct_pack_gen","id"); ("pdbx_struct_pack_gen","asym_id"); ("pdbx_struct_pack_gen","symmetry"); 
    ("pdbx_trna_info","id"); ("pdbx_trna_info","name"); ("pdbx_trna_info","num_per_asym_unit"); 
    ("pdbx_unpair","chain_id"); 
    ("pdbx_refine_ls_restr_ncs","dom_id"); 
    ("pdbx_struct_ncs_virus_gen","id"); ("pdbx_struct_ncs_virus_gen","oper_id"); ("pdbx_struct_ncs_virus_gen","asym_id"); ("pdbx_struct_ncs_virus_gen","pdb_chain_id"); 
    ("pdbx_sequence_annotation","pdb_chain_id"); ("pdbx_sequence_annotation","ncbi_taxid"); 
    ("pdbx_chem_comp_synonyms","name"); ("pdbx_chem_comp_synonyms","synonym"); 
    ("pdbx_post_process_details","entry_id"); 
    ("pdbx_post_process_status","entry_id"); ("pdbx_post_process_status","cycle_id"); ("pdbx_post_process_status","date_begin"); ("pdbx_post_process_status","date_end"); ("pdbx_post_process_status","details"); ("pdbx_post_process_status","annotator"); 
    ("pdbx_struct_link","id"); ("pdbx_struct_link","ptnr1_label_asym_id"); ("pdbx_struct_link","ptnr1_label_atom_id"); ("pdbx_struct_link","ptnr1_label_comp_id"); ("pdbx_struct_link","ptnr1_label_seq_id"); ("pdbx_struct_link","ptnr2_label_asym_id"); ("pdbx_struct_link","ptnr2_label_atom_id"); ("pdbx_struct_link","ptnr2_label_comp_id"); ("pdbx_struct_link","ptnr2_label_seq_id"); 
    ("pdbx_missing_residue_list","pdb_chain_id"); ("pdbx_missing_residue_list","pdb_residue_name"); ("pdbx_missing_residue_list","pdb_residue_number"); 
    ("pdbx_data_processing_cell","entry_id"); 
    ("pdbx_data_processing_reflns","entry_id"); 
    ("pdbx_data_processing_detector","entry_id"); 
    ("pdbx_chem_comp_nonstandard","comp_id"); ("pdbx_chem_comp_nonstandard","type"); 
    ("pdbx_entity_poly_protein_class","entity_id"); ("pdbx_entity_poly_protein_class","class"); 
    ("pdbx_entity_name_taxonomy_tree","id"); ("pdbx_entity_name_taxonomy_tree","parent_id"); 
    ("pdbx_entity_name_taxonomy","id"); ("pdbx_entity_name_taxonomy","name"); ("pdbx_entity_name_taxonomy","name_type"); 
    ("pdbx_entity_name_instance","name"); ("pdbx_entity_name_instance","pdb_id"); ("pdbx_entity_name_instance","rcsb_id"); ("pdbx_entity_name_instance","entity_id"); ("pdbx_entity_name_instance","pdb_chain_id"); ("pdbx_entity_name_instance","pdb_mol_id"); 
    ("pdbx_tableinfo","tablename"); ("pdbx_tableinfo","description"); ("pdbx_tableinfo","type"); ("pdbx_tableinfo","table_serial_no"); ("pdbx_tableinfo","group_name"); ("pdbx_tableinfo","WWW_Selection_Criteria"); ("pdbx_tableinfo","WWW_Report_Criteria"); 
    ("pdbx_columninfo","columnname"); ("pdbx_columninfo","tablename"); ("pdbx_columninfo","description"); ("pdbx_columninfo","example"); ("pdbx_columninfo","type"); ("pdbx_columninfo","table_serial_no"); ("pdbx_columninfo","column_serial_no"); ("pdbx_columninfo","WWW_Selection_Criteria"); ("pdbx_columninfo","WWW_Report_Criteria"); 
    ("pdbx_val_angle","id"); ("pdbx_val_angle","model_id"); ("pdbx_val_angle","auth_asym_id_1"); ("pdbx_val_angle","auth_atom_id_1"); ("pdbx_val_angle","auth_comp_id_1"); ("pdbx_val_angle","auth_seq_id_1"); ("pdbx_val_angle","auth_atom_id_2"); ("pdbx_val_angle","auth_asym_id_2"); ("pdbx_val_angle","auth_comp_id_2"); ("pdbx_val_angle","auth_seq_id_2"); ("pdbx_val_angle","auth_atom_id_3"); ("pdbx_val_angle","auth_asym_id_3"); ("pdbx_val_angle","auth_comp_id_3"); ("pdbx_val_angle","auth_seq_id_3"); ("pdbx_val_angle","angle"); ("pdbx_val_angle","angle_deviation"); 
    ("pdbx_val_bond","id"); ("pdbx_val_bond","model_id"); ("pdbx_val_bond","auth_asym_id_1"); ("pdbx_val_bond","auth_atom_id_1"); ("pdbx_val_bond","auth_comp_id_1"); ("pdbx_val_bond","auth_seq_id_1"); ("pdbx_val_bond","auth_atom_id_2"); ("pdbx_val_bond","auth_asym_id_2"); ("pdbx_val_bond","auth_comp_id_2"); ("pdbx_val_bond","auth_seq_id_2"); ("pdbx_val_bond","bond"); ("pdbx_val_bond","bond_deviation"); 
    ("pdbx_val_contact","id"); ("pdbx_val_contact","model_id"); ("pdbx_val_contact","auth_asym_id_1"); ("pdbx_val_contact","auth_atom_id_1"); ("pdbx_val_contact","auth_comp_id_1"); ("pdbx_val_contact","auth_seq_id_1"); ("pdbx_val_contact","auth_atom_id_2"); ("pdbx_val_contact","auth_asym_id_2"); ("pdbx_val_contact","auth_comp_id_2"); ("pdbx_val_contact","auth_seq_id_2"); ("pdbx_val_contact","dist"); 
    ("pdbx_val_sym_contact","id"); ("pdbx_val_sym_contact","model_id"); ("pdbx_val_sym_contact","auth_asym_id_1"); ("pdbx_val_sym_contact","auth_atom_id_1"); ("pdbx_val_sym_contact","auth_comp_id_1"); ("pdbx_val_sym_contact","auth_seq_id_1"); ("pdbx_val_sym_contact","auth_atom_id_2"); ("pdbx_val_sym_contact","auth_asym_id_2"); ("pdbx_val_sym_contact","auth_comp_id_2"); ("pdbx_val_sym_contact","auth_seq_id_2"); ("pdbx_val_sym_contact","dist"); 
    ("pdbx_rmch_outlier","id"); ("pdbx_rmch_outlier","model_id"); ("pdbx_rmch_outlier","auth_asym_id"); ("pdbx_rmch_outlier","auth_comp_id"); ("pdbx_rmch_outlier","auth_seq_id"); ("pdbx_rmch_outlier","phi"); ("pdbx_rmch_outlier","psi"); 
    ("pdbx_missing_atom_poly","id"); ("pdbx_missing_atom_poly","model_id"); ("pdbx_missing_atom_poly","auth_asym_id"); ("pdbx_missing_atom_poly","auth_comp_id"); ("pdbx_missing_atom_poly","auth_seq_id"); ("pdbx_missing_atom_poly","atom_name"); 
    ("pdbx_missing_atom_nonpoly","id"); ("pdbx_missing_atom_nonpoly","model_id"); ("pdbx_missing_atom_nonpoly","auth_asym_id"); ("pdbx_missing_atom_nonpoly","auth_comp_id"); ("pdbx_missing_atom_nonpoly","auth_seq_id"); ("pdbx_missing_atom_nonpoly","atom_name"); 
    ("pdbx_val_chiral","id"); ("pdbx_val_chiral","model_id"); ("pdbx_val_chiral","auth_asym_id"); ("pdbx_val_chiral","auth_comp_id"); ("pdbx_val_chiral","auth_seq_id"); ("pdbx_val_chiral","chiral_center_atom_name"); ("pdbx_val_chiral","chiral_neighbor_atom_name"); 
    ("pdbx_atlas","entry_id"); ("pdbx_atlas","page_id"); ("pdbx_atlas","page_name"); 
    ("pdbx_summary_flags","entry_id"); ("pdbx_summary_flags","flag_id"); ("pdbx_summary_flags","flag_value"); 
    ("pdbx_entity_func_bind_mode","id"); ("pdbx_entity_func_bind_mode","domain_id"); ("pdbx_entity_func_bind_mode","entity_id"); ("pdbx_entity_func_bind_mode","protein_binds_to"); ("pdbx_entity_func_bind_mode","type"); 
    ("pdbx_entity_func_enzyme","bind_mode_id"); ("pdbx_entity_func_enzyme","type"); 
    ("pdbx_entity_func_regulatory","bind_mode_id"); ("pdbx_entity_func_regulatory","type"); 
    ("pdbx_entity_func_structural","bind_mode_id"); ("pdbx_entity_func_structural","type"); 
    ("pdbx_entity_func_other","bind_mode_id"); ("pdbx_entity_func_other","type"); 
    ("pdbx_entity_poly_domain","id"); ("pdbx_entity_poly_domain","entity_id"); ("pdbx_entity_poly_domain","begin_mon_id"); ("pdbx_entity_poly_domain","begin_seq_num"); ("pdbx_entity_poly_domain","end_mon_id"); ("pdbx_entity_poly_domain","end_seq_num"); 
    ("pdbx_na_struct_keywds","entry_id"); 
    ("pdbx_entity_poly_na_type","entity_id"); ("pdbx_entity_poly_na_type","type"); 
    ("pdbx_entity_poly_na_nonstandard","entity_id"); ("pdbx_entity_poly_na_nonstandard","feature"); 
    ("pdbx_virtual_angle","model_id"); ("pdbx_virtual_angle","atom_site_id_1"); ("pdbx_virtual_angle","atom_site_id_2"); ("pdbx_virtual_angle","atom_site_id_3"); ("pdbx_virtual_angle","site_symmetry_1"); ("pdbx_virtual_angle","site_symmetry_2"); ("pdbx_virtual_angle","site_symmetry_3"); 
    ("pdbx_virtual_bond","model_id"); ("pdbx_virtual_bond","atom_site_id_1"); ("pdbx_virtual_bond","atom_site_id_2"); ("pdbx_virtual_bond","site_symmetry_1"); ("pdbx_virtual_bond","site_symmetry_2"); 
    ("pdbx_virtual_torsion","model_id"); ("pdbx_virtual_torsion","atom_site_id_1"); ("pdbx_virtual_torsion","atom_site_id_2"); ("pdbx_virtual_torsion","atom_site_id_3"); ("pdbx_virtual_torsion","atom_site_id_4"); ("pdbx_virtual_torsion","site_symmetry_1"); ("pdbx_virtual_torsion","site_symmetry_2"); ("pdbx_virtual_torsion","site_symmetry_3"); ("pdbx_virtual_torsion","site_symmetry_4"); 
    ("pdbx_sequence_pattern","label_asym_id"); ("pdbx_sequence_pattern","pattern_count"); ("pdbx_sequence_pattern","sequence_pattern"); 
    ("pdbx_stereochemistry","id"); ("pdbx_stereochemistry","model_id"); ("pdbx_stereochemistry","label_comp_id"); ("pdbx_stereochemistry","auth_seq_id"); ("pdbx_stereochemistry","label_seq_id"); ("pdbx_stereochemistry","label_atom_id"); ("pdbx_stereochemistry","label_alt_id"); ("pdbx_stereochemistry","label_atom_id_u"); ("pdbx_stereochemistry","label_alt_id_u"); ("pdbx_stereochemistry","label_atom_id_v"); ("pdbx_stereochemistry","label_alt_id_v"); ("pdbx_stereochemistry","label_atom_id_w"); ("pdbx_stereochemistry","label_alt_id_w"); ("pdbx_stereochemistry","volume3"); ("pdbx_stereochemistry","angle_out_of_plane"); 
    ("pdbx_rms_devs_covalent","entry_id"); ("pdbx_rms_devs_covalent","rms_bonds"); ("pdbx_rms_devs_covalent","num_bonds"); ("pdbx_rms_devs_covalent","rms_bonds_base"); ("pdbx_rms_devs_covalent","num_bonds_base"); ("pdbx_rms_devs_covalent","rms_bonds_sugar"); ("pdbx_rms_devs_covalent","num_bonds_sugar"); ("pdbx_rms_devs_covalent","rms_bonds_phosphate"); ("pdbx_rms_devs_covalent","num_bonds_phosphate"); ("pdbx_rms_devs_covalent","rms_angles"); ("pdbx_rms_devs_covalent","num_angles"); ("pdbx_rms_devs_covalent","rms_angles_base"); ("pdbx_rms_devs_covalent","num_angles_base"); ("pdbx_rms_devs_covalent","rms_angles_sugar"); ("pdbx_rms_devs_covalent","num_angles_sugar"); ("pdbx_rms_devs_covalent","rms_angles_phosphate"); ("pdbx_rms_devs_covalent","num_angles_phosphate"); 
    ("pdbx_rms_devs_cov_by_monomer","id"); ("pdbx_rms_devs_cov_by_monomer","model_id"); ("pdbx_rms_devs_cov_by_monomer","label_comp_id"); ("pdbx_rms_devs_cov_by_monomer","auth_seq_id"); ("pdbx_rms_devs_cov_by_monomer","label_seq_id"); ("pdbx_rms_devs_cov_by_monomer","rms_bonds"); ("pdbx_rms_devs_cov_by_monomer","num_bonds"); ("pdbx_rms_devs_cov_by_monomer","rms_angles"); ("pdbx_rms_devs_cov_by_monomer","num_angles"); 
    ("pdbx_sugar_phosphate_geometry","id"); ("pdbx_sugar_phosphate_geometry","model_id"); ("pdbx_sugar_phosphate_geometry","label_comp_id"); ("pdbx_sugar_phosphate_geometry","label_seq_id"); 
    ("pdbx_nmr_computing","entry_id"); 
    ("pdbx_audit_conform_extension","extension_dict_name"); ("pdbx_audit_conform_extension","extension_dict_version"); 
    ("pdbx_dcc_mapman","pdbid"); 
    ("pdbx_dcc_rscc_mapman","id"); 
    ("pdbx_dcc_rscc_mapman_overall","pdbid"); 
    ("pdbx_dcc_density","pdbid"); 
    ("pdbx_dcc_geometry","pdbid"); 
    ("pdbx_dcc_density_corr","ordinal"); 
    ("pdbx_dcc_map","id"); 
    ("pdbx_deposit_group","group_id"); 
    ("pdbx_deposit_group_index","group_id"); ("pdbx_deposit_group_index","ordinal_id"); 
    ("pdbx_struct_assembly_auth_evidence","id"); ("pdbx_struct_assembly_auth_evidence","assembly_id"); ("pdbx_struct_assembly_auth_evidence","experimental_support"); 
    ("pdbx_struct_assembly_auth_classification","assembly_id"); ("pdbx_struct_assembly_auth_classification","reason_for_interest"); 
    ("pdbx_crystal_alignment","crystal_id"); 
    ("pdbx_audit_revision_history","ordinal"); ("pdbx_audit_revision_history","data_content_type"); ("pdbx_audit_revision_history","major_revision"); ("pdbx_audit_revision_history","minor_revision"); ("pdbx_audit_revision_history","revision_date"); 
    ("pdbx_audit_revision_group","ordinal"); ("pdbx_audit_revision_group","revision_ordinal"); ("pdbx_audit_revision_group","data_content_type"); ("pdbx_audit_revision_group","group"); 
    ("pdbx_audit_revision_category","ordinal"); ("pdbx_audit_revision_category","revision_ordinal"); ("pdbx_audit_revision_category","data_content_type"); ("pdbx_audit_revision_category","category"); 
    ("pdbx_audit_revision_details","ordinal"); ("pdbx_audit_revision_details","revision_ordinal"); ("pdbx_audit_revision_details","data_content_type"); 
    ("pdbx_audit_revision_item","ordinal"); ("pdbx_audit_revision_item","revision_ordinal"); ("pdbx_audit_revision_item","data_content_type"); ("pdbx_audit_revision_item","item"); 
    ("pdbx_supporting_exp_data_set","ordinal"); ("pdbx_supporting_exp_data_set","data_content_type"); 
    ];
    fun (cat,item) -> Hashtbl.mem ht (cat,item)

  let category_links = [
    (("entity","entity","1"),[("pdbx_parent_entity_id","id"); ]);
    (("em_experiment","entry","1"),[("entry_id","id"); ]);
    (("entity_poly","entity","1"),[("entity_id","id"); ]);
    (("em_specimen","em_experiment","1"),[("experiment_id","id"); ]);
    (("entity_poly_seq","chem_comp","1"),[("mon_id","id"); ]);
    (("entity_poly_seq","entity_poly","2"),[("entity_id","entity_id"); ]);
    (("struct_asym","entity","1"),[("entity_id","id"); ]);
    (("refine","entry","1"),[("entry_id","id"); ]);
    (("em_imaging","entry","2"),[("entry_id","id"); ]);
    (("em_imaging","citation","1"),[("citation_id","id"); ]);
    (("em_imaging","em_specimen","3"),[("specimen_id","id"); ]);
    (("chem_comp_atom","chem_comp","2"),[("comp_id","id"); ]);
    (("chemical_conn_atom","atom_type","1"),[("type_symbol","symbol"); ]);
    (("pdbx_poly_seq_scheme","entity_poly_seq","1"),[("entity_id","entity_id"); ("seq_id","num"); ("mon_id","mon_id"); ]);
    (("pdbx_poly_seq_scheme","struct_asym","2"),[("asym_id","id"); ("entity_id","entity_id"); ]);
    (("pdbx_refine_tls","refine","1"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("struct_ncs_dom","struct_ncs_ens","1"),[("pdbx_ens_id","id"); ]);
    (("em_image_recording","em_imaging","1"),[("imaging_id","id"); ]);
    (("struct_biol","struct_biol","1"),[("pdbx_parent_biol_id","id"); ]);
    (("pdbx_reference_entity_list","pdbx_reference_molecule","1"),[("prd_id","prd_id"); ]);
    (("atom_site","entity","7"),[("label_entity_id","id"); ]);
    (("atom_site","chem_comp","4"),[("label_comp_id","id"); ]);
    (("atom_site","atom_type","3"),[("type_symbol","symbol"); ]);
    (("atom_site","entity_poly_seq","8"),[("label_comp_id","mon_id"); ("label_entity_id","entity_id"); ("label_seq_id","num"); ]);
    (("atom_site","struct_asym","11"),[("label_asym_id","id"); ("label_entity_id","entity_id"); ]);
    (("atom_site","atom_sites_footnote","2"),[("footnote_id","id"); ]);
    (("atom_site","chem_comp_atom","5"),[("label_atom_id","atom_id"); ]);
    (("atom_site","chemical_conn_atom","6"),[("chemical_conn_number","number"); ]);
    (("atom_site","pdbx_poly_seq_scheme","9"),[("auth_asym_id","pdb_strand_id"); ("auth_comp_id","pdb_mon_id"); ("auth_seq_id","pdb_seq_num"); ("label_asym_id","asym_id"); ("label_comp_id","mon_id"); ("label_entity_id","entity_id"); ("label_seq_id","seq_id"); ("pdbx_PDB_ins_code","pdb_ins_code"); ]);
    (("atom_site","pdbx_refine_tls","10"),[("pdbx_tls_group_id","id"); ]);
    (("atom_site","struct_ncs_dom","12"),[("pdbx_ncs_dom_id","id"); ]);
    (("pdbx_construct","entry","2"),[("entry_id","id"); ]);
    (("pdbx_construct","entity","1"),[("entity_id","id"); ]);
    (("pdbx_construct","pdbx_robot_system","3"),[("robot_id","id"); ]);
    (("em_image_processing","em_image_recording","1"),[("image_recording_id","id"); ]);
    (("struct_ref","entity","1"),[("entity_id","id"); ]);
    (("struct_ref","struct_biol","2"),[("biol_id","id"); ]);
    (("pdbx_reference_entity_poly","pdbx_reference_entity_list","1"),[("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ]);
    (("pdbx_entity_name_taxonomy_tree","pdbx_entity_name_taxonomy_tree","1"),[("id","parent_id"); ]);
    (("phasing_MAD_clust","phasing_MAD_expt","1"),[("expt_id","id"); ]);
    (("diffrn","exptl_crystal","1"),[("crystal_id","id"); ]);
    (("struct_sheet_range","atom_site","2"),[("end_auth_asym_id","auth_asym_id"); ("end_auth_comp_id","auth_comp_id"); ("end_auth_seq_id","auth_seq_id"); ("end_label_comp_id","label_comp_id"); ("end_label_seq_id","label_seq_id"); ("end_label_asym_id","label_asym_id"); ("pdbx_end_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("struct_sheet_range","atom_site","1"),[("beg_auth_asym_id","auth_asym_id"); ("beg_auth_comp_id","auth_comp_id"); ("beg_auth_seq_id","auth_seq_id"); ("beg_label_comp_id","label_comp_id"); ("beg_label_seq_id","label_seq_id"); ("beg_label_asym_id","label_asym_id"); ("pdbx_beg_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("struct_sheet_range","struct_sheet","3"),[("sheet_id","id"); ]);
    (("pdbx_reference_molecule_list","pdbx_reference_molecule_family","1"),[("family_prd_id","family_prd_id"); ]);
    (("pdbx_struct_entity_inst","entity","1"),[("entity_id","id"); ]);
    (("em_tomography_specimen","em_specimen","1"),[("specimen_id","id"); ]);
    (("pdbx_exptl_crystal_grow_sol","exptl_crystal","1"),[("crystal_id","id"); ]);
    (("pdbx_view_category","pdbx_view_category_group","1"),[("view_group_id","view_group_id"); ]);
    (("software","citation","1"),[("citation_id","id"); ]);
    (("em_buffer","em_specimen","1"),[("specimen_id","id"); ]);
    (("pdbx_reference_linked_entity_comp_list","pdbx_reference_linked_entity","1"),[("linked_entity_id","id"); ]);
    (("pdbx_entity_func_bind_mode","entity","1"),[("entity_id","id"); ]);
    (("pdbx_chem_comp_model_atom","pdbx_chem_comp_model","1"),[("model_id","id"); ]);
    (("em_3d_fitting","entry","1"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_clone","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_clone","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_clone","pdbx_robot_system","4"),[("robot_id","id"); ]);
    (("pdbx_entity_src_gen_clone","pdbx_construct","3"),[("end_construct_id","id"); ]);
    (("em_3d_reconstruction","entry","2"),[("entry_id","id"); ]);
    (("em_3d_reconstruction","citation","1"),[("citation_id","id"); ]);
    (("em_3d_reconstruction","em_image_processing","3"),[("image_processing_id","id"); ]);
    (("chem_link_tor","chem_link","1"),[("link_id","id"); ]);
    (("pdbx_validate_planes","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ("label_alt_id","label_alt_id"); ]);
    (("pdbx_linked_entity_list","entity","1"),[("entity_id","id"); ]);
    (("pdbx_linked_entity_list","pdbx_linked_entity","2"),[("linked_entity_id","linked_entity_id"); ]);
    (("em_sample_support","citation","1"),[("citation_id","id"); ]);
    (("em_sample_support","em_specimen","2"),[("specimen_id","id"); ]);
    (("struct_ref_seq","entity_poly_seq","1"),[("seq_align_beg","num"); ]);
    (("struct_ref_seq","entity_poly_seq","2"),[("seq_align_end","num"); ]);
    (("struct_ref_seq","pdbx_poly_seq_scheme","3"),[("seq_align_beg","seq_id"); ("pdbx_strand_id","pdb_strand_id"); ("pdbx_auth_seq_align_beg","pdb_seq_num"); ("pdbx_seq_align_beg_ins_code","pdb_ins_code"); ]);
    (("struct_ref_seq","pdbx_poly_seq_scheme","4"),[("pdbx_strand_id","pdb_strand_id"); ("seq_align_end","seq_id"); ("pdbx_auth_seq_align_end","pdb_seq_num"); ("pdbx_seq_align_end_ins_code","pdb_ins_code"); ]);
    (("struct_ref_seq","struct_ref","5"),[("ref_id","id"); ]);
    (("phasing_MIR_der","phasing_set","1"),[("der_set_id","id"); ]);
    (("phasing_MIR_der","phasing_set","2"),[("native_set_id","id"); ]);
    (("pdbx_chem_comp_import","chem_comp","1"),[("comp_id","id"); ]);
    (("pdbx_reference_entity_poly_seq","pdbx_reference_entity_poly","1"),[("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ]);
    (("pdbx_entity_src_gen_express","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_express","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_express","pdbx_robot_system","5"),[("robot_id","id"); ]);
    (("pdbx_entity_src_gen_express","pdbx_construct","3"),[("end_construct_id","id"); ]);
    (("pdbx_entity_src_gen_express","pdbx_construct","4"),[("plasmid_id","id"); ]);
    (("pdbx_entity_name_taxonomy","pdbx_entity_name_taxonomy_tree","1"),[("id","id"); ]);
    (("chem_comp_tor","chem_comp_atom","3"),[("atom_id_3","atom_id"); ]);
    (("chem_comp_tor","chem_comp_atom","1"),[("comp_id","comp_id"); ("atom_id_1","atom_id"); ]);
    (("chem_comp_tor","chem_comp_atom","4"),[("atom_id_4","atom_id"); ]);
    (("chem_comp_tor","chem_comp_atom","2"),[("atom_id_2","atom_id"); ]);
    (("chem_link_plane","chem_link","1"),[("link_id","id"); ]);
    (("pdbx_nonpoly_scheme","struct_asym","2"),[("asym_id","id"); ("entity_id","entity_id"); ]);
    (("pdbx_nonpoly_scheme","atom_site","1"),[("asym_id","label_asym_id"); ("entity_id","label_entity_id"); ("mon_id","label_comp_id"); ("pdb_strand_id","auth_asym_id"); ("pdb_seq_num","auth_seq_id"); ("pdb_mon_id","auth_comp_id"); ("pdb_ins_code","pdbx_PDB_ins_code"); ]);
    (("pdbx_sequence_range","atom_site","1"),[("beg_label_alt_id","label_alt_id"); ("beg_label_asym_id","label_asym_id"); ("beg_label_comp_id","label_comp_id"); ("beg_label_seq_id","label_seq_id"); ("beg_auth_asym_id","auth_asym_id"); ("beg_auth_comp_id","auth_comp_id"); ("beg_auth_seq_id","auth_seq_id"); ]);
    (("pdbx_sequence_range","atom_site","2"),[("end_label_alt_id","label_alt_id"); ("end_label_asym_id","label_asym_id"); ("end_label_comp_id","label_comp_id"); ("end_label_seq_id","label_seq_id"); ("end_auth_asym_id","auth_asym_id"); ("end_auth_comp_id","auth_comp_id"); ("end_auth_seq_id","auth_seq_id"); ]);
    (("phasing_MAD_set","phasing_MAD_expt","2"),[("expt_id","id"); ]);
    (("phasing_MAD_set","phasing_set","3"),[("set_id","id"); ]);
    (("phasing_MAD_set","phasing_MAD_clust","1"),[("clust_id","id"); ]);
    (("refine_ls_restr","refine","1"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("pdbx_soln_scatter","entry","1"),[("entry_id","id"); ]);
    (("chem_comp_chir","chem_comp","1"),[("comp_id","id"); ]);
    (("chem_comp_chir","chem_comp_atom","2"),[("atom_id","atom_id"); ]);
    (("diffrn_standard_refln","diffrn","1"),[("diffrn_id","id"); ]);
    (("chem_comp_plane","chem_comp","1"),[("comp_id","id"); ]);
    (("atom_sites_alt","atom_site","1"),[("id","label_alt_id"); ]);
    (("chem_link_chir","chem_link","1"),[("link_id","id"); ]);
    (("pdbx_entity_src_gen_prod_other","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_prod_other","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_prod_other","pdbx_robot_system","4"),[("robot_id","id"); ]);
    (("pdbx_entity_src_gen_prod_other","pdbx_construct","3"),[("end_construct_id","id"); ]);
    (("pdbx_val_contact","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id_1","auth_asym_id"); ("auth_atom_id_1","auth_atom_id"); ("auth_comp_id_1","auth_comp_id"); ("auth_seq_id_1","auth_seq_id"); ("auth_PDB_insert_id_1","pdbx_PDB_ins_code"); ("label_alt_id_1","label_alt_id"); ("label_asym_id_1","label_asym_id"); ("label_atom_id_1","label_atom_id"); ("label_comp_id_1","label_comp_id"); ("label_seq_id_1","label_seq_id"); ]);
    (("pdbx_val_contact","atom_site","2"),[("auth_atom_id_2","auth_atom_id"); ("auth_asym_id_2","auth_asym_id"); ("auth_comp_id_2","auth_comp_id"); ("auth_seq_id_2","auth_seq_id"); ("auth_PDB_insert_id_2","pdbx_PDB_ins_code"); ("label_alt_id_2","label_alt_id"); ("label_asym_id_2","label_asym_id"); ("label_atom_id_2","label_atom_id"); ("label_comp_id_2","label_comp_id"); ("label_seq_id_2","label_seq_id"); ]);
    (("pdbx_stereochemistry","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_seq_id","label_seq_id"); ("label_atom_id","label_atom_id"); ("label_alt_id","label_alt_id"); ]);
    (("pdbx_stereochemistry","atom_site","2"),[("label_atom_id_u","label_atom_id"); ("label_alt_id_u","label_alt_id"); ]);
    (("pdbx_stereochemistry","atom_site","3"),[("label_atom_id_v","label_atom_id"); ("label_alt_id_v","label_alt_id"); ]);
    (("pdbx_stereochemistry","atom_site","4"),[("label_atom_id_w","label_atom_id"); ("label_alt_id_w","label_alt_id"); ]);
    (("em_depositor_info","entry","1"),[("entry_id","id"); ]);
    (("pdbx_chem_comp_atom_feature","chem_comp_atom","1"),[("comp_id","comp_id"); ("atom_id","atom_id"); ]);
    (("pdbx_virtual_angle","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ]);
    (("pdbx_struct_conn_angle","atom_site","2"),[("ptnr2_label_alt_id","label_alt_id"); ("ptnr2_label_asym_id","label_asym_id"); ("ptnr2_label_atom_id","label_atom_id"); ("ptnr2_label_comp_id","label_comp_id"); ("ptnr2_label_seq_id","label_seq_id"); ("ptnr2_auth_asym_id","auth_asym_id"); ("ptnr2_auth_atom_id","auth_atom_id"); ("ptnr2_auth_comp_id","auth_comp_id"); ("ptnr2_auth_seq_id","auth_seq_id"); ("ptnr2_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("pdbx_struct_conn_angle","atom_site","3"),[("ptnr3_auth_asym_id","auth_asym_id"); ("ptnr3_auth_atom_id","auth_atom_id"); ("ptnr3_auth_comp_id","auth_comp_id"); ("ptnr3_PDB_ins_code","pdbx_PDB_ins_code"); ("ptnr3_auth_seq_id","auth_seq_id"); ("ptnr3_label_alt_id","label_alt_id"); ("ptnr3_label_asym_id","label_asym_id"); ("ptnr3_label_atom_id","label_atom_id"); ("ptnr3_label_comp_id","label_comp_id"); ("ptnr3_label_seq_id","label_seq_id"); ]);
    (("pdbx_struct_conn_angle","atom_site","1"),[("ptnr1_label_alt_id","label_alt_id"); ("ptnr1_label_asym_id","label_asym_id"); ("ptnr1_label_atom_id","label_atom_id"); ("ptnr1_label_comp_id","label_comp_id"); ("ptnr1_label_seq_id","label_seq_id"); ("ptnr1_auth_asym_id","auth_asym_id"); ("ptnr1_auth_atom_id","auth_atom_id"); ("ptnr1_auth_comp_id","auth_comp_id"); ("ptnr1_auth_seq_id","auth_seq_id"); ("ptnr1_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("pdbx_entity_src_gen_lysis","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_lysis","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_lysis","pdbx_robot_system","5"),[("robot_id","id"); ]);
    (("pdbx_entity_src_gen_lysis","pdbx_construct","4"),[("end_construct_id","id"); ]);
    (("pdbx_entity_src_gen_lysis","pdbx_buffer","3"),[("buffer_id","id"); ]);
    (("refine_ls_restr_ncs","struct_asym","2"),[("pdbx_asym_id","id"); ]);
    (("refine_ls_restr_ncs","refine","1"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("refine_ls_restr_ncs","struct_ncs_dom","3"),[("pdbx_ens_id","pdbx_ens_id"); ]);
    (("refine_ls_restr_ncs","atom_site","4"),[("pdbx_auth_asym_id","auth_asym_id"); ]);
    (("struct","entry","1"),[("entry_id","id"); ]);
    (("pdbx_na_struct_keywds","entry","1"),[("entry_id","id"); ]);
    (("database","entry","1"),[("entry_id","id"); ]);
    (("pdbx_struct_sheet_hbond","atom_site","1"),[("range_1_label_atom_id","label_atom_id"); ("range_1_label_seq_id","label_seq_id"); ("range_1_label_comp_id","label_comp_id"); ("range_1_label_asym_id","label_asym_id"); ("range_1_auth_atom_id","auth_atom_id"); ("range_1_auth_seq_id","auth_seq_id"); ("range_1_auth_comp_id","auth_comp_id"); ("range_1_auth_asym_id","auth_asym_id"); ("range_1_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("pdbx_struct_sheet_hbond","atom_site","2"),[("range_2_label_atom_id","label_atom_id"); ("range_2_label_seq_id","label_seq_id"); ("range_2_label_comp_id","label_comp_id"); ("range_2_label_asym_id","label_asym_id"); ("range_2_auth_atom_id","auth_atom_id"); ("range_2_auth_seq_id","auth_seq_id"); ("range_2_auth_comp_id","auth_comp_id"); ("range_2_auth_asym_id","auth_asym_id"); ("range_2_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("pdbx_struct_sheet_hbond","struct_sheet","3"),[("sheet_id","id"); ]);
    (("pdbx_struct_sheet_hbond","struct_sheet_range","5"),[("range_id_2","id"); ]);
    (("pdbx_struct_sheet_hbond","struct_sheet_range","4"),[("range_id_1","id"); ]);
    (("pdbx_struct_chem_comp_diagnostics","atom_site","1"),[("pdb_strand_id","auth_asym_id"); ("asym_id","label_asym_id"); ("auth_seq_id","auth_seq_id"); ("seq_num","label_seq_id"); ("auth_comp_id","auth_comp_id"); ]);
    (("chem_comp_angle","chem_comp_atom","2"),[("atom_id_2","atom_id"); ]);
    (("chem_comp_angle","chem_comp_atom","3"),[("atom_id_3","atom_id"); ]);
    (("chem_comp_angle","chem_comp_atom","1"),[("comp_id","comp_id"); ("atom_id_1","atom_id"); ]);
    (("atom_sites","entry","1"),[("entry_id","id"); ]);
    (("chem_link_bond","chem_link","1"),[("link_id","id"); ]);
    (("em_virus_entity","em_entity_assembly","1"),[("entity_assembly_id","id"); ]);
    (("pdbx_reference_molecule_synonyms","pdbx_reference_molecule_list","1"),[("family_prd_id","family_prd_id"); ("prd_id","prd_id"); ]);
    (("pdbx_database_status_history","entry","1"),[("entry_id","id"); ]);
    (("pdbx_nmr_systematic_chem_shift_offset","pdbx_nmr_assigned_chem_shift_list","1"),[("assigned_chem_shift_list_id","id"); ]);
    (("pdbx_coordinate_model","struct_asym","1"),[("asym_id","id"); ]);
    (("symmetry","entry","1"),[("entry_id","id"); ]);
    (("phasing_averaging","entry","1"),[("entry_id","id"); ]);
    (("diffrn_orient_matrix","diffrn","1"),[("diffrn_id","id"); ]);
    (("atom_site_anisotrop","atom_type","2"),[("type_symbol","symbol"); ]);
    (("atom_site_anisotrop","atom_site","1"),[("id","id"); ("pdbx_auth_seq_id","auth_seq_id"); ("pdbx_auth_alt_id","pdbx_auth_alt_id"); ("pdbx_auth_asym_id","auth_asym_id"); ("pdbx_auth_atom_id","auth_atom_id"); ("pdbx_auth_comp_id","auth_comp_id"); ("pdbx_label_seq_id","label_seq_id"); ("pdbx_label_alt_id","label_alt_id"); ("pdbx_label_asym_id","label_asym_id"); ("pdbx_label_atom_id","label_atom_id"); ("pdbx_label_comp_id","label_comp_id"); ("pdbx_PDB_ins_code","pdbx_PDB_ins_code"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); ]);
    (("pdbx_nmr_chem_shift_software","pdbx_nmr_assigned_chem_shift_list","1"),[("assigned_chem_shift_list_id","id"); ]);
    (("em_structure_factors","em_experiment","1"),[("experiment_id","id"); ]);
    (("em_vitrification","entry","2"),[("entry_id","id"); ]);
    (("em_vitrification","citation","1"),[("citation_id","id"); ]);
    (("em_vitrification","em_specimen","3"),[("specimen_id","id"); ]);
    (("pdbx_chem_comp_model_descriptor","pdbx_chem_comp_model","1"),[("model_id","id"); ]);
    (("chem_comp_bond","chem_comp","3"),[("comp_id","id"); ]);
    (("chem_comp_bond","chem_comp_atom","1"),[("comp_id","comp_id"); ("atom_id_1","atom_id"); ]);
    (("chem_comp_bond","chem_comp_atom","2"),[("comp_id","comp_id"); ("atom_id_2","atom_id"); ]);
    (("struct_ncs_ens_gen","struct_ncs_ens","3"),[("ens_id","id"); ]);
    (("struct_ncs_ens_gen","struct_ncs_dom","1"),[("dom_id_1","id"); ]);
    (("struct_ncs_ens_gen","struct_ncs_dom","2"),[("dom_id_2","id"); ]);
    (("struct_ncs_ens_gen","struct_ncs_oper","4"),[("oper_id","id"); ]);
    (("pdbx_reference_entity_sequence","pdbx_reference_entity_list","1"),[("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ]);
    (("pdbx_nmr_constraints","entry","1"),[("entry_id","id"); ]);
    (("pdbx_summary_flags","entry","1"),[("entry_id","id"); ]);
    (("em_layer_lines","em_experiment","1"),[("experiment_id","id"); ]);
    (("struct_sheet_topology","struct_sheet","1"),[("sheet_id","id"); ]);
    (("struct_sheet_topology","struct_sheet_range","2"),[("range_id_1","id"); ]);
    (("struct_sheet_topology","struct_sheet_range","3"),[("range_id_2","id"); ]);
    (("phasing_MAD","entry","1"),[("entry_id","id"); ]);
    (("ndb_struct_conf_na","entry","1"),[("entry_id","id"); ]);
    (("pdbx_entity_name","entity","1"),[("entity_id","id"); ]);
    (("pdbx_reference_molecule_annotation","pdbx_reference_molecule_list","1"),[("family_prd_id","family_prd_id"); ("prd_id","prd_id"); ]);
    (("pdbx_struct_asym_gen","struct_asym","2"),[("asym_id","id"); ]);
    (("pdbx_struct_asym_gen","pdbx_struct_entity_inst","1"),[("entity_inst_id","id"); ]);
    (("em_assembly","entry","1"),[("entry_id","id"); ]);
    (("pdbx_audit_revision_details","pdbx_audit_revision_history","1"),[("data_content_type","data_content_type"); ("revision_ordinal","ordinal"); ]);
    (("em_fiducial_markers","em_tomography_specimen","1"),[("em_tomography_specimen_id","id"); ]);
    (("em_embedding","em_specimen","1"),[("specimen_id","id"); ]);
    (("exptl_crystal_face","exptl_crystal","1"),[("crystal_id","id"); ]);
    (("pdbx_validate_torsion","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ("label_alt_id","label_alt_id"); ]);
    (("em_figure_depositor_info","em_experiment","1"),[("experiment_id","id"); ]);
    (("em_focused_ion_beam","em_tomography_specimen","1"),[("em_tomography_specimen_id","id"); ]);
    (("pdbx_exptl_crystal_grow_comp","exptl_crystal","1"),[("crystal_id","id"); ]);
    (("pdbx_exptl_crystal_grow_comp","pdbx_exptl_crystal_grow_sol","2"),[("sol_id","sol_id"); ]);
    (("refine_funct_minimized","refine","1"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("pdbx_view_item","pdbx_view_category","1"),[("category_id","category_id"); ]);
    (("pdbx_feature_assembly","citation","1"),[("feature_citation_id","id"); ]);
    (("pdbx_feature_assembly","struct_biol","3"),[("assembly_id","id"); ]);
    (("pdbx_feature_assembly","software","2"),[("feature_software_id","name"); ]);
    (("em_buffer_component","em_buffer","1"),[("buffer_id","id"); ]);
    (("publ_manuscript_incl","entry","1"),[("entry_id","id"); ]);
    (("em_sample_preparation","entry","1"),[("entry_id","id"); ]);
    (("em_map","entry","1"),[("entry_id","id"); ]);
    (("pdbx_struct_mod_residue","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ]);
    (("em_imaging_optics","em_imaging","1"),[("imaging_id","id"); ]);
    (("pdbx_validate_symm_contact","atom_site","2"),[("auth_atom_id_2","auth_atom_id"); ("auth_asym_id_2","auth_asym_id"); ("auth_comp_id_2","auth_comp_id"); ("auth_seq_id_2","auth_seq_id"); ("PDB_ins_code_2","pdbx_PDB_ins_code"); ("label_alt_id_2","label_alt_id"); ]);
    (("pdbx_validate_symm_contact","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id_1","auth_asym_id"); ("auth_atom_id_1","auth_atom_id"); ("auth_comp_id_1","auth_comp_id"); ("auth_seq_id_1","auth_seq_id"); ("PDB_ins_code_1","pdbx_PDB_ins_code"); ("label_alt_id_1","label_alt_id"); ]);
    (("pdbx_feature_monomer","citation","2"),[("feature_citation_id","id"); ]);
    (("pdbx_feature_monomer","atom_site","1"),[("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ]);
    (("pdbx_feature_monomer","software","3"),[("feature_software_id","name"); ]);
    (("pdbx_reference_entity_subcomponents","pdbx_reference_molecule","1"),[("prd_id","prd_id"); ]);
    (("pdbx_entity_poly_protein_class","entity","1"),[("entity_id","id"); ]);
    (("pdbx_reference_linked_entity_link","pdbx_reference_linked_entity_comp_list","1"),[("linked_entity_id","linked_entity_id"); ("from_list_id","list_id"); ]);
    (("pdbx_reference_entity_nonpoly","pdbx_reference_entity_list","1"),[("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ]);
    (("pdbx_rmch_outlier","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_PDB_insert_id","pdbx_PDB_ins_code"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ]);
    (("pdbx_entity_assembly","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_assembly","struct_biol","2"),[("biol_id","id"); ]);
    (("em_final_classification","em_image_processing","1"),[("image_processing_id","id"); ]);
    (("refine_B_iso","refine","1"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("pdbx_entity_func_enzyme","pdbx_entity_func_bind_mode","1"),[("bind_mode_id","id"); ]);
    (("em_virus_natural_host","em_entity_assembly","1"),[("entity_assembly_id","id"); ]);
    (("geom_hbond","atom_site","1"),[("atom_site_auth_asym_id_A","auth_asym_id"); ("atom_site_auth_atom_id_A","auth_atom_id"); ("atom_site_auth_comp_id_A","auth_comp_id"); ("atom_site_auth_seq_id_A","auth_seq_id"); ("atom_site_id_A","id"); ("atom_site_label_alt_id_A","label_alt_id"); ("atom_site_label_comp_id_A","label_comp_id"); ("atom_site_label_atom_id_A","label_atom_id"); ("atom_site_label_seq_id_A","label_seq_id"); ("atom_site_label_asym_id_A","label_asym_id"); ]);
    (("geom_hbond","atom_site","2"),[("atom_site_auth_asym_id_D","auth_asym_id"); ("atom_site_auth_atom_id_D","auth_atom_id"); ("atom_site_auth_comp_id_D","auth_comp_id"); ("atom_site_auth_seq_id_D","auth_seq_id"); ("atom_site_id_D","id"); ("atom_site_label_alt_id_D","label_alt_id"); ("atom_site_label_comp_id_D","label_comp_id"); ("atom_site_label_atom_id_D","label_atom_id"); ("atom_site_label_seq_id_D","label_seq_id"); ("atom_site_label_asym_id_D","label_asym_id"); ]);
    (("geom_hbond","atom_site","3"),[("atom_site_auth_asym_id_H","auth_asym_id"); ("atom_site_auth_atom_id_H","auth_atom_id"); ("atom_site_auth_comp_id_H","auth_comp_id"); ("atom_site_auth_seq_id_H","auth_seq_id"); ("atom_site_id_H","id"); ("atom_site_label_alt_id_H","label_alt_id"); ("atom_site_label_comp_id_H","label_comp_id"); ("atom_site_label_atom_id_H","label_atom_id"); ("atom_site_label_seq_id_H","label_seq_id"); ("atom_site_label_asym_id_H","label_asym_id"); ]);
    (("pdbx_linked_entity_instance_list","struct_asym","2"),[("asym_id","id"); ]);
    (("pdbx_linked_entity_instance_list","pdbx_linked_entity","1"),[("linked_entity_id","linked_entity_id"); ]);
    (("pdbx_virtual_torsion","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ]);
    (("struct_sheet_hbond","atom_site","1"),[("range_1_beg_auth_atom_id","auth_atom_id"); ("range_1_beg_auth_seq_id","auth_seq_id"); ("range_1_beg_label_atom_id","label_atom_id"); ("range_1_beg_label_seq_id","label_seq_id"); ("pdbx_range_1_beg_auth_comp_id","auth_comp_id"); ("pdbx_range_1_beg_auth_asym_id","auth_asym_id"); ("pdbx_range_1_beg_label_comp_id","label_comp_id"); ("pdbx_range_1_beg_label_asym_id","label_asym_id"); ("pdbx_range_1_beg_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("struct_sheet_hbond","atom_site","2"),[("range_1_end_auth_atom_id","auth_atom_id"); ("range_1_end_auth_seq_id","auth_seq_id"); ("range_1_end_label_atom_id","label_atom_id"); ("range_1_end_label_seq_id","label_seq_id"); ("pdbx_range_1_end_auth_comp_id","auth_comp_id"); ("pdbx_range_1_end_auth_asym_id","auth_asym_id"); ("pdbx_range_1_end_label_comp_id","label_comp_id"); ("pdbx_range_1_end_label_asym_id","label_asym_id"); ("pdbx_range_1_end_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("struct_sheet_hbond","atom_site","3"),[("range_2_beg_auth_atom_id","auth_atom_id"); ("range_2_beg_auth_seq_id","auth_seq_id"); ("range_2_beg_label_atom_id","label_atom_id"); ("range_2_beg_label_seq_id","label_seq_id"); ("pdbx_range_2_beg_label_comp_id","label_comp_id"); ("pdbx_range_2_beg_label_asym_id","label_asym_id"); ("pdbx_range_2_beg_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("struct_sheet_hbond","atom_site","4"),[("range_2_end_auth_atom_id","auth_atom_id"); ("range_2_end_auth_seq_id","auth_seq_id"); ("range_2_end_label_atom_id","label_atom_id"); ("range_2_end_label_seq_id","label_seq_id"); ("pdbx_range_2_end_label_comp_id","label_comp_id"); ("pdbx_range_2_end_label_asym_id","label_asym_id"); ]);
    (("struct_sheet_hbond","struct_sheet","5"),[("sheet_id","id"); ]);
    (("struct_sheet_hbond","struct_sheet_range","7"),[("range_id_2","id"); ]);
    (("struct_sheet_hbond","struct_sheet_range","6"),[("range_id_1","id"); ]);
    (("pdbx_chem_comp_audit","chem_comp","1"),[("comp_id","id"); ]);
    (("em_ultramicrotomy","em_tomography_specimen","1"),[("em_tomography_specimen_id","id"); ]);
    (("phasing_MIR","entry","1"),[("entry_id","id"); ]);
    (("diffrn_detector","diffrn","1"),[("diffrn_id","id"); ]);
    (("struct_mon_details","entry","1"),[("entry_id","id"); ]);
    (("pdbx_chem_comp_feature","chem_comp","1"),[("comp_id","id"); ]);
    (("pdbx_unobs_or_zero_occ_residues","chem_comp","2"),[("auth_comp_id","id"); ]);
    (("pdbx_unobs_or_zero_occ_residues","chem_comp","3"),[("label_comp_id","id"); ]);
    (("pdbx_unobs_or_zero_occ_residues","struct_asym","4"),[("label_asym_id","id"); ]);
    (("pdbx_unobs_or_zero_occ_residues","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ]);
    (("pdbx_chem_comp_descriptor","chem_comp","1"),[("comp_id","id"); ]);
    (("pdbx_struct_group_component_range","atom_site","3"),[("end_auth_asym_id","auth_asym_id"); ("end_auth_comp_id","auth_comp_id"); ("end_auth_seq_id","auth_seq_id"); ("end_label_asym_id","label_asym_id"); ("end_label_comp_id","label_comp_id"); ("end_label_seq_id","label_seq_id"); ("end_PDB_ins_code","pdbx_PDB_ins_code"); ("end_label_alt_id","label_alt_id"); ]);
    (("pdbx_struct_group_component_range","atom_site","2"),[("PDB_model_num","pdbx_PDB_model_num"); ("beg_auth_asym_id","auth_asym_id"); ("beg_auth_comp_id","auth_comp_id"); ("beg_auth_seq_id","auth_seq_id"); ("beg_label_asym_id","label_asym_id"); ("beg_label_comp_id","label_comp_id"); ("beg_label_seq_id","label_seq_id"); ("beg_PDB_ins_code","pdbx_PDB_ins_code"); ("beg_label_alt_id","label_alt_id"); ]);
    (("pdbx_struct_group_component_range","pdbx_struct_group_list","1"),[("struct_group_id","struct_group_id"); ]);
    (("pdbx_entity_src_gen_pure","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_pure","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_pure","pdbx_robot_system","4"),[("conc_device_id","id"); ]);
    (("pdbx_entity_src_gen_pure","pdbx_buffer","3"),[("storage_buffer_id","id"); ]);
    (("pdbx_chem_comp_model_audit","pdbx_chem_comp_model_atom","1"),[("model_id","model_id"); ]);
    (("em_shadowing","em_specimen","1"),[("specimen_id","id"); ]);
    (("pdbx_domain_range","atom_site","2"),[("end_label_alt_id","label_alt_id"); ("end_label_asym_id","label_asym_id"); ("end_label_comp_id","label_comp_id"); ("end_label_seq_id","label_seq_id"); ("end_auth_asym_id","auth_asym_id"); ("end_auth_comp_id","auth_comp_id"); ("end_auth_seq_id","auth_seq_id"); ]);
    (("pdbx_domain_range","atom_site","1"),[("beg_label_alt_id","label_alt_id"); ("beg_label_asym_id","label_asym_id"); ("beg_label_comp_id","label_comp_id"); ("beg_label_seq_id","label_seq_id"); ("beg_auth_asym_id","auth_asym_id"); ("beg_auth_comp_id","auth_comp_id"); ("beg_auth_seq_id","auth_seq_id"); ]);
    (("pdbx_domain_range","pdbx_domain","3"),[("domain_id","id"); ]);
    (("pdbx_struct_ref_seq_feature_prop","pdbx_struct_ref_seq_feature","1"),[("feature_id","feature_id"); ]);
    (("pdbx_chem_comp_model_feature","pdbx_chem_comp_model","1"),[("model_id","id"); ]);
    (("em_3d_crystal_entity","em_image_processing","1"),[("image_processing_id","id"); ]);
    (("pdbx_audit","entry","2"),[("entry_id","id"); ]);
    (("pdbx_audit","audit","1"),[("current_version","revision_id"); ]);
    (("pdbx_entity_poly_na_type","entity","1"),[("entity_id","id"); ]);
    (("pdbx_buffer_components","pdbx_buffer","1"),[("buffer_id","id"); ]);
    (("pdbx_helical_symmetry_depositor_info","entry","1"),[("entry_id","id"); ]);
    (("pdbx_nmr_spectral_peak_software","pdbx_nmr_spectral_peak_list","1"),[("spectral_peak_list_id","id"); ]);
    (("pdbx_rms_devs_cov_by_monomer","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_seq_id","label_seq_id"); ]);
    (("pdbx_refine","entry","1"),[("entry_id","id"); ]);
    (("pdbx_refine","refine","2"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("pdbx_chem_comp_nonstandard","chem_comp","1"),[("comp_id","id"); ]);
    (("em_ctf_correction","em_image_processing","1"),[("em_image_processing_id","id"); ]);
    (("pdbx_atlas","entry","1"),[("entry_id","id"); ]);
    (("diffrn_source","diffrn","1"),[("diffrn_id","id"); ]);
    (("pdbx_feature_entry","citation","1"),[("feature_citation_id","id"); ]);
    (("pdbx_feature_entry","software","2"),[("feature_software_id","name"); ]);
    (("cell_measurement","entry","1"),[("entry_id","id"); ]);
    (("pdbx_nmr_chem_shift_experiment","pdbx_nmr_assigned_chem_shift_list","1"),[("assigned_chem_shift_list_id","id"); ]);
    (("pdbx_database_status","entry","1"),[("entry_id","id"); ]);
    (("diffrn_reflns","diffrn","1"),[("diffrn_id","id"); ]);
    (("pdbx_refine_component","atom_site","1"),[("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ]);
    (("pdbx_virtual_bond","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ]);
    (("em_software","em_imaging","3"),[("imaging_id","id"); ]);
    (("em_software","em_image_processing","2"),[("image_processing_id","id"); ]);
    (("em_software","em_3d_fitting","1"),[("fitting_id","id"); ]);
    (("em_particle_selection","em_image_processing","1"),[("image_processing_id","id"); ]);
    (("struct_site_view","struct_site","1"),[("site_id","id"); ]);
    (("struct_conn","atom_site","1"),[("ptnr1_auth_asym_id","auth_asym_id"); ("ptnr1_auth_atom_id","auth_atom_id"); ("ptnr1_auth_comp_id","auth_comp_id"); ("ptnr1_auth_seq_id","auth_seq_id"); ("ptnr1_label_alt_id","label_alt_id"); ("ptnr1_label_comp_id","label_comp_id"); ("ptnr1_label_atom_id","label_atom_id"); ("ptnr1_label_seq_id","label_seq_id"); ("ptnr1_label_asym_id","label_asym_id"); ("pdbx_ptnr1_PDB_ins_code","pdbx_PDB_ins_code"); ("pdbx_ptnr1_auth_alt_id","pdbx_auth_alt_id"); ("pdbx_ptnr1_label_alt_id","label_alt_id"); ]);
    (("struct_conn","atom_site","3"),[("pdbx_ptnr3_auth_alt_id","pdbx_auth_alt_id"); ("pdbx_ptnr3_auth_asym_id","auth_asym_id"); ("pdbx_ptnr3_auth_atom_id","auth_atom_id"); ("pdbx_ptnr3_auth_comp_id","auth_comp_id"); ("pdbx_ptnr3_PDB_ins_code","pdbx_PDB_ins_code"); ("pdbx_ptnr3_auth_seq_id","auth_seq_id"); ("pdbx_ptnr3_label_asym_id","label_asym_id"); ("pdbx_ptnr3_label_atom_id","label_atom_id"); ("pdbx_ptnr3_label_comp_id","label_comp_id"); ("pdbx_ptnr3_label_seq_id","label_seq_id"); ("pdbx_ptnr3_label_alt_id","label_alt_id"); ]);
    (("struct_conn","atom_site","2"),[("ptnr2_auth_asym_id","auth_asym_id"); ("ptnr2_auth_atom_id","auth_atom_id"); ("ptnr2_auth_comp_id","auth_comp_id"); ("ptnr2_auth_seq_id","auth_seq_id"); ("ptnr2_label_alt_id","label_alt_id"); ("ptnr2_label_comp_id","label_comp_id"); ("ptnr2_label_atom_id","label_atom_id"); ("ptnr2_label_seq_id","label_seq_id"); ("ptnr2_label_asym_id","label_asym_id"); ("pdbx_ptnr2_PDB_ins_code","pdbx_PDB_ins_code"); ("pdbx_ptnr2_auth_alt_id","pdbx_auth_alt_id"); ("pdbx_ptnr2_label_alt_id","label_alt_id"); ]);
    (("struct_conn","struct_conn_type","4"),[("conn_type_id","id"); ]);
    (("pdbx_entity_src_gen_clone_ligation","pdbx_entity_src_gen_clone","1"),[("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ]);
    (("entity_keywords","entity","1"),[("entity_id","id"); ]);
    (("pdbx_database_message","entry","1"),[("entry_id","id"); ]);
    (("em_single_particle_entity","em_3d_reconstruction","1"),[("image_processing_id","id"); ]);
    (("entity_link","entity","2"),[("entity_id_1","id"); ]);
    (("entity_link","entity","3"),[("entity_id_2","id"); ]);
    (("entity_link","entity_poly_seq","5"),[("entity_seq_num_2","num"); ]);
    (("entity_link","entity_poly_seq","4"),[("entity_seq_num_1","num"); ]);
    (("entity_link","chem_link","1"),[("link_id","id"); ]);
    (("refine_ls_shell","refine","1"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("em_entity_assembly_recombinant","em_entity_assembly","1"),[("entity_assembly_id","id"); ]);
    (("pdbx_entity_func_structural","pdbx_entity_func_bind_mode","1"),[("bind_mode_id","id"); ]);
    (("geom_bond","atom_site","1"),[("atom_site_auth_asym_id_1","auth_asym_id"); ("atom_site_auth_atom_id_1","auth_atom_id"); ("atom_site_auth_comp_id_1","auth_comp_id"); ("atom_site_auth_seq_id_1","auth_seq_id"); ("atom_site_id_1","id"); ("atom_site_label_alt_id_1","label_alt_id"); ("atom_site_label_comp_id_1","label_comp_id"); ("atom_site_label_atom_id_1","label_atom_id"); ("atom_site_label_seq_id_1","label_seq_id"); ("atom_site_label_asym_id_1","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_1","pdbx_PDB_ins_code"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); ]);
    (("geom_bond","atom_site","2"),[("atom_site_auth_asym_id_2","auth_asym_id"); ("atom_site_auth_atom_id_2","auth_atom_id"); ("atom_site_auth_comp_id_2","auth_comp_id"); ("atom_site_auth_seq_id_2","auth_seq_id"); ("atom_site_id_2","id"); ("atom_site_label_alt_id_2","label_alt_id"); ("atom_site_label_comp_id_2","label_comp_id"); ("atom_site_label_atom_id_2","label_atom_id"); ("atom_site_label_seq_id_2","label_seq_id"); ("atom_site_label_asym_id_2","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_2","pdbx_PDB_ins_code"); ]);
    (("database_PDB_rev_record","database_PDB_rev","1"),[("rev_num","num"); ]);
    (("chem_link_tor_value","chem_link_tor","1"),[("tor_id","id"); ]);
    (("pdbx_version","entry","1"),[("entry_id","id"); ]);
    (("pdbx_audit_revision_group","pdbx_audit_revision_history","1"),[("data_content_type","data_content_type"); ("revision_ordinal","ordinal"); ]);
    (("pdbx_nmr_force_constants","entry","1"),[("entry_id","id"); ]);
    (("pdbx_entity_src_syn","entity","1"),[("entity_id","id"); ]);
    (("em_image_scans","entry","2"),[("entry_id","id"); ]);
    (("em_image_scans","citation","1"),[("citation_id","id"); ]);
    (("em_image_scans","em_image_recording","3"),[("image_recording_id","id"); ]);
    (("struct_mon_nucl","atom_site","1"),[("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_alt_id","label_alt_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("label_asym_id","label_asym_id"); ]);
    (("pdbx_validate_planes_atom","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ("auth_atom_id","auth_atom_id"); ]);
    (("pdbx_validate_planes_atom","pdbx_validate_planes","2"),[("plane_id","id"); ]);
    (("pdbx_struct_assembly_gen","pdbx_struct_assembly","1"),[("assembly_id","id"); ]);
    (("chemical_formula","entry","1"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_clone_recombination","pdbx_entity_src_gen_clone","1"),[("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ]);
    (("pdbx_linked_entity_link_list","entity_poly_seq","2"),[("entity_seq_num_2","num"); ]);
    (("pdbx_linked_entity_link_list","entity_poly_seq","1"),[("entity_seq_num_1","num"); ]);
    (("pdbx_linked_entity_link_list","pdbx_linked_entity_list","4"),[("entity_id_2","entity_id"); ("component_2","component_id"); ]);
    (("pdbx_linked_entity_link_list","pdbx_linked_entity_list","3"),[("linked_entity_id","linked_entity_id"); ("entity_id_1","entity_id"); ("component_1","component_id"); ]);
    (("em_2d_crystal_entity","em_image_processing","1"),[("image_processing_id","id"); ]);
    (("pdbx_val_chiral","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_PDB_insert_id","pdbx_PDB_ins_code"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ]);
    (("database_PDB_matrix","entry","1"),[("entry_id","id"); ]);
    (("em_support_film","em_sample_support","1"),[("sample_support_id","id"); ]);
    (("struct_biol_view","struct_biol","1"),[("biol_id","id"); ]);
    (("em_helical_entity","em_image_processing","1"),[("image_processing_id","id"); ]);
    (("refine_occupancy","refine","1"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("pdbx_point_symmetry_depositor_info","entry","1"),[("entry_id","id"); ]);
    (("pdbx_validate_chiral","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ("auth_atom_id","auth_atom_id"); ("label_alt_id","label_alt_id"); ]);
    (("pdbx_data_processing_detector","entry","1"),[("entry_id","id"); ]);
    (("entry_link","entry","1"),[("entry_id","id"); ]);
    (("struct_ref_seq_dif","entity_poly_seq","2"),[("mon_id","mon_id"); ("seq_num","num"); ]);
    (("struct_ref_seq_dif","pdbx_poly_seq_scheme","3"),[("mon_id","mon_id"); ("seq_num","seq_id"); ("pdbx_pdb_strand_id","pdb_strand_id"); ("pdbx_pdb_ins_code","pdb_ins_code"); ("pdbx_auth_seq_num","pdb_seq_num"); ]);
    (("struct_ref_seq_dif","struct_ref_seq","4"),[("align_id","align_id"); ]);
    (("pdbx_sequence_pattern","atom_site","1"),[("label_asym_id","label_asym_id"); ("auth_asym_id","auth_asym_id"); ]);
    (("pdbx_reference_linked_entity_comp_link","pdbx_reference_linked_entity_comp_list","2"),[("list_id_2","list_id"); ]);
    (("pdbx_reference_linked_entity_comp_link","pdbx_reference_linked_entity_comp_list","1"),[("linked_entity_id","linked_entity_id"); ("list_id_1","list_id"); ]);
    (("pdbx_family_prd_audit","pdbx_reference_molecule_family","1"),[("family_prd_id","family_prd_id"); ]);
    (("computing","entry","1"),[("entry_id","id"); ]);
    (("pdbx_feature_domain","citation","1"),[("feature_citation_id","id"); ]);
    (("pdbx_feature_domain","software","3"),[("feature_software_id","name"); ]);
    (("pdbx_feature_domain","pdbx_domain","2"),[("domain_id","id"); ]);
    (("pdbx_val_bond","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id_1","auth_asym_id"); ("auth_atom_id_1","auth_atom_id"); ("auth_comp_id_1","auth_comp_id"); ("auth_seq_id_1","auth_seq_id"); ("auth_PDB_insert_id_1","pdbx_PDB_ins_code"); ("label_alt_id_1","label_alt_id"); ("label_asym_id_1","label_asym_id"); ("label_atom_id_1","label_atom_id"); ("label_comp_id_1","label_comp_id"); ("label_seq_id_1","label_seq_id"); ]);
    (("pdbx_val_bond","atom_site","2"),[("auth_atom_id_2","auth_atom_id"); ("auth_asym_id_2","auth_asym_id"); ("auth_comp_id_2","auth_comp_id"); ("auth_seq_id_2","auth_seq_id"); ("auth_PDB_insert_id_2","pdbx_PDB_ins_code"); ("label_alt_id_2","label_alt_id"); ("label_asym_id_2","label_asym_id"); ("label_atom_id_2","label_atom_id"); ("label_comp_id_2","label_comp_id"); ("label_seq_id_2","label_seq_id"); ]);
    (("phasing_MIR_der_shell","phasing_MIR_der","1"),[("der_id","id"); ]);
    (("pdbx_chem_comp_subcomponent_entity_list","chem_comp","1"),[("parent_comp_id","id"); ]);
    (("pdbx_struct_ncs_virus_gen","struct_asym","1"),[("asym_id","id"); ]);
    (("pdbx_struct_ncs_virus_gen","struct_ncs_oper","2"),[("oper_id","id"); ]);
    (("entity_src_gen","entity","1"),[("entity_id","id"); ]);
    (("entity_src_gen","pdbx_construct","2"),[("start_construct_id","id"); ]);
    (("pdbx_chem_comp_model_reference","pdbx_chem_comp_model","1"),[("model_id","id"); ]);
    (("journal","entry","1"),[("entry_id","id"); ]);
    (("pdbx_entity_func_other","pdbx_entity_func_bind_mode","1"),[("bind_mode_id","id"); ]);
    (("pdbx_refine_tls_group","struct_asym","3"),[("beg_label_asym_id","id"); ]);
    (("pdbx_refine_tls_group","struct_asym","4"),[("end_label_asym_id","id"); ]);
    (("pdbx_refine_tls_group","refine","2"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("pdbx_refine_tls_group","pdbx_refine_tls","1"),[("refine_tls_id","id"); ]);
    (("pdbx_val_angle","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id_1","auth_asym_id"); ("auth_atom_id_1","auth_atom_id"); ("auth_comp_id_1","auth_comp_id"); ("auth_seq_id_1","auth_seq_id"); ("auth_PDB_insert_id_1","pdbx_PDB_ins_code"); ("label_alt_id_1","label_alt_id"); ("label_asym_id_1","label_asym_id"); ("label_atom_id_1","label_atom_id"); ("label_comp_id_1","label_comp_id"); ("label_seq_id_1","label_seq_id"); ]);
    (("pdbx_val_angle","atom_site","3"),[("auth_atom_id_3","auth_atom_id"); ("auth_asym_id_3","auth_asym_id"); ("auth_comp_id_3","auth_comp_id"); ("auth_seq_id_3","auth_seq_id"); ("auth_PDB_insert_id_3","pdbx_PDB_ins_code"); ("label_alt_id_3","label_alt_id"); ("label_asym_id_3","label_asym_id"); ("label_atom_id_3","label_atom_id"); ("label_comp_id_3","label_comp_id"); ("label_seq_id_3","label_seq_id"); ]);
    (("pdbx_val_angle","atom_site","2"),[("auth_atom_id_2","auth_atom_id"); ("auth_asym_id_2","auth_asym_id"); ("auth_comp_id_2","auth_comp_id"); ("auth_seq_id_2","auth_seq_id"); ("auth_PDB_insert_id_2","pdbx_PDB_ins_code"); ("label_alt_id_2","label_alt_id"); ("label_asym_id_2","label_asym_id"); ("label_atom_id_2","label_atom_id"); ("label_comp_id_2","label_comp_id"); ("label_seq_id_2","label_seq_id"); ]);
    (("pdbx_database_PDB_master","entry","1"),[("entry_id","id"); ]);
    (("pdbx_post_process_details","entry","1"),[("entry_id","id"); ]);
    (("pdbx_struct_biol_func","struct_biol","1"),[("biol_id","id"); ]);
    (("struct_biol_gen","struct_asym","1"),[("asym_id","id"); ]);
    (("struct_biol_gen","struct_biol","2"),[("biol_id","id"); ]);
    (("pdbx_helical_symmetry","entry","1"),[("entry_id","id"); ]);
    (("pdbx_diffrn_reflns_shell","diffrn","1"),[("diffrn_id","id"); ]);
    (("pdbx_chem_comp_atom_edit","pdbx_chem_comp_import","1"),[("comp_id","comp_id"); ]);
    (("pdbx_entity_src_gen_prod_pcr","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_prod_pcr","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_prod_pcr","pdbx_robot_system","6"),[("robot_id","id"); ]);
    (("pdbx_entity_src_gen_prod_pcr","pdbx_construct","4"),[("forward_primer_id","id"); ]);
    (("pdbx_entity_src_gen_prod_pcr","pdbx_construct","5"),[("reverse_primer_id","id"); ]);
    (("pdbx_entity_src_gen_prod_pcr","pdbx_construct","3"),[("end_construct_id","id"); ]);
    (("pdbx_reference_entity_link","pdbx_reference_entity_list","2"),[("ref_entity_id_1","ref_entity_id"); ("component_1","component_id"); ]);
    (("pdbx_reference_entity_link","pdbx_reference_entity_list","1"),[("prd_id","prd_id"); ]);
    (("pdbx_reference_entity_link","pdbx_reference_entity_list","3"),[("ref_entity_id_2","ref_entity_id"); ("component_2","component_id"); ]);
    (("pdbx_reference_entity_link","pdbx_reference_entity_poly_seq","4"),[("entity_seq_num_1","num"); ]);
    (("pdbx_reference_entity_link","pdbx_reference_entity_poly_seq","5"),[("entity_seq_num_2","num"); ]);
    (("em_structure_factors_depositor_info","em_experiment","1"),[("experiment_id","id"); ]);
    (("em_entity_assembly_molwt","em_entity_assembly","1"),[("entity_assembly_id","id"); ]);
    (("pdbx_entry_details","entry","1"),[("entry_id","id"); ]);
    (("phasing_set_refln","phasing_set","1"),[("set_id","id"); ]);
    (("entity_name_com","entity","1"),[("entity_id","id"); ]);
    (("em_map_depositor_info","entry","1"),[("entry_id","id"); ]);
    (("em_map_depositor_info","em_experiment","2"),[("experiment_id","id"); ]);
    (("citation_author","citation","1"),[("citation_id","id"); ]);
    (("geom","entry","1"),[("entry_id","id"); ]);
    (("chemical","entry","1"),[("entry_id","id"); ]);
    (("diffrn_standards","diffrn","1"),[("diffrn_id","id"); ]);
    (("geom_torsion","atom_site","1"),[("atom_site_auth_asym_id_1","auth_asym_id"); ("atom_site_auth_atom_id_1","auth_atom_id"); ("atom_site_auth_comp_id_1","auth_comp_id"); ("atom_site_auth_seq_id_1","auth_seq_id"); ("atom_site_id_1","id"); ("atom_site_label_alt_id_1","label_alt_id"); ("atom_site_label_comp_id_1","label_comp_id"); ("atom_site_label_atom_id_1","label_atom_id"); ("atom_site_label_seq_id_1","label_seq_id"); ("atom_site_label_asym_id_1","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_1","pdbx_PDB_ins_code"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); ]);
    (("geom_torsion","atom_site","4"),[("atom_site_auth_asym_id_4","auth_asym_id"); ("atom_site_auth_atom_id_4","auth_atom_id"); ("atom_site_auth_comp_id_4","auth_comp_id"); ("atom_site_auth_seq_id_4","auth_seq_id"); ("atom_site_id_4","id"); ("atom_site_label_alt_id_4","label_alt_id"); ("atom_site_label_comp_id_4","label_comp_id"); ("atom_site_label_atom_id_4","label_atom_id"); ("atom_site_label_seq_id_4","label_seq_id"); ("atom_site_label_asym_id_4","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_4","pdbx_PDB_ins_code"); ]);
    (("geom_torsion","atom_site","2"),[("atom_site_auth_asym_id_2","auth_asym_id"); ("atom_site_auth_atom_id_2","auth_atom_id"); ("atom_site_auth_comp_id_2","auth_comp_id"); ("atom_site_auth_seq_id_2","auth_seq_id"); ("atom_site_id_2","id"); ("atom_site_label_alt_id_2","label_alt_id"); ("atom_site_label_comp_id_2","label_comp_id"); ("atom_site_label_atom_id_2","label_atom_id"); ("atom_site_label_seq_id_2","label_seq_id"); ("atom_site_label_asym_id_2","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_2","pdbx_PDB_ins_code"); ]);
    (("geom_torsion","atom_site","3"),[("atom_site_auth_asym_id_3","auth_asym_id"); ("atom_site_auth_atom_id_3","auth_atom_id"); ("atom_site_auth_comp_id_3","auth_comp_id"); ("atom_site_auth_seq_id_3","auth_seq_id"); ("atom_site_id_3","id"); ("atom_site_label_alt_id_3","label_alt_id"); ("atom_site_label_comp_id_3","label_comp_id"); ("atom_site_label_atom_id_3","label_atom_id"); ("atom_site_label_seq_id_3","label_seq_id"); ("atom_site_label_asym_id_3","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_3","pdbx_PDB_ins_code"); ]);
    (("pdbx_entity_src_gen_express_timepoint","pdbx_entity_src_gen_express","1"),[("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ]);
    (("struct_site_gen","atom_site","1"),[("auth_asym_id","auth_asym_id"); ("auth_atom_id","auth_atom_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_alt_id","label_alt_id"); ("label_comp_id","label_comp_id"); ("label_atom_id","label_atom_id"); ("label_seq_id","label_seq_id"); ("label_asym_id","label_asym_id"); ]);
    (("struct_site_gen","struct_site","2"),[("site_id","id"); ]);
    (("pdbx_entity_name_instance","pdbx_entity_name_taxonomy","1"),[("name","name"); ]);
    (("pdbx_missing_atom_poly","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_PDB_insert_id","pdbx_PDB_ins_code"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ]);
    (("struct_keywords","entry","1"),[("entry_id","id"); ]);
    (("pdbx_sugar_phosphate_geometry","atom_site","3"),[("neighbor_comp_id_3prime","label_comp_id"); ]);
    (("pdbx_sugar_phosphate_geometry","atom_site","2"),[("neighbor_comp_id_5prime","label_comp_id"); ]);
    (("pdbx_sugar_phosphate_geometry","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_seq_id","label_seq_id"); ]);
    (("chem_comp_tor_value","chem_comp_atom","1"),[("comp_id","comp_id"); ]);
    (("chem_comp_tor_value","chem_comp_tor","2"),[("tor_id","id"); ]);
    (("pdbx_entity_poly_na_nonstandard","entity","1"),[("entity_id","id"); ]);
    (("pdbx_reference_entity_src_nat","pdbx_reference_entity_list","1"),[("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ]);
    (("pdbx_exptl_pd","entry","1"),[("entry_id","id"); ]);
    (("entity_name_sys","entity","1"),[("entity_id","id"); ]);
    (("pdbx_nmr_computing","entry","1"),[("entry_id","id"); ]);
    (("pdbx_entity_prod_protocol","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_prod_protocol","entity","1"),[("entity_id","id"); ]);
    (("publ","entry","1"),[("entry_id","id"); ]);
    (("chem_link_plane_atom","chem_link_plane","1"),[("plane_id","id"); ]);
    (("phasing_isomorphous","entry","1"),[("entry_id","id"); ]);
    (("em_diffraction_stats","em_image_processing","1"),[("image_processing_id","id"); ]);
    (("refine_analyze","entry","1"),[("entry_id","id"); ]);
    (("refine_analyze","refine","2"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("pdbx_coord","entry","1"),[("entry_id","id"); ]);
    (("struct_conf","atom_site","2"),[("end_auth_asym_id","auth_asym_id"); ("end_auth_comp_id","auth_comp_id"); ("end_auth_seq_id","auth_seq_id"); ("end_label_comp_id","label_comp_id"); ("end_label_seq_id","label_seq_id"); ("end_label_asym_id","label_asym_id"); ("pdbx_end_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("struct_conf","atom_site","1"),[("beg_auth_asym_id","auth_asym_id"); ("beg_auth_comp_id","auth_comp_id"); ("beg_auth_seq_id","auth_seq_id"); ("beg_label_comp_id","label_comp_id"); ("beg_label_seq_id","label_seq_id"); ("beg_label_asym_id","label_asym_id"); ("pdbx_beg_PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("struct_conf","struct_conf_type","3"),[("conf_type_id","id"); ]);
    (("pdbx_entity_poly_domain","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_poly_domain","entity_poly_seq","2"),[("begin_mon_id","mon_id"); ("begin_seq_num","num"); ]);
    (("pdbx_entity_poly_domain","entity_poly_seq","3"),[("end_mon_id","mon_id"); ("end_seq_num","num"); ]);
    (("em_crystal_formation","em_specimen","1"),[("specimen_id","id"); ]);
    (("em_layer_lines_depositor_info","em_experiment","1"),[("experiment_id","id"); ]);
    (("ndb_struct_na_base_pair","atom_site","1"),[("model_number","pdbx_PDB_model_num"); ("i_label_asym_id","label_asym_id"); ("i_label_comp_id","label_comp_id"); ("i_label_seq_id","label_seq_id"); ("i_auth_asym_id","auth_asym_id"); ("i_auth_seq_id","auth_seq_id"); ]);
    (("ndb_struct_na_base_pair","atom_site","2"),[("j_label_asym_id","label_asym_id"); ("j_label_comp_id","label_comp_id"); ("j_label_seq_id","label_seq_id"); ("j_auth_asym_id","auth_asym_id"); ("j_auth_seq_id","auth_seq_id"); ]);
    (("pdbx_entity_func_regulatory","pdbx_entity_func_bind_mode","1"),[("bind_mode_id","id"); ]);
    (("geom_contact","atom_site","2"),[("atom_site_auth_asym_id_2","auth_asym_id"); ("atom_site_auth_atom_id_2","auth_atom_id"); ("atom_site_auth_comp_id_2","auth_comp_id"); ("atom_site_auth_seq_id_2","auth_seq_id"); ("atom_site_id_2","id"); ("atom_site_label_alt_id_2","label_alt_id"); ("atom_site_label_comp_id_2","label_comp_id"); ("atom_site_label_atom_id_2","label_atom_id"); ("atom_site_label_seq_id_2","label_seq_id"); ("atom_site_label_asym_id_2","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_2","pdbx_PDB_ins_code"); ]);
    (("geom_contact","atom_site","1"),[("atom_site_auth_asym_id_1","auth_asym_id"); ("atom_site_auth_atom_id_1","auth_atom_id"); ("atom_site_auth_comp_id_1","auth_comp_id"); ("atom_site_auth_seq_id_1","auth_seq_id"); ("atom_site_id_1","id"); ("atom_site_label_alt_id_1","label_alt_id"); ("atom_site_label_comp_id_1","label_comp_id"); ("atom_site_label_atom_id_1","label_atom_id"); ("atom_site_label_seq_id_1","label_seq_id"); ("atom_site_label_asym_id_1","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_1","pdbx_PDB_ins_code"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); ]);
    (("pdbx_struct_msym_gen","pdbx_struct_entity_inst","1"),[("entity_inst_id","id"); ]);
    (("pdbx_deposit_group_index","pdbx_deposit_group","1"),[("group_id","group_id"); ]);
    (("pdbx_struct_ref_seq_deletion","pdbx_poly_seq_scheme","1"),[("asym_id","asym_id"); ]);
    (("pdbx_data_processing_reflns","entry","1"),[("entry_id","id"); ]);
    (("pdbx_entity_nonpoly","entity","2"),[("entity_id","id"); ]);
    (("pdbx_entity_nonpoly","chem_comp","1"),[("comp_id","id"); ]);
    (("pdbx_entity_nonpoly","pdbx_nonpoly_scheme","3"),[("entity_id","entity_id"); ("comp_id","mon_id"); ]);
    (("em_grid_pretreatment","em_sample_support","1"),[("sample_support_id","id"); ]);
    (("struct_site_keywords","struct_site","1"),[("site_id","id"); ]);
    (("pdbx_exptl_crystal_cryo_treatment","exptl_crystal","1"),[("crystal_id","id"); ]);
    (("pdbx_audit_revision_category","pdbx_audit_revision_history","1"),[("data_content_type","data_content_type"); ("revision_ordinal","ordinal"); ]);
    (("pdbx_missing_atom_nonpoly","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_PDB_insert_id","pdbx_PDB_ins_code"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ]);
    (("pdbx_feature_sequence_range","citation","1"),[("feature_citation_id","id"); ]);
    (("pdbx_feature_sequence_range","software","3"),[("feature_software_id","name"); ]);
    (("pdbx_feature_sequence_range","pdbx_sequence_range","2"),[("seq_range_id","seq_range_id"); ]);
    (("pdbx_xplor_file","refine","1"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("diffrn_orient_refln","diffrn","1"),[("diffrn_id","id"); ]);
    (("pdbx_refine_aux_file","refine","1"),[("pdbx_refine_id","pdbx_refine_id"); ]);
    (("phasing_MAD_ratio","phasing_MAD_expt","2"),[("expt_id","id"); ]);
    (("phasing_MAD_ratio","phasing_MAD_clust","1"),[("clust_id","id"); ]);
    (("phasing_MAD_ratio","phasing_MAD_set","3"),[("wavelength_1","wavelength"); ]);
    (("phasing_MAD_ratio","phasing_MAD_set","4"),[("wavelength_2","wavelength"); ]);
    (("em_detector","entry","1"),[("entry_id","id"); ]);
    (("pdbx_solvent_atom_site_mapping","atom_site","1"),[("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_atom_id","label_atom_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ("auth_asym_id","auth_asym_id"); ("auth_atom_id","auth_atom_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ]);
    (("pdbx_reference_molecule_details","pdbx_reference_molecule_list","1"),[("family_prd_id","family_prd_id"); ("prd_id","prd_id"); ]);
    (("refine_ls_restr_type","refine_ls_restr","1"),[("type","type"); ]);
    (("pdbx_chem_comp_bond_edit","pdbx_chem_comp_import","1"),[("comp_id","comp_id"); ]);
    (("pdbx_nmr_details","entry","1"),[("entry_id","id"); ]);
    (("pdbx_struct_assembly_auth_evidence_depositor_info","pdbx_struct_assembly_depositor_info","1"),[("assembly_id","id"); ]);
    (("pdbx_reference_molecule_features","pdbx_reference_molecule_list","1"),[("family_prd_id","family_prd_id"); ("prd_id","prd_id"); ]);
    (("pdbx_reference_molecule_related_structures","citation","2"),[("citation_id","id"); ]);
    (("pdbx_reference_molecule_related_structures","pdbx_reference_molecule_list","1"),[("family_prd_id","family_prd_id"); ]);
    (("em_high_pressure_freezing","em_tomography_specimen","1"),[("em_tomography_specimen_id","id"); ]);
    (("refln","exptl_crystal","2"),[("crystal_id","id"); ]);
    (("refln","diffrn","4"),[("pdbx_diffrn_id","id"); ]);
    (("refln","diffrn_radiation_wavelength","1"),[("wavelength_id","id"); ]);
    (("refln","reflns_scale","3"),[("scale_group_code","group_code"); ]);
    (("pdbx_database_proc","entry","1"),[("entry_id","id"); ]);
    (("phasing_MIR_der_refln","phasing_set","2"),[("set_id","id"); ]);
    (("phasing_MIR_der_refln","phasing_MIR_der","1"),[("der_id","id"); ]);
    (("struct_biol_keywords","struct_biol","1"),[("biol_id","id"); ]);
    (("reflns","entry","1"),[("entry_id","id"); ]);
    (("em_3d_fitting_list","em_3d_fitting","1"),[("3d_fitting_id","id"); ]);
    (("pdbx_validate_close_contact","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id_1","auth_asym_id"); ("auth_atom_id_1","auth_atom_id"); ("auth_comp_id_1","auth_comp_id"); ("auth_seq_id_1","auth_seq_id"); ("PDB_ins_code_1","pdbx_PDB_ins_code"); ("label_alt_id_1","label_alt_id"); ]);
    (("pdbx_validate_close_contact","atom_site","2"),[("auth_atom_id_2","auth_atom_id"); ("auth_asym_id_2","auth_asym_id"); ("auth_comp_id_2","auth_comp_id"); ("auth_seq_id_2","auth_seq_id"); ("PDB_ins_code_2","pdbx_PDB_ins_code"); ("label_alt_id_2","label_alt_id"); ]);
    (("em_volume_selection","em_image_processing","1"),[("image_processing_id","id"); ]);
    (("pdbx_soln_scatter_model","pdbx_soln_scatter","1"),[("scatter_id","id"); ]);
    (("pdbx_validate_main_chain_plane","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ("label_alt_id","label_alt_id"); ]);
    (("chem_comp_chir_atom","chem_comp","1"),[("comp_id","id"); ]);
    (("chem_comp_chir_atom","chem_comp_atom","2"),[("atom_id","atom_id"); ]);
    (("chem_comp_chir_atom","chem_comp_chir","3"),[("chir_id","id"); ]);
    (("pdbx_unobs_or_zero_occ_atoms","chem_comp","2"),[("auth_comp_id","id"); ]);
    (("pdbx_unobs_or_zero_occ_atoms","chem_comp","3"),[("label_comp_id","id"); ]);
    (("pdbx_unobs_or_zero_occ_atoms","struct_asym","4"),[("label_asym_id","id"); ]);
    (("pdbx_unobs_or_zero_occ_atoms","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ]);
    (("pdbx_entity_src_gen_chrom","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_chrom","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_chrom","pdbx_robot_system","6"),[("robot_id","id"); ]);
    (("pdbx_entity_src_gen_chrom","pdbx_construct","5"),[("end_construct_id","id"); ]);
    (("pdbx_entity_src_gen_chrom","pdbx_buffer","3"),[("equilibration_buffer_id","id"); ]);
    (("pdbx_entity_src_gen_chrom","pdbx_buffer","4"),[("elution_buffer_id","id"); ]);
    (("pdbx_entity_src_gen_refold","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_refold","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_refold","pdbx_robot_system","7"),[("robot_id","id"); ]);
    (("pdbx_entity_src_gen_refold","pdbx_construct","6"),[("end_construct_id","id"); ]);
    (("pdbx_entity_src_gen_refold","pdbx_buffer","3"),[("denature_buffer_id","id"); ]);
    (("pdbx_entity_src_gen_refold","pdbx_buffer","4"),[("refold_buffer_id","id"); ]);
    (("pdbx_entity_src_gen_refold","pdbx_buffer","5"),[("storage_buffer_id","id"); ]);
    (("pdbx_entity_poly_comp_link_list","entity_poly_seq","5"),[("entity_id","entity_id"); ("entity_comp_num_1","num"); ("comp_id_1","mon_id"); ]);
    (("pdbx_entity_poly_comp_link_list","entity_poly_seq","6"),[("entity_comp_num_2","num"); ("comp_id_2","mon_id"); ]);
    (("pdbx_entity_poly_comp_link_list","chem_comp_atom","1"),[("atom_id_1","atom_id"); ]);
    (("pdbx_entity_poly_comp_link_list","chem_comp_atom","4"),[("leaving_atom_id_2","atom_id"); ]);
    (("pdbx_entity_poly_comp_link_list","chem_comp_atom","2"),[("leaving_atom_id_1","atom_id"); ]);
    (("pdbx_entity_poly_comp_link_list","chem_comp_atom","3"),[("atom_id_2","atom_id"); ]);
    (("pdbx_val_sym_contact","atom_site","2"),[("auth_atom_id_2","auth_atom_id"); ("auth_asym_id_2","auth_asym_id"); ("auth_comp_id_2","auth_comp_id"); ("auth_seq_id_2","auth_seq_id"); ("auth_PDB_insert_id_2","pdbx_PDB_ins_code"); ("label_alt_id_2","label_alt_id"); ("label_asym_id_2","label_asym_id"); ("label_atom_id_2","label_atom_id"); ("label_comp_id_2","label_comp_id"); ("label_seq_id_2","label_seq_id"); ]);
    (("pdbx_val_sym_contact","atom_site","1"),[("model_id","pdbx_PDB_model_num"); ("auth_asym_id_1","auth_asym_id"); ("auth_atom_id_1","auth_atom_id"); ("auth_comp_id_1","auth_comp_id"); ("auth_seq_id_1","auth_seq_id"); ("auth_PDB_insert_id_1","pdbx_PDB_ins_code"); ("label_alt_id_1","label_alt_id"); ("label_asym_id_1","label_asym_id"); ("label_atom_id_1","label_atom_id"); ("label_comp_id_1","label_comp_id"); ("label_seq_id_1","label_seq_id"); ]);
    (("pdbx_data_processing_cell","entry","1"),[("entry_id","id"); ]);
    (("diffrn_refln","diffrn","1"),[("diffrn_id","id"); ]);
    (("diffrn_refln","diffrn_radiation_wavelength","3"),[("wavelength_id","id"); ]);
    (("diffrn_refln","diffrn_attenuator","2"),[("attenuator_code","code"); ]);
    (("diffrn_refln","diffrn_scale_group","4"),[("scale_group_code","code"); ]);
    (("diffrn_refln","diffrn_standard_refln","5"),[("standard_code","code"); ]);
    (("pdbx_remediation_atom_site_mapping","atom_site","1"),[("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_atom_id","label_atom_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("pdbx_remediation_atom_site_mapping","atom_site","2"),[("auth_asym_id","auth_asym_id"); ("auth_atom_id","auth_atom_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ]);
    (("em_2d_projection_selection","entry","1"),[("entry_id","id"); ]);
    (("diffrn_measurement","diffrn","1"),[("diffrn_id","id"); ]);
    (("exptl_crystal_grow_comp","exptl_crystal","1"),[("crystal_id","id"); ]);
    (("pdbx_chem_comp_identifier","chem_comp","1"),[("comp_id","id"); ]);
    (("pdbx_post_process_status","entry","1"),[("entry_id","id"); ]);
    (("geom_angle","atom_site","2"),[("atom_site_auth_asym_id_2","auth_asym_id"); ("atom_site_auth_atom_id_2","auth_atom_id"); ("atom_site_auth_comp_id_2","auth_comp_id"); ("atom_site_auth_seq_id_2","auth_seq_id"); ("atom_site_id_2","id"); ("atom_site_label_alt_id_2","label_alt_id"); ("atom_site_label_comp_id_2","label_comp_id"); ("atom_site_label_atom_id_2","label_atom_id"); ("atom_site_label_seq_id_2","label_seq_id"); ("atom_site_label_asym_id_2","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_2","pdbx_PDB_ins_code"); ]);
    (("geom_angle","atom_site","1"),[("atom_site_auth_asym_id_1","auth_asym_id"); ("atom_site_auth_atom_id_1","auth_atom_id"); ("atom_site_auth_comp_id_1","auth_comp_id"); ("atom_site_auth_seq_id_1","auth_seq_id"); ("atom_site_id_1","id"); ("atom_site_label_alt_id_1","label_alt_id"); ("atom_site_label_comp_id_1","label_comp_id"); ("atom_site_label_atom_id_1","label_atom_id"); ("atom_site_label_seq_id_1","label_seq_id"); ("atom_site_label_asym_id_1","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_1","pdbx_PDB_ins_code"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); ]);
    (("geom_angle","atom_site","3"),[("atom_site_auth_asym_id_3","auth_asym_id"); ("atom_site_auth_atom_id_3","auth_atom_id"); ("atom_site_auth_comp_id_3","auth_comp_id"); ("atom_site_auth_seq_id_3","auth_seq_id"); ("atom_site_id_3","id"); ("atom_site_label_alt_id_3","label_alt_id"); ("atom_site_label_comp_id_3","label_comp_id"); ("atom_site_label_atom_id_3","label_atom_id"); ("atom_site_label_seq_id_3","label_seq_id"); ("atom_site_label_asym_id_3","label_asym_id"); ("pdbx_atom_site_PDB_ins_code_3","pdbx_PDB_ins_code"); ]);
    (("em_virus_shell","em_entity_assembly","1"),[("entity_assembly_id","id"); ]);
    (("struct_mon_prot","atom_site","1"),[("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_alt_id","label_alt_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("label_asym_id","label_asym_id"); ]);
    (("exptl_crystal_grow","exptl_crystal","1"),[("crystal_id","id"); ]);
    (("cell","entry","1"),[("entry_id","id"); ]);
    (("em_entity_assembly_naturalsource","em_entity_assembly","1"),[("entity_assembly_id","id"); ]);
    (("pdbx_audit_revision_item","pdbx_audit_revision_history","1"),[("data_content_type","data_content_type"); ("revision_ordinal","ordinal"); ]);
    (("pdbx_validate_polymer_linkage","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id_1","auth_asym_id"); ("auth_atom_id_1","auth_atom_id"); ("auth_comp_id_1","auth_comp_id"); ("auth_seq_id_1","auth_seq_id"); ("PDB_ins_code_1","pdbx_PDB_ins_code"); ("label_alt_id_1","label_alt_id"); ]);
    (("pdbx_validate_polymer_linkage","atom_site","2"),[("auth_atom_id_2","auth_atom_id"); ("auth_asym_id_2","auth_asym_id"); ("auth_comp_id_2","auth_comp_id"); ("auth_seq_id_2","auth_seq_id"); ("PDB_ins_code_2","pdbx_PDB_ins_code"); ("label_alt_id_2","label_alt_id"); ]);
    (("ndb_struct_feature_na","entry","1"),[("entry_id","id"); ]);
    (("diffrn_radiation","diffrn","1"),[("diffrn_id","id"); ]);
    (("diffrn_radiation","diffrn_radiation_wavelength","2"),[("wavelength_id","id"); ]);
    (("phasing_MIR_der_site","phasing_MIR_der","1"),[("der_id","id"); ]);
    (("pdbx_entity_src_gen_prod_digest","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_prod_digest","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_prod_digest","pdbx_robot_system","4"),[("robot_id","id"); ]);
    (("pdbx_entity_src_gen_prod_digest","pdbx_construct","3"),[("end_construct_id","id"); ]);
    (("em_staining","em_specimen","1"),[("specimen_id","id"); ]);
    (("struct_sheet_order","struct_sheet","1"),[("sheet_id","id"); ]);
    (("struct_sheet_order","struct_sheet_range","3"),[("range_id_2","id"); ]);
    (("struct_sheet_order","struct_sheet_range","2"),[("range_id_1","id"); ]);
    (("pdbx_prerelease_seq","entity","1"),[("entity_id","id"); ]);
    (("pdbx_validate_rmsd_angle","atom_site","2"),[("auth_atom_id_2","auth_atom_id"); ("auth_asym_id_2","auth_asym_id"); ("auth_comp_id_2","auth_comp_id"); ("auth_seq_id_2","auth_seq_id"); ("PDB_ins_code_2","pdbx_PDB_ins_code"); ("label_alt_id_2","label_alt_id"); ]);
    (("pdbx_validate_rmsd_angle","atom_site","3"),[("auth_atom_id_3","auth_atom_id"); ("auth_asym_id_3","auth_asym_id"); ("auth_comp_id_3","auth_comp_id"); ("auth_seq_id_3","auth_seq_id"); ("PDB_ins_code_3","pdbx_PDB_ins_code"); ("label_alt_id_3","label_alt_id"); ]);
    (("pdbx_validate_rmsd_angle","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id_1","auth_asym_id"); ("auth_atom_id_1","auth_atom_id"); ("auth_comp_id_1","auth_comp_id"); ("auth_seq_id_1","auth_seq_id"); ("PDB_ins_code_1","pdbx_PDB_ins_code"); ("label_alt_id_1","label_alt_id"); ]);
    (("pdbx_entity_src_gen_fract","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_fract","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_fract","pdbx_robot_system","4"),[("robot_id","id"); ]);
    (("pdbx_entity_src_gen_fract","pdbx_construct","3"),[("end_construct_id","id"); ]);
    (("pdbx_entity_instance_feature","atom_site","1"),[("asym_id","label_asym_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("comp_id","label_comp_id"); ("seq_num","label_seq_id"); ]);
    (("chem_comp_plane_atom","chem_comp","1"),[("comp_id","id"); ]);
    (("chem_comp_plane_atom","chem_comp_atom","2"),[("atom_id","atom_id"); ]);
    (("chem_comp_plane_atom","chem_comp_plane","3"),[("plane_id","id"); ]);
    (("pdbx_struct_special_symmetry","chem_comp","1"),[("auth_comp_id","id"); ("label_comp_id","id"); ]);
    (("pdbx_struct_special_symmetry","struct_asym","2"),[("label_asym_id","id"); ]);
    (("pdbx_struct_special_symmetry","atom_site","3"),[("PDB_model_num","pdbx_PDB_model_num"); ]);
    (("struct_ncs_dom_lim","struct_asym","1"),[("beg_label_asym_id","id"); ]);
    (("struct_ncs_dom_lim","struct_asym","2"),[("end_label_asym_id","id"); ]);
    (("struct_ncs_dom_lim","struct_ncs_dom","3"),[("dom_id","id"); ("pdbx_ens_id","pdbx_ens_id"); ]);
    (("pdbx_prd_audit","pdbx_reference_molecule","1"),[("prd_id","prd_id"); ]);
    (("pdbx_struct_chem_comp_feature","atom_site","1"),[("pdb_strand_id","auth_asym_id"); ("asym_id","label_asym_id"); ("auth_seq_id","auth_seq_id"); ("seq_num","label_seq_id"); ("auth_comp_id","auth_comp_id"); ]);
    (("pdbx_entity_src_gen_proteolysis","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_proteolysis","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_proteolysis","pdbx_robot_system","5"),[("robot_id","id"); ]);
    (("pdbx_entity_src_gen_proteolysis","pdbx_construct","4"),[("end_construct_id","id"); ]);
    (("pdbx_entity_src_gen_proteolysis","pdbx_buffer","3"),[("cleavage_buffer_id","id"); ]);
    (("pdbx_struct_assembly_auth_classification","pdbx_struct_assembly","1"),[("assembly_id","id"); ]);
    (("pdbx_validate_rmsd_bond","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id_1","auth_asym_id"); ("auth_atom_id_1","auth_atom_id"); ("auth_comp_id_1","auth_comp_id"); ("auth_seq_id_1","auth_seq_id"); ("PDB_ins_code_1","pdbx_PDB_ins_code"); ("label_alt_id_1","label_alt_id"); ]);
    (("pdbx_validate_rmsd_bond","atom_site","2"),[("auth_atom_id_2","auth_atom_id"); ("auth_asym_id_2","auth_asym_id"); ("auth_comp_id_2","auth_comp_id"); ("auth_seq_id_2","auth_seq_id"); ("PDB_ins_code_2","pdbx_PDB_ins_code"); ("label_alt_id_2","label_alt_id"); ]);
    (("pdbx_nmr_refine","entry","1"),[("entry_id","id"); ]);
    (("pdbx_entity_descriptor","entity","1"),[("entity_id","id"); ]);
    (("citation_editor","citation","1"),[("citation_id","id"); ]);
    (("em_start_model","em_image_processing","1"),[("image_processing_id","id"); ]);
    (("pdbx_struct_assembly_auth_evidence","pdbx_struct_assembly","1"),[("assembly_id","id"); ]);
    (("pdbx_distant_solvent_atoms","chem_comp","3"),[("label_comp_id","id"); ]);
    (("pdbx_distant_solvent_atoms","chem_comp","2"),[("auth_comp_id","id"); ]);
    (("pdbx_distant_solvent_atoms","struct_asym","4"),[("label_asym_id","id"); ]);
    (("pdbx_distant_solvent_atoms","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ]);
    (("pdbx_atom_site_aniso_tls","pdbx_refine_tls","3"),[("tls_group_id","id"); ]);
    (("pdbx_atom_site_aniso_tls","atom_site","1"),[("id","id"); ("type_symbol","type_symbol"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_atom_id","auth_atom_id"); ("auth_asym_id","auth_asym_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ("label_asym_id","label_asym_id"); ("label_atom_id","label_atom_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ]);
    (("pdbx_atom_site_aniso_tls","atom_sites_alt","2"),[("label_alt_id","id"); ]);
    (("pdbx_phasing_MR","phasing_set","1"),[("native_set_id","id"); ]);
    (("pdbx_molecule","struct_asym","1"),[("asym_id","id"); ]);
    (("exptl","entry","1"),[("entry_id","id"); ]);
    (("pdbx_struct_group_components","atom_site","2"),[("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("PDB_ins_code","pdbx_PDB_ins_code"); ("PDB_model_num","pdbx_PDB_model_num"); ("label_alt_id","label_alt_id"); ]);
    (("pdbx_struct_group_components","pdbx_struct_group_list","1"),[("struct_group_id","struct_group_id"); ]);
    (("chem_link_chir_atom","chem_link_chir","1"),[("chir_id","id"); ]);
    (("pdbx_nmr_ensemble_rms","entry","1"),[("entry_id","id"); ]);
    (("pdbx_nmr_representative","entry","1"),[("entry_id","id"); ]);
    (("ndb_struct_na_base_pair_step","atom_site","1"),[("model_number","pdbx_PDB_model_num"); ("i_label_asym_id_1","label_asym_id"); ("i_label_comp_id_1","label_comp_id"); ("i_label_seq_id_1","label_seq_id"); ("i_auth_asym_id_1","auth_asym_id"); ("i_auth_seq_id_1","auth_seq_id"); ]);
    (("ndb_struct_na_base_pair_step","atom_site","3"),[("i_label_asym_id_2","label_asym_id"); ("i_label_comp_id_2","label_comp_id"); ("i_label_seq_id_2","label_seq_id"); ("i_auth_asym_id_2","auth_asym_id"); ("i_auth_seq_id_2","auth_seq_id"); ]);
    (("ndb_struct_na_base_pair_step","atom_site","2"),[("j_label_asym_id_1","label_asym_id"); ("j_label_comp_id_1","label_comp_id"); ("j_label_seq_id_1","label_seq_id"); ("j_auth_asym_id_1","auth_asym_id"); ("j_auth_seq_id_1","auth_seq_id"); ]);
    (("ndb_struct_na_base_pair_step","atom_site","4"),[("j_label_asym_id_2","label_asym_id"); ("j_label_comp_id_2","label_comp_id"); ("j_label_seq_id_2","label_seq_id"); ("j_auth_asym_id_2","auth_asym_id"); ("j_auth_seq_id_2","auth_seq_id"); ]);
    (("pdbx_validate_peptide_omega","atom_site","2"),[("auth_asym_id_2","auth_asym_id"); ("auth_comp_id_2","auth_comp_id"); ("auth_seq_id_2","auth_seq_id"); ("PDB_ins_code_2","pdbx_PDB_ins_code"); ("label_alt_id_2","label_alt_id"); ]);
    (("pdbx_validate_peptide_omega","atom_site","1"),[("PDB_model_num","pdbx_PDB_model_num"); ("auth_asym_id_1","auth_asym_id"); ("auth_comp_id_1","auth_comp_id"); ("auth_seq_id_1","auth_seq_id"); ("PDB_ins_code_1","pdbx_PDB_ins_code"); ("label_alt_id_1","label_alt_id"); ]);
    (("em_admin","entry","1"),[("entry_id","id"); ]);
    (("chem_comp_link","chem_comp","1"),[("type_comp_1","type"); ]);
    (("chem_comp_link","chem_comp","2"),[("type_comp_2","type"); ]);
    (("chem_comp_link","chem_link","3"),[("link_id","id"); ]);
    (("pdbx_rms_devs_covalent","entry","1"),[("entry_id","id"); ]);
    (("pdbx_struct_assembly_gen_depositor_info","pdbx_struct_assembly_depositor_info","1"),[("assembly_id","id"); ]);
    (("pdbx_reference_entity_poly_link","pdbx_reference_entity_list","4"),[("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ("component_id","component_id"); ]);
    (("pdbx_reference_entity_poly_link","pdbx_reference_entity_poly","1"),[("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ]);
    (("pdbx_reference_entity_poly_link","pdbx_reference_entity_poly_seq","2"),[("ref_entity_id","ref_entity_id"); ("entity_seq_num_1","num"); ("comp_id_1","mon_id"); ]);
    (("pdbx_reference_entity_poly_link","pdbx_reference_entity_poly_seq","3"),[("ref_entity_id","ref_entity_id"); ("entity_seq_num_2","num"); ("comp_id_2","mon_id"); ]);
    (("pdbx_nmr_spectral_dim","pdbx_nmr_spectral_peak_list","1"),[("spectral_peak_list_id","id"); ]);
    (("struct_mon_prot_cis","atom_site","2"),[("pdbx_auth_asym_id_2","auth_asym_id"); ("pdbx_auth_comp_id_2","auth_comp_id"); ("pdbx_auth_seq_id_2","auth_seq_id"); ("pdbx_label_asym_id_2","label_asym_id"); ("pdbx_label_comp_id_2","label_comp_id"); ("pdbx_label_seq_id_2","label_seq_id"); ("pdbx_PDB_ins_code_2","pdbx_PDB_ins_code"); ]);
    (("struct_mon_prot_cis","atom_site","1"),[("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_alt_id","label_alt_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("label_asym_id","label_asym_id"); ("pdbx_PDB_ins_code","pdbx_PDB_ins_code"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); ]);
    (("pdbx_point_symmetry","entry","1"),[("entry_id","id"); ]);
    (("em_euler_angle_assignment","em_image_processing","1"),[("image_processing_id","id"); ]);
    (("pdbx_entity_src_gen_prod_other_parameter","pdbx_entity_src_gen_prod_other","1"),[("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ]);
    (("pdbx_struct_ref_seq_insertion","pdbx_poly_seq_scheme","1"),[("comp_id","mon_id"); ("asym_id","asym_id"); ("auth_asym_id","pdb_strand_id"); ("auth_seq_id","auth_seq_num"); ("seq_id","seq_id"); ("PDB_ins_code","pdb_ins_code"); ]);
    (("pdbx_chem_comp_model_bond","pdbx_chem_comp_model_atom","1"),[("atom_id_1","atom_id"); ("atom_id_2","atom_id"); ("model_id","model_id"); ]);
    (("pdbx_construct_feature","entry","1"),[("entry_id","id"); ]);
    (("pdbx_construct_feature","pdbx_construct","2"),[("construct_id","id"); ]);
    (("chem_link_angle","chem_link","1"),[("link_id","id"); ]);
    (("pdbx_nmr_ensemble","entry","1"),[("entry_id","id"); ]);
    (("atom_sites_alt_gen","atom_sites_alt","1"),[("alt_id","id"); ]);
    (("atom_sites_alt_gen","atom_sites_alt_ens","2"),[("ens_id","id"); ]);
    (("chemical_conn_bond","chemical_conn_atom","1"),[("atom_1","number"); ]);
    (("chemical_conn_bond","chemical_conn_atom","2"),[("atom_2","number"); ]);
    (("pdbx_entity_src_gen_character","entry","2"),[("entry_id","id"); ]);
    (("pdbx_entity_src_gen_character","entity","1"),[("entity_id","id"); ]);
    (("pdbx_entity_src_gen_character","pdbx_robot_system","3"),[("robot_id","id"); ]);
    (("pdbx_chem_comp_subcomponent_struct_conn","chem_comp_atom","1"),[("entity_id_1","pdbx_component_entity_id"); ("atom_id_1","pdbx_component_atom_id"); ("comp_id_1","pdbx_component_comp_id"); ("seq_id_1","pdbx_residue_numbering"); ]);
    (("pdbx_chem_comp_subcomponent_struct_conn","chem_comp_atom","2"),[("atom_id_2","pdbx_component_atom_id"); ("entity_id_2","pdbx_component_entity_id"); ("comp_id_2","pdbx_component_comp_id"); ("seq_id_2","pdbx_residue_numbering"); ]);
    (("entity_src_nat","entity","1"),[("entity_id","id"); ]);
  ]

  let mmcif_to_pdbml_item,pdbml_to_mmcif_item = 
    let ht = Hashtbl.create 100 in
    List.iter (fun (c,p) -> Hashtbl.add ht c p) [
    ("name","name"); ("command","command"); ("document","document"); 
    ("aniso_B[1][1]","aniso_B11"); ("aniso_B[1][1]_esd","aniso_B11_esd"); ("aniso_B[1][2]","aniso_B12"); ("aniso_B[1][2]_esd","aniso_B12_esd"); ("aniso_B[1][3]","aniso_B13"); ("aniso_B[1][3]_esd","aniso_B13_esd"); ("aniso_B[2][2]","aniso_B22"); ("aniso_B[2][2]_esd","aniso_B22_esd"); ("aniso_B[2][3]","aniso_B23"); ("aniso_B[2][3]_esd","aniso_B23_esd"); ("aniso_B[3][3]","aniso_B33"); ("aniso_B[3][3]_esd","aniso_B33_esd"); ("aniso_ratio","aniso_ratio"); ("aniso_U[1][1]","aniso_U11"); ("aniso_U[1][1]_esd","aniso_U11_esd"); ("aniso_U[1][2]","aniso_U12"); ("aniso_U[1][2]_esd","aniso_U12_esd"); ("aniso_U[1][3]","aniso_U13"); ("aniso_U[1][3]_esd","aniso_U13_esd"); ("aniso_U[2][2]","aniso_U22"); ("aniso_U[2][2]_esd","aniso_U22_esd"); ("aniso_U[2][3]","aniso_U23"); ("aniso_U[2][3]_esd","aniso_U23_esd"); ("aniso_U[3][3]","aniso_U33"); ("aniso_U[3][3]_esd","aniso_U33_esd"); ("attached_hydrogens","attached_hydrogens"); ("auth_asym_id","auth_asym_id"); ("auth_atom_id","auth_atom_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("B_equiv_geom_mean","B_equiv_geom_mean"); ("B_equiv_geom_mean_esd","B_equiv_geom_mean_esd"); ("B_iso_or_equiv","B_iso_or_equiv"); ("B_iso_or_equiv_esd","B_iso_or_equiv_esd"); ("calc_attached_atom","calc_attached_atom"); ("calc_flag","calc_flag"); ("Cartn_x","Cartn_x"); ("Cartn_x_esd","Cartn_x_esd"); ("Cartn_y","Cartn_y"); ("Cartn_y_esd","Cartn_y_esd"); ("Cartn_z","Cartn_z"); ("Cartn_z_esd","Cartn_z_esd"); ("chemical_conn_number","chemical_conn_number"); ("constraints","constraints"); ("details","details"); ("disorder_assembly","disorder_assembly"); ("disorder_group","disorder_group"); ("footnote_id","footnote_id"); ("fract_x","fract_x"); ("fract_x_esd","fract_x_esd"); ("fract_y","fract_y"); ("fract_y_esd","fract_y_esd"); ("fract_z","fract_z"); ("fract_z_esd","fract_z_esd"); ("group_PDB","group_PDB"); ("id","id"); ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_atom_id","label_atom_id"); ("label_comp_id","label_comp_id"); ("label_entity_id","label_entity_id"); ("label_seq_id","label_seq_id"); ("occupancy","occupancy"); ("occupancy_esd","occupancy_esd"); ("restraints","restraints"); ("symmetry_multiplicity","symmetry_multiplicity"); ("thermal_displace_type","thermal_displace_type"); ("type_symbol","type_symbol"); ("U_equiv_geom_mean","U_equiv_geom_mean"); ("U_equiv_geom_mean_esd","U_equiv_geom_mean_esd"); ("U_iso_or_equiv","U_iso_or_equiv"); ("U_iso_or_equiv_esd","U_iso_or_equiv_esd"); ("Wyckoff_symbol","Wyckoff_symbol"); ("adp_type","adp_type"); ("refinement_flags","refinement_flags"); ("refinement_flags_adp","refinement_flags_adp"); ("refinement_flags_occupancy","refinement_flags_occupancy"); ("refinement_flags_posn","refinement_flags_posn"); ("pdbx_auth_alt_id","pdbx_auth_alt_id"); ("pdbx_PDB_ins_code","pdbx_PDB_ins_code"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); ("pdbx_PDB_residue_no","pdbx_PDB_residue_no"); ("pdbx_PDB_residue_name","pdbx_PDB_residue_name"); ("pdbx_PDB_strand_id","pdbx_PDB_strand_id"); ("pdbx_PDB_atom_name","pdbx_PDB_atom_name"); ("pdbx_auth_atom_name","pdbx_auth_atom_name"); ("pdbx_formal_charge","pdbx_formal_charge"); ("pdbx_auth_comp_id","pdbx_auth_comp_id"); ("pdbx_auth_asym_id","pdbx_auth_asym_id"); ("pdbx_auth_seq_id","pdbx_auth_seq_id"); ("pdbx_tls_group_id","pdbx_tls_group_id"); ("pdbx_ncs_dom_id","pdbx_ncs_dom_id"); ("pdbx_struct_group_id","pdbx_struct_group_id"); ("pdbx_group_NDB","pdbx_group_NDB"); ("pdbx_atom_group","pdbx_atom_group"); ("pdbx_label_seq_num","pdbx_label_seq_num"); ("pdbx_not_in_asym","pdbx_not_in_asym"); 
    ("B[1][1]","B11"); ("B[1][1]_esd","B11_esd"); ("B[1][2]","B12"); ("B[1][2]_esd","B12_esd"); ("B[1][3]","B13"); ("B[1][3]_esd","B13_esd"); ("B[2][2]","B22"); ("B[2][2]_esd","B22_esd"); ("B[2][3]","B23"); ("B[2][3]_esd","B23_esd"); ("B[3][3]","B33"); ("B[3][3]_esd","B33_esd"); ("ratio","ratio"); ("id","id"); ("type_symbol","type_symbol"); ("U[1][1]","U11"); ("U[1][1]_esd","U11_esd"); ("U[1][2]","U12"); ("U[1][2]_esd","U12_esd"); ("U[1][3]","U13"); ("U[1][3]_esd","U13_esd"); ("U[2][2]","U22"); ("U[2][2]_esd","U22_esd"); ("U[2][3]","U23"); ("U[2][3]_esd","U23_esd"); ("U[3][3]","U33"); ("U[3][3]_esd","U33_esd"); ("pdbx_auth_seq_id","pdbx_auth_seq_id"); ("pdbx_auth_alt_id","pdbx_auth_alt_id"); ("pdbx_auth_asym_id","pdbx_auth_asym_id"); ("pdbx_auth_atom_id","pdbx_auth_atom_id"); ("pdbx_auth_comp_id","pdbx_auth_comp_id"); ("pdbx_label_seq_id","pdbx_label_seq_id"); ("pdbx_label_alt_id","pdbx_label_alt_id"); ("pdbx_label_asym_id","pdbx_label_asym_id"); ("pdbx_label_atom_id","pdbx_label_atom_id"); ("pdbx_label_comp_id","pdbx_label_comp_id"); ("pdbx_PDB_ins_code","pdbx_PDB_ins_code"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); ("pdbx_not_in_asym","pdbx_not_in_asym"); ("pdbx_PDB_residue_no","pdbx_PDB_residue_no"); ("pdbx_PDB_residue_name","pdbx_PDB_residue_name"); ("pdbx_PDB_strand_id","pdbx_PDB_strand_id"); ("pdbx_PDB_atom_name","pdbx_PDB_atom_name"); ("pdbx_auth_atom_name","pdbx_auth_atom_name"); ("pdbx_label_ins_code","pdbx_label_ins_code"); 
    ("entry_id","entry_id"); ("Cartn_transf_matrix[1][1]","Cartn_transf_matrix11"); ("Cartn_transf_matrix[1][2]","Cartn_transf_matrix12"); ("Cartn_transf_matrix[1][3]","Cartn_transf_matrix13"); ("Cartn_transf_matrix[2][1]","Cartn_transf_matrix21"); ("Cartn_transf_matrix[2][2]","Cartn_transf_matrix22"); ("Cartn_transf_matrix[2][3]","Cartn_transf_matrix23"); ("Cartn_transf_matrix[3][1]","Cartn_transf_matrix31"); ("Cartn_transf_matrix[3][2]","Cartn_transf_matrix32"); ("Cartn_transf_matrix[3][3]","Cartn_transf_matrix33"); ("Cartn_transf_vector[1]","Cartn_transf_vector1"); ("Cartn_transf_vector[2]","Cartn_transf_vector2"); ("Cartn_transf_vector[3]","Cartn_transf_vector3"); ("Cartn_transform_axes","Cartn_transform_axes"); ("fract_transf_matrix[1][1]","fract_transf_matrix11"); ("fract_transf_matrix[1][2]","fract_transf_matrix12"); ("fract_transf_matrix[1][3]","fract_transf_matrix13"); ("fract_transf_matrix[2][1]","fract_transf_matrix21"); ("fract_transf_matrix[2][2]","fract_transf_matrix22"); ("fract_transf_matrix[2][3]","fract_transf_matrix23"); ("fract_transf_matrix[3][1]","fract_transf_matrix31"); ("fract_transf_matrix[3][2]","fract_transf_matrix32"); ("fract_transf_matrix[3][3]","fract_transf_matrix33"); ("fract_transf_vector[1]","fract_transf_vector1"); ("fract_transf_vector[2]","fract_transf_vector2"); ("fract_transf_vector[3]","fract_transf_vector3"); ("solution_primary","solution_primary"); ("solution_secondary","solution_secondary"); ("solution_hydrogens","solution_hydrogens"); ("special_details","special_details"); 
    ("details","details"); ("id","id"); 
    ("details","details"); ("id","id"); 
    ("alt_id","alt_id"); ("ens_id","ens_id"); 
    ("id","id"); ("text","text"); 
    ("analytical_mass_percent","analytical_mass_percent"); ("description","description"); ("number_in_cell","number_in_cell"); ("oxidation_number","oxidation_number"); ("radius_bond","radius_bond"); ("radius_contact","radius_contact"); ("scat_Cromer_Mann_a1","scat_Cromer_Mann_a1"); ("scat_Cromer_Mann_a2","scat_Cromer_Mann_a2"); ("scat_Cromer_Mann_a3","scat_Cromer_Mann_a3"); ("scat_Cromer_Mann_a4","scat_Cromer_Mann_a4"); ("scat_Cromer_Mann_b1","scat_Cromer_Mann_b1"); ("scat_Cromer_Mann_b2","scat_Cromer_Mann_b2"); ("scat_Cromer_Mann_b3","scat_Cromer_Mann_b3"); ("scat_Cromer_Mann_b4","scat_Cromer_Mann_b4"); ("scat_Cromer_Mann_c","scat_Cromer_Mann_c"); ("scat_dispersion_imag","scat_dispersion_imag"); ("scat_dispersion_real","scat_dispersion_real"); ("scat_length_neutron","scat_length_neutron"); ("scat_source","scat_source"); ("scat_versus_stol_list","scat_versus_stol_list"); ("symbol","symbol"); ("scat_dispersion_source","scat_dispersion_source"); ("pdbx_scat_Cromer_Mann_a5","pdbx_scat_Cromer_Mann_a5"); ("pdbx_scat_Cromer_Mann_b5","pdbx_scat_Cromer_Mann_b5"); 
    ("creation_date","creation_date"); ("creation_method","creation_method"); ("revision_id","revision_id"); ("update_record","update_record"); 
    ("address","address"); ("name","name"); ("pdbx_ordinal","pdbx_ordinal"); ("identifier_ORCID","identifier_ORCID"); 
    ("dict_location","dict_location"); ("dict_name","dict_name"); ("dict_version","dict_version"); 
    ("address","address"); ("email","email"); ("fax","fax"); ("name","name"); ("phone","phone"); 
    ("angle_alpha","angle_alpha"); ("angle_alpha_esd","angle_alpha_esd"); ("angle_beta","angle_beta"); ("angle_beta_esd","angle_beta_esd"); ("angle_gamma","angle_gamma"); ("angle_gamma_esd","angle_gamma_esd"); ("entry_id","entry_id"); ("details","details"); ("formula_units_Z","formula_units_Z"); ("length_a","length_a"); ("length_a_esd","length_a_esd"); ("length_b","length_b"); ("length_b_esd","length_b_esd"); ("length_c","length_c"); ("length_c_esd","length_c_esd"); ("volume","volume"); ("volume_esd","volume_esd"); ("Z_PDB","Z_PDB"); ("reciprocal_angle_alpha","reciprocal_angle_alpha"); ("reciprocal_angle_beta","reciprocal_angle_beta"); ("reciprocal_angle_gamma","reciprocal_angle_gamma"); ("reciprocal_angle_alpha_esd","reciprocal_angle_alpha_esd"); ("reciprocal_angle_beta_esd","reciprocal_angle_beta_esd"); ("reciprocal_angle_gamma_esd","reciprocal_angle_gamma_esd"); ("reciprocal_length_a","reciprocal_length_a"); ("reciprocal_length_b","reciprocal_length_b"); ("reciprocal_length_c","reciprocal_length_c"); ("reciprocal_length_a_esd","reciprocal_length_a_esd"); ("reciprocal_length_b_esd","reciprocal_length_b_esd"); ("reciprocal_length_c_esd","reciprocal_length_c_esd"); ("pdbx_unique_axis","pdbx_unique_axis"); 
    ("entry_id","entry_id"); ("pressure","pressure"); ("pressure_esd","pressure_esd"); ("radiation","radiation"); ("reflns_used","reflns_used"); ("temp","temp"); ("temp_esd","temp_esd"); ("theta_max","theta_max"); ("theta_min","theta_min"); ("wavelength","wavelength"); 
    ("index_h","index_h"); ("index_k","index_k"); ("index_l","index_l"); ("theta","theta"); 
    ("formula","formula"); ("formula_weight","formula_weight"); ("id","id"); ("model_details","model_details"); ("model_erf","model_erf"); ("model_source","model_source"); ("mon_nstd_class","mon_nstd_class"); ("mon_nstd_details","mon_nstd_details"); ("mon_nstd_flag","mon_nstd_flag"); ("mon_nstd_parent","mon_nstd_parent"); ("mon_nstd_parent_comp_id","mon_nstd_parent_comp_id"); ("name","name"); ("number_atoms_all","number_atoms_all"); ("number_atoms_nh","number_atoms_nh"); ("one_letter_code","one_letter_code"); ("three_letter_code","three_letter_code"); ("type","type"); ("pdbx_synonyms","pdbx_synonyms"); ("pdbx_modification_details","pdbx_modification_details"); ("pdbx_component_no","pdbx_component_no"); ("pdbx_type","pdbx_type"); ("pdbx_ambiguous_flag","pdbx_ambiguous_flag"); ("pdbx_replaced_by","pdbx_replaced_by"); ("pdbx_replaces","pdbx_replaces"); ("pdbx_formal_charge","pdbx_formal_charge"); ("pdbx_subcomponent_list","pdbx_subcomponent_list"); ("pdbx_model_coordinates_details","pdbx_model_coordinates_details"); ("pdbx_model_coordinates_db_code","pdbx_model_coordinates_db_code"); ("pdbx_ideal_coordinates_details","pdbx_ideal_coordinates_details"); ("pdbx_ideal_coordinates_missing_flag","pdbx_ideal_coordinates_missing_flag"); ("pdbx_model_coordinates_missing_flag","pdbx_model_coordinates_missing_flag"); ("pdbx_initial_date","pdbx_initial_date"); ("pdbx_modified_date","pdbx_modified_date"); ("pdbx_release_status","pdbx_release_status"); ("pdbx_processing_site","pdbx_processing_site"); ("pdbx_number_subcomponents","pdbx_number_subcomponents"); ("pdbx_class_1","pdbx_class_1"); ("pdbx_class_2","pdbx_class_2"); ("pdbx_comp_type","pdbx_comp_type"); ("pdbx_reserved_name","pdbx_reserved_name"); ("pdbx_status","pdbx_status"); ("pdbx_type_modified","pdbx_type_modified"); ("pdbx_casnum","pdbx_casnum"); ("pdbx_smiles","pdbx_smiles"); ("pdbx_nscnum","pdbx_nscnum"); 
    ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("atom_id_3","atom_id_3"); ("comp_id","comp_id"); ("value_angle","value_angle"); ("value_angle_esd","value_angle_esd"); ("value_dist","value_dist"); ("value_dist_esd","value_dist_esd"); 
    ("alt_atom_id","alt_atom_id"); ("atom_id","atom_id"); ("charge","charge"); ("model_Cartn_x","model_Cartn_x"); ("model_Cartn_x_esd","model_Cartn_x_esd"); ("model_Cartn_y","model_Cartn_y"); ("model_Cartn_y_esd","model_Cartn_y_esd"); ("model_Cartn_z","model_Cartn_z"); ("model_Cartn_z_esd","model_Cartn_z_esd"); ("comp_id","comp_id"); ("partial_charge","partial_charge"); ("substruct_code","substruct_code"); ("type_symbol","type_symbol"); ("pdbx_align","pdbx_align"); ("pdbx_ordinal","pdbx_ordinal"); ("pdbx_component_atom_id","pdbx_component_atom_id"); ("pdbx_component_comp_id","pdbx_component_comp_id"); ("pdbx_alt_atom_id","pdbx_alt_atom_id"); ("pdbx_alt_comp_id","pdbx_alt_comp_id"); ("pdbx_model_Cartn_x_ideal","pdbx_model_Cartn_x_ideal"); ("pdbx_model_Cartn_y_ideal","pdbx_model_Cartn_y_ideal"); ("pdbx_model_Cartn_z_ideal","pdbx_model_Cartn_z_ideal"); ("pdbx_stereo_config","pdbx_stereo_config"); ("pdbx_aromatic_flag","pdbx_aromatic_flag"); ("pdbx_leaving_atom_flag","pdbx_leaving_atom_flag"); ("pdbx_residue_numbering","pdbx_residue_numbering"); ("pdbx_polymer_type","pdbx_polymer_type"); ("pdbx_ref_id","pdbx_ref_id"); ("pdbx_component_id","pdbx_component_id"); ("pdbx_component_entity_id","pdbx_component_entity_id"); 
    ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("comp_id","comp_id"); ("value_order","value_order"); ("value_dist","value_dist"); ("value_dist_esd","value_dist_esd"); ("pdbx_ordinal","pdbx_ordinal"); ("pdbx_stereo_config","pdbx_stereo_config"); ("pdbx_aromatic_flag","pdbx_aromatic_flag"); 
    ("atom_id","atom_id"); ("atom_config","atom_config"); ("id","id"); ("comp_id","comp_id"); ("number_atoms_all","number_atoms_all"); ("number_atoms_nh","number_atoms_nh"); ("volume_flag","volume_flag"); ("volume_three","volume_three"); ("volume_three_esd","volume_three_esd"); 
    ("atom_id","atom_id"); ("chir_id","chir_id"); ("comp_id","comp_id"); ("dev","dev"); 
    ("link_id","link_id"); ("details","details"); ("type_comp_1","type_comp_1"); ("type_comp_2","type_comp_2"); 
    ("id","id"); ("comp_id","comp_id"); ("number_atoms_all","number_atoms_all"); ("number_atoms_nh","number_atoms_nh"); 
    ("atom_id","atom_id"); ("comp_id","comp_id"); ("plane_id","plane_id"); ("dist_esd","dist_esd"); 
    ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("atom_id_3","atom_id_3"); ("atom_id_4","atom_id_4"); ("id","id"); ("comp_id","comp_id"); 
    ("comp_id","comp_id"); ("tor_id","tor_id"); ("angle","angle"); ("angle_esd","angle_esd"); ("dist","dist"); ("dist_esd","dist_esd"); 
    ("id","id"); ("details","details"); 
    ("atom_1_comp_id","atom_1_comp_id"); ("atom_2_comp_id","atom_2_comp_id"); ("atom_3_comp_id","atom_3_comp_id"); ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("atom_id_3","atom_id_3"); ("link_id","link_id"); ("value_angle","value_angle"); ("value_angle_esd","value_angle_esd"); ("value_dist","value_dist"); ("value_dist_esd","value_dist_esd"); 
    ("atom_1_comp_id","atom_1_comp_id"); ("atom_2_comp_id","atom_2_comp_id"); ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("link_id","link_id"); ("value_dist","value_dist"); ("value_dist_esd","value_dist_esd"); ("value_order","value_order"); 
    ("atom_comp_id","atom_comp_id"); ("atom_id","atom_id"); ("atom_config","atom_config"); ("id","id"); ("link_id","link_id"); ("number_atoms_all","number_atoms_all"); ("number_atoms_nh","number_atoms_nh"); ("volume_flag","volume_flag"); ("volume_three","volume_three"); ("volume_three_esd","volume_three_esd"); 
    ("atom_comp_id","atom_comp_id"); ("atom_id","atom_id"); ("chir_id","chir_id"); ("dev","dev"); 
    ("id","id"); ("link_id","link_id"); ("number_atoms_all","number_atoms_all"); ("number_atoms_nh","number_atoms_nh"); 
    ("atom_comp_id","atom_comp_id"); ("atom_id","atom_id"); ("plane_id","plane_id"); 
    ("atom_1_comp_id","atom_1_comp_id"); ("atom_2_comp_id","atom_2_comp_id"); ("atom_3_comp_id","atom_3_comp_id"); ("atom_4_comp_id","atom_4_comp_id"); ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("atom_id_3","atom_id_3"); ("atom_id_4","atom_id_4"); ("id","id"); ("link_id","link_id"); 
    ("tor_id","tor_id"); ("angle","angle"); ("angle_esd","angle_esd"); ("dist","dist"); ("dist_esd","dist_esd"); 
    ("entry_id","entry_id"); ("compound_source","compound_source"); ("melting_point","melting_point"); ("name_common","name_common"); ("name_mineral","name_mineral"); ("name_structure_type","name_structure_type"); ("name_systematic","name_systematic"); ("absolute_configuration","absolute_configuration"); ("melting_point_gt","melting_point_gt"); ("melting_point_lt","melting_point_lt"); ("optical_rotation","optical_rotation"); ("properties_biological","properties_biological"); ("properties_physical","properties_physical"); ("temperature_decomposition","temperature_decomposition"); ("temperature_decomposition_esd","temperature_decomposition_esd"); ("temperature_decomposition_gt","temperature_decomposition_gt"); ("temperature_decomposition_lt","temperature_decomposition_lt"); ("temperature_sublimation","temperature_sublimation"); ("temperature_sublimation_esd","temperature_sublimation_esd"); ("temperature_sublimation_gt","temperature_sublimation_gt"); ("temperature_sublimation_lt","temperature_sublimation_lt"); 
    ("charge","charge"); ("display_x","display_x"); ("display_y","display_y"); ("NCA","NCA"); ("NH","NH"); ("number","number"); ("type_symbol","type_symbol"); 
    ("atom_1","atom_1"); ("atom_2","atom_2"); ("type","type"); 
    ("analytical","analytical"); ("entry_id","entry_id"); ("iupac","iupac"); ("moiety","moiety"); ("structural","structural"); ("sum","sum"); ("weight","weight"); ("weight_meas","weight_meas"); 
    ("abstract","abstract"); ("abstract_id_CAS","abstract_id_CAS"); ("book_id_ISBN","book_id_ISBN"); ("book_publisher","book_publisher"); ("book_publisher_city","book_publisher_city"); ("book_title","book_title"); ("coordinate_linkage","coordinate_linkage"); ("country","country"); ("database_id_Medline","database_id_Medline"); ("details","details"); ("id","id"); ("journal_abbrev","journal_abbrev"); ("journal_id_ASTM","journal_id_ASTM"); ("journal_id_CSD","journal_id_CSD"); ("journal_id_ISSN","journal_id_ISSN"); ("journal_full","journal_full"); ("journal_issue","journal_issue"); ("journal_volume","journal_volume"); ("language","language"); ("page_first","page_first"); ("page_last","page_last"); ("title","title"); ("year","year"); ("database_id_CSD","database_id_CSD"); ("pdbx_database_id_DOI","pdbx_database_id_DOI"); ("pdbx_database_id_PubMed","pdbx_database_id_PubMed"); ("unpublished_flag","unpublished_flag"); 
    ("citation_id","citation_id"); ("name","name"); ("ordinal","ordinal"); 
    ("citation_id","citation_id"); ("name","name"); ("ordinal","ordinal"); 
    ("entry_id","entry_id"); ("cell_refinement","cell_refinement"); ("data_collection","data_collection"); ("data_reduction","data_reduction"); ("molecular_graphics","molecular_graphics"); ("publication_material","publication_material"); ("structure_refinement","structure_refinement"); ("structure_solution","structure_solution"); ("pdbx_structure_refinement_method","pdbx_structure_refinement_method"); ("pdbx_data_reduction_ii","pdbx_data_reduction_ii"); ("pdbx_data_reduction_ds","pdbx_data_reduction_ds"); 
    ("entry_id","entry_id"); ("journal_ASTM","journal_ASTM"); ("journal_CSD","journal_CSD"); ("CSD_history","CSD_history"); ("code_CAS","code_CAS"); ("code_CSD","code_CSD"); ("code_ICSD","code_ICSD"); ("code_MDF","code_MDF"); ("code_NBS","code_NBS"); ("code_PDB","code_PDB"); ("code_PDF","code_PDF"); ("code_depnum_ccdc_fiz","code_depnum_ccdc_fiz"); ("code_depnum_ccdc_journal","code_depnum_ccdc_journal"); ("code_depnum_ccdc_archive","code_depnum_ccdc_archive"); ("pdbx_code_NDB","pdbx_code_NDB"); ("pdbx_code_PDB","pdbx_code_PDB"); ("pdbx_related_codes_PDB","pdbx_related_codes_PDB"); 
    ("database_id","database_id"); ("database_code","database_code"); 
    ("id","id"); ("text","text"); 
    ("entry_id","entry_id"); ("origx[1][1]","origx11"); ("origx[1][2]","origx12"); ("origx[1][3]","origx13"); ("origx[2][1]","origx21"); ("origx[2][2]","origx22"); ("origx[2][3]","origx23"); ("origx[3][1]","origx31"); ("origx[3][2]","origx32"); ("origx[3][3]","origx33"); ("origx_vector[1]","origx_vector1"); ("origx_vector[2]","origx_vector2"); ("origx_vector[3]","origx_vector3"); ("scale[1][1]","scale11"); ("scale[1][2]","scale12"); ("scale[1][3]","scale13"); ("scale[2][1]","scale21"); ("scale[2][2]","scale22"); ("scale[2][3]","scale23"); ("scale[3][1]","scale31"); ("scale[3][2]","scale32"); ("scale[3][3]","scale33"); ("scale_vector[1]","scale_vector1"); ("scale_vector[2]","scale_vector2"); ("scale_vector[3]","scale_vector3"); 
    ("id","id"); ("text","text"); 
    ("author_name","author_name"); ("date","date"); ("date_original","date_original"); ("mod_type","mod_type"); ("num","num"); ("replaced_by","replaced_by"); ("replaces","replaces"); ("status","status"); ("pdbx_record_revised_1","pdbx_record_revised_1"); ("pdbx_record_revised_2","pdbx_record_revised_2"); ("pdbx_record_revised_3","pdbx_record_revised_3"); ("pdbx_record_revised_4","pdbx_record_revised_4"); 
    ("details","details"); ("rev_num","rev_num"); ("type","type"); 
    ("details","details"); ("id","id"); ("vector[1]","vector1"); ("vector[2]","vector2"); ("vector[3]","vector3"); 
    ("ambient_environment","ambient_environment"); ("ambient_temp","ambient_temp"); ("ambient_temp_details","ambient_temp_details"); ("ambient_temp_esd","ambient_temp_esd"); ("crystal_id","crystal_id"); ("crystal_support","crystal_support"); ("crystal_treatment","crystal_treatment"); ("details","details"); ("id","id"); ("ambient_pressure","ambient_pressure"); ("ambient_pressure_esd","ambient_pressure_esd"); ("ambient_pressure_gt","ambient_pressure_gt"); ("ambient_pressure_lt","ambient_pressure_lt"); ("ambient_temp_gt","ambient_temp_gt"); ("ambient_temp_lt","ambient_temp_lt"); 
    ("code","code"); ("scale","scale"); ("material","material"); 
    ("details","details"); ("detector","detector"); ("diffrn_id","diffrn_id"); ("type","type"); ("area_resol_mean","area_resol_mean"); ("dtime","dtime"); ("pdbx_frames_total","pdbx_frames_total"); ("pdbx_collection_time_total","pdbx_collection_time_total"); ("pdbx_collection_date","pdbx_collection_date"); 
    ("diffrn_id","diffrn_id"); ("details","details"); ("device","device"); ("device_details","device_details"); ("device_type","device_type"); ("method","method"); ("specimen_support","specimen_support"); ("pdbx_date","pdbx_date"); 
    ("diffrn_id","diffrn_id"); ("type","type"); ("UB[1][1]","UB11"); ("UB[1][2]","UB12"); ("UB[1][3]","UB13"); ("UB[2][1]","UB21"); ("UB[2][2]","UB22"); ("UB[2][3]","UB23"); ("UB[3][1]","UB31"); ("UB[3][2]","UB32"); ("UB[3][3]","UB33"); 
    ("angle_chi","angle_chi"); ("angle_kappa","angle_kappa"); ("angle_omega","angle_omega"); ("angle_phi","angle_phi"); ("angle_psi","angle_psi"); ("angle_theta","angle_theta"); ("diffrn_id","diffrn_id"); ("index_h","index_h"); ("index_k","index_k"); ("index_l","index_l"); 
    ("collimation","collimation"); ("diffrn_id","diffrn_id"); ("filter_edge","filter_edge"); ("inhomogeneity","inhomogeneity"); ("monochromator","monochromator"); ("polarisn_norm","polarisn_norm"); ("polarisn_ratio","polarisn_ratio"); ("probe","probe"); ("type","type"); ("xray_symbol","xray_symbol"); ("wavelength_id","wavelength_id"); ("pdbx_monochromatic_or_laue_m_l","pdbx_monochromatic_or_laue_m_l"); ("pdbx_wavelength_list","pdbx_wavelength_list"); ("pdbx_wavelength","pdbx_wavelength"); ("pdbx_diffrn_protocol","pdbx_diffrn_protocol"); ("pdbx_analyzer","pdbx_analyzer"); ("pdbx_scattering_type","pdbx_scattering_type"); 
    ("id","id"); ("wavelength","wavelength"); ("wt","wt"); 
    ("angle_chi","angle_chi"); ("angle_kappa","angle_kappa"); ("angle_omega","angle_omega"); ("angle_phi","angle_phi"); ("angle_psi","angle_psi"); ("angle_theta","angle_theta"); ("attenuator_code","attenuator_code"); ("counts_bg_1","counts_bg_1"); ("counts_bg_2","counts_bg_2"); ("counts_net","counts_net"); ("counts_peak","counts_peak"); ("counts_total","counts_total"); ("detect_slit_horiz","detect_slit_horiz"); ("detect_slit_vert","detect_slit_vert"); ("diffrn_id","diffrn_id"); ("elapsed_time","elapsed_time"); ("id","id"); ("index_h","index_h"); ("index_k","index_k"); ("index_l","index_l"); ("intensity_net","intensity_net"); ("intensity_sigma","intensity_sigma"); ("scale_group_code","scale_group_code"); ("scan_mode","scan_mode"); ("scan_mode_backgd","scan_mode_backgd"); ("scan_rate","scan_rate"); ("scan_time_backgd","scan_time_backgd"); ("scan_width","scan_width"); ("sint_over_lambda","sint_over_lambda"); ("standard_code","standard_code"); ("wavelength","wavelength"); ("wavelength_id","wavelength_id"); ("class_code","class_code"); ("intensity_u","intensity_u"); 
    ("av_R_equivalents","av_R_equivalents"); ("av_sigmaI_over_netI","av_sigmaI_over_netI"); ("diffrn_id","diffrn_id"); ("limit_h_max","limit_h_max"); ("limit_h_min","limit_h_min"); ("limit_k_max","limit_k_max"); ("limit_k_min","limit_k_min"); ("limit_l_max","limit_l_max"); ("limit_l_min","limit_l_min"); ("number","number"); ("reduction_process","reduction_process"); ("theta_max","theta_max"); ("theta_min","theta_min"); ("transf_matrix[1][1]","transf_matrix11"); ("transf_matrix[1][2]","transf_matrix12"); ("transf_matrix[1][3]","transf_matrix13"); ("transf_matrix[2][1]","transf_matrix21"); ("transf_matrix[2][2]","transf_matrix22"); ("transf_matrix[2][3]","transf_matrix23"); ("transf_matrix[3][1]","transf_matrix31"); ("transf_matrix[3][2]","transf_matrix32"); ("transf_matrix[3][3]","transf_matrix33"); ("av_unetI/netI","av_unetI_over_netI"); ("pdbx_d_res_low","pdbx_d_res_low"); ("pdbx_d_res_high","pdbx_d_res_high"); ("pdbx_percent_possible_obs","pdbx_percent_possible_obs"); ("pdbx_Rmerge_I_obs","pdbx_Rmerge_I_obs"); ("pdbx_Rsym_value","pdbx_Rsym_value"); ("pdbx_chi_squared","pdbx_chi_squared"); ("pdbx_redundancy","pdbx_redundancy"); ("pdbx_rejects","pdbx_rejects"); ("pdbx_observed_criterion","pdbx_observed_criterion"); ("pdbx_number_obs","pdbx_number_obs"); 
    ("code","code"); ("I_net","I_net"); 
    ("current","current"); ("details","details"); ("diffrn_id","diffrn_id"); ("power","power"); ("size","size"); ("source","source"); ("target","target"); ("type","type"); ("voltage","voltage"); ("take-off_angle","take-off_angle"); ("pdbx_wavelength_list","pdbx_wavelength_list"); ("pdbx_wavelength","pdbx_wavelength"); ("pdbx_synchrotron_beamline","pdbx_synchrotron_beamline"); ("pdbx_synchrotron_site","pdbx_synchrotron_site"); ("pdbx_synchrotron_y_n","pdbx_synchrotron_y_n"); ("pdbx_source_specific_beamline","pdbx_source_specific_beamline"); 
    ("code","code"); ("diffrn_id","diffrn_id"); ("index_h","index_h"); ("index_k","index_k"); ("index_l","index_l"); 
    ("diffrn_id","diffrn_id"); ("decay_%","decay_"); ("interval_count","interval_count"); ("interval_time","interval_time"); ("number","number"); ("scale_sigma","scale_sigma"); ("scale_u","scale_u"); 
    ("details","details"); ("formula_weight","formula_weight"); ("id","id"); ("src_method","src_method"); ("type","type"); ("pdbx_description","pdbx_description"); ("pdbx_number_of_molecules","pdbx_number_of_molecules"); ("pdbx_parent_entity_id","pdbx_parent_entity_id"); ("pdbx_mutation","pdbx_mutation"); ("pdbx_fragment","pdbx_fragment"); ("pdbx_ec","pdbx_ec"); ("pdbx_modification","pdbx_modification"); ("pdbx_formula_weight_exptl","pdbx_formula_weight_exptl"); ("pdbx_formula_weight_exptl_method","pdbx_formula_weight_exptl_method"); ("pdbx_target_id","pdbx_target_id"); ("pdbx_entities_per_biological_unit","pdbx_entities_per_biological_unit"); 
    ("entity_id","entity_id"); ("text","text"); ("pdbx_mutation","pdbx_mutation"); ("pdbx_fragment","pdbx_fragment"); ("pdbx_ec","pdbx_ec"); ("pdbx_antibody_isotype","pdbx_antibody_isotype"); 
    ("link_id","link_id"); ("details","details"); ("entity_id_1","entity_id_1"); ("entity_id_2","entity_id_2"); ("entity_seq_num_1","entity_seq_num_1"); ("entity_seq_num_2","entity_seq_num_2"); 
    ("entity_id","entity_id"); ("name","name"); 
    ("entity_id","entity_id"); ("name","name"); ("system","system"); 
    ("entity_id","entity_id"); ("nstd_chirality","nstd_chirality"); ("nstd_linkage","nstd_linkage"); ("nstd_monomer","nstd_monomer"); ("number_of_monomers","number_of_monomers"); ("type","type"); ("type_details","type_details"); ("pdbx_strand_id","pdbx_strand_id"); ("pdbx_seq_one_letter_code","pdbx_seq_one_letter_code"); ("pdbx_seq_one_letter_code_can","pdbx_seq_one_letter_code_can"); ("pdbx_target_identifier","pdbx_target_identifier"); ("pdbx_seq_one_letter_code_sample","pdbx_seq_one_letter_code_sample"); ("pdbx_explicit_linking_flag","pdbx_explicit_linking_flag"); ("pdbx_sequence_evidence_code","pdbx_sequence_evidence_code"); ("pdbx_build_self_reference","pdbx_build_self_reference"); ("pdbx_N_terminal_seq_one_letter_code","pdbx_N_terminal_seq_one_letter_code"); ("pdbx_C_terminal_seq_one_letter_code","pdbx_C_terminal_seq_one_letter_code"); ("pdbx_seq_three_letter_code","pdbx_seq_three_letter_code"); ("pdbx_seq_db_name","pdbx_seq_db_name"); ("pdbx_seq_db_id","pdbx_seq_db_id"); ("pdbx_seq_align_begin","pdbx_seq_align_begin"); ("pdbx_seq_align_end","pdbx_seq_align_end"); 
    ("entity_id","entity_id"); ("hetero","hetero"); ("mon_id","mon_id"); ("num","num"); 
    ("id","id"); ("pdbx_DOI","pdbx_DOI"); 
    ("entry_id","entry_id"); ("id","id"); ("details","details"); 
    ("absorpt_coefficient_mu","absorpt_coefficient_mu"); ("absorpt_correction_T_max","absorpt_correction_T_max"); ("absorpt_correction_T_min","absorpt_correction_T_min"); ("absorpt_correction_type","absorpt_correction_type"); ("absorpt_process_details","absorpt_process_details"); ("entry_id","entry_id"); ("crystals_number","crystals_number"); ("details","details"); ("method","method"); ("method_details","method_details"); 
    ("colour","colour"); ("density_diffrn","density_diffrn"); ("density_Matthews","density_Matthews"); ("density_method","density_method"); ("density_percent_sol","density_percent_sol"); ("description","description"); ("F_000","F_000"); ("id","id"); ("preparation","preparation"); ("size_max","size_max"); ("size_mid","size_mid"); ("size_min","size_min"); ("size_rad","size_rad"); ("colour_lustre","colour_lustre"); ("colour_modifier","colour_modifier"); ("colour_primary","colour_primary"); ("density_meas","density_meas"); ("density_meas_esd","density_meas_esd"); ("density_meas_gt","density_meas_gt"); ("density_meas_lt","density_meas_lt"); ("density_meas_temp","density_meas_temp"); ("density_meas_temp_esd","density_meas_temp_esd"); ("density_meas_temp_gt","density_meas_temp_gt"); ("density_meas_temp_lt","density_meas_temp_lt"); ("pdbx_crystal_image_url","pdbx_crystal_image_url"); ("pdbx_crystal_image_format","pdbx_crystal_image_format"); ("pdbx_mosaicity","pdbx_mosaicity"); ("pdbx_mosaicity_esd","pdbx_mosaicity_esd"); ("pdbx_crystal_image","pdbx_crystal_image"); ("pdbx_x-ray_image","pdbx_x-ray_image"); ("pdbx_x-ray_image_type","pdbx_x-ray_image_type"); ("pdbx_crystal_diffrn_limit","pdbx_crystal_diffrn_limit"); ("pdbx_crystal_diffrn_lifetime","pdbx_crystal_diffrn_lifetime"); ("pdbx_crystal_direction_1","pdbx_crystal_direction_1"); ("pdbx_crystal_direction_2","pdbx_crystal_direction_2"); ("pdbx_crystal_direction_3","pdbx_crystal_direction_3"); 
    ("crystal_id","crystal_id"); ("diffr_chi","diffr_chi"); ("diffr_kappa","diffr_kappa"); ("diffr_phi","diffr_phi"); ("diffr_psi","diffr_psi"); ("index_h","index_h"); ("index_k","index_k"); ("index_l","index_l"); ("perp_dist","perp_dist"); 
    ("apparatus","apparatus"); ("atmosphere","atmosphere"); ("crystal_id","crystal_id"); ("details","details"); ("method","method"); ("method_ref","method_ref"); ("pH","pH"); ("pressure","pressure"); ("pressure_esd","pressure_esd"); ("seeding","seeding"); ("seeding_ref","seeding_ref"); ("temp","temp"); ("temp_details","temp_details"); ("temp_esd","temp_esd"); ("time","time"); ("pdbx_details","pdbx_details"); ("pdbx_pH_range","pdbx_pH_range"); 
    ("conc","conc"); ("details","details"); ("crystal_id","crystal_id"); ("id","id"); ("name","name"); ("sol_id","sol_id"); ("volume","volume"); ("pdbx_conc_final","pdbx_conc_final"); ("pdbx_bath","pdbx_bath"); ("pdbx_salt","pdbx_salt"); ("pdbx_soak_salt","pdbx_soak_salt"); ("pdbx_soak_solv","pdbx_soak_solv"); ("pdbx_solv","pdbx_solv"); 
    ("entry_id","entry_id"); ("details","details"); 
    ("atom_site_id_1","atom_site_id_1"); ("atom_site_label_alt_id_1","atom_site_label_alt_id_1"); ("atom_site_label_atom_id_1","atom_site_label_atom_id_1"); ("atom_site_label_comp_id_1","atom_site_label_comp_id_1"); ("atom_site_label_seq_id_1","atom_site_label_seq_id_1"); ("atom_site_label_asym_id_1","atom_site_label_asym_id_1"); ("atom_site_id_2","atom_site_id_2"); ("atom_site_label_alt_id_2","atom_site_label_alt_id_2"); ("atom_site_label_atom_id_2","atom_site_label_atom_id_2"); ("atom_site_label_comp_id_2","atom_site_label_comp_id_2"); ("atom_site_label_seq_id_2","atom_site_label_seq_id_2"); ("atom_site_label_asym_id_2","atom_site_label_asym_id_2"); ("atom_site_id_3","atom_site_id_3"); ("atom_site_label_alt_id_3","atom_site_label_alt_id_3"); ("atom_site_label_atom_id_3","atom_site_label_atom_id_3"); ("atom_site_label_comp_id_3","atom_site_label_comp_id_3"); ("atom_site_label_seq_id_3","atom_site_label_seq_id_3"); ("atom_site_label_asym_id_3","atom_site_label_asym_id_3"); ("atom_site_auth_asym_id_1","atom_site_auth_asym_id_1"); ("atom_site_auth_atom_id_1","atom_site_auth_atom_id_1"); ("atom_site_auth_comp_id_1","atom_site_auth_comp_id_1"); ("atom_site_auth_seq_id_1","atom_site_auth_seq_id_1"); ("atom_site_auth_atom_id_2","atom_site_auth_atom_id_2"); ("atom_site_auth_asym_id_2","atom_site_auth_asym_id_2"); ("atom_site_auth_comp_id_2","atom_site_auth_comp_id_2"); ("atom_site_auth_seq_id_2","atom_site_auth_seq_id_2"); ("atom_site_auth_atom_id_3","atom_site_auth_atom_id_3"); ("atom_site_auth_asym_id_3","atom_site_auth_asym_id_3"); ("atom_site_auth_comp_id_3","atom_site_auth_comp_id_3"); ("atom_site_auth_seq_id_3","atom_site_auth_seq_id_3"); ("publ_flag","publ_flag"); ("site_symmetry_1","site_symmetry_1"); ("site_symmetry_2","site_symmetry_2"); ("site_symmetry_3","site_symmetry_3"); ("value","value"); ("value_esd","value_esd"); ("pdbx_atom_site_PDB_ins_code_1","pdbx_atom_site_PDB_ins_code_1"); ("pdbx_atom_site_PDB_ins_code_2","pdbx_atom_site_PDB_ins_code_2"); ("pdbx_atom_site_PDB_ins_code_3","pdbx_atom_site_PDB_ins_code_3"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); 
    ("atom_site_id_1","atom_site_id_1"); ("atom_site_label_alt_id_1","atom_site_label_alt_id_1"); ("atom_site_label_atom_id_1","atom_site_label_atom_id_1"); ("atom_site_label_comp_id_1","atom_site_label_comp_id_1"); ("atom_site_label_seq_id_1","atom_site_label_seq_id_1"); ("atom_site_label_asym_id_1","atom_site_label_asym_id_1"); ("atom_site_id_2","atom_site_id_2"); ("atom_site_label_alt_id_2","atom_site_label_alt_id_2"); ("atom_site_label_atom_id_2","atom_site_label_atom_id_2"); ("atom_site_label_comp_id_2","atom_site_label_comp_id_2"); ("atom_site_label_seq_id_2","atom_site_label_seq_id_2"); ("atom_site_label_asym_id_2","atom_site_label_asym_id_2"); ("atom_site_auth_atom_id_1","atom_site_auth_atom_id_1"); ("atom_site_auth_asym_id_1","atom_site_auth_asym_id_1"); ("atom_site_auth_comp_id_1","atom_site_auth_comp_id_1"); ("atom_site_auth_seq_id_1","atom_site_auth_seq_id_1"); ("atom_site_auth_atom_id_2","atom_site_auth_atom_id_2"); ("atom_site_auth_asym_id_2","atom_site_auth_asym_id_2"); ("atom_site_auth_comp_id_2","atom_site_auth_comp_id_2"); ("atom_site_auth_seq_id_2","atom_site_auth_seq_id_2"); ("dist","dist"); ("dist_esd","dist_esd"); ("publ_flag","publ_flag"); ("site_symmetry_1","site_symmetry_1"); ("site_symmetry_2","site_symmetry_2"); ("valence","valence"); ("pdbx_atom_site_PDB_ins_code_1","pdbx_atom_site_PDB_ins_code_1"); ("pdbx_atom_site_PDB_ins_code_2","pdbx_atom_site_PDB_ins_code_2"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); 
    ("atom_site_id_1","atom_site_id_1"); ("atom_site_label_alt_id_1","atom_site_label_alt_id_1"); ("atom_site_label_atom_id_1","atom_site_label_atom_id_1"); ("atom_site_label_comp_id_1","atom_site_label_comp_id_1"); ("atom_site_label_seq_id_1","atom_site_label_seq_id_1"); ("atom_site_label_asym_id_1","atom_site_label_asym_id_1"); ("atom_site_id_2","atom_site_id_2"); ("atom_site_label_alt_id_2","atom_site_label_alt_id_2"); ("atom_site_label_atom_id_2","atom_site_label_atom_id_2"); ("atom_site_label_comp_id_2","atom_site_label_comp_id_2"); ("atom_site_label_seq_id_2","atom_site_label_seq_id_2"); ("atom_site_label_asym_id_2","atom_site_label_asym_id_2"); ("atom_site_auth_atom_id_1","atom_site_auth_atom_id_1"); ("atom_site_auth_asym_id_1","atom_site_auth_asym_id_1"); ("atom_site_auth_comp_id_1","atom_site_auth_comp_id_1"); ("atom_site_auth_seq_id_1","atom_site_auth_seq_id_1"); ("atom_site_auth_atom_id_2","atom_site_auth_atom_id_2"); ("atom_site_auth_asym_id_2","atom_site_auth_asym_id_2"); ("atom_site_auth_comp_id_2","atom_site_auth_comp_id_2"); ("atom_site_auth_seq_id_2","atom_site_auth_seq_id_2"); ("dist","dist"); ("dist_esd","dist_esd"); ("publ_flag","publ_flag"); ("site_symmetry_1","site_symmetry_1"); ("site_symmetry_2","site_symmetry_2"); ("pdbx_atom_site_PDB_ins_code_1","pdbx_atom_site_PDB_ins_code_1"); ("pdbx_atom_site_PDB_ins_code_2","pdbx_atom_site_PDB_ins_code_2"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); 
    ("angle_DHA","angle_DHA"); ("angle_DHA_esd","angle_DHA_esd"); ("atom_site_id_A","atom_site_id_A"); ("atom_site_label_alt_id_A","atom_site_label_alt_id_A"); ("atom_site_label_asym_id_A","atom_site_label_asym_id_A"); ("atom_site_label_atom_id_A","atom_site_label_atom_id_A"); ("atom_site_label_comp_id_A","atom_site_label_comp_id_A"); ("atom_site_label_seq_id_A","atom_site_label_seq_id_A"); ("atom_site_id_D","atom_site_id_D"); ("atom_site_label_alt_id_D","atom_site_label_alt_id_D"); ("atom_site_label_asym_id_D","atom_site_label_asym_id_D"); ("atom_site_label_atom_id_D","atom_site_label_atom_id_D"); ("atom_site_label_comp_id_D","atom_site_label_comp_id_D"); ("atom_site_label_seq_id_D","atom_site_label_seq_id_D"); ("atom_site_id_H","atom_site_id_H"); ("atom_site_label_alt_id_H","atom_site_label_alt_id_H"); ("atom_site_label_asym_id_H","atom_site_label_asym_id_H"); ("atom_site_label_atom_id_H","atom_site_label_atom_id_H"); ("atom_site_label_comp_id_H","atom_site_label_comp_id_H"); ("atom_site_label_seq_id_H","atom_site_label_seq_id_H"); ("atom_site_auth_asym_id_A","atom_site_auth_asym_id_A"); ("atom_site_auth_atom_id_A","atom_site_auth_atom_id_A"); ("atom_site_auth_comp_id_A","atom_site_auth_comp_id_A"); ("atom_site_auth_seq_id_A","atom_site_auth_seq_id_A"); ("atom_site_auth_asym_id_D","atom_site_auth_asym_id_D"); ("atom_site_auth_atom_id_D","atom_site_auth_atom_id_D"); ("atom_site_auth_comp_id_D","atom_site_auth_comp_id_D"); ("atom_site_auth_seq_id_D","atom_site_auth_seq_id_D"); ("atom_site_auth_asym_id_H","atom_site_auth_asym_id_H"); ("atom_site_auth_atom_id_H","atom_site_auth_atom_id_H"); ("atom_site_auth_comp_id_H","atom_site_auth_comp_id_H"); ("atom_site_auth_seq_id_H","atom_site_auth_seq_id_H"); ("dist_DA","dist_DA"); ("dist_DA_esd","dist_DA_esd"); ("dist_DH","dist_DH"); ("dist_DH_esd","dist_DH_esd"); ("dist_HA","dist_HA"); ("dist_HA_esd","dist_HA_esd"); ("publ_flag","publ_flag"); ("site_symmetry_A","site_symmetry_A"); ("site_symmetry_D","site_symmetry_D"); ("site_symmetry_H","site_symmetry_H"); 
    ("atom_site_id_1","atom_site_id_1"); ("atom_site_label_alt_id_1","atom_site_label_alt_id_1"); ("atom_site_label_atom_id_1","atom_site_label_atom_id_1"); ("atom_site_label_comp_id_1","atom_site_label_comp_id_1"); ("atom_site_label_seq_id_1","atom_site_label_seq_id_1"); ("atom_site_label_asym_id_1","atom_site_label_asym_id_1"); ("atom_site_id_2","atom_site_id_2"); ("atom_site_label_alt_id_2","atom_site_label_alt_id_2"); ("atom_site_label_atom_id_2","atom_site_label_atom_id_2"); ("atom_site_label_comp_id_2","atom_site_label_comp_id_2"); ("atom_site_label_seq_id_2","atom_site_label_seq_id_2"); ("atom_site_label_asym_id_2","atom_site_label_asym_id_2"); ("atom_site_id_3","atom_site_id_3"); ("atom_site_label_alt_id_3","atom_site_label_alt_id_3"); ("atom_site_label_atom_id_3","atom_site_label_atom_id_3"); ("atom_site_label_comp_id_3","atom_site_label_comp_id_3"); ("atom_site_label_seq_id_3","atom_site_label_seq_id_3"); ("atom_site_label_asym_id_3","atom_site_label_asym_id_3"); ("atom_site_id_4","atom_site_id_4"); ("atom_site_label_alt_id_4","atom_site_label_alt_id_4"); ("atom_site_label_atom_id_4","atom_site_label_atom_id_4"); ("atom_site_label_comp_id_4","atom_site_label_comp_id_4"); ("atom_site_label_seq_id_4","atom_site_label_seq_id_4"); ("atom_site_label_asym_id_4","atom_site_label_asym_id_4"); ("atom_site_auth_atom_id_1","atom_site_auth_atom_id_1"); ("atom_site_auth_asym_id_1","atom_site_auth_asym_id_1"); ("atom_site_auth_comp_id_1","atom_site_auth_comp_id_1"); ("atom_site_auth_seq_id_1","atom_site_auth_seq_id_1"); ("atom_site_auth_atom_id_2","atom_site_auth_atom_id_2"); ("atom_site_auth_asym_id_2","atom_site_auth_asym_id_2"); ("atom_site_auth_comp_id_2","atom_site_auth_comp_id_2"); ("atom_site_auth_seq_id_2","atom_site_auth_seq_id_2"); ("atom_site_auth_atom_id_3","atom_site_auth_atom_id_3"); ("atom_site_auth_asym_id_3","atom_site_auth_asym_id_3"); ("atom_site_auth_comp_id_3","atom_site_auth_comp_id_3"); ("atom_site_auth_seq_id_3","atom_site_auth_seq_id_3"); ("atom_site_auth_atom_id_4","atom_site_auth_atom_id_4"); ("atom_site_auth_asym_id_4","atom_site_auth_asym_id_4"); ("atom_site_auth_comp_id_4","atom_site_auth_comp_id_4"); ("atom_site_auth_seq_id_4","atom_site_auth_seq_id_4"); ("publ_flag","publ_flag"); ("site_symmetry_1","site_symmetry_1"); ("site_symmetry_2","site_symmetry_2"); ("site_symmetry_3","site_symmetry_3"); ("site_symmetry_4","site_symmetry_4"); ("value","value"); ("value_esd","value_esd"); ("pdbx_atom_site_PDB_ins_code_1","pdbx_atom_site_PDB_ins_code_1"); ("pdbx_atom_site_PDB_ins_code_2","pdbx_atom_site_PDB_ins_code_2"); ("pdbx_atom_site_PDB_ins_code_3","pdbx_atom_site_PDB_ins_code_3"); ("pdbx_atom_site_PDB_ins_code_4","pdbx_atom_site_PDB_ins_code_4"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); 
    ("entry_id","entry_id"); ("coden_ASTM","coden_ASTM"); ("coden_Cambridge","coden_Cambridge"); ("coeditor_address","coeditor_address"); ("coeditor_code","coeditor_code"); ("coeditor_email","coeditor_email"); ("coeditor_fax","coeditor_fax"); ("coeditor_name","coeditor_name"); ("coeditor_notes","coeditor_notes"); ("coeditor_phone","coeditor_phone"); ("data_validation_number","data_validation_number"); ("date_accepted","date_accepted"); ("date_from_coeditor","date_from_coeditor"); ("date_to_coeditor","date_to_coeditor"); ("date_printers_final","date_printers_final"); ("date_printers_first","date_printers_first"); ("date_proofs_in","date_proofs_in"); ("date_proofs_out","date_proofs_out"); ("date_recd_copyright","date_recd_copyright"); ("date_recd_electronic","date_recd_electronic"); ("date_recd_hard_copy","date_recd_hard_copy"); ("issue","issue"); ("language","language"); ("name_full","name_full"); ("page_first","page_first"); ("page_last","page_last"); ("paper_category","paper_category"); ("suppl_publ_number","suppl_publ_number"); ("suppl_publ_pages","suppl_publ_pages"); ("techeditor_address","techeditor_address"); ("techeditor_code","techeditor_code"); ("techeditor_email","techeditor_email"); ("techeditor_fax","techeditor_fax"); ("techeditor_name","techeditor_name"); ("techeditor_notes","techeditor_notes"); ("techeditor_phone","techeditor_phone"); ("volume","volume"); ("year","year"); 
    ("subterm","subterm"); ("term","term"); ("type","type"); 
    ("method","method"); 
    ("details","details"); ("entry_id","entry_id"); ("method","method"); 
    ("details","details"); ("entry_id","entry_id"); ("method","method"); ("parent","parent"); 
    ("details","details"); ("entry_id","entry_id"); ("method","method"); ("pdbx_d_res_low","pdbx_d_res_low"); ("pdbx_d_res_high","pdbx_d_res_high"); ("pdbx_reflns_acentric","pdbx_reflns_acentric"); ("pdbx_reflns_centric","pdbx_reflns_centric"); ("pdbx_reflns","pdbx_reflns"); ("pdbx_fom_acentric","pdbx_fom_acentric"); ("pdbx_fom_centric","pdbx_fom_centric"); ("pdbx_fom","pdbx_fom"); ("pdbx_R_cullis_centric","pdbx_R_cullis_centric"); ("pdbx_R_cullis_acentric","pdbx_R_cullis_acentric"); ("pdbx_R_cullis","pdbx_R_cullis"); ("pdbx_R_kraut_centric","pdbx_R_kraut_centric"); ("pdbx_R_kraut_acentric","pdbx_R_kraut_acentric"); ("pdbx_R_kraut","pdbx_R_kraut"); ("pdbx_loc_centric","pdbx_loc_centric"); ("pdbx_loc_acentric","pdbx_loc_acentric"); ("pdbx_loc","pdbx_loc"); ("pdbx_power_centric","pdbx_power_centric"); ("pdbx_power_acentric","pdbx_power_acentric"); ("pdbx_power","pdbx_power"); ("pdbx_number_data_sets","pdbx_number_data_sets"); ("pdbx_anom_scat_method","pdbx_anom_scat_method"); 
    ("expt_id","expt_id"); ("id","id"); ("number_set","number_set"); 
    ("delta_delta_phi","delta_delta_phi"); ("delta_phi","delta_phi"); ("delta_phi_sigma","delta_phi_sigma"); ("id","id"); ("mean_fom","mean_fom"); ("number_clust","number_clust"); ("R_normal_all","R_normal_all"); ("R_normal_anom_scat","R_normal_anom_scat"); 
    ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("expt_id","expt_id"); ("clust_id","clust_id"); ("ratio_one_wl","ratio_one_wl"); ("ratio_one_wl_centric","ratio_one_wl_centric"); ("ratio_two_wl","ratio_two_wl"); ("wavelength_1","wavelength_1"); ("wavelength_2","wavelength_2"); 
    ("clust_id","clust_id"); ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("expt_id","expt_id"); ("f_double_prime","f_double_prime"); ("f_prime","f_prime"); ("set_id","set_id"); ("wavelength","wavelength"); ("wavelength_details","wavelength_details"); ("pdbx_atom_type","pdbx_atom_type"); ("pdbx_f_prime_refined","pdbx_f_prime_refined"); ("pdbx_f_double_prime_refined","pdbx_f_double_prime_refined"); 
    ("details","details"); ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("entry_id","entry_id"); ("FOM","FOM"); ("FOM_acentric","FOM_acentric"); ("FOM_centric","FOM_centric"); ("method","method"); ("reflns","reflns"); ("reflns_acentric","reflns_acentric"); ("reflns_centric","reflns_centric"); ("reflns_criterion","reflns_criterion"); ("pdbx_number_derivatives","pdbx_number_derivatives"); 
    ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("der_set_id","der_set_id"); ("details","details"); ("id","id"); ("native_set_id","native_set_id"); ("number_of_sites","number_of_sites"); ("power_acentric","power_acentric"); ("power_centric","power_centric"); ("R_cullis_acentric","R_cullis_acentric"); ("R_cullis_anomalous","R_cullis_anomalous"); ("R_cullis_centric","R_cullis_centric"); ("reflns_acentric","reflns_acentric"); ("reflns_anomalous","reflns_anomalous"); ("reflns_centric","reflns_centric"); ("reflns_criteria","reflns_criteria"); ("pdbx_R_kraut_centric","pdbx_R_kraut_centric"); ("pdbx_R_kraut_acentric","pdbx_R_kraut_acentric"); ("pdbx_R_kraut","pdbx_R_kraut"); ("pdbx_loc_centric","pdbx_loc_centric"); ("pdbx_loc_acentric","pdbx_loc_acentric"); ("pdbx_loc","pdbx_loc"); ("pdbx_fom_centric","pdbx_fom_centric"); ("pdbx_fom_acentric","pdbx_fom_acentric"); ("pdbx_fom","pdbx_fom"); ("pdbx_power","pdbx_power"); ("pdbx_R_cullis","pdbx_R_cullis"); ("pdbx_reflns","pdbx_reflns"); 
    ("der_id","der_id"); ("F_calc","F_calc"); ("F_calc_au","F_calc_au"); ("F_meas","F_meas"); ("F_meas_au","F_meas_au"); ("F_meas_sigma","F_meas_sigma"); ("F_meas_sigma_au","F_meas_sigma_au"); ("HL_A_iso","HL_A_iso"); ("HL_B_iso","HL_B_iso"); ("HL_C_iso","HL_C_iso"); ("HL_D_iso","HL_D_iso"); ("index_h","index_h"); ("index_k","index_k"); ("index_l","index_l"); ("phase_calc","phase_calc"); ("set_id","set_id"); 
    ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("der_id","der_id"); ("fom","fom"); ("ha_ampl","ha_ampl"); ("loc","loc"); ("phase","phase"); ("power","power"); ("R_cullis","R_cullis"); ("R_kraut","R_kraut"); ("reflns","reflns"); ("pdbx_R_cullis_centric","pdbx_R_cullis_centric"); ("pdbx_R_cullis_acentric","pdbx_R_cullis_acentric"); ("pdbx_R_kraut_centric","pdbx_R_kraut_centric"); ("pdbx_R_kraut_acentric","pdbx_R_kraut_acentric"); ("pdbx_loc_centric","pdbx_loc_centric"); ("pdbx_loc_acentric","pdbx_loc_acentric"); ("pdbx_power_centric","pdbx_power_centric"); ("pdbx_power_acentric","pdbx_power_acentric"); ("pdbx_fom_centric","pdbx_fom_centric"); ("pdbx_fom_acentric","pdbx_fom_acentric"); ("pdbx_reflns_centric","pdbx_reflns_centric"); ("pdbx_reflns_acentric","pdbx_reflns_acentric"); 
    ("atom_type_symbol","atom_type_symbol"); ("B_iso","B_iso"); ("B_iso_esd","B_iso_esd"); ("Cartn_x","Cartn_x"); ("Cartn_x_esd","Cartn_x_esd"); ("Cartn_y","Cartn_y"); ("Cartn_y_esd","Cartn_y_esd"); ("Cartn_z","Cartn_z"); ("Cartn_z_esd","Cartn_z_esd"); ("der_id","der_id"); ("details","details"); ("fract_x","fract_x"); ("fract_x_esd","fract_x_esd"); ("fract_y","fract_y"); ("fract_y_esd","fract_y_esd"); ("fract_z","fract_z"); ("fract_z_esd","fract_z_esd"); ("id","id"); ("occupancy","occupancy"); ("occupancy_anom","occupancy_anom"); ("occupancy_anom_su","occupancy_anom_su"); ("occupancy_iso","occupancy_iso"); ("occupancy_iso_su","occupancy_iso_su"); 
    ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("FOM","FOM"); ("FOM_acentric","FOM_acentric"); ("FOM_centric","FOM_centric"); ("loc","loc"); ("mean_phase","mean_phase"); ("power","power"); ("R_cullis","R_cullis"); ("R_kraut","R_kraut"); ("reflns","reflns"); ("reflns_acentric","reflns_acentric"); ("reflns_anomalous","reflns_anomalous"); ("reflns_centric","reflns_centric"); ("pdbx_loc_centric","pdbx_loc_centric"); ("pdbx_loc_acentric","pdbx_loc_acentric"); ("pdbx_power_centric","pdbx_power_centric"); ("pdbx_power_acentric","pdbx_power_acentric"); ("pdbx_R_kraut_centric","pdbx_R_kraut_centric"); ("pdbx_R_kraut_acentric","pdbx_R_kraut_acentric"); ("pdbx_R_cullis_centric","pdbx_R_cullis_centric"); ("pdbx_R_cullis_acentric","pdbx_R_cullis_acentric"); 
    ("cell_angle_alpha","cell_angle_alpha"); ("cell_angle_beta","cell_angle_beta"); ("cell_angle_gamma","cell_angle_gamma"); ("cell_length_a","cell_length_a"); ("cell_length_b","cell_length_b"); ("cell_length_c","cell_length_c"); ("detector_specific","detector_specific"); ("detector_type","detector_type"); ("id","id"); ("radiation_source_specific","radiation_source_specific"); ("radiation_wavelength","radiation_wavelength"); ("temp","temp"); ("pdbx_temp_details","pdbx_temp_details"); ("pdbx_d_res_high","pdbx_d_res_high"); ("pdbx_d_res_low","pdbx_d_res_low"); 
    ("set_id","set_id"); ("F_meas","F_meas"); ("F_meas_au","F_meas_au"); ("F_meas_sigma","F_meas_sigma"); ("F_meas_sigma_au","F_meas_sigma_au"); ("index_h","index_h"); ("index_k","index_k"); ("index_l","index_l"); 
    ("entry_id","entry_id"); ("contact_author","contact_author"); ("contact_author_address","contact_author_address"); ("contact_author_email","contact_author_email"); ("contact_author_fax","contact_author_fax"); ("contact_author_name","contact_author_name"); ("contact_author_phone","contact_author_phone"); ("contact_letter","contact_letter"); ("manuscript_creation","manuscript_creation"); ("manuscript_processed","manuscript_processed"); ("manuscript_text","manuscript_text"); ("requested_category","requested_category"); ("requested_coeditor_name","requested_coeditor_name"); ("requested_journal","requested_journal"); ("section_abstract","section_abstract"); ("section_acknowledgements","section_acknowledgements"); ("section_comment","section_comment"); ("section_discussion","section_discussion"); ("section_experimental","section_experimental"); ("section_exptl_prep","section_exptl_prep"); ("section_exptl_refinement","section_exptl_refinement"); ("section_exptl_solution","section_exptl_solution"); ("section_figure_captions","section_figure_captions"); ("section_introduction","section_introduction"); ("section_references","section_references"); ("section_synopsis","section_synopsis"); ("section_table_legends","section_table_legends"); ("section_title","section_title"); ("section_title_footnote","section_title_footnote"); 
    ("address","address"); ("email","email"); ("footnote","footnote"); ("name","name"); ("id_iucr","id_iucr"); 
    ("contents","contents"); ("element","element"); ("format","format"); ("label","label"); ("title","title"); 
    ("entry_id","entry_id"); ("extra_defn","extra_defn"); ("extra_info","extra_info"); ("extra_item","extra_item"); 
    ("aniso_B[1][1]","aniso_B11"); ("aniso_B[1][2]","aniso_B12"); ("aniso_B[1][3]","aniso_B13"); ("aniso_B[2][2]","aniso_B22"); ("aniso_B[2][3]","aniso_B23"); ("aniso_B[3][3]","aniso_B33"); ("B_iso_max","B_iso_max"); ("B_iso_mean","B_iso_mean"); ("B_iso_min","B_iso_min"); ("correlation_coeff_Fo_to_Fc","correlation_coeff_Fo_to_Fc"); ("correlation_coeff_Fo_to_Fc_free","correlation_coeff_Fo_to_Fc_free"); ("details","details"); ("diff_density_max","diff_density_max"); ("diff_density_max_esd","diff_density_max_esd"); ("diff_density_min","diff_density_min"); ("diff_density_min_esd","diff_density_min_esd"); ("diff_density_rms","diff_density_rms"); ("diff_density_rms_esd","diff_density_rms_esd"); ("entry_id","entry_id"); ("pdbx_refine_id","pdbx_refine_id"); ("ls_abs_structure_details","ls_abs_structure_details"); ("ls_abs_structure_Flack","ls_abs_structure_Flack"); ("ls_abs_structure_Flack_esd","ls_abs_structure_Flack_esd"); ("ls_abs_structure_Rogers","ls_abs_structure_Rogers"); ("ls_abs_structure_Rogers_esd","ls_abs_structure_Rogers_esd"); ("ls_d_res_high","ls_d_res_high"); ("ls_d_res_low","ls_d_res_low"); ("ls_extinction_coef","ls_extinction_coef"); ("ls_extinction_coef_esd","ls_extinction_coef_esd"); ("ls_extinction_expression","ls_extinction_expression"); ("ls_extinction_method","ls_extinction_method"); ("ls_goodness_of_fit_all","ls_goodness_of_fit_all"); ("ls_goodness_of_fit_all_esd","ls_goodness_of_fit_all_esd"); ("ls_goodness_of_fit_obs","ls_goodness_of_fit_obs"); ("ls_goodness_of_fit_obs_esd","ls_goodness_of_fit_obs_esd"); ("ls_hydrogen_treatment","ls_hydrogen_treatment"); ("ls_matrix_type","ls_matrix_type"); ("ls_number_constraints","ls_number_constraints"); ("ls_number_parameters","ls_number_parameters"); ("ls_number_reflns_all","ls_number_reflns_all"); ("ls_number_reflns_obs","ls_number_reflns_obs"); ("ls_number_reflns_R_free","ls_number_reflns_R_free"); ("ls_number_reflns_R_work","ls_number_reflns_R_work"); ("ls_number_restraints","ls_number_restraints"); ("ls_percent_reflns_obs","ls_percent_reflns_obs"); ("ls_percent_reflns_R_free","ls_percent_reflns_R_free"); ("ls_R_factor_all","ls_R_factor_all"); ("ls_R_factor_obs","ls_R_factor_obs"); ("ls_R_factor_R_free","ls_R_factor_R_free"); ("ls_R_factor_R_free_error","ls_R_factor_R_free_error"); ("ls_R_factor_R_free_error_details","ls_R_factor_R_free_error_details"); ("ls_R_factor_R_work","ls_R_factor_R_work"); ("ls_R_Fsqd_factor_obs","ls_R_Fsqd_factor_obs"); ("ls_R_I_factor_obs","ls_R_I_factor_obs"); ("ls_redundancy_reflns_all","ls_redundancy_reflns_all"); ("ls_redundancy_reflns_obs","ls_redundancy_reflns_obs"); ("ls_restrained_S_all","ls_restrained_S_all"); ("ls_restrained_S_obs","ls_restrained_S_obs"); ("ls_shift_over_esd_max","ls_shift_over_esd_max"); ("ls_shift_over_esd_mean","ls_shift_over_esd_mean"); ("ls_structure_factor_coef","ls_structure_factor_coef"); ("ls_weighting_details","ls_weighting_details"); ("ls_weighting_scheme","ls_weighting_scheme"); ("ls_wR_factor_all","ls_wR_factor_all"); ("ls_wR_factor_obs","ls_wR_factor_obs"); ("ls_wR_factor_R_free","ls_wR_factor_R_free"); ("ls_wR_factor_R_work","ls_wR_factor_R_work"); ("occupancy_max","occupancy_max"); ("occupancy_min","occupancy_min"); ("solvent_model_details","solvent_model_details"); ("solvent_model_param_bsol","solvent_model_param_bsol"); ("solvent_model_param_ksol","solvent_model_param_ksol"); ("ls_R_factor_gt","ls_R_factor_gt"); ("ls_goodness_of_fit_gt","ls_goodness_of_fit_gt"); ("ls_goodness_of_fit_ref","ls_goodness_of_fit_ref"); ("ls_shift_over_su_max","ls_shift_over_su_max"); ("ls_shift_over_su_max_lt","ls_shift_over_su_max_lt"); ("ls_shift_over_su_mean","ls_shift_over_su_mean"); ("ls_shift_over_su_mean_lt","ls_shift_over_su_mean_lt"); ("pdbx_ls_sigma_I","pdbx_ls_sigma_I"); ("pdbx_ls_sigma_F","pdbx_ls_sigma_F"); ("pdbx_ls_sigma_Fsqd","pdbx_ls_sigma_Fsqd"); ("pdbx_data_cutoff_high_absF","pdbx_data_cutoff_high_absF"); ("pdbx_data_cutoff_high_rms_absF","pdbx_data_cutoff_high_rms_absF"); ("pdbx_data_cutoff_low_absF","pdbx_data_cutoff_low_absF"); ("pdbx_isotropic_thermal_model","pdbx_isotropic_thermal_model"); ("pdbx_ls_cross_valid_method","pdbx_ls_cross_valid_method"); ("pdbx_method_to_determine_struct","pdbx_method_to_determine_struct"); ("pdbx_starting_model","pdbx_starting_model"); ("pdbx_stereochemistry_target_values","pdbx_stereochemistry_target_values"); ("pdbx_R_Free_selection_details","pdbx_R_Free_selection_details"); ("pdbx_stereochem_target_val_spec_case","pdbx_stereochem_target_val_spec_case"); ("pdbx_overall_ESU_R","pdbx_overall_ESU_R"); ("pdbx_overall_ESU_R_Free","pdbx_overall_ESU_R_Free"); ("pdbx_solvent_vdw_probe_radii","pdbx_solvent_vdw_probe_radii"); ("pdbx_solvent_ion_probe_radii","pdbx_solvent_ion_probe_radii"); ("pdbx_solvent_shrinkage_radii","pdbx_solvent_shrinkage_radii"); ("pdbx_real_space_R","pdbx_real_space_R"); ("pdbx_density_correlation","pdbx_density_correlation"); ("pdbx_pd_number_of_powder_patterns","pdbx_pd_number_of_powder_patterns"); ("pdbx_pd_number_of_points","pdbx_pd_number_of_points"); ("pdbx_pd_meas_number_of_points","pdbx_pd_meas_number_of_points"); ("pdbx_pd_proc_ls_prof_R_factor","pdbx_pd_proc_ls_prof_R_factor"); ("pdbx_pd_proc_ls_prof_wR_factor","pdbx_pd_proc_ls_prof_wR_factor"); ("pdbx_pd_Marquardt_correlation_coeff","pdbx_pd_Marquardt_correlation_coeff"); ("pdbx_pd_Fsqrd_R_factor","pdbx_pd_Fsqrd_R_factor"); ("pdbx_pd_ls_matrix_band_width","pdbx_pd_ls_matrix_band_width"); ("pdbx_overall_phase_error","pdbx_overall_phase_error"); ("pdbx_overall_SU_R_free_Cruickshank_DPI","pdbx_overall_SU_R_free_Cruickshank_DPI"); ("pdbx_overall_SU_R_free_Blow_DPI","pdbx_overall_SU_R_free_Blow_DPI"); ("pdbx_overall_SU_R_Blow_DPI","pdbx_overall_SU_R_Blow_DPI"); ("pdbx_TLS_residual_ADP_flag","pdbx_TLS_residual_ADP_flag"); ("pdbx_diffrn_id","pdbx_diffrn_id"); ("overall_SU_B","overall_SU_B"); ("overall_SU_ML","overall_SU_ML"); ("overall_SU_R_Cruickshank_DPI","overall_SU_R_Cruickshank_DPI"); ("overall_SU_R_free","overall_SU_R_free"); ("overall_FOM_free_R_set","overall_FOM_free_R_set"); ("overall_FOM_work_R_set","overall_FOM_work_R_set"); ("pdbx_average_fsc_overall","pdbx_average_fsc_overall"); ("pdbx_average_fsc_work","pdbx_average_fsc_work"); ("pdbx_average_fsc_free","pdbx_average_fsc_free"); ("pdbx_overall_ESU_B","pdbx_overall_ESU_B"); ("pdbx_overall_ESU_ML","pdbx_overall_ESU_ML"); 
    ("entry_id","entry_id"); ("pdbx_refine_id","pdbx_refine_id"); ("Luzzati_coordinate_error_free","Luzzati_coordinate_error_free"); ("Luzzati_coordinate_error_obs","Luzzati_coordinate_error_obs"); ("Luzzati_d_res_low_free","Luzzati_d_res_low_free"); ("Luzzati_d_res_low_obs","Luzzati_d_res_low_obs"); ("Luzzati_sigma_a_free","Luzzati_sigma_a_free"); ("Luzzati_sigma_a_free_details","Luzzati_sigma_a_free_details"); ("Luzzati_sigma_a_obs","Luzzati_sigma_a_obs"); ("Luzzati_sigma_a_obs_details","Luzzati_sigma_a_obs_details"); ("number_disordered_residues","number_disordered_residues"); ("occupancy_sum_hydrogen","occupancy_sum_hydrogen"); ("occupancy_sum_non_hydrogen","occupancy_sum_non_hydrogen"); ("RG_d_res_high","RG_d_res_high"); ("RG_d_res_low","RG_d_res_low"); ("RG_free","RG_free"); ("RG_work","RG_work"); ("RG_free_work_ratio","RG_free_work_ratio"); ("pdbx_Luzzati_d_res_high_obs","pdbx_Luzzati_d_res_high_obs"); 
    ("pdbx_refine_id","pdbx_refine_id"); ("class","class"); ("details","details"); ("treatment","treatment"); ("value","value"); ("pdbx_residue_name","pdbx_residue_name"); ("pdbx_strand","pdbx_strand"); ("pdbx_residue_num","pdbx_residue_num"); 
    ("pdbx_refine_id","pdbx_refine_id"); ("number_terms","number_terms"); ("residual","residual"); ("type","type"); ("weight","weight"); 
    ("pdbx_refine_id","pdbx_refine_id"); ("cycle_id","cycle_id"); ("details","details"); ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("number_atoms_solvent","number_atoms_solvent"); ("number_atoms_total","number_atoms_total"); ("number_reflns_all","number_reflns_all"); ("number_reflns_obs","number_reflns_obs"); ("number_reflns_R_free","number_reflns_R_free"); ("number_reflns_R_work","number_reflns_R_work"); ("R_factor_all","R_factor_all"); ("R_factor_obs","R_factor_obs"); ("R_factor_R_free","R_factor_R_free"); ("R_factor_R_work","R_factor_R_work"); ("pdbx_number_residues_total","pdbx_number_residues_total"); ("pdbx_B_iso_mean_ligand","pdbx_B_iso_mean_ligand"); ("pdbx_B_iso_mean_solvent","pdbx_B_iso_mean_solvent"); ("pdbx_number_atoms_protein","pdbx_number_atoms_protein"); ("pdbx_number_atoms_nucleic_acid","pdbx_number_atoms_nucleic_acid"); ("pdbx_number_atoms_ligand","pdbx_number_atoms_ligand"); ("pdbx_number_atoms_lipid","pdbx_number_atoms_lipid"); ("pdbx_number_atoms_carb","pdbx_number_atoms_carb"); ("pdbx_pseudo_atom_details","pdbx_pseudo_atom_details"); ("pdbx_number_atoms_solvent","pdbx_number_atoms_solvent"); ("pdbx_number_atoms_total","pdbx_number_atoms_total"); 
    ("pdbx_refine_id","pdbx_refine_id"); ("criterion","criterion"); ("dev_ideal","dev_ideal"); ("dev_ideal_target","dev_ideal_target"); ("number","number"); ("rejects","rejects"); ("type","type"); ("weight","weight"); ("pdbx_restraint_function","pdbx_restraint_function"); 
    ("pdbx_refine_id","pdbx_refine_id"); ("dom_id","dom_id"); ("ncs_model_details","ncs_model_details"); ("rms_dev_B_iso","rms_dev_B_iso"); ("rms_dev_position","rms_dev_position"); ("weight_B_iso","weight_B_iso"); ("weight_position","weight_position"); ("pdbx_ordinal","pdbx_ordinal"); ("pdbx_type","pdbx_type"); ("pdbx_asym_id","pdbx_asym_id"); ("pdbx_auth_asym_id","pdbx_auth_asym_id"); ("pdbx_number","pdbx_number"); ("pdbx_rms","pdbx_rms"); ("pdbx_weight","pdbx_weight"); ("pdbx_ens_id","pdbx_ens_id"); 
    ("distance_cutoff_high","distance_cutoff_high"); ("distance_cutoff_low","distance_cutoff_low"); ("type","type"); 
    ("pdbx_refine_id","pdbx_refine_id"); ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("number_reflns_all","number_reflns_all"); ("number_reflns_obs","number_reflns_obs"); ("number_reflns_R_free","number_reflns_R_free"); ("number_reflns_R_work","number_reflns_R_work"); ("percent_reflns_obs","percent_reflns_obs"); ("percent_reflns_R_free","percent_reflns_R_free"); ("R_factor_all","R_factor_all"); ("R_factor_obs","R_factor_obs"); ("R_factor_R_free","R_factor_R_free"); ("R_factor_R_free_error","R_factor_R_free_error"); ("R_factor_R_work","R_factor_R_work"); ("redundancy_reflns_all","redundancy_reflns_all"); ("redundancy_reflns_obs","redundancy_reflns_obs"); ("wR_factor_all","wR_factor_all"); ("wR_factor_obs","wR_factor_obs"); ("wR_factor_R_free","wR_factor_R_free"); ("wR_factor_R_work","wR_factor_R_work"); ("pdbx_total_number_of_bins_used","pdbx_total_number_of_bins_used"); ("pdbx_phase_error","pdbx_phase_error"); ("pdbx_fsc_work","pdbx_fsc_work"); ("pdbx_fsc_free","pdbx_fsc_free"); 
    ("pdbx_refine_id","pdbx_refine_id"); ("class","class"); ("details","details"); ("treatment","treatment"); ("value","value"); 
    ("A_calc","A_calc"); ("A_calc_au","A_calc_au"); ("A_meas","A_meas"); ("A_meas_au","A_meas_au"); ("B_calc","B_calc"); ("B_calc_au","B_calc_au"); ("B_meas","B_meas"); ("B_meas_au","B_meas_au"); ("crystal_id","crystal_id"); ("F_calc","F_calc"); ("F_calc_au","F_calc_au"); ("F_meas","F_meas"); ("F_meas_au","F_meas_au"); ("F_meas_sigma","F_meas_sigma"); ("F_meas_sigma_au","F_meas_sigma_au"); ("F_squared_calc","F_squared_calc"); ("F_squared_meas","F_squared_meas"); ("F_squared_sigma","F_squared_sigma"); ("fom","fom"); ("index_h","index_h"); ("index_k","index_k"); ("index_l","index_l"); ("intensity_calc","intensity_calc"); ("intensity_meas","intensity_meas"); ("intensity_sigma","intensity_sigma"); ("status","status"); ("phase_calc","phase_calc"); ("phase_meas","phase_meas"); ("refinement_status","refinement_status"); ("scale_group_code","scale_group_code"); ("sint_over_lambda","sint_over_lambda"); ("symmetry_epsilon","symmetry_epsilon"); ("symmetry_multiplicity","symmetry_multiplicity"); ("wavelength","wavelength"); ("wavelength_id","wavelength_id"); ("class_code","class_code"); ("d_spacing","d_spacing"); ("include_status","include_status"); ("mean_path_length_tbar","mean_path_length_tbar"); ("pdbx_F_calc_part_solvent","pdbx_F_calc_part_solvent"); ("pdbx_phase_calc_part_solvent","pdbx_phase_calc_part_solvent"); ("pdbx_F_calc_with_solvent","pdbx_F_calc_with_solvent"); ("pdbx_phase_calc_with_solvent","pdbx_phase_calc_with_solvent"); ("pdbx_anom_difference","pdbx_anom_difference"); ("pdbx_anom_difference_sigma","pdbx_anom_difference_sigma"); ("pdbx_I_plus","pdbx_I_plus"); ("pdbx_I_minus","pdbx_I_minus"); ("pdbx_F_plus","pdbx_F_plus"); ("pdbx_F_minus","pdbx_F_minus"); ("pdbx_I_plus_sigma","pdbx_I_plus_sigma"); ("pdbx_I_minus_sigma","pdbx_I_minus_sigma"); ("pdbx_F_minus_sigma","pdbx_F_minus_sigma"); ("pdbx_F_plus_sigma","pdbx_F_plus_sigma"); ("pdbx_HL_A_iso","pdbx_HL_A_iso"); ("pdbx_HL_B_iso","pdbx_HL_B_iso"); ("pdbx_HL_C_iso","pdbx_HL_C_iso"); ("pdbx_HL_D_iso","pdbx_HL_D_iso"); ("pdbx_fiber_layer","pdbx_fiber_layer"); ("pdbx_fiber_coordinate","pdbx_fiber_coordinate"); ("pdbx_fiber_F_meas_au","pdbx_fiber_F_meas_au"); ("pdbx_FWT","pdbx_FWT"); ("pdbx_PHWT","pdbx_PHWT"); ("pdbx_DELFWT","pdbx_DELFWT"); ("pdbx_DELPHWT","pdbx_DELPHWT"); ("pdbx_diffrn_id","pdbx_diffrn_id"); ("pdbx_r_free_flag","pdbx_r_free_flag"); ("pdbx_anomalous_diff","pdbx_anomalous_diff"); ("pdbx_anomalous_diff_sigma","pdbx_anomalous_diff_sigma"); ("pdbx_phase_cycle","pdbx_phase_cycle"); ("pdbx_cos_phase_calc","pdbx_cos_phase_calc"); ("pdbx_sin_phase_calc","pdbx_sin_phase_calc"); 
    ("I","I"); ("I_over_sigmaI","I_over_sigmaI"); ("index_h","index_h"); ("index_k","index_k"); ("index_l","index_l"); ("sigmaI","sigmaI"); 
    ("B_iso_Wilson_estimate","B_iso_Wilson_estimate"); ("entry_id","entry_id"); ("data_reduction_details","data_reduction_details"); ("data_reduction_method","data_reduction_method"); ("d_resolution_high","d_resolution_high"); ("d_resolution_low","d_resolution_low"); ("details","details"); ("limit_h_max","limit_h_max"); ("limit_h_min","limit_h_min"); ("limit_k_max","limit_k_max"); ("limit_k_min","limit_k_min"); ("limit_l_max","limit_l_max"); ("limit_l_min","limit_l_min"); ("number_all","number_all"); ("number_obs","number_obs"); ("observed_criterion","observed_criterion"); ("observed_criterion_F_max","observed_criterion_F_max"); ("observed_criterion_F_min","observed_criterion_F_min"); ("observed_criterion_I_max","observed_criterion_I_max"); ("observed_criterion_I_min","observed_criterion_I_min"); ("observed_criterion_sigma_F","observed_criterion_sigma_F"); ("observed_criterion_sigma_I","observed_criterion_sigma_I"); ("percent_possible_obs","percent_possible_obs"); ("R_free_details","R_free_details"); ("Rmerge_F_all","Rmerge_F_all"); ("Rmerge_F_obs","Rmerge_F_obs"); ("Friedel_coverage","Friedel_coverage"); ("number_gt","number_gt"); ("threshold_expression","threshold_expression"); ("pdbx_redundancy","pdbx_redundancy"); ("pdbx_Rmerge_I_obs","pdbx_Rmerge_I_obs"); ("pdbx_Rmerge_I_all","pdbx_Rmerge_I_all"); ("pdbx_Rsym_value","pdbx_Rsym_value"); ("pdbx_netI_over_av_sigmaI","pdbx_netI_over_av_sigmaI"); ("pdbx_netI_over_sigmaI","pdbx_netI_over_sigmaI"); ("pdbx_res_netI_over_av_sigmaI_2","pdbx_res_netI_over_av_sigmaI_2"); ("pdbx_res_netI_over_sigmaI_2","pdbx_res_netI_over_sigmaI_2"); ("pdbx_chi_squared","pdbx_chi_squared"); ("pdbx_scaling_rejects","pdbx_scaling_rejects"); ("pdbx_d_res_high_opt","pdbx_d_res_high_opt"); ("pdbx_d_res_low_opt","pdbx_d_res_low_opt"); ("pdbx_d_res_opt_method","pdbx_d_res_opt_method"); ("phase_calculation_details","phase_calculation_details"); ("pdbx_Rrim_I_all","pdbx_Rrim_I_all"); ("pdbx_Rpim_I_all","pdbx_Rpim_I_all"); ("pdbx_d_opt","pdbx_d_opt"); ("pdbx_number_measured_all","pdbx_number_measured_all"); ("pdbx_diffrn_id","pdbx_diffrn_id"); ("pdbx_ordinal","pdbx_ordinal"); ("pdbx_CC_half","pdbx_CC_half"); ("pdbx_R_split","pdbx_R_split"); ("pdbx_redundancy_reflns_obs","pdbx_redundancy_reflns_obs"); ("pdbx_number_anomalous","pdbx_number_anomalous"); ("pdbx_Rrim_I_all_anomalous","pdbx_Rrim_I_all_anomalous"); ("pdbx_Rpim_I_all_anomalous","pdbx_Rpim_I_all_anomalous"); ("pdbx_Rmerge_I_anomalous","pdbx_Rmerge_I_anomalous"); 
    ("group_code","group_code"); ("meas_F","meas_F"); ("meas_F_squared","meas_F_squared"); ("meas_intensity","meas_intensity"); 
    ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("meanI_over_sigI_all","meanI_over_sigI_all"); ("meanI_over_sigI_obs","meanI_over_sigI_obs"); ("number_measured_all","number_measured_all"); ("number_measured_obs","number_measured_obs"); ("number_possible","number_possible"); ("number_unique_all","number_unique_all"); ("number_unique_obs","number_unique_obs"); ("percent_possible_all","percent_possible_all"); ("percent_possible_obs","percent_possible_obs"); ("Rmerge_F_all","Rmerge_F_all"); ("Rmerge_F_obs","Rmerge_F_obs"); ("Rmerge_I_all","Rmerge_I_all"); ("Rmerge_I_obs","Rmerge_I_obs"); ("meanI_over_sigI_gt","meanI_over_sigI_gt"); ("meanI_over_uI_all","meanI_over_uI_all"); ("meanI_over_uI_gt","meanI_over_uI_gt"); ("number_measured_gt","number_measured_gt"); ("number_unique_gt","number_unique_gt"); ("percent_possible_gt","percent_possible_gt"); ("Rmerge_F_gt","Rmerge_F_gt"); ("Rmerge_I_gt","Rmerge_I_gt"); ("pdbx_redundancy","pdbx_redundancy"); ("pdbx_Rsym_value","pdbx_Rsym_value"); ("pdbx_chi_squared","pdbx_chi_squared"); ("pdbx_netI_over_sigmaI_all","pdbx_netI_over_sigmaI_all"); ("pdbx_netI_over_sigmaI_obs","pdbx_netI_over_sigmaI_obs"); ("pdbx_Rrim_I_all","pdbx_Rrim_I_all"); ("pdbx_Rpim_I_all","pdbx_Rpim_I_all"); ("pdbx_rejects","pdbx_rejects"); ("pdbx_ordinal","pdbx_ordinal"); ("pdbx_diffrn_id","pdbx_diffrn_id"); ("pdbx_CC_half","pdbx_CC_half"); ("pdbx_R_split","pdbx_R_split"); ("pdbx_redundancy_reflns_obs","pdbx_redundancy_reflns_obs"); ("pdbx_number_anomalous","pdbx_number_anomalous"); ("pdbx_Rrim_I_all_anomalous","pdbx_Rrim_I_all_anomalous"); ("pdbx_Rpim_I_all_anomalous","pdbx_Rpim_I_all_anomalous"); ("pdbx_Rmerge_I_all_anomalous","pdbx_Rmerge_I_all_anomalous"); 
    ("citation_id","citation_id"); ("classification","classification"); ("compiler_name","compiler_name"); ("compiler_version","compiler_version"); ("contact_author","contact_author"); ("contact_author_email","contact_author_email"); ("date","date"); ("description","description"); ("dependencies","dependencies"); ("hardware","hardware"); ("language","language"); ("location","location"); ("mods","mods"); ("name","name"); ("os","os"); ("os_version","os_version"); ("type","type"); ("version","version"); ("pdbx_ordinal","pdbx_ordinal"); 
    ("entry_id","entry_id"); ("title","title"); ("pdbx_descriptor","pdbx_descriptor"); ("pdbx_model_details","pdbx_model_details"); ("pdbx_formula_weight","pdbx_formula_weight"); ("pdbx_formula_weight_method","pdbx_formula_weight_method"); ("pdbx_model_type_details","pdbx_model_type_details"); ("pdbx_CASP_flag","pdbx_CASP_flag"); ("pdbx_details","pdbx_details"); ("pdbx_title_text","pdbx_title_text"); 
    ("details","details"); ("entity_id","entity_id"); ("id","id"); ("pdbx_modified","pdbx_modified"); ("pdbx_blank_PDB_chainid_flag","pdbx_blank_PDB_chainid_flag"); ("pdbx_PDB_id","pdbx_PDB_id"); ("pdbx_alt_id","pdbx_alt_id"); ("pdbx_type","pdbx_type"); ("pdbx_order","pdbx_order"); ("pdbx_fraction_per_asym_unit","pdbx_fraction_per_asym_unit"); ("pdbx_missing_num_begin_of_chain_not_in_seqres","pdbx_missing_num_begin_of_chain_not_in_seqres"); ("pdbx_missing_num_end_of_chain_not_in_seqres","pdbx_missing_num_end_of_chain_not_in_seqres"); ("pdbx_missing_num_begin_of_chain_in_seqres","pdbx_missing_num_begin_of_chain_in_seqres"); 
    ("details","details"); ("id","id"); ("pdbx_parent_biol_id","pdbx_parent_biol_id"); ("pdbx_formula_weight","pdbx_formula_weight"); ("pdbx_formula_weight_method","pdbx_formula_weight_method"); ("pdbx_aggregation_state","pdbx_aggregation_state"); ("pdbx_assembly_method","pdbx_assembly_method"); 
    ("asym_id","asym_id"); ("biol_id","biol_id"); ("details","details"); ("symmetry","symmetry"); ("pdbx_full_symmetry_operation","pdbx_full_symmetry_operation"); ("pdbx_PDB_order","pdbx_PDB_order"); ("pdbx_new_asym_id","pdbx_new_asym_id"); ("pdbx_new_pdb_asym_id","pdbx_new_pdb_asym_id"); ("pdbx_color_red","pdbx_color_red"); ("pdbx_color_green","pdbx_color_green"); ("pdbx_color_blue","pdbx_color_blue"); ("pdbx_after_begin_residue_no","pdbx_after_begin_residue_no"); ("pdbx_after_end_residue_no","pdbx_after_end_residue_no"); ("pdbx_before_begin_residue_no","pdbx_before_begin_residue_no"); ("pdbx_before_end_residue_no","pdbx_before_end_residue_no"); 
    ("biol_id","biol_id"); ("text","text"); 
    ("biol_id","biol_id"); ("details","details"); ("id","id"); ("rot_matrix[1][1]","rot_matrix11"); ("rot_matrix[1][2]","rot_matrix12"); ("rot_matrix[1][3]","rot_matrix13"); ("rot_matrix[2][1]","rot_matrix21"); ("rot_matrix[2][2]","rot_matrix22"); ("rot_matrix[2][3]","rot_matrix23"); ("rot_matrix[3][1]","rot_matrix31"); ("rot_matrix[3][2]","rot_matrix32"); ("rot_matrix[3][3]","rot_matrix33"); ("pdbx_vector[1]","pdbx_vector1"); ("pdbx_vector[2]","pdbx_vector2"); ("pdbx_vector[3]","pdbx_vector3"); 
    ("beg_label_asym_id","beg_label_asym_id"); ("beg_label_comp_id","beg_label_comp_id"); ("beg_label_seq_id","beg_label_seq_id"); ("beg_auth_asym_id","beg_auth_asym_id"); ("beg_auth_comp_id","beg_auth_comp_id"); ("beg_auth_seq_id","beg_auth_seq_id"); ("conf_type_id","conf_type_id"); ("details","details"); ("end_label_asym_id","end_label_asym_id"); ("end_label_comp_id","end_label_comp_id"); ("end_label_seq_id","end_label_seq_id"); ("end_auth_asym_id","end_auth_asym_id"); ("end_auth_comp_id","end_auth_comp_id"); ("end_auth_seq_id","end_auth_seq_id"); ("id","id"); ("pdbx_beg_PDB_ins_code","pdbx_beg_PDB_ins_code"); ("pdbx_end_PDB_ins_code","pdbx_end_PDB_ins_code"); ("pdbx_PDB_helix_class","pdbx_PDB_helix_class"); ("pdbx_PDB_helix_length","pdbx_PDB_helix_length"); ("pdbx_PDB_helix_id","pdbx_PDB_helix_id"); 
    ("criteria","criteria"); ("id","id"); ("reference","reference"); 
    ("conn_type_id","conn_type_id"); ("details","details"); ("id","id"); ("ptnr1_label_alt_id","ptnr1_label_alt_id"); ("ptnr1_label_asym_id","ptnr1_label_asym_id"); ("ptnr1_label_atom_id","ptnr1_label_atom_id"); ("ptnr1_label_comp_id","ptnr1_label_comp_id"); ("ptnr1_label_seq_id","ptnr1_label_seq_id"); ("ptnr1_auth_asym_id","ptnr1_auth_asym_id"); ("ptnr1_auth_atom_id","ptnr1_auth_atom_id"); ("ptnr1_auth_comp_id","ptnr1_auth_comp_id"); ("ptnr1_auth_seq_id","ptnr1_auth_seq_id"); ("ptnr1_role","ptnr1_role"); ("ptnr1_symmetry","ptnr1_symmetry"); ("ptnr2_label_alt_id","ptnr2_label_alt_id"); ("ptnr2_label_asym_id","ptnr2_label_asym_id"); ("ptnr2_label_atom_id","ptnr2_label_atom_id"); ("ptnr2_label_comp_id","ptnr2_label_comp_id"); ("ptnr2_label_seq_id","ptnr2_label_seq_id"); ("ptnr2_auth_asym_id","ptnr2_auth_asym_id"); ("ptnr2_auth_atom_id","ptnr2_auth_atom_id"); ("ptnr2_auth_comp_id","ptnr2_auth_comp_id"); ("ptnr2_auth_seq_id","ptnr2_auth_seq_id"); ("ptnr2_role","ptnr2_role"); ("ptnr2_symmetry","ptnr2_symmetry"); ("pdbx_ptnr1_PDB_ins_code","pdbx_ptnr1_PDB_ins_code"); ("pdbx_ptnr1_auth_alt_id","pdbx_ptnr1_auth_alt_id"); ("pdbx_ptnr1_label_alt_id","pdbx_ptnr1_label_alt_id"); ("pdbx_ptnr1_standard_comp_id","pdbx_ptnr1_standard_comp_id"); ("pdbx_ptnr2_PDB_ins_code","pdbx_ptnr2_PDB_ins_code"); ("pdbx_ptnr2_auth_alt_id","pdbx_ptnr2_auth_alt_id"); ("pdbx_ptnr2_label_alt_id","pdbx_ptnr2_label_alt_id"); ("pdbx_ptnr3_auth_alt_id","pdbx_ptnr3_auth_alt_id"); ("pdbx_ptnr3_auth_asym_id","pdbx_ptnr3_auth_asym_id"); ("pdbx_ptnr3_auth_atom_id","pdbx_ptnr3_auth_atom_id"); ("pdbx_ptnr3_auth_comp_id","pdbx_ptnr3_auth_comp_id"); ("pdbx_ptnr3_PDB_ins_code","pdbx_ptnr3_PDB_ins_code"); ("pdbx_ptnr3_auth_seq_id","pdbx_ptnr3_auth_seq_id"); ("pdbx_ptnr3_label_alt_id","pdbx_ptnr3_label_alt_id"); ("pdbx_ptnr3_label_asym_id","pdbx_ptnr3_label_asym_id"); ("pdbx_ptnr3_label_atom_id","pdbx_ptnr3_label_atom_id"); ("pdbx_ptnr3_label_comp_id","pdbx_ptnr3_label_comp_id"); ("pdbx_ptnr3_label_seq_id","pdbx_ptnr3_label_seq_id"); ("pdbx_PDB_id","pdbx_PDB_id"); ("pdbx_dist_value","pdbx_dist_value"); ("pdbx_value_order","pdbx_value_order"); ("pdbx_leaving_atom_flag","pdbx_leaving_atom_flag"); ("pdbx_ptnr1_mod_name","pdbx_ptnr1_mod_name"); ("pdbx_ptnr1_sugar_name","pdbx_ptnr1_sugar_name"); ("pdbx_ptnr1_replaced_atom","pdbx_ptnr1_replaced_atom"); ("pdbx_ptnr3_auth_ins_code","pdbx_ptnr3_auth_ins_code"); 
    ("criteria","criteria"); ("id","id"); ("reference","reference"); 
    ("entry_id","entry_id"); ("text","text"); ("pdbx_keywords","pdbx_keywords"); ("pdbx_details","pdbx_details"); 
    ("entry_id","entry_id"); ("prot_cis","prot_cis"); ("RSCC","RSCC"); ("RSR","RSR"); 
    ("alpha","alpha"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("beta","beta"); ("chi1","chi1"); ("chi2","chi2"); ("delta","delta"); ("details","details"); ("epsilon","epsilon"); ("gamma","gamma"); ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("mean_B_all","mean_B_all"); ("mean_B_base","mean_B_base"); ("mean_B_phos","mean_B_phos"); ("mean_B_sugar","mean_B_sugar"); ("nu0","nu0"); ("nu1","nu1"); ("nu2","nu2"); ("nu3","nu3"); ("nu4","nu4"); ("P","P"); ("RSCC_all","RSCC_all"); ("RSCC_base","RSCC_base"); ("RSCC_phos","RSCC_phos"); ("RSCC_sugar","RSCC_sugar"); ("RSR_all","RSR_all"); ("RSR_base","RSR_base"); ("RSR_phos","RSR_phos"); ("RSR_sugar","RSR_sugar"); ("tau0","tau0"); ("tau1","tau1"); ("tau2","tau2"); ("tau3","tau3"); ("tau4","tau4"); ("taum","taum"); ("zeta","zeta"); 
    ("chi1","chi1"); ("chi2","chi2"); ("chi3","chi3"); ("chi4","chi4"); ("chi5","chi5"); ("details","details"); ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("RSCC_all","RSCC_all"); ("RSCC_main","RSCC_main"); ("RSCC_side","RSCC_side"); ("RSR_all","RSR_all"); ("RSR_main","RSR_main"); ("RSR_side","RSR_side"); ("mean_B_all","mean_B_all"); ("mean_B_main","mean_B_main"); ("mean_B_side","mean_B_side"); ("omega","omega"); ("phi","phi"); ("psi","psi"); 
    ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("pdbx_auth_asym_id_2","pdbx_auth_asym_id_2"); ("pdbx_auth_comp_id_2","pdbx_auth_comp_id_2"); ("pdbx_auth_seq_id_2","pdbx_auth_seq_id_2"); ("pdbx_label_asym_id_2","pdbx_label_asym_id_2"); ("pdbx_label_comp_id_2","pdbx_label_comp_id_2"); ("pdbx_label_seq_id_2","pdbx_label_seq_id_2"); ("pdbx_PDB_ins_code","pdbx_PDB_ins_code"); ("pdbx_PDB_ins_code_2","pdbx_PDB_ins_code_2"); ("pdbx_PDB_model_num","pdbx_PDB_model_num"); ("pdbx_omega_angle","pdbx_omega_angle"); ("pdbx_id","pdbx_id"); ("pdbx_auth_ins_code","pdbx_auth_ins_code"); ("pdbx_auth_ins_code_2","pdbx_auth_ins_code_2"); 
    ("details","details"); ("id","id"); ("pdbx_ens_id","pdbx_ens_id"); 
    ("beg_label_alt_id","beg_label_alt_id"); ("beg_label_asym_id","beg_label_asym_id"); ("beg_label_comp_id","beg_label_comp_id"); ("beg_label_seq_id","beg_label_seq_id"); ("beg_auth_asym_id","beg_auth_asym_id"); ("beg_auth_comp_id","beg_auth_comp_id"); ("beg_auth_seq_id","beg_auth_seq_id"); ("dom_id","dom_id"); ("end_label_alt_id","end_label_alt_id"); ("end_label_asym_id","end_label_asym_id"); ("end_label_comp_id","end_label_comp_id"); ("end_label_seq_id","end_label_seq_id"); ("end_auth_asym_id","end_auth_asym_id"); ("end_auth_comp_id","end_auth_comp_id"); ("end_auth_seq_id","end_auth_seq_id"); ("selection_details","selection_details"); ("pdbx_component_id","pdbx_component_id"); ("pdbx_refine_code","pdbx_refine_code"); ("pdbx_ens_id","pdbx_ens_id"); 
    ("details","details"); ("id","id"); ("point_group","point_group"); 
    ("dom_id_1","dom_id_1"); ("dom_id_2","dom_id_2"); ("ens_id","ens_id"); ("oper_id","oper_id"); 
    ("code","code"); ("details","details"); ("id","id"); ("matrix[1][1]","matrix11"); ("matrix[1][2]","matrix12"); ("matrix[1][3]","matrix13"); ("matrix[2][1]","matrix21"); ("matrix[2][2]","matrix22"); ("matrix[2][3]","matrix23"); ("matrix[3][1]","matrix31"); ("matrix[3][2]","matrix32"); ("matrix[3][3]","matrix33"); ("vector[1]","vector1"); ("vector[2]","vector2"); ("vector[3]","vector3"); 
    ("biol_id","biol_id"); ("db_code","db_code"); ("db_name","db_name"); ("details","details"); ("entity_id","entity_id"); ("id","id"); ("seq_align","seq_align"); ("seq_dif","seq_dif"); ("pdbx_db_accession","pdbx_db_accession"); ("pdbx_db_isoform","pdbx_db_isoform"); ("pdbx_seq_one_letter_code","pdbx_seq_one_letter_code"); ("pdbx_align_begin","pdbx_align_begin"); ("pdbx_align_end","pdbx_align_end"); 
    ("align_id","align_id"); ("db_align_beg","db_align_beg"); ("db_align_end","db_align_end"); ("details","details"); ("ref_id","ref_id"); ("seq_align_beg","seq_align_beg"); ("seq_align_end","seq_align_end"); ("pdbx_strand_id","pdbx_strand_id"); ("pdbx_db_accession","pdbx_db_accession"); ("pdbx_db_align_beg_ins_code","pdbx_db_align_beg_ins_code"); ("pdbx_db_align_end_ins_code","pdbx_db_align_end_ins_code"); ("pdbx_PDB_id_code","pdbx_PDB_id_code"); ("pdbx_auth_seq_align_beg","pdbx_auth_seq_align_beg"); ("pdbx_auth_seq_align_end","pdbx_auth_seq_align_end"); ("pdbx_seq_align_beg_ins_code","pdbx_seq_align_beg_ins_code"); ("pdbx_seq_align_end_ins_code","pdbx_seq_align_end_ins_code"); 
    ("align_id","align_id"); ("db_mon_id","db_mon_id"); ("details","details"); ("mon_id","mon_id"); ("seq_num","seq_num"); ("pdbx_pdb_id_code","pdbx_pdb_id_code"); ("pdbx_pdb_strand_id","pdbx_pdb_strand_id"); ("pdbx_pdb_ins_code","pdbx_pdb_ins_code"); ("pdbx_auth_seq_num","pdbx_auth_seq_num"); ("pdbx_seq_db_name","pdbx_seq_db_name"); ("pdbx_seq_db_accession_code","pdbx_seq_db_accession_code"); ("pdbx_seq_db_seq_num","pdbx_seq_db_seq_num"); ("pdbx_ordinal","pdbx_ordinal"); 
    ("details","details"); ("id","id"); ("number_strands","number_strands"); ("type","type"); 
    ("range_1_beg_label_atom_id","range_1_beg_label_atom_id"); ("range_1_beg_label_seq_id","range_1_beg_label_seq_id"); ("range_1_end_label_atom_id","range_1_end_label_atom_id"); ("range_1_end_label_seq_id","range_1_end_label_seq_id"); ("range_2_beg_label_atom_id","range_2_beg_label_atom_id"); ("range_2_beg_label_seq_id","range_2_beg_label_seq_id"); ("range_2_end_label_atom_id","range_2_end_label_atom_id"); ("range_2_end_label_seq_id","range_2_end_label_seq_id"); ("range_1_beg_auth_atom_id","range_1_beg_auth_atom_id"); ("range_1_beg_auth_seq_id","range_1_beg_auth_seq_id"); ("range_1_end_auth_atom_id","range_1_end_auth_atom_id"); ("range_1_end_auth_seq_id","range_1_end_auth_seq_id"); ("range_2_beg_auth_atom_id","range_2_beg_auth_atom_id"); ("range_2_beg_auth_seq_id","range_2_beg_auth_seq_id"); ("range_2_end_auth_atom_id","range_2_end_auth_atom_id"); ("range_2_end_auth_seq_id","range_2_end_auth_seq_id"); ("range_id_1","range_id_1"); ("range_id_2","range_id_2"); ("sheet_id","sheet_id"); ("pdbx_range_1_beg_auth_comp_id","pdbx_range_1_beg_auth_comp_id"); ("pdbx_range_1_beg_auth_asym_id","pdbx_range_1_beg_auth_asym_id"); ("pdbx_range_1_end_auth_comp_id","pdbx_range_1_end_auth_comp_id"); ("pdbx_range_1_end_auth_asym_id","pdbx_range_1_end_auth_asym_id"); ("pdbx_range_1_beg_label_comp_id","pdbx_range_1_beg_label_comp_id"); ("pdbx_range_1_beg_label_asym_id","pdbx_range_1_beg_label_asym_id"); ("pdbx_range_1_beg_PDB_ins_code","pdbx_range_1_beg_PDB_ins_code"); ("pdbx_range_1_end_label_comp_id","pdbx_range_1_end_label_comp_id"); ("pdbx_range_1_end_label_asym_id","pdbx_range_1_end_label_asym_id"); ("pdbx_range_1_end_PDB_ins_code","pdbx_range_1_end_PDB_ins_code"); ("pdbx_range_2_beg_label_comp_id","pdbx_range_2_beg_label_comp_id"); ("pdbx_range_2_beg_label_asym_id","pdbx_range_2_beg_label_asym_id"); ("pdbx_range_2_beg_PDB_ins_code","pdbx_range_2_beg_PDB_ins_code"); ("pdbx_range_2_end_label_comp_id","pdbx_range_2_end_label_comp_id"); ("pdbx_range_2_end_label_asym_id","pdbx_range_2_end_label_asym_id"); ("pdbx_range_2_end_label_ins_code","pdbx_range_2_end_label_ins_code"); 
    ("offset","offset"); ("range_id_1","range_id_1"); ("range_id_2","range_id_2"); ("sense","sense"); ("sheet_id","sheet_id"); 
    ("beg_label_asym_id","beg_label_asym_id"); ("beg_label_comp_id","beg_label_comp_id"); ("beg_label_seq_id","beg_label_seq_id"); ("end_label_asym_id","end_label_asym_id"); ("end_label_comp_id","end_label_comp_id"); ("end_label_seq_id","end_label_seq_id"); ("beg_auth_asym_id","beg_auth_asym_id"); ("beg_auth_comp_id","beg_auth_comp_id"); ("beg_auth_seq_id","beg_auth_seq_id"); ("end_auth_asym_id","end_auth_asym_id"); ("end_auth_comp_id","end_auth_comp_id"); ("end_auth_seq_id","end_auth_seq_id"); ("id","id"); ("sheet_id","sheet_id"); ("symmetry","symmetry"); ("pdbx_beg_PDB_ins_code","pdbx_beg_PDB_ins_code"); ("pdbx_end_PDB_ins_code","pdbx_end_PDB_ins_code"); 
    ("offset","offset"); ("range_id_1","range_id_1"); ("range_id_2","range_id_2"); ("sense","sense"); ("sheet_id","sheet_id"); 
    ("details","details"); ("id","id"); ("pdbx_num_residues","pdbx_num_residues"); ("pdbx_evidence_code","pdbx_evidence_code"); ("pdbx_auth_asym_id","pdbx_auth_asym_id"); ("pdbx_auth_comp_id","pdbx_auth_comp_id"); ("pdbx_auth_seq_id","pdbx_auth_seq_id"); ("pdbx_auth_ins_code","pdbx_auth_ins_code"); 
    ("details","details"); ("id","id"); ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_atom_id","label_atom_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("auth_asym_id","auth_asym_id"); ("auth_atom_id","auth_atom_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("site_id","site_id"); ("symmetry","symmetry"); ("pdbx_auth_ins_code","pdbx_auth_ins_code"); ("pdbx_num_res","pdbx_num_res"); 
    ("site_id","site_id"); ("text","text"); 
    ("details","details"); ("id","id"); ("rot_matrix[1][1]","rot_matrix11"); ("rot_matrix[1][2]","rot_matrix12"); ("rot_matrix[1][3]","rot_matrix13"); ("rot_matrix[2][1]","rot_matrix21"); ("rot_matrix[2][2]","rot_matrix22"); ("rot_matrix[2][3]","rot_matrix23"); ("rot_matrix[3][1]","rot_matrix31"); ("rot_matrix[3][2]","rot_matrix32"); ("rot_matrix[3][3]","rot_matrix33"); ("site_id","site_id"); 
    ("entry_id","entry_id"); ("cell_setting","cell_setting"); ("Int_Tables_number","Int_Tables_number"); ("space_group_name_Hall","space_group_name_Hall"); ("space_group_name_H-M","space_group_name_H-M"); ("pdbx_full_space_group_name_H-M","pdbx_full_space_group_name_H-M"); 
    ("id","id"); ("pos_as_xyz","pos_as_xyz"); 
    ("block_code","block_code"); ("block_description","block_description"); 
    ("av_R_eq","av_R_eq"); ("av_sgI/I","av_sgI_over_I"); ("av_uI/I","av_uI_over_I"); ("code","code"); ("description","description"); ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("number","number"); 
    ("code","code"); ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("R_factor_gt","R_factor_gt"); ("R_factor_all","R_factor_all"); ("R_Fsqd_factor","R_Fsqd_factor"); ("R_I_factor","R_I_factor"); ("wR_factor_all","wR_factor_all"); 
    ("code","code"); ("description","description"); ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("number_gt","number_gt"); ("number_total","number_total"); ("R_factor_all","R_factor_all"); ("R_factor_gt","R_factor_gt"); ("R_Fsqd_factor","R_Fsqd_factor"); ("R_I_factor","R_I_factor"); ("wR_factor_all","wR_factor_all"); 
    ("crystal_system","crystal_system"); ("id","id"); ("IT_number","IT_number"); ("name_Hall","name_Hall"); ("name_H-M_alt","name_H-M_alt"); 
    ("id","id"); ("operation_xyz","operation_xyz"); ("sg_id","sg_id"); 
    ("atom_1","atom_1"); ("atom_1_valence","atom_1_valence"); ("atom_2","atom_2"); ("atom_2_valence","atom_2_valence"); ("B","B"); ("details","details"); ("id","id"); ("ref_id","ref_id"); ("Ro","Ro"); 
    ("id","id"); ("reference","reference"); 
    ("entry_id","entry_id"); ("current_version","current_version"); 
    ("entry_id","entry_id"); ("revision_date","revision_date"); ("major_version","major_version"); ("minor_version","minor_version"); ("details","details"); ("revision_type","revision_type"); 
    ("address","address"); ("name","name"); ("ordinal","ordinal"); 
    ("entry_id","entry_id"); ("message_id","message_id"); ("date","date"); ("content_type","content_type"); ("message_type","message_type"); ("sender","sender"); ("sender_address_fax","sender_address_fax"); ("sender_address_phone","sender_address_phone"); ("sender_address_email","sender_address_email"); ("sender_address_mail","sender_address_mail"); ("receiver","receiver"); ("receiver_address_fax","receiver_address_fax"); ("receiver_address_phone","receiver_address_phone"); ("receiver_address_email","receiver_address_email"); ("receiver_address_mail","receiver_address_mail"); ("message","message"); 
    ("id","id"); ("date","date"); ("pdb_id","pdb_id"); ("replace_pdb_id","replace_pdb_id"); ("details","details"); 
    ("entry_id","entry_id"); ("cycle_id","cycle_id"); ("date_begin_cycle","date_begin_cycle"); ("date_end_cycle","date_end_cycle"); ("details","details"); 
    ("id","id"); ("text","text"); 
    ("status_code","status_code"); ("author_release_status_code","author_release_status_code"); ("status_code_sf","status_code_sf"); ("status_code_mr","status_code_mr"); ("dep_release_code_coordinates","dep_release_code_coordinates"); ("dep_release_code_sequence","dep_release_code_sequence"); ("dep_release_code_struct_fact","dep_release_code_struct_fact"); ("dep_release_code_nmr_constraints","dep_release_code_nmr_constraints"); ("entry_id","entry_id"); ("recvd_deposit_form","recvd_deposit_form"); ("date_deposition_form","date_deposition_form"); ("date_begin_deposition","date_begin_deposition"); ("date_begin_processing","date_begin_processing"); ("date_end_processing","date_end_processing"); ("date_begin_release_preparation","date_begin_release_preparation"); ("date_author_release_request","date_author_release_request"); ("recvd_coordinates","recvd_coordinates"); ("date_coordinates","date_coordinates"); ("recvd_struct_fact","recvd_struct_fact"); ("date_struct_fact","date_struct_fact"); ("recvd_nmr_constraints","recvd_nmr_constraints"); ("date_nmr_constraints","date_nmr_constraints"); ("recvd_internal_approval","recvd_internal_approval"); ("recvd_manuscript","recvd_manuscript"); ("date_manuscript","date_manuscript"); ("name_depositor","name_depositor"); ("recvd_author_approval","recvd_author_approval"); ("author_approval_type","author_approval_type"); ("date_author_approval","date_author_approval"); ("recvd_initial_deposition_date","recvd_initial_deposition_date"); ("date_submitted","date_submitted"); ("rcsb_annotator","rcsb_annotator"); ("date_of_sf_release","date_of_sf_release"); ("date_of_mr_release","date_of_mr_release"); ("date_of_PDB_release","date_of_PDB_release"); ("date_hold_coordinates","date_hold_coordinates"); ("date_hold_struct_fact","date_hold_struct_fact"); ("date_hold_nmr_constraints","date_hold_nmr_constraints"); ("hold_for_publication","hold_for_publication"); ("SG_entry","SG_entry"); ("pdb_date_of_author_approval","pdb_date_of_author_approval"); ("deposit_site","deposit_site"); ("process_site","process_site"); ("dep_release_code_chemical_shifts","dep_release_code_chemical_shifts"); ("recvd_chemical_shifts","recvd_chemical_shifts"); ("date_chemical_shifts","date_chemical_shifts"); ("date_hold_chemical_shifts","date_hold_chemical_shifts"); ("status_code_cs","status_code_cs"); ("date_of_cs_release","date_of_cs_release"); ("methods_development_category","methods_development_category"); ("pdb_format_compatible","pdb_format_compatible"); ("auth_req_rel_date","auth_req_rel_date"); ("ndb_tid","ndb_tid"); ("status_coordinates_in_NDB","status_coordinates_in_NDB"); ("date_revised","date_revised"); ("replaced_entry_id","replaced_entry_id"); ("revision_id","revision_id"); ("revision_description","revision_description"); ("pdbx_annotator","pdbx_annotator"); ("date_of_NDB_release","date_of_NDB_release"); ("date_released_to_PDB","date_released_to_PDB"); ("skip_PDB_REMARK_500","skip_PDB_REMARK_500"); ("skip_PDB_REMARK","skip_PDB_REMARK"); ("title_suppression","title_suppression"); 
    ("entity_id","entity_id"); ("name","name"); ("name_type","name_type"); 
    ("entity_id","entity_id"); ("seq_one_letter_code","seq_one_letter_code"); 
    ("asym_id","asym_id"); ("entity_id","entity_id"); ("seq_id","seq_id"); ("hetero","hetero"); ("mon_id","mon_id"); ("pdb_strand_id","pdb_strand_id"); ("ndb_seq_num","ndb_seq_num"); ("pdb_seq_num","pdb_seq_num"); ("auth_seq_num","auth_seq_num"); ("pdb_mon_id","pdb_mon_id"); ("auth_mon_id","auth_mon_id"); ("pdb_ins_code","pdb_ins_code"); 
    ("asym_id","asym_id"); ("entity_id","entity_id"); ("mon_id","mon_id"); ("pdb_strand_id","pdb_strand_id"); ("ndb_seq_num","ndb_seq_num"); ("pdb_seq_num","pdb_seq_num"); ("auth_seq_num","auth_seq_num"); ("pdb_mon_id","pdb_mon_id"); ("auth_mon_id","auth_mon_id"); ("pdb_ins_code","pdb_ins_code"); 
    ("entry_id","entry_id"); ("pdbx_refine_id","pdbx_refine_id"); ("R_factor_all_no_cutoff","R_factor_all_no_cutoff"); ("R_factor_obs_no_cutoff","R_factor_obs_no_cutoff"); ("free_R_factor_4sig_cutoff","free_R_factor_4sig_cutoff"); ("free_R_factor_no_cutoff","free_R_factor_no_cutoff"); ("free_R_error_no_cutoff","free_R_error_no_cutoff"); ("free_R_val_test_set_size_perc_no_cutoff","free_R_val_test_set_size_perc_no_cutoff"); ("free_R_val_test_set_ct_no_cutoff","free_R_val_test_set_ct_no_cutoff"); ("number_reflns_obs_no_cutoff","number_reflns_obs_no_cutoff"); ("R_factor_all_4sig_cutoff","R_factor_all_4sig_cutoff"); ("R_factor_obs_4sig_cutoff","R_factor_obs_4sig_cutoff"); ("free_R_val_4sig_cutoff","free_R_val_4sig_cutoff"); ("free_R_val_test_set_size_perc_4sig_cutoff","free_R_val_test_set_size_perc_4sig_cutoff"); ("free_R_val_test_set_ct_4sig_cutoff","free_R_val_test_set_ct_4sig_cutoff"); ("number_reflns_obs_4sig_cutoff","number_reflns_obs_4sig_cutoff"); ("free_R_val_no_cutoff","free_R_val_no_cutoff"); 
    ("range_id_1","range_id_1"); ("range_id_2","range_id_2"); ("sheet_id","sheet_id"); ("range_1_label_atom_id","range_1_label_atom_id"); ("range_1_label_seq_id","range_1_label_seq_id"); ("range_1_label_comp_id","range_1_label_comp_id"); ("range_1_label_asym_id","range_1_label_asym_id"); ("range_1_auth_atom_id","range_1_auth_atom_id"); ("range_1_auth_seq_id","range_1_auth_seq_id"); ("range_1_auth_comp_id","range_1_auth_comp_id"); ("range_1_auth_asym_id","range_1_auth_asym_id"); ("range_1_PDB_ins_code","range_1_PDB_ins_code"); ("range_2_label_atom_id","range_2_label_atom_id"); ("range_2_label_seq_id","range_2_label_seq_id"); ("range_2_label_comp_id","range_2_label_comp_id"); ("range_2_label_asym_id","range_2_label_asym_id"); ("range_2_auth_atom_id","range_2_auth_atom_id"); ("range_2_auth_seq_id","range_2_auth_seq_id"); ("range_2_auth_comp_id","range_2_auth_comp_id"); ("range_2_auth_asym_id","range_2_auth_asym_id"); ("range_2_PDB_ins_code","range_2_PDB_ins_code"); 
    ("serial_no","serial_no"); ("pdbx_refine_id","pdbx_refine_id"); ("param_file","param_file"); ("topol_file","topol_file"); 
    ("serial_no","serial_no"); ("pdbx_refine_id","pdbx_refine_id"); ("file_name","file_name"); ("file_type","file_type"); 
    ("db_name","db_name"); ("details","details"); ("db_id","db_id"); ("content_type","content_type"); 
    ("id","id"); ("entity_id","entity_id"); ("biol_id","biol_id"); ("num_copies","num_copies"); 
    ("crystal_id","crystal_id"); ("comp_id","comp_id"); ("comp_name","comp_name"); ("sol_id","sol_id"); ("conc","conc"); ("conc_range","conc_range"); ("conc_units","conc_units"); 
    ("crystal_id","crystal_id"); ("sol_id","sol_id"); ("volume","volume"); ("volume_units","volume_units"); ("pH","pH"); 
    ("crystal_id","crystal_id"); ("final_solution_details","final_solution_details"); ("soaking_details","soaking_details"); ("cooling_details","cooling_details"); ("annealing_details","annealing_details"); 
    ("id","id"); ("pdbx_refine_id","pdbx_refine_id"); ("details","details"); ("method","method"); ("origin_x","origin_x"); ("origin_y","origin_y"); ("origin_z","origin_z"); ("T[1][1]","T11"); ("T[1][1]_esd","T11_esd"); ("T[1][2]","T12"); ("T[1][2]_esd","T12_esd"); ("T[1][3]","T13"); ("T[1][3]_esd","T13_esd"); ("T[2][2]","T22"); ("T[2][2]_esd","T22_esd"); ("T[2][3]","T23"); ("T[2][3]_esd","T23_esd"); ("T[3][3]","T33"); ("T[3][3]_esd","T33_esd"); ("L[1][1]","L11"); ("L[1][1]_esd","L11_esd"); ("L[1][2]","L12"); ("L[1][2]_esd","L12_esd"); ("L[1][3]","L13"); ("L[1][3]_esd","L13_esd"); ("L[2][2]","L22"); ("L[2][2]_esd","L22_esd"); ("L[2][3]","L23"); ("L[2][3]_esd","L23_esd"); ("L[3][3]","L33"); ("L[3][3]_esd","L33_esd"); ("S[1][1]","S11"); ("S[1][1]_esd","S11_esd"); ("S[1][2]","S12"); ("S[1][2]_esd","S12_esd"); ("S[1][3]","S13"); ("S[1][3]_esd","S13_esd"); ("S[2][1]","S21"); ("S[2][1]_esd","S21_esd"); ("S[2][2]","S22"); ("S[2][2]_esd","S22_esd"); ("S[2][3]","S23"); ("S[2][3]_esd","S23_esd"); ("S[3][1]","S31"); ("S[3][1]_esd","S31_esd"); ("S[3][2]","S32"); ("S[3][2]_esd","S32_esd"); ("S[3][3]","S33"); ("S[3][3]_esd","S33_esd"); 
    ("id","id"); ("pdbx_refine_id","pdbx_refine_id"); ("refine_tls_id","refine_tls_id"); ("beg_label_asym_id","beg_label_asym_id"); ("beg_label_seq_id","beg_label_seq_id"); ("beg_auth_asym_id","beg_auth_asym_id"); ("beg_auth_seq_id","beg_auth_seq_id"); ("end_label_asym_id","end_label_asym_id"); ("end_label_seq_id","end_label_seq_id"); ("end_auth_asym_id","end_auth_asym_id"); ("end_auth_seq_id","end_auth_seq_id"); ("selection","selection"); ("selection_details","selection_details"); 
    ("id","id"); ("address_1","address_1"); ("address_2","address_2"); ("address_3","address_3"); ("legacy_address","legacy_address"); ("city","city"); ("state_province","state_province"); ("postal_code","postal_code"); ("email","email"); ("fax","fax"); ("name_first","name_first"); ("name_last","name_last"); ("name_mi","name_mi"); ("name_salutation","name_salutation"); ("country","country"); ("continent","continent"); ("phone","phone"); ("role","role"); ("organization_type","organization_type"); ("identifier_ORCID","identifier_ORCID"); 
    ("id","id"); ("project_name","project_name"); ("full_name_of_center","full_name_of_center"); ("initial_of_center","initial_of_center"); 
    ("id","id"); ("type_symbol","type_symbol"); ("tls_group_id","tls_group_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_atom_id","auth_atom_id"); ("auth_asym_id","auth_asym_id"); ("PDB_ins_code","PDB_ins_code"); ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_atom_id","label_atom_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("U_tls[1][1]","U_tls11"); ("U_tls[2][2]","U_tls22"); ("U_tls[3][3]","U_tls33"); ("U_tls[1][2]","U_tls12"); ("U_tls[1][3]","U_tls13"); ("U_tls[2][3]","U_tls23"); 
    ("entry_id","entry_id"); ("text","text"); 
    ("solution_id","solution_id"); ("contents","contents"); ("solvent_system","solvent_system"); ("label","label"); ("type","type"); ("details","details"); 
    ("solution_id","solution_id"); ("component","component"); ("concentration","concentration"); ("concentration_range","concentration_range"); ("concentration_units","concentration_units"); ("isotopic_labeling","isotopic_labeling"); ("concentration_err","concentration_err"); 
    ("conditions_id","conditions_id"); ("temperature","temperature"); ("pressure_units","pressure_units"); ("pressure","pressure"); ("pH","pH"); ("ionic_strength","ionic_strength"); ("details","details"); ("ionic_strength_err","ionic_strength_err"); ("ionic_strength_units","ionic_strength_units"); ("label","label"); ("pH_err","pH_err"); ("pH_units","pH_units"); ("pressure_err","pressure_err"); ("temperature_err","temperature_err"); ("temperature_units","temperature_units"); 
    ("spectrometer_id","spectrometer_id"); ("model","model"); ("type","type"); ("manufacturer","manufacturer"); ("field_strength","field_strength"); ("details","details"); ("name","name"); 
    ("experiment_id","experiment_id"); ("conditions_id","conditions_id"); ("solution_id","solution_id"); ("type","type"); ("spectrometer_id","spectrometer_id"); ("sample_state","sample_state"); 
    ("ordinal","ordinal"); ("classification","classification"); ("name","name"); ("version","version"); ("authors","authors"); ("details","details"); 
    ("entry_id","entry_id"); ("NOE_constraints_total","NOE_constraints_total"); ("NOE_intraresidue_total_count","NOE_intraresidue_total_count"); ("NOE_interentity_total_count","NOE_interentity_total_count"); ("NOE_sequential_total_count","NOE_sequential_total_count"); ("NOE_medium_range_total_count","NOE_medium_range_total_count"); ("NOE_long_range_total_count","NOE_long_range_total_count"); ("protein_phi_angle_constraints_total_count","protein_phi_angle_constraints_total_count"); ("protein_psi_angle_constraints_total_count","protein_psi_angle_constraints_total_count"); ("protein_chi_angle_constraints_total_count","protein_chi_angle_constraints_total_count"); ("protein_other_angle_constraints_total_count","protein_other_angle_constraints_total_count"); ("NOE_interproton_distance_evaluation","NOE_interproton_distance_evaluation"); ("NOE_pseudoatom_corrections","NOE_pseudoatom_corrections"); ("NOE_motional_averaging_correction","NOE_motional_averaging_correction"); ("hydrogen_bond_constraints_total_count","hydrogen_bond_constraints_total_count"); ("disulfide_bond_constraints_total_count","disulfide_bond_constraints_total_count"); ("NA_alpha-angle_constraints_total_count","NA_alpha-angle_constraints_total_count"); ("NA_beta-angle_constraints_total_count","NA_beta-angle_constraints_total_count"); ("NA_gamma-angle_constraints_total_count","NA_gamma-angle_constraints_total_count"); ("NA_delta-angle_constraints_total_count","NA_delta-angle_constraints_total_count"); ("NA_epsilon-angle_constraints_total_count","NA_epsilon-angle_constraints_total_count"); ("NA_chi-angle_constraints_total_count","NA_chi-angle_constraints_total_count"); ("NA_other-angle_constraints_total_count","NA_other-angle_constraints_total_count"); ("NA_sugar_pucker_constraints_total_count","NA_sugar_pucker_constraints_total_count"); 
    ("entry_id","entry_id"); ("conformers_calculated_total_number","conformers_calculated_total_number"); ("conformers_submitted_total_number","conformers_submitted_total_number"); ("conformer_selection_criteria","conformer_selection_criteria"); ("representative_conformer","representative_conformer"); ("average_constraints_per_residue","average_constraints_per_residue"); ("average_constraint_violations_per_residue","average_constraint_violations_per_residue"); ("maximum_distance_constraint_violation","maximum_distance_constraint_violation"); ("average_distance_constraint_violation","average_distance_constraint_violation"); ("maximum_upper_distance_constraint_violation","maximum_upper_distance_constraint_violation"); ("maximum_lower_distance_constraint_violation","maximum_lower_distance_constraint_violation"); ("distance_constraint_violation_method","distance_constraint_violation_method"); ("maximum_torsion_angle_constraint_violation","maximum_torsion_angle_constraint_violation"); ("average_torsion_angle_constraint_violation","average_torsion_angle_constraint_violation"); ("torsion_angle_constraint_violation_method","torsion_angle_constraint_violation_method"); 
    ("entry_id","entry_id"); ("residue_range_begin","residue_range_begin"); ("chain_range_begin","chain_range_begin"); ("residue_range_end","residue_range_end"); ("chain_range_end","chain_range_end"); ("atom_type","atom_type"); ("distance_rms_dev","distance_rms_dev"); ("distance_rms_dev_error","distance_rms_dev_error"); ("covalent_bond_rms_dev","covalent_bond_rms_dev"); ("covalent_bond_rms_dev_error","covalent_bond_rms_dev_error"); ("bond_angle_rms_dev","bond_angle_rms_dev"); ("bond_angle_rms_dev_error","bond_angle_rms_dev_error"); ("improper_torsion_angle_rms_dev","improper_torsion_angle_rms_dev"); ("improper_torsion_angle_rms_dev_error","improper_torsion_angle_rms_dev_error"); ("peptide_planarity_rms_dev","peptide_planarity_rms_dev"); ("peptide_planarity_rms_dev_error","peptide_planarity_rms_dev_error"); ("dihedral_angles_rms_dev","dihedral_angles_rms_dev"); ("dihedral_angles_rms_dev_error","dihedral_angles_rms_dev_error"); ("coord_average_rmsd_method","coord_average_rmsd_method"); 
    ("entry_id","entry_id"); ("conformer_id","conformer_id"); ("selection_criteria","selection_criteria"); 
    ("entry_id","entry_id"); ("method","method"); ("details","details"); ("software_ordinal","software_ordinal"); 
    ("entry_id","entry_id"); ("exptl_distance_term","exptl_distance_term"); ("exptl_distance_term_units","exptl_distance_term_units"); ("exptl_torsion_angles_term","exptl_torsion_angles_term"); ("exptl_torsion_angles_term_units","exptl_torsion_angles_term_units"); ("exptl_J_coupling_term","exptl_J_coupling_term"); ("exptl_J_coupling_term_units","exptl_J_coupling_term_units"); ("exptl_13C_shift_term","exptl_13C_shift_term"); ("exptl_13C_shift_term_units","exptl_13C_shift_term_units"); ("exptl_1H_shift_term","exptl_1H_shift_term"); ("exptl_1H_shift_term_units","exptl_1H_shift_term_units"); ("exptl_dipolar_coupling_term","exptl_dipolar_coupling_term"); ("exptl_dipolar_coupling_term_units","exptl_dipolar_coupling_term_units"); ("exptl_D_isotope_shift_term","exptl_D_isotope_shift_term"); ("exptl_D_isotope_shift_term_units","exptl_D_isotope_shift_term_units"); ("covalent_geom_bond_term","covalent_geom_bond_term"); ("covalent_geom_bond_term_units","covalent_geom_bond_term_units"); ("covalent_geom_angles_term","covalent_geom_angles_term"); ("covalent_geom_angles_term_units","covalent_geom_angles_term_units"); ("covalent_geom_impropers_term","covalent_geom_impropers_term"); ("covalent_geom_impropers_term_units","covalent_geom_impropers_term_units"); ("non-bonded_inter_van_der_Waals_term_type","non-bonded_inter_van_der_Waals_term_type"); ("non-bonded_inter_van_der_Waals_term","non-bonded_inter_van_der_Waals_term"); ("non-bonded_inter_van_der_Waals_term_units","non-bonded_inter_van_der_Waals_term_units"); ("non-bonded_inter_conf_db_potential_term","non-bonded_inter_conf_db_potential_term"); ("non-bonded_inter_radius_of_gyration_term","non-bonded_inter_radius_of_gyration_term"); ("non-bonded_inter_radius_of_gyration_term_units","non-bonded_inter_radius_of_gyration_term_units"); 
    ("entry_id","entry_id"); ("feature","feature"); ("feature_count","feature_count"); 
    ("entry_id","entry_id"); ("feature","feature"); ("feature_count","feature_count"); 
    ("model_number","model_number"); ("pair_number","pair_number"); ("pair_name","pair_name"); ("i_label_asym_id","i_label_asym_id"); ("i_label_comp_id","i_label_comp_id"); ("i_label_seq_id","i_label_seq_id"); ("i_symmetry","i_symmetry"); ("j_label_asym_id","j_label_asym_id"); ("j_label_comp_id","j_label_comp_id"); ("j_label_seq_id","j_label_seq_id"); ("j_symmetry","j_symmetry"); ("i_auth_asym_id","i_auth_asym_id"); ("i_auth_seq_id","i_auth_seq_id"); ("i_PDB_ins_code","i_PDB_ins_code"); ("j_auth_asym_id","j_auth_asym_id"); ("j_auth_seq_id","j_auth_seq_id"); ("j_PDB_ins_code","j_PDB_ins_code"); ("shear","shear"); ("stretch","stretch"); ("stagger","stagger"); ("buckle","buckle"); ("propeller","propeller"); ("opening","opening"); ("hbond_type_12","hbond_type_12"); ("hbond_type_28","hbond_type_28"); 
    ("model_number","model_number"); ("step_number","step_number"); ("step_name","step_name"); ("i_label_asym_id_1","i_label_asym_id_1"); ("i_label_comp_id_1","i_label_comp_id_1"); ("i_label_seq_id_1","i_label_seq_id_1"); ("i_symmetry_1","i_symmetry_1"); ("j_label_asym_id_1","j_label_asym_id_1"); ("j_label_comp_id_1","j_label_comp_id_1"); ("j_label_seq_id_1","j_label_seq_id_1"); ("j_symmetry_1","j_symmetry_1"); ("i_label_asym_id_2","i_label_asym_id_2"); ("i_label_comp_id_2","i_label_comp_id_2"); ("i_label_seq_id_2","i_label_seq_id_2"); ("i_symmetry_2","i_symmetry_2"); ("j_label_asym_id_2","j_label_asym_id_2"); ("j_label_comp_id_2","j_label_comp_id_2"); ("j_label_seq_id_2","j_label_seq_id_2"); ("j_symmetry_2","j_symmetry_2"); ("i_auth_asym_id_1","i_auth_asym_id_1"); ("i_auth_seq_id_1","i_auth_seq_id_1"); ("i_PDB_ins_code_1","i_PDB_ins_code_1"); ("j_auth_asym_id_1","j_auth_asym_id_1"); ("j_auth_seq_id_1","j_auth_seq_id_1"); ("j_PDB_ins_code_1","j_PDB_ins_code_1"); ("i_auth_asym_id_2","i_auth_asym_id_2"); ("i_auth_seq_id_2","i_auth_seq_id_2"); ("i_PDB_ins_code_2","i_PDB_ins_code_2"); ("j_auth_asym_id_2","j_auth_asym_id_2"); ("j_auth_seq_id_2","j_auth_seq_id_2"); ("j_PDB_ins_code_2","j_PDB_ins_code_2"); ("shift","shift"); ("slide","slide"); ("rise","rise"); ("tilt","tilt"); ("roll","roll"); ("twist","twist"); ("x_displacement","x_displacement"); ("y_displacement","y_displacement"); ("helical_rise","helical_rise"); ("inclination","inclination"); ("tip","tip"); ("helical_twist","helical_twist"); 
    ("coord_section","coord_section"); 
    ("entity_id","entity_id"); ("comp_id","comp_id"); ("name","name"); 
    ("entry_id","entry_id"); ("method","method"); ("mask_type","mask_type"); ("fom_acentric","fom_acentric"); ("fom_centric","fom_centric"); ("fom","fom"); ("reflns_acentric","reflns_acentric"); ("reflns_centric","reflns_centric"); ("reflns","reflns"); ("delta_phi_initial","delta_phi_initial"); ("delta_phi_final","delta_phi_final"); 
    ("d_res_high","d_res_high"); ("d_res_low","d_res_low"); ("fom_acentric","fom_acentric"); ("fom_centric","fom_centric"); ("fom","fom"); ("reflns_acentric","reflns_acentric"); ("reflns_centric","reflns_centric"); ("reflns","reflns"); ("delta_phi_initial","delta_phi_initial"); ("delta_phi_final","delta_phi_final"); 
    ("d_res_low","d_res_low"); ("d_res_high","d_res_high"); ("reflns_acentric","reflns_acentric"); ("reflns_centric","reflns_centric"); ("reflns","reflns"); ("fom_acentric","fom_acentric"); ("fom_centric","fom_centric"); ("fom","fom"); ("R_cullis_centric","R_cullis_centric"); ("R_cullis_acentric","R_cullis_acentric"); ("R_cullis","R_cullis"); ("R_kraut_centric","R_kraut_centric"); ("R_kraut_acentric","R_kraut_acentric"); ("R_kraut","R_kraut"); ("loc_centric","loc_centric"); ("loc_acentric","loc_acentric"); ("loc","loc"); ("power_centric","power_centric"); ("power_acentric","power_acentric"); ("power","power"); 
    ("id","id"); ("d_res_low","d_res_low"); ("d_res_high","d_res_high"); ("number_of_sites","number_of_sites"); ("reflns_acentric","reflns_acentric"); ("reflns_centric","reflns_centric"); ("reflns","reflns"); ("fom_acentric","fom_acentric"); ("fom_centric","fom_centric"); ("fom","fom"); ("R_cullis_centric","R_cullis_centric"); ("R_cullis_acentric","R_cullis_acentric"); ("R_cullis","R_cullis"); ("R_kraut_centric","R_kraut_centric"); ("R_kraut_acentric","R_kraut_acentric"); ("R_kraut","R_kraut"); ("loc_centric","loc_centric"); ("loc_acentric","loc_acentric"); ("loc","loc"); ("power_centric","power_centric"); ("power_acentric","power_acentric"); ("power","power"); 
    ("id","id"); ("d_res_low","d_res_low"); ("d_res_high","d_res_high"); ("reflns_acentric","reflns_acentric"); ("reflns_centric","reflns_centric"); ("reflns","reflns"); ("fom_acentric","fom_acentric"); ("fom_centric","fom_centric"); ("fom","fom"); ("R_cullis_centric","R_cullis_centric"); ("R_cullis_acentric","R_cullis_acentric"); ("R_cullis","R_cullis"); ("R_kraut_centric","R_kraut_centric"); ("R_kraut_acentric","R_kraut_acentric"); ("R_kraut","R_kraut"); ("loc_centric","loc_centric"); ("loc_acentric","loc_acentric"); ("loc","loc"); ("power_centric","power_centric"); ("power_acentric","power_acentric"); ("power","power"); 
    ("id","id"); ("atom_type_symbol","atom_type_symbol"); ("Cartn_x","Cartn_x"); ("Cartn_y","Cartn_y"); ("Cartn_z","Cartn_z"); ("Cartn_x_esd","Cartn_x_esd"); ("Cartn_y_esd","Cartn_y_esd"); ("Cartn_z_esd","Cartn_z_esd"); ("fract_x","fract_x"); ("fract_y","fract_y"); ("fract_z","fract_z"); ("fract_x_esd","fract_x_esd"); ("fract_y_esd","fract_y_esd"); ("fract_z_esd","fract_z_esd"); ("b_iso","b_iso"); ("b_iso_esd","b_iso_esd"); ("occupancy","occupancy"); ("occupancy_esd","occupancy_esd"); ("set_id","set_id"); ("occupancy_iso","occupancy_iso"); 
    ("entry_id","entry_id"); ("method_rotation","method_rotation"); ("d_res_high_rotation","d_res_high_rotation"); ("d_res_low_rotation","d_res_low_rotation"); ("sigma_F_rotation","sigma_F_rotation"); ("sigma_I_rotation","sigma_I_rotation"); ("reflns_percent_rotation","reflns_percent_rotation"); ("method_translation","method_translation"); ("d_res_high_translation","d_res_high_translation"); ("d_res_low_translation","d_res_low_translation"); ("sigma_F_translation","sigma_F_translation"); ("sigma_I_translation","sigma_I_translation"); ("reflns_percent_translation","reflns_percent_translation"); ("correlation_coeff_Io_to_Ic","correlation_coeff_Io_to_Ic"); ("correlation_coeff_Fo_to_Fc","correlation_coeff_Fo_to_Fc"); ("R_factor","R_factor"); ("R_rigid_body","R_rigid_body"); ("packing","packing"); ("model_details","model_details"); ("native_set_id","native_set_id"); ("d_res_high_fit","d_res_high_fit"); ("d_res_low_fit","d_res_low_fit"); ("zscore_rotation","zscore_rotation"); ("LL_gain_rotation","LL_gain_rotation"); ("zscore_translation","zscore_translation"); ("LL_gain_translation","LL_gain_translation"); 
    ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("B_iso","B_iso"); ("B_iso_main_chain","B_iso_main_chain"); ("B_iso_side_chain","B_iso_side_chain"); ("shift","shift"); ("shift_side_chain","shift_side_chain"); ("shift_main_chain","shift_main_chain"); ("correlation","correlation"); ("correlation_side_chain","correlation_side_chain"); ("correlation_main_chain","correlation_main_chain"); ("real_space_R","real_space_R"); ("real_space_R_side_chain","real_space_R_side_chain"); ("real_space_R_main_chain","real_space_R_main_chain"); ("connect","connect"); ("density_index","density_index"); ("density_index_main_chain","density_index_main_chain"); ("density_index_side_chain","density_index_side_chain"); ("density_ratio","density_ratio"); ("density_ratio_main_chain","density_ratio_main_chain"); ("density_ratio_side_chain","density_ratio_side_chain"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("protocol","protocol"); ("protocol_type","protocol_type"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("next_step_id","next_step_id"); ("end_construct_id","end_construct_id"); ("robot_id","robot_id"); ("date","date"); ("process_name","process_name"); ("details","details"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("parameter","parameter"); ("value","value"); ("details","details"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("next_step_id","next_step_id"); ("end_construct_id","end_construct_id"); ("robot_id","robot_id"); ("date","date"); ("forward_primer_id","forward_primer_id"); ("reverse_primer_id","reverse_primer_id"); ("reaction_details","reaction_details"); ("purification_details","purification_details"); ("summary","summary"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("next_step_id","next_step_id"); ("end_construct_id","end_construct_id"); ("robot_id","robot_id"); ("date","date"); ("restriction_enzyme_1","restriction_enzyme_1"); ("restriction_enzyme_2","restriction_enzyme_2"); ("purification_details","purification_details"); ("summary","summary"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("next_step_id","next_step_id"); ("end_construct_id","end_construct_id"); ("robot_id","robot_id"); ("date","date"); ("gene_insert_method","gene_insert_method"); ("vector_name","vector_name"); ("vector_details","vector_details"); ("transformation_method","transformation_method"); ("marker","marker"); ("verification_method","verification_method"); ("purification_details","purification_details"); ("summary","summary"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("cleavage_enzymes","cleavage_enzymes"); ("ligation_enzymes","ligation_enzymes"); ("temperature","temperature"); ("time","time"); ("details","details"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("system","system"); ("recombination_enzymes","recombination_enzymes"); ("details","details"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("next_step_id","next_step_id"); ("end_construct_id","end_construct_id"); ("robot_id","robot_id"); ("date","date"); ("promoter_type","promoter_type"); ("plasmid_id","plasmid_id"); ("vector_type","vector_type"); ("N_terminal_seq_tag","N_terminal_seq_tag"); ("C_terminal_seq_tag","C_terminal_seq_tag"); ("host_org_scientific_name","host_org_scientific_name"); ("host_org_common_name","host_org_common_name"); ("host_org_variant","host_org_variant"); ("host_org_strain","host_org_strain"); ("host_org_tissue","host_org_tissue"); ("host_org_culture_collection","host_org_culture_collection"); ("host_org_cell_line","host_org_cell_line"); ("host_org_tax_id","host_org_tax_id"); ("host_org_details","host_org_details"); ("culture_base_media","culture_base_media"); ("culture_additives","culture_additives"); ("culture_volume","culture_volume"); ("culture_time","culture_time"); ("culture_temperature","culture_temperature"); ("inducer","inducer"); ("inducer_concentration","inducer_concentration"); ("induction_details","induction_details"); ("multiplicity_of_infection","multiplicity_of_infection"); ("induction_timepoint","induction_timepoint"); ("induction_temperature","induction_temperature"); ("harvesting_details","harvesting_details"); ("storage_details","storage_details"); ("summary","summary"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("serial","serial"); ("OD","OD"); ("time","time"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("next_step_id","next_step_id"); ("end_construct_id","end_construct_id"); ("robot_id","robot_id"); ("date","date"); ("method","method"); ("buffer_id","buffer_id"); ("buffer_volume","buffer_volume"); ("temperature","temperature"); ("time","time"); ("details","details"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("next_step_id","next_step_id"); ("end_construct_id","end_construct_id"); ("robot_id","robot_id"); ("date","date"); ("denature_buffer_id","denature_buffer_id"); ("refold_buffer_id","refold_buffer_id"); ("temperature","temperature"); ("time","time"); ("storage_buffer_id","storage_buffer_id"); ("details","details"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("next_step_id","next_step_id"); ("end_construct_id","end_construct_id"); ("robot_id","robot_id"); ("date","date"); ("details","details"); ("protease","protease"); ("protein_protease_ratio","protein_protease_ratio"); ("cleavage_buffer_id","cleavage_buffer_id"); ("cleavage_temperature","cleavage_temperature"); ("cleavage_time","cleavage_time"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("next_step_id","next_step_id"); ("end_construct_id","end_construct_id"); ("robot_id","robot_id"); ("date","date"); ("column_type","column_type"); ("column_volume","column_volume"); ("column_temperature","column_temperature"); ("equilibration_buffer_id","equilibration_buffer_id"); ("flow_rate","flow_rate"); ("elution_buffer_id","elution_buffer_id"); ("elution_protocol","elution_protocol"); ("sample_prep_details","sample_prep_details"); ("sample_volume","sample_volume"); ("sample_concentration","sample_concentration"); ("sample_conc_method","sample_conc_method"); ("volume_pooled_fractions","volume_pooled_fractions"); ("yield_pooled_fractions","yield_pooled_fractions"); ("yield_method","yield_method"); ("post_treatment","post_treatment"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("next_step_id","next_step_id"); ("end_construct_id","end_construct_id"); ("robot_id","robot_id"); ("date","date"); ("method","method"); ("temperature","temperature"); ("details","details"); ("protein_location","protein_location"); ("protein_volume","protein_volume"); ("protein_yield","protein_yield"); ("protein_yield_method","protein_yield_method"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("product_id","product_id"); ("date","date"); ("conc_device_id","conc_device_id"); ("conc_details","conc_details"); ("conc_assay_method","conc_assay_method"); ("protein_concentration","protein_concentration"); ("protein_yield","protein_yield"); ("protein_purity","protein_purity"); ("protein_oligomeric_state","protein_oligomeric_state"); ("storage_buffer_id","storage_buffer_id"); ("storage_temperature","storage_temperature"); ("summary","summary"); 
    ("entry_id","entry_id"); ("entity_id","entity_id"); ("step_id","step_id"); ("robot_id","robot_id"); ("date","date"); ("method","method"); ("result","result"); ("details","details"); 
    ("entry_id","entry_id"); ("id","id"); ("name","name"); ("organisation","organisation"); ("entity_id","entity_id"); ("robot_id","robot_id"); ("date","date"); ("details","details"); ("class","class"); ("type","type"); ("seq","seq"); 
    ("id","id"); ("construct_id","construct_id"); ("entry_id","entry_id"); ("start_seq","start_seq"); ("end_seq","end_seq"); ("type","type"); ("details","details"); 
    ("id","id"); ("model","model"); ("type","type"); ("manufacturer","manufacturer"); 
    ("id","id"); ("name","name"); ("details","details"); 
    ("id","id"); ("buffer_id","buffer_id"); ("name","name"); ("volume","volume"); ("conc","conc"); ("details","details"); ("conc_units","conc_units"); ("isotopic_labeling","isotopic_labeling"); 
    ("details","details"); ("id","id"); 
    ("beg_label_alt_id","beg_label_alt_id"); ("beg_label_asym_id","beg_label_asym_id"); ("beg_label_comp_id","beg_label_comp_id"); ("beg_label_seq_id","beg_label_seq_id"); ("beg_auth_asym_id","beg_auth_asym_id"); ("beg_auth_comp_id","beg_auth_comp_id"); ("beg_auth_seq_id","beg_auth_seq_id"); ("domain_id","domain_id"); ("end_label_alt_id","end_label_alt_id"); ("end_label_asym_id","end_label_asym_id"); ("end_label_comp_id","end_label_comp_id"); ("end_label_seq_id","end_label_seq_id"); ("end_auth_asym_id","end_auth_asym_id"); ("end_auth_comp_id","end_auth_comp_id"); ("end_auth_seq_id","end_auth_seq_id"); 
    ("beg_label_alt_id","beg_label_alt_id"); ("beg_label_asym_id","beg_label_asym_id"); ("beg_label_comp_id","beg_label_comp_id"); ("beg_label_seq_id","beg_label_seq_id"); ("beg_auth_asym_id","beg_auth_asym_id"); ("beg_auth_comp_id","beg_auth_comp_id"); ("beg_auth_seq_id","beg_auth_seq_id"); ("seq_range_id","seq_range_id"); ("end_label_alt_id","end_label_alt_id"); ("end_label_asym_id","end_label_asym_id"); ("end_label_comp_id","end_label_comp_id"); ("end_label_seq_id","end_label_seq_id"); ("end_auth_asym_id","end_auth_asym_id"); ("end_auth_comp_id","end_auth_comp_id"); ("end_auth_seq_id","end_auth_seq_id"); 
    ("id","id"); ("feature_name","feature_name"); ("feature_type","feature_type"); ("feature","feature"); ("feature_identifier","feature_identifier"); ("feature_assigned_by","feature_assigned_by"); ("feature_citation_id","feature_citation_id"); ("feature_software_id","feature_software_id"); 
    ("id","id"); ("domain_id","domain_id"); ("feature_name","feature_name"); ("feature_type","feature_type"); ("feature","feature"); ("feature_identifier","feature_identifier"); ("feature_assigned_by","feature_assigned_by"); ("feature_citation_id","feature_citation_id"); ("feature_software_id","feature_software_id"); 
    ("id","id"); ("seq_range_id","seq_range_id"); ("feature_name","feature_name"); ("feature_type","feature_type"); ("feature","feature"); ("feature_identifier","feature_identifier"); ("feature_assigned_by","feature_assigned_by"); ("feature_citation_id","feature_citation_id"); ("feature_software_id","feature_software_id"); 
    ("id","id"); ("assembly_id","assembly_id"); ("feature_name","feature_name"); ("feature_type","feature_type"); ("feature","feature"); ("feature_identifier","feature_identifier"); ("feature_assigned_by","feature_assigned_by"); ("feature_citation_id","feature_citation_id"); ("feature_software_id","feature_software_id"); 
    ("id","id"); ("feature_name","feature_name"); ("feature_type","feature_type"); ("feature","feature"); ("feature_identifier","feature_identifier"); ("feature_assigned_by","feature_assigned_by"); ("feature_citation_id","feature_citation_id"); ("feature_software_id","feature_software_id"); ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); 
    ("entry_id","entry_id"); ("spec_preparation_pH","spec_preparation_pH"); ("spec_preparation_pH_range","spec_preparation_pH_range"); ("spec_preparation","spec_preparation"); 
    ("diffrn_id","diffrn_id"); ("crystal_id","crystal_id"); ("domain_id","domain_id"); ("type","type"); ("operator","operator"); ("fraction","fraction"); ("mean_I2_over_mean_I_square","mean_I2_over_mean_I_square"); ("mean_F_square_over_mean_F2","mean_F_square_over_mean_F2"); 
    ("type","type"); ("value","value"); ("details","details"); 
    ("entry_id","entry_id"); ("citation_id","citation_id"); ("details","details"); 
    ("biol_id","biol_id"); ("type","type"); ("value","value"); ("details","details"); 
    ("feature_id","feature_id"); ("align_id","align_id"); ("type","type"); ("details","details"); ("pdb_strand_id","pdb_strand_id"); ("asym_id","asym_id"); ("beg_auth_seq_id","beg_auth_seq_id"); ("end_auth_seq_id","end_auth_seq_id"); ("beg_seq_num","beg_seq_num"); ("end_seq_num","end_seq_num"); ("beg_auth_mon_id","beg_auth_mon_id"); ("end_auth_mon_id","end_auth_mon_id"); ("beg_pdb_ins_code","beg_pdb_ins_code"); ("end_pdb_ins_code","end_pdb_ins_code"); 
    ("feature_id","feature_id"); ("property_id","property_id"); ("type","type"); ("value","value"); ("details","details"); ("beg_db_mon_id","beg_db_mon_id"); ("end_db_mon_id","end_db_mon_id"); ("beg_db_seq_id","beg_db_seq_id"); ("end_db_seq_id","end_db_seq_id"); 
    ("details","details"); ("type","type"); ("pdb_strand_id","pdb_strand_id"); ("asym_id","asym_id"); ("auth_seq_id","auth_seq_id"); ("seq_num","seq_num"); ("auth_comp_id","auth_comp_id"); ("pdb_ins_code","pdb_ins_code"); ("ordinal","ordinal"); 
    ("comp_id","comp_id"); ("type","type"); ("support","support"); ("value","value"); ("source","source"); 
    ("asym_id","asym_id"); ("type","type"); 
    ("details","details"); ("type","type"); ("pdb_strand_id","pdb_strand_id"); ("asym_id","asym_id"); ("auth_seq_id","auth_seq_id"); ("seq_num","seq_num"); ("auth_comp_id","auth_comp_id"); ("pdb_ins_code","pdb_ins_code"); ("ordinal","ordinal"); 
    ("diffrn_id","diffrn_id"); ("d_res_low","d_res_low"); ("d_res_high","d_res_high"); ("percent_possible_obs","percent_possible_obs"); ("Rmerge_I_obs","Rmerge_I_obs"); ("Rsym_value","Rsym_value"); ("chi_squared","chi_squared"); ("redundancy","redundancy"); ("rejects","rejects"); ("number_obs","number_obs"); 
    ("atom_type_1","atom_type_1"); ("atom_type_2","atom_type_2"); ("lower_limit","lower_limit"); ("upper_limit","upper_limit"); 
    ("entry_id","entry_id"); ("id","id"); ("type","type"); ("source_beamline","source_beamline"); ("source_beamline_instrument","source_beamline_instrument"); ("detector_type","detector_type"); ("detector_specific","detector_specific"); ("source_type","source_type"); ("source_class","source_class"); ("num_time_frames","num_time_frames"); ("sample_pH","sample_pH"); ("temperature","temperature"); ("concentration_range","concentration_range"); ("buffer_name","buffer_name"); ("mean_guiner_radius","mean_guiner_radius"); ("mean_guiner_radius_esd","mean_guiner_radius_esd"); ("min_mean_cross_sectional_radii_gyration","min_mean_cross_sectional_radii_gyration"); ("min_mean_cross_sectional_radii_gyration_esd","min_mean_cross_sectional_radii_gyration_esd"); ("max_mean_cross_sectional_radii_gyration","max_mean_cross_sectional_radii_gyration"); ("max_mean_cross_sectional_radii_gyration_esd","max_mean_cross_sectional_radii_gyration_esd"); ("protein_length","protein_length"); ("data_reduction_software_list","data_reduction_software_list"); ("data_analysis_software_list","data_analysis_software_list"); 
    ("scatter_id","scatter_id"); ("id","id"); ("details","details"); ("method","method"); ("software_list","software_list"); ("software_author_list","software_author_list"); ("entry_fitting_list","entry_fitting_list"); ("num_conformers_calculated","num_conformers_calculated"); ("num_conformers_submitted","num_conformers_submitted"); ("representative_conformer","representative_conformer"); ("conformer_selection_criteria","conformer_selection_criteria"); 
    ("comp_id","comp_id"); ("descriptor","descriptor"); ("type","type"); ("program","program"); ("program_version","program_version"); ("ordinal","ordinal"); 
    ("comp_id","comp_id"); ("identifier","identifier"); ("type","type"); ("program","program"); ("program_version","program_version"); ("ordinal","ordinal"); 
    ("comp_id","comp_id"); 
    ("ordinal","ordinal"); ("comp_id","comp_id"); ("edit_op","edit_op"); ("atom_id","atom_id"); ("edit_atom_id","edit_atom_id"); ("edit_atom_value","edit_atom_value"); 
    ("ordinal","ordinal"); ("comp_id","comp_id"); ("edit_op","edit_op"); ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("edit_bond_value","edit_bond_value"); 
    ("comp_id","comp_id"); ("date","date"); ("annotator","annotator"); ("processing_site","processing_site"); ("details","details"); ("action_type","action_type"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id_1","auth_asym_id_1"); ("auth_atom_id_1","auth_atom_id_1"); ("auth_comp_id_1","auth_comp_id_1"); ("auth_seq_id_1","auth_seq_id_1"); ("auth_atom_id_2","auth_atom_id_2"); ("auth_asym_id_2","auth_asym_id_2"); ("auth_comp_id_2","auth_comp_id_2"); ("auth_seq_id_2","auth_seq_id_2"); ("PDB_ins_code_1","PDB_ins_code_1"); ("PDB_ins_code_2","PDB_ins_code_2"); ("label_alt_id_1","label_alt_id_1"); ("label_alt_id_2","label_alt_id_2"); ("symm_as_xyz_1","symm_as_xyz_1"); ("symm_as_xyz_2","symm_as_xyz_2"); ("dist","dist"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id_1","auth_asym_id_1"); ("auth_atom_id_1","auth_atom_id_1"); ("auth_comp_id_1","auth_comp_id_1"); ("auth_seq_id_1","auth_seq_id_1"); ("auth_atom_id_2","auth_atom_id_2"); ("auth_asym_id_2","auth_asym_id_2"); ("auth_comp_id_2","auth_comp_id_2"); ("auth_seq_id_2","auth_seq_id_2"); ("PDB_ins_code_1","PDB_ins_code_1"); ("PDB_ins_code_2","PDB_ins_code_2"); ("label_alt_id_1","label_alt_id_1"); ("label_alt_id_2","label_alt_id_2"); ("site_symmetry_1","site_symmetry_1"); ("site_symmetry_2","site_symmetry_2"); ("dist","dist"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id_1","auth_asym_id_1"); ("auth_atom_id_1","auth_atom_id_1"); ("auth_comp_id_1","auth_comp_id_1"); ("auth_seq_id_1","auth_seq_id_1"); ("auth_atom_id_2","auth_atom_id_2"); ("auth_asym_id_2","auth_asym_id_2"); ("auth_comp_id_2","auth_comp_id_2"); ("auth_seq_id_2","auth_seq_id_2"); ("PDB_ins_code_1","PDB_ins_code_1"); ("PDB_ins_code_2","PDB_ins_code_2"); ("label_alt_id_1","label_alt_id_1"); ("label_alt_id_2","label_alt_id_2"); ("bond_deviation","bond_deviation"); ("bond_value","bond_value"); ("bond_target_value","bond_target_value"); ("bond_standard_deviation","bond_standard_deviation"); ("linker_flag","linker_flag"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id_1","auth_asym_id_1"); ("auth_atom_id_1","auth_atom_id_1"); ("auth_comp_id_1","auth_comp_id_1"); ("auth_seq_id_1","auth_seq_id_1"); ("auth_atom_id_2","auth_atom_id_2"); ("auth_asym_id_2","auth_asym_id_2"); ("auth_comp_id_2","auth_comp_id_2"); ("auth_seq_id_2","auth_seq_id_2"); ("auth_atom_id_3","auth_atom_id_3"); ("auth_asym_id_3","auth_asym_id_3"); ("auth_comp_id_3","auth_comp_id_3"); ("auth_seq_id_3","auth_seq_id_3"); ("PDB_ins_code_1","PDB_ins_code_1"); ("PDB_ins_code_2","PDB_ins_code_2"); ("PDB_ins_code_3","PDB_ins_code_3"); ("label_alt_id_1","label_alt_id_1"); ("label_alt_id_2","label_alt_id_2"); ("label_alt_id_3","label_alt_id_3"); ("angle_deviation","angle_deviation"); ("angle_value","angle_value"); ("angle_target_value","angle_target_value"); ("angle_standard_deviation","angle_standard_deviation"); ("linker_flag","linker_flag"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("label_alt_id","label_alt_id"); ("phi","phi"); ("psi","psi"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id_1","auth_asym_id_1"); ("auth_asym_id_2","auth_asym_id_2"); ("auth_comp_id_1","auth_comp_id_1"); ("auth_comp_id_2","auth_comp_id_2"); ("auth_seq_id_1","auth_seq_id_1"); ("auth_seq_id_2","auth_seq_id_2"); ("PDB_ins_code_1","PDB_ins_code_1"); ("PDB_ins_code_2","PDB_ins_code_2"); ("label_alt_id_1","label_alt_id_1"); ("label_alt_id_2","label_alt_id_2"); ("omega","omega"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_atom_id","auth_atom_id"); ("label_alt_id","label_alt_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("omega","omega"); ("details","details"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("label_alt_id","label_alt_id"); ("rmsd","rmsd"); ("type","type"); 
    ("plane_id","plane_id"); ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("auth_atom_id","auth_atom_id"); ("atom_deviation","atom_deviation"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("label_alt_id","label_alt_id"); ("improper_torsion_angle","improper_torsion_angle"); 
    ("id","id"); ("ptnr1_label_alt_id","ptnr1_label_alt_id"); ("ptnr1_label_asym_id","ptnr1_label_asym_id"); ("ptnr1_label_atom_id","ptnr1_label_atom_id"); ("ptnr1_label_comp_id","ptnr1_label_comp_id"); ("ptnr1_label_seq_id","ptnr1_label_seq_id"); ("ptnr1_auth_asym_id","ptnr1_auth_asym_id"); ("ptnr1_auth_atom_id","ptnr1_auth_atom_id"); ("ptnr1_auth_comp_id","ptnr1_auth_comp_id"); ("ptnr1_auth_seq_id","ptnr1_auth_seq_id"); ("ptnr1_symmetry","ptnr1_symmetry"); ("ptnr2_label_alt_id","ptnr2_label_alt_id"); ("ptnr2_label_asym_id","ptnr2_label_asym_id"); ("ptnr2_label_atom_id","ptnr2_label_atom_id"); ("ptnr2_label_comp_id","ptnr2_label_comp_id"); ("ptnr2_label_seq_id","ptnr2_label_seq_id"); ("ptnr2_auth_asym_id","ptnr2_auth_asym_id"); ("ptnr2_auth_atom_id","ptnr2_auth_atom_id"); ("ptnr2_auth_comp_id","ptnr2_auth_comp_id"); ("ptnr2_auth_seq_id","ptnr2_auth_seq_id"); ("ptnr2_symmetry","ptnr2_symmetry"); ("ptnr1_PDB_ins_code","ptnr1_PDB_ins_code"); ("ptnr1_auth_alt_id","ptnr1_auth_alt_id"); ("ptnr2_PDB_ins_code","ptnr2_PDB_ins_code"); ("ptnr2_auth_alt_id","ptnr2_auth_alt_id"); ("ptnr3_auth_alt_id","ptnr3_auth_alt_id"); ("ptnr3_auth_asym_id","ptnr3_auth_asym_id"); ("ptnr3_auth_atom_id","ptnr3_auth_atom_id"); ("ptnr3_auth_comp_id","ptnr3_auth_comp_id"); ("ptnr3_PDB_ins_code","ptnr3_PDB_ins_code"); ("ptnr3_auth_seq_id","ptnr3_auth_seq_id"); ("ptnr3_label_alt_id","ptnr3_label_alt_id"); ("ptnr3_label_asym_id","ptnr3_label_asym_id"); ("ptnr3_label_atom_id","ptnr3_label_atom_id"); ("ptnr3_label_comp_id","ptnr3_label_comp_id"); ("ptnr3_label_seq_id","ptnr3_label_seq_id"); ("ptnr3_symmetry","ptnr3_symmetry"); ("value","value"); ("value_esd","value_esd"); 
    ("id","id"); ("polymer_flag","polymer_flag"); ("occupancy_flag","occupancy_flag"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); 
    ("id","id"); ("polymer_flag","polymer_flag"); ("occupancy_flag","occupancy_flag"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_atom_id","auth_atom_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("label_alt_id","label_alt_id"); ("label_atom_id","label_atom_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); 
    ("entry_id","entry_id"); ("nonpolymer_details","nonpolymer_details"); ("sequence_details","sequence_details"); ("compound_details","compound_details"); ("source_details","source_details"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("parent_comp_id","parent_comp_id"); ("details","details"); 
    ("id","id"); ("comp_id","comp_id"); ("asym_id","asym_id"); ("auth_asym_id","auth_asym_id"); ("auth_seq_id","auth_seq_id"); ("seq_id","seq_id"); ("PDB_ins_code","PDB_ins_code"); ("details","details"); ("db_code","db_code"); ("db_name","db_name"); 
    ("id","id"); ("details","details"); ("asym_id","asym_id"); ("comp_id","comp_id"); ("db_seq_id","db_seq_id"); ("db_code","db_code"); ("db_name","db_name"); 
    ("id","id"); ("group_PDB","group_PDB"); ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_atom_id","label_atom_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("pdbx_align","pdbx_align"); ("PDB_ins_code","PDB_ins_code"); ("pre_auth_asym_id","pre_auth_asym_id"); ("pre_auth_atom_id","pre_auth_atom_id"); ("pre_auth_comp_id","pre_auth_comp_id"); ("pre_auth_seq_id","pre_auth_seq_id"); ("pre_PDB_ins_code","pre_PDB_ins_code"); ("pre_group_PDB","pre_group_PDB"); ("pre_auth_alt_id","pre_auth_alt_id"); ("pre_pdbx_align","pre_pdbx_align"); ("auth_asym_id","auth_asym_id"); ("auth_atom_id","auth_atom_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_alt_id","auth_alt_id"); ("occupancy","occupancy"); ("pre_occupancy","pre_occupancy"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id_1","auth_asym_id_1"); ("auth_atom_id_1","auth_atom_id_1"); ("auth_comp_id_1","auth_comp_id_1"); ("auth_seq_id_1","auth_seq_id_1"); ("auth_atom_id_2","auth_atom_id_2"); ("auth_asym_id_2","auth_asym_id_2"); ("auth_comp_id_2","auth_comp_id_2"); ("auth_seq_id_2","auth_seq_id_2"); ("PDB_ins_code_1","PDB_ins_code_1"); ("PDB_ins_code_2","PDB_ins_code_2"); ("label_alt_id_1","label_alt_id_1"); ("label_alt_id_2","label_alt_id_2"); ("dist","dist"); 
    ("entry_id","entry_id"); ("number_of_operations","number_of_operations"); ("rotation_per_n_subunits","rotation_per_n_subunits"); ("rise_per_n_subunits","rise_per_n_subunits"); ("n_subunits_divisor","n_subunits_divisor"); ("dyad_axis","dyad_axis"); ("circular_symmetry","circular_symmetry"); 
    ("entry_id","entry_id"); ("Schoenflies_symbol","Schoenflies_symbol"); ("circular_symmetry","circular_symmetry"); ("H-M_notation","H-M_notation"); 
    ("details","details"); ("entity_id","entity_id"); ("id","id"); 
    ("id","id"); ("type","type"); ("name","name"); ("symmetry_operation","symmetry_operation"); ("matrix[1][1]","matrix11"); ("matrix[1][2]","matrix12"); ("matrix[1][3]","matrix13"); ("matrix[2][1]","matrix21"); ("matrix[2][2]","matrix22"); ("matrix[2][3]","matrix23"); ("matrix[3][1]","matrix31"); ("matrix[3][2]","matrix32"); ("matrix[3][3]","matrix33"); ("vector[1]","vector1"); ("vector[2]","vector2"); ("vector[3]","vector3"); 
    ("method_details","method_details"); ("oligomeric_details","oligomeric_details"); ("oligomeric_count","oligomeric_count"); ("details","details"); ("id","id"); 
    ("entity_inst_id","entity_inst_id"); ("asym_id_list","asym_id_list"); ("auth_asym_id_list","auth_asym_id_list"); ("assembly_id","assembly_id"); ("oper_expression","oper_expression"); 
    ("entity_inst_id","entity_inst_id"); ("asym_id","asym_id"); ("oper_expression","oper_expression"); 
    ("entity_inst_id","entity_inst_id"); ("msym_id","msym_id"); ("oper_expression","oper_expression"); 
    ("id","id"); ("name","name"); ("matrix[1][1]","matrix11"); ("matrix[1][2]","matrix12"); ("matrix[1][3]","matrix13"); ("matrix[2][1]","matrix21"); ("matrix[2][2]","matrix22"); ("matrix[2][3]","matrix23"); ("matrix[3][1]","matrix31"); ("matrix[3][2]","matrix32"); ("matrix[3][3]","matrix33"); ("vector[1]","vector1"); ("vector[2]","vector2"); ("vector[3]","vector3"); 
    ("comp_id","comp_id"); ("atom_id","atom_id"); ("feature_type","feature_type"); 
    ("family_prd_id","family_prd_id"); ("name","name"); ("release_status","release_status"); ("replaces","replaces"); ("replaced_by","replaced_by"); 
    ("prd_id","prd_id"); ("family_prd_id","family_prd_id"); 
    ("prd_id","prd_id"); ("formula_weight","formula_weight"); ("formula","formula"); ("type","type"); ("type_evidence_code","type_evidence_code"); ("class","class"); ("class_evidence_code","class_evidence_code"); ("name","name"); ("represent_as","represent_as"); ("chem_comp_id","chem_comp_id"); ("compound_details","compound_details"); ("description","description"); ("representative_PDB_id_code","representative_PDB_id_code"); ("release_status","release_status"); ("replaces","replaces"); ("replaced_by","replaced_by"); 
    ("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ("type","type"); ("details","details"); ("component_id","component_id"); 
    ("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ("details","details"); ("name","name"); ("chem_comp_id","chem_comp_id"); 
    ("link_id","link_id"); ("prd_id","prd_id"); ("details","details"); ("ref_entity_id_1","ref_entity_id_1"); ("ref_entity_id_2","ref_entity_id_2"); ("entity_seq_num_1","entity_seq_num_1"); ("entity_seq_num_2","entity_seq_num_2"); ("comp_id_1","comp_id_1"); ("comp_id_2","comp_id_2"); ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("value_order","value_order"); ("component_1","component_1"); ("component_2","component_2"); ("nonpoly_res_num_1","nonpoly_res_num_1"); ("nonpoly_res_num_2","nonpoly_res_num_2"); ("link_class","link_class"); 
    ("link_id","link_id"); ("prd_id","prd_id"); ("details","details"); ("ref_entity_id","ref_entity_id"); ("component_id","component_id"); ("entity_seq_num_1","entity_seq_num_1"); ("entity_seq_num_2","entity_seq_num_2"); ("comp_id_1","comp_id_1"); ("comp_id_2","comp_id_2"); ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("insert_code_1","insert_code_1"); ("insert_code_2","insert_code_2"); ("value_order","value_order"); 
    ("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ("type","type"); ("db_code","db_code"); ("db_name","db_name"); 
    ("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ("mon_id","mon_id"); ("parent_mon_id","parent_mon_id"); ("num","num"); ("observed","observed"); ("hetero","hetero"); 
    ("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ("type","type"); ("NRP_flag","NRP_flag"); ("one_letter_codes","one_letter_codes"); 
    ("prd_id","prd_id"); ("ref_entity_id","ref_entity_id"); ("ordinal","ordinal"); ("organism_scientific","organism_scientific"); ("strain","strain"); ("taxid","taxid"); ("atcc","atcc"); ("db_code","db_code"); ("db_name","db_name"); ("source","source"); ("source_id","source_id"); 
    ("family_prd_id","family_prd_id"); ("prd_id","prd_id"); ("ordinal","ordinal"); ("source","source"); ("source_id","source_id"); ("text","text"); 
    ("family_prd_id","family_prd_id"); ("prd_id","prd_id"); ("ordinal","ordinal"); ("name","name"); ("source","source"); ("chem_comp_id","chem_comp_id"); 
    ("prd_id","prd_id"); ("seq","seq"); ("chem_comp_id","chem_comp_id"); 
    ("family_prd_id","family_prd_id"); ("prd_id","prd_id"); ("ordinal","ordinal"); ("text","text"); ("type","type"); ("support","support"); ("source","source"); ("chem_comp_id","chem_comp_id"); 
    ("family_prd_id","family_prd_id"); ("prd_id","prd_id"); ("ordinal","ordinal"); ("source_ordinal","source_ordinal"); ("type","type"); ("value","value"); ("source","source"); ("chem_comp_id","chem_comp_id"); 
    ("family_prd_id","family_prd_id"); ("ordinal","ordinal"); ("db_name","db_name"); ("db_code","db_code"); ("db_accession","db_accession"); ("name","name"); ("formula","formula"); ("citation_id","citation_id"); 
    ("struct_group_id","struct_group_id"); ("name","name"); ("type","type"); ("group_enumeration_type","group_enumeration_type"); ("description","description"); ("selection","selection"); ("selection_details","selection_details"); 
    ("ordinal","ordinal"); ("struct_group_id","struct_group_id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("label_alt_id","label_alt_id"); 
    ("ordinal","ordinal"); ("struct_group_id","struct_group_id"); ("PDB_model_num","PDB_model_num"); ("beg_auth_asym_id","beg_auth_asym_id"); ("beg_auth_comp_id","beg_auth_comp_id"); ("beg_auth_seq_id","beg_auth_seq_id"); ("beg_PDB_ins_code","beg_PDB_ins_code"); ("beg_label_asym_id","beg_label_asym_id"); ("beg_label_comp_id","beg_label_comp_id"); ("beg_label_seq_id","beg_label_seq_id"); ("beg_label_alt_id","beg_label_alt_id"); ("end_auth_asym_id","end_auth_asym_id"); ("end_auth_comp_id","end_auth_comp_id"); ("end_auth_seq_id","end_auth_seq_id"); ("end_PDB_ins_code","end_PDB_ins_code"); ("end_label_asym_id","end_label_asym_id"); ("end_label_comp_id","end_label_comp_id"); ("end_label_seq_id","end_label_seq_id"); ("end_label_alt_id","end_label_alt_id"); 
    ("prd_id","prd_id"); ("date","date"); ("annotator","annotator"); ("processing_site","processing_site"); ("details","details"); ("action_type","action_type"); 
    ("family_prd_id","family_prd_id"); ("date","date"); ("annotator","annotator"); ("processing_site","processing_site"); ("details","details"); ("action_type","action_type"); 
    ("prd_id","prd_id"); ("instance_id","instance_id"); ("asym_id","asym_id"); ("linked_entity_id","linked_entity_id"); 
    ("prd_id","prd_id"); ("class","class"); ("type","type"); ("name","name"); ("details","details"); 
    ("id","id"); ("family_prd_id","family_prd_id"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_atom_id","auth_atom_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("label_alt_id","label_alt_id"); ("label_atom_id","label_atom_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("neighbor_macromolecule_distance","neighbor_macromolecule_distance"); ("neighbor_ligand_distance","neighbor_ligand_distance"); 
    ("id","id"); ("PDB_model_num","PDB_model_num"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); 
    ("publication_abbrev","publication_abbrev"); ("ASTM_code_type","ASTM_code_type"); ("ASTM_code_value","ASTM_code_value"); ("ISSN_code_type","ISSN_code_type"); ("ISSN_code_value","ISSN_code_value"); ("country","country"); ("start_year","start_year"); ("end_year","end_year"); 
    ("chem_shift_13C_err","chem_shift_13C_err"); ("chem_shift_15N_err","chem_shift_15N_err"); ("chem_shift_19F_err","chem_shift_19F_err"); ("chem_shift_1H_err","chem_shift_1H_err"); ("chem_shift_2H_err","chem_shift_2H_err"); ("chem_shift_31P_err","chem_shift_31P_err"); ("chem_shift_reference_id","chem_shift_reference_id"); ("conditions_id","conditions_id"); ("data_file_name","data_file_name"); ("details","details"); ("entry_id","entry_id"); ("error_derivation_method","error_derivation_method"); ("id","id"); ("label","label"); ("conditions_label","conditions_label"); 
    ("assigned_chem_shift_list_id","assigned_chem_shift_list_id"); ("entry_id","entry_id"); ("experiment_id","experiment_id"); ("experiment_name","experiment_name"); ("sample_state","sample_state"); ("solution_id","solution_id"); 
    ("atom_group","atom_group"); ("atom_isotope_number","atom_isotope_number"); ("atom_type","atom_type"); ("chem_shift_reference_id","chem_shift_reference_id"); ("chem_shift_units","chem_shift_units"); ("chem_shift_val","chem_shift_val"); ("correction_val","correction_val"); ("entry_id","entry_id"); ("external_ref_axis","external_ref_axis"); ("external_ref_loc","external_ref_loc"); ("external_ref_sample_geometry","external_ref_sample_geometry"); ("indirect_shift_ratio","indirect_shift_ratio"); ("mol_common_name","mol_common_name"); ("rank","rank"); ("ref_correction_type","ref_correction_type"); ("ref_method","ref_method"); ("ref_type","ref_type"); ("solvent","solvent"); 
    ("carbon_shifts_flag","carbon_shifts_flag"); ("details","details"); ("entry_id","entry_id"); ("id","id"); ("label","label"); ("nitrogen_shifts_flag","nitrogen_shifts_flag"); ("other_shifts_flag","other_shifts_flag"); ("phosphorus_shifts_flag","phosphorus_shifts_flag"); ("proton_shifts_flag","proton_shifts_flag"); 
    ("assigned_chem_shift_list_id","assigned_chem_shift_list_id"); ("entry_id","entry_id"); ("software_id","software_id"); ("software_label","software_label"); 
    ("constraint_filename","constraint_filename"); ("constraint_number","constraint_number"); ("constraint_subtype","constraint_subtype"); ("constraint_type","constraint_type"); ("entry_id","entry_id"); ("id","id"); ("software_name","software_name"); ("software_ordinal","software_ordinal"); 
    ("entry_id","entry_id"); ("software_ordinal","software_ordinal"); ("task","task"); 
    ("id","id"); ("atom_type","atom_type"); ("atom_isotope_number","atom_isotope_number"); ("spectral_region","spectral_region"); ("magnetization_linkage_id","magnetization_linkage_id"); ("sweep_width","sweep_width"); ("encoding_code","encoding_code"); ("encoded_source_dimension_id","encoded_source_dimension_id"); ("entry_id","entry_id"); ("spectral_peak_list_id","spectral_peak_list_id"); ("sweep_width_units","sweep_width_units"); ("center_frequency_offset","center_frequency_offset"); ("under_sampling_type","under_sampling_type"); 
    ("entry_id","entry_id"); ("id","id"); ("data_file_name","data_file_name"); ("solution_id","solution_id"); ("conditions_id","conditions_id"); ("experiment_id","experiment_id"); ("number_of_spectral_dimensions","number_of_spectral_dimensions"); ("details","details"); ("text_data_format","text_data_format"); ("label","label"); ("conditions_label","conditions_label"); 
    ("software_id","software_id"); ("entry_id","entry_id"); ("spectral_peak_list_id","spectral_peak_list_id"); 
    ("type","type"); ("atom_type","atom_type"); ("atom_isotope_number","atom_isotope_number"); ("val","val"); ("val_err","val_err"); ("entry_id","entry_id"); ("assigned_chem_shift_list_id","assigned_chem_shift_list_id"); ("ordinal","ordinal"); 
    ("data_file_id","data_file_id"); ("data_file_name","data_file_name"); ("data_file_category","data_file_category"); ("data_file_syntax","data_file_syntax"); ("entry_id","entry_id"); 
    ("funding_organization","funding_organization"); ("country","country"); ("grant_number","grant_number"); ("ordinal","ordinal"); 
    ("id","id"); ("type","type"); ("entity_id_1","entity_id_1"); ("entity_id_2","entity_id_2"); ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("comp_id_1","comp_id_1"); ("comp_id_2","comp_id_2"); ("seq_id_1","seq_id_1"); ("seq_id_2","seq_id_2"); 
    ("id","id"); ("parent_comp_id","parent_comp_id"); ("type","type"); ("class","class"); 
    ("common_name","common_name"); ("details","details"); ("entity_id","entity_id"); ("genus","genus"); ("species","species"); ("strain","strain"); ("tissue","tissue"); ("tissue_fraction","tissue_fraction"); ("pdbx_organism_scientific","pdbx_organism_scientific"); ("pdbx_secretion","pdbx_secretion"); ("pdbx_fragment","pdbx_fragment"); ("pdbx_variant","pdbx_variant"); ("pdbx_cell_line","pdbx_cell_line"); ("pdbx_atcc","pdbx_atcc"); ("pdbx_cellular_location","pdbx_cellular_location"); ("pdbx_organ","pdbx_organ"); ("pdbx_organelle","pdbx_organelle"); ("pdbx_cell","pdbx_cell"); ("pdbx_plasmid_name","pdbx_plasmid_name"); ("pdbx_plasmid_details","pdbx_plasmid_details"); ("pdbx_ncbi_taxonomy_id","pdbx_ncbi_taxonomy_id"); ("pdbx_src_id","pdbx_src_id"); ("pdbx_alt_source_flag","pdbx_alt_source_flag"); ("pdbx_beg_seq_num","pdbx_beg_seq_num"); ("pdbx_end_seq_num","pdbx_end_seq_num"); ("pdbx_culture_collection","pdbx_culture_collection"); 
    ("entity_id","entity_id"); ("gene_src_common_name","gene_src_common_name"); ("gene_src_details","gene_src_details"); ("gene_src_genus","gene_src_genus"); ("gene_src_species","gene_src_species"); ("gene_src_strain","gene_src_strain"); ("gene_src_tissue","gene_src_tissue"); ("gene_src_tissue_fraction","gene_src_tissue_fraction"); ("host_org_genus","host_org_genus"); ("host_org_species","host_org_species"); ("pdbx_gene_src_fragment","pdbx_gene_src_fragment"); ("pdbx_gene_src_gene","pdbx_gene_src_gene"); ("pdbx_gene_src_scientific_name","pdbx_gene_src_scientific_name"); ("pdbx_gene_src_variant","pdbx_gene_src_variant"); ("pdbx_gene_src_cell_line","pdbx_gene_src_cell_line"); ("pdbx_gene_src_atcc","pdbx_gene_src_atcc"); ("pdbx_gene_src_organ","pdbx_gene_src_organ"); ("pdbx_gene_src_organelle","pdbx_gene_src_organelle"); ("pdbx_gene_src_plasmid","pdbx_gene_src_plasmid"); ("pdbx_gene_src_plasmid_name","pdbx_gene_src_plasmid_name"); ("pdbx_gene_src_cell","pdbx_gene_src_cell"); ("pdbx_gene_src_cellular_location","pdbx_gene_src_cellular_location"); ("pdbx_host_org_gene","pdbx_host_org_gene"); ("pdbx_host_org_organ","pdbx_host_org_organ"); ("pdbx_host_org_organelle","pdbx_host_org_organelle"); ("pdbx_host_org_cellular_location","pdbx_host_org_cellular_location"); ("pdbx_host_org_strain","pdbx_host_org_strain"); ("pdbx_host_org_tissue_fraction","pdbx_host_org_tissue_fraction"); ("pdbx_description","pdbx_description"); ("host_org_common_name","host_org_common_name"); ("host_org_details","host_org_details"); ("host_org_strain","host_org_strain"); ("plasmid_details","plasmid_details"); ("plasmid_name","plasmid_name"); ("pdbx_host_org_variant","pdbx_host_org_variant"); ("pdbx_host_org_cell_line","pdbx_host_org_cell_line"); ("pdbx_host_org_atcc","pdbx_host_org_atcc"); ("pdbx_host_org_culture_collection","pdbx_host_org_culture_collection"); ("pdbx_host_org_cell","pdbx_host_org_cell"); ("pdbx_host_org_scientific_name","pdbx_host_org_scientific_name"); ("pdbx_host_org_tissue","pdbx_host_org_tissue"); ("pdbx_host_org_vector","pdbx_host_org_vector"); ("pdbx_host_org_vector_type","pdbx_host_org_vector_type"); ("expression_system_id","expression_system_id"); ("gene_src_dev_stage","gene_src_dev_stage"); ("start_construct_id","start_construct_id"); ("pdbx_gene_src_ncbi_taxonomy_id","pdbx_gene_src_ncbi_taxonomy_id"); ("pdbx_host_org_ncbi_taxonomy_id","pdbx_host_org_ncbi_taxonomy_id"); ("pdbx_src_id","pdbx_src_id"); ("pdbx_alt_source_flag","pdbx_alt_source_flag"); ("pdbx_seq_type","pdbx_seq_type"); ("pdbx_beg_seq_num","pdbx_beg_seq_num"); ("pdbx_end_seq_num","pdbx_end_seq_num"); ("pdbx_gene_src_culture_collection","pdbx_gene_src_culture_collection"); 
    ("details","details"); ("organism_scientific","organism_scientific"); ("organism_common_name","organism_common_name"); ("strain","strain"); ("ncbi_taxonomy_id","ncbi_taxonomy_id"); ("entity_id","entity_id"); ("pdbx_src_id","pdbx_src_id"); ("pdbx_alt_source_flag","pdbx_alt_source_flag"); ("pdbx_beg_seq_num","pdbx_beg_seq_num"); ("pdbx_end_seq_num","pdbx_end_seq_num"); 
    ("link_id","link_id"); ("details","details"); ("entity_id","entity_id"); ("entity_comp_num_1","entity_comp_num_1"); ("entity_comp_num_2","entity_comp_num_2"); ("comp_id_1","comp_id_1"); ("comp_id_2","comp_id_2"); ("atom_id_1","atom_id_1"); ("leaving_atom_id_1","leaving_atom_id_1"); ("atom_stereo_config_1","atom_stereo_config_1"); ("atom_id_2","atom_id_2"); ("leaving_atom_id_2","leaving_atom_id_2"); ("atom_stereo_config_2","atom_stereo_config_2"); ("value_order","value_order"); 
    ("linked_entity_id","linked_entity_id"); ("type","type"); ("class","class"); ("name","name"); ("description","description"); ("prd_id","prd_id"); 
    ("linked_entity_id","linked_entity_id"); ("instance_id","instance_id"); ("asym_id","asym_id"); 
    ("linked_entity_id","linked_entity_id"); ("entity_id","entity_id"); ("component_id","component_id"); ("details","details"); 
    ("link_id","link_id"); ("linked_entity_id","linked_entity_id"); ("details","details"); ("entity_id_1","entity_id_1"); ("entity_id_2","entity_id_2"); ("entity_seq_num_1","entity_seq_num_1"); ("entity_seq_num_2","entity_seq_num_2"); ("comp_id_1","comp_id_1"); ("comp_id_2","comp_id_2"); ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("value_order","value_order"); ("component_1","component_1"); ("component_2","component_2"); ("link_class","link_class"); 
    ("entity_id","entity_id"); ("descriptor","descriptor"); ("type","type"); ("program","program"); ("program_version","program_version"); ("ordinal","ordinal"); 
    ("id","id"); ("class","class"); ("name","name"); ("taxonomy_id","taxonomy_id"); ("taxonomy_class","taxonomy_class"); ("link_to_entity_type","link_to_entity_type"); ("link_to_comp_id","link_to_comp_id"); ("link_from_entity_type","link_from_entity_type"); 
    ("linked_entity_id","linked_entity_id"); ("list_id","list_id"); ("name","name"); ("comp_id","comp_id"); 
    ("linked_entity_id","linked_entity_id"); ("link_id","link_id"); ("list_id_1","list_id_1"); ("list_id_2","list_id_2"); ("details","details"); ("comp_id_1","comp_id_1"); ("comp_id_2","comp_id_2"); ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("leaving_atom_id_1","leaving_atom_id_1"); ("atom_stereo_config_1","atom_stereo_config_1"); ("leaving_atom_id_2","leaving_atom_id_2"); ("atom_stereo_config_2","atom_stereo_config_2"); ("value_order","value_order"); 
    ("linked_entity_id","linked_entity_id"); ("link_id","link_id"); ("from_list_id","from_list_id"); ("details","details"); ("to_comp_id","to_comp_id"); ("from_comp_id","from_comp_id"); ("to_atom_id","to_atom_id"); ("from_atom_id","from_atom_id"); ("from_leaving_atom_id","from_leaving_atom_id"); ("from_atom_stereo_config","from_atom_stereo_config"); ("value_order","value_order"); 
    ("ordinal","ordinal"); ("data_reference","data_reference"); ("metadata_reference","metadata_reference"); ("data_set_type","data_set_type"); ("details","details"); 
    ("entry_id","entry_id"); ("ordinal","ordinal"); ("date_begin","date_begin"); ("date_end","date_end"); ("status_code","status_code"); ("details","details"); 
    ("id","id"); ("entry_id","entry_id"); ("name","name"); ("aggregation_state","aggregation_state"); ("composition","composition"); ("num_components","num_components"); ("mol_wt_exp","mol_wt_exp"); ("mol_wt_theo","mol_wt_theo"); ("mol_wt_method","mol_wt_method"); ("details","details"); 
    ("id","id"); ("assembly_id","assembly_id"); ("parent_id","parent_id"); ("source","source"); ("type","type"); ("name","name"); ("details","details"); ("go_id","go_id"); ("ipr_id","ipr_id"); ("synonym","synonym"); ("number_of_copies","number_of_copies"); ("oligomeric_details","oligomeric_details"); ("entity_id_list","entity_id_list"); ("ebi_organism_scientific","ebi_organism_scientific"); ("ebi_organism_common","ebi_organism_common"); ("ebi_strain","ebi_strain"); ("ebi_tissue","ebi_tissue"); ("ebi_cell","ebi_cell"); ("ebi_organelle","ebi_organelle"); ("ebi_cellular_location","ebi_cellular_location"); ("ebi_engineered","ebi_engineered"); ("ebi_expression_system","ebi_expression_system"); ("ebi_expression_system_plasmid","ebi_expression_system_plasmid"); ("mutant_flag","mutant_flag"); 
    ("id","id"); ("virus_host_category","virus_host_category"); ("virus_host_species","virus_host_species"); ("virus_host_growth_cell","virus_host_growth_cell"); ("virus_type","virus_type"); ("virus_isolate","virus_isolate"); ("ictvdb_id","ictvdb_id"); ("entity_assembly_id","entity_assembly_id"); ("enveloped","enveloped"); ("empty","empty"); ("details","details"); 
    ("entry_id","entry_id"); ("id","id"); ("ph","ph"); ("buffer_id","buffer_id"); ("sample_concentration","sample_concentration"); ("2d_crystal_grow_id","_2d_crystal_grow_id"); ("support_id","support_id"); ("entity_assembly_id","entity_assembly_id"); ("details","details"); 
    ("id","id"); ("film_material","film_material"); ("method","method"); ("grid_material","grid_material"); ("grid_mesh_size","grid_mesh_size"); ("grid_type","grid_type"); ("pretreatment","pretreatment"); ("details","details"); ("specimen_id","specimen_id"); ("citation_id","citation_id"); 
    ("id","id"); ("specimen_id","specimen_id"); ("name","name"); ("details","details"); ("pH","pH"); 
    ("entry_id","entry_id"); ("id","id"); ("sample_preparation_id","sample_preparation_id"); ("specimen_id","specimen_id"); ("cryogen_name","cryogen_name"); ("humidity","humidity"); ("temp","temp"); ("chamber_temperature","chamber_temperature"); ("instrument","instrument"); ("method","method"); ("time_resolved_state","time_resolved_state"); ("citation_id","citation_id"); ("details","details"); 
    ("entry_id","entry_id"); ("id","id"); ("astigmatism","astigmatism"); ("electron_beam_tilt_params","electron_beam_tilt_params"); ("residual_tilt","residual_tilt"); ("sample_support_id","sample_support_id"); ("detector_id","detector_id"); ("scans_id","scans_id"); ("microscope_id","microscope_id"); ("microscope_model","microscope_model"); ("specimen_holder_type","specimen_holder_type"); ("specimen_holder_model","specimen_holder_model"); ("details","details"); ("date","date"); ("accelerating_voltage","accelerating_voltage"); ("illumination_mode","illumination_mode"); ("mode","mode"); ("nominal_cs","nominal_cs"); ("nominal_defocus_min","nominal_defocus_min"); ("nominal_defocus_max","nominal_defocus_max"); ("calibrated_defocus_min","calibrated_defocus_min"); ("calibrated_defocus_max","calibrated_defocus_max"); ("tilt_angle_min","tilt_angle_min"); ("tilt_angle_max","tilt_angle_max"); ("nominal_magnification","nominal_magnification"); ("calibrated_magnification","calibrated_magnification"); ("electron_source","electron_source"); ("electron_dose","electron_dose"); ("energy_filter","energy_filter"); ("energy_window","energy_window"); ("citation_id","citation_id"); ("temperature","temperature"); ("detector_distance","detector_distance"); ("recording_temperature_minimum","recording_temperature_minimum"); ("recording_temperature_maximum","recording_temperature_maximum"); ("alignment_procedure","alignment_procedure"); ("c2_aperture_diameter","c2_aperture_diameter"); ("specimen_id","specimen_id"); ("cryogen","cryogen"); 
    ("entry_id","entry_id"); ("id","id"); ("details","details"); ("type","type"); ("detective_quantum_efficiency","detective_quantum_efficiency"); ("mode","mode"); 
    ("entry_id","entry_id"); ("id","id"); ("number_digital_images","number_digital_images"); ("details","details"); ("scanner_model","scanner_model"); ("sampling_size","sampling_size"); ("od_range","od_range"); ("quant_bit_size","quant_bit_size"); ("citation_id","citation_id"); ("dimension_height","dimension_height"); ("dimension_width","dimension_width"); ("frames_per_image","frames_per_image"); ("image_recording_id","image_recording_id"); ("used_frames_per_image","used_frames_per_image"); 
    ("entry_id","entry_id"); ("id","id"); ("num_particles","num_particles"); ("software_name","software_name"); ("method","method"); ("details","details"); ("citation_id","citation_id"); 
    ("entry_id","entry_id"); ("id","id"); ("method","method"); ("algorithm","algorithm"); ("citation_id","citation_id"); ("details","details"); ("resolution","resolution"); ("resolution_method","resolution_method"); ("magnification_calibration","magnification_calibration"); ("ctf_correction_method","ctf_correction_method"); ("nominal_pixel_size","nominal_pixel_size"); ("actual_pixel_size","actual_pixel_size"); ("num_particles","num_particles"); ("euler_angles_details","euler_angles_details"); ("num_class_averages","num_class_averages"); ("software","software"); ("fsc_type","fsc_type"); ("refinement_type","refinement_type"); ("image_processing_id","image_processing_id"); ("symmetry_type","symmetry_type"); 
    ("id","id"); ("entry_id","entry_id"); ("method","method"); ("target_criteria","target_criteria"); ("software_name","software_name"); ("details","details"); ("overall_b_value","overall_b_value"); ("ref_space","ref_space"); ("ref_protocol","ref_protocol"); 
    ("id","id"); ("3d_fitting_id","_3d_fitting_id"); ("pdb_entry_id","pdb_entry_id"); ("pdb_chain_id","pdb_chain_id"); ("pdb_chain_residue_range","pdb_chain_residue_range"); ("details","details"); 
    ("id","id"); ("entity_assembly_id","entity_assembly_id"); ("image_processing_id","image_processing_id"); ("details","details"); ("dyad","dyad"); ("axial_symmetry","axial_symmetry"); ("angular_rotation_per_subunit","angular_rotation_per_subunit"); ("axial_rise_per_subunit","axial_rise_per_subunit"); ("hand","hand"); 
    ("entry_id","entry_id"); ("id","id"); ("reconstruction_method","reconstruction_method"); ("aggregation_state","aggregation_state"); ("specimen_type","specimen_type"); ("entity_assembly_id","entity_assembly_id"); 
    ("entry_id","entry_id"); ("id","id"); ("symmetry_type","symmetry_type"); ("image_processing_id","image_processing_id"); ("point_symmetry","point_symmetry"); 
    ("current_status","current_status"); ("deposition_date","deposition_date"); ("deposition_site","deposition_site"); ("details","details"); ("entry_id","entry_id"); ("last_update","last_update"); ("map_release_date","map_release_date"); ("map_hold_date","map_hold_date"); ("header_release_date","header_release_date"); ("obsoleted_date","obsoleted_date"); ("replace_existing_entry_flag","replace_existing_entry_flag"); ("title","title"); 
    ("author","author"); ("ordinal","ordinal"); 
    ("access_code","access_code"); ("db_name","db_name"); ("details","details"); ("id","id"); ("relationship","relationship"); 
    ("id","id"); ("link","link"); ("link_type","link_type"); 
    ("depositor_hold_instructions","depositor_hold_instructions"); ("entry_id","entry_id"); ("macromolecule_description","macromolecule_description"); ("obsolete_instructions","obsolete_instructions"); ("same_authors_as_pdb","same_authors_as_pdb"); ("same_title_as_pdb","same_title_as_pdb"); 
    ("date","date"); ("details","details"); ("entry","entry"); ("id","id"); 
    ("date","date"); ("details","details"); ("entry","entry"); ("id","id"); 
    ("entity_assembly_id","entity_assembly_id"); ("experimental_flag","experimental_flag"); ("id","id"); ("units","units"); ("value","value"); ("method","method"); 
    ("cell","cell"); ("cellular_location","cellular_location"); ("entity_assembly_id","entity_assembly_id"); ("id","id"); ("ncbi_tax_id","ncbi_tax_id"); ("organism","organism"); ("organelle","organelle"); ("organ","organ"); ("strain","strain"); ("tissue","tissue"); 
    ("cell","cell"); ("entity_assembly_id","entity_assembly_id"); ("id","id"); ("ncbi_tax_id","ncbi_tax_id"); ("organism","organism"); ("plasmid","plasmid"); ("strain","strain"); 
    ("entity_assembly_id","entity_assembly_id"); ("id","id"); ("ncbi_tax_id","ncbi_tax_id"); ("organism","organism"); ("strain","strain"); 
    ("diameter","diameter"); ("entity_assembly_id","entity_assembly_id"); ("id","id"); ("name","name"); ("triangulation","triangulation"); 
    ("concentration","concentration"); ("details","details"); ("embedding_applied","embedding_applied"); ("experiment_id","experiment_id"); ("id","id"); ("shadowing_applied","shadowing_applied"); ("staining_applied","staining_applied"); ("vitrification_applied","vitrification_applied"); 
    ("details","details"); ("id","id"); ("material","material"); ("specimen_id","specimen_id"); 
    ("diameter","diameter"); ("em_tomography_specimen_id","em_tomography_specimen_id"); ("id","id"); ("manufacturer","manufacturer"); 
    ("current","current"); ("details","details"); ("dose_rate","dose_rate"); ("duration","duration"); ("em_tomography_specimen_id","em_tomography_specimen_id"); ("final_thickness","final_thickness"); ("id","id"); ("initial_thickness","initial_thickness"); ("instrument","instrument"); ("ion","ion"); ("temperature","temperature"); ("voltage","voltage"); 
    ("atmosphere","atmosphere"); ("id","id"); ("pressure","pressure"); ("sample_support_id","sample_support_id"); ("time","time"); ("type","type"); 
    ("details","details"); ("em_tomography_specimen_id","em_tomography_specimen_id"); ("final_thickness","final_thickness"); ("id","id"); ("instrument","instrument"); ("temperature","temperature"); 
    ("details","details"); ("em_tomography_specimen_id","em_tomography_specimen_id"); ("id","id"); ("instrument","instrument"); 
    ("angle","angle"); ("details","details"); ("id","id"); ("material","material"); ("specimen_id","specimen_id"); ("thickness","thickness"); 
    ("cryo_protectant","cryo_protectant"); ("details","details"); ("fiducial_markers","fiducial_markers"); ("high_pressure_freezing","high_pressure_freezing"); ("id","id"); ("sectioning","sectioning"); ("specimen_id","specimen_id"); 
    ("atmosphere","atmosphere"); ("details","details"); ("id","id"); ("instrument","instrument"); ("lipid_mixture","lipid_mixture"); ("lipid_protein_ratio","lipid_protein_ratio"); ("specimen_id","specimen_id"); ("temperature","temperature"); ("time","time"); ("time_unit","time_unit"); 
    ("details","details"); ("id","id"); ("material","material"); ("specimen_id","specimen_id"); ("type","type"); 
    ("id","id"); ("material","material"); ("sample_support_id","sample_support_id"); ("thickness","thickness"); ("topology","topology"); 
    ("buffer_id","buffer_id"); ("concentration","concentration"); ("concentration_units","concentration_units"); ("formula","formula"); ("id","id"); ("name","name"); 
    ("camera_length","camera_length"); ("id","id"); ("imaging_id","imaging_id"); ("tilt_angle_list","tilt_angle_list"); 
    ("em_diffraction_stats_id","em_diffraction_stats_id"); ("fourier_space_coverage","fourier_space_coverage"); ("high_resolution","high_resolution"); ("id","id"); ("low_resolution","low_resolution"); ("multiplicity","multiplicity"); ("num_structure_factors","num_structure_factors"); ("phase_residual","phase_residual"); 
    ("details","details"); ("fourier_space_coverage","fourier_space_coverage"); ("high_resolution","high_resolution"); ("id","id"); ("image_processing_id","image_processing_id"); ("num_intensities_measured","num_intensities_measured"); ("num_structure_factors","num_structure_factors"); ("overall_phase_error","overall_phase_error"); ("overall_phase_residual","overall_phase_residual"); ("phase_error_rejection_criteria","phase_error_rejection_criteria"); ("r_merge","r_merge"); ("r_sym","r_sym"); 
    ("axis1_angle_increment","axis1_angle_increment"); ("axis1_max_angle","axis1_max_angle"); ("axis1_min_angle","axis1_min_angle"); ("axis2_angle_increment","axis2_angle_increment"); ("axis2_max_angle","axis2_max_angle"); ("axis2_min_angle","axis2_min_angle"); ("dual_tilt_axis_rotation","dual_tilt_axis_rotation"); ("id","id"); ("imaging_id","imaging_id"); 
    ("average_exposure_time","average_exposure_time"); ("avg_electron_dose_per_image","avg_electron_dose_per_image"); ("details","details"); ("detector_mode","detector_mode"); ("film_or_detector_model","film_or_detector_model"); ("id","id"); ("imaging_id","imaging_id"); ("num_diffraction_images","num_diffraction_images"); ("num_grids_imaged","num_grids_imaged"); ("num_real_images","num_real_images"); 
    ("chr_aberration_corrector","chr_aberration_corrector"); ("energyfilter_lower","energyfilter_lower"); ("energyfilter_name","energyfilter_name"); ("energyfilter_upper","energyfilter_upper"); ("id","id"); ("imaging_id","imaging_id"); ("phase_plate","phase_plate"); ("sph_aberration_corrector","sph_aberration_corrector"); 
    ("avg_num_images_per_class","avg_num_images_per_class"); ("details","details"); ("id","id"); ("image_processing_id","image_processing_id"); ("num_classes","num_classes"); ("type","type"); 
    ("details","details"); ("emdb_id","emdb_id"); ("id","id"); ("image_processing_id","image_processing_id"); ("insilico_model","insilico_model"); ("orthogonal_tilt_angle1","orthogonal_tilt_angle1"); ("orthogonal_tilt_angle2","orthogonal_tilt_angle2"); ("orthogonal_tilt_num_images","orthogonal_tilt_num_images"); ("other","other"); ("pdb_id","pdb_id"); ("random_conical_tilt_angle","random_conical_tilt_angle"); ("random_conical_tilt_num_images","random_conical_tilt_num_images"); ("type","type"); 
    ("category","category"); ("details","details"); ("id","id"); ("image_processing_id","image_processing_id"); ("fitting_id","fitting_id"); ("imaging_id","imaging_id"); ("name","name"); ("version","version"); 
    ("details","details"); ("id","id"); ("image_processing_id","image_processing_id"); ("order","order"); ("proj_matching_angular_sampling","proj_matching_angular_sampling"); ("proj_matching_merit_function","proj_matching_merit_function"); ("proj_matching_num_projections","proj_matching_num_projections"); ("type","type"); 
    ("amplitude_correction","amplitude_correction"); ("amplitude_correction_factor","amplitude_correction_factor"); ("amplitude_correction_space","amplitude_correction_space"); ("correction_operation","correction_operation"); ("details","details"); ("em_image_processing_id","em_image_processing_id"); ("id","id"); ("phase_reversal","phase_reversal"); ("phase_reversal_anisotropic","phase_reversal_anisotropic"); ("phase_reversal_correction_space","phase_reversal_correction_space"); ("type","type"); 
    ("details","details"); ("id","id"); ("image_processing_id","image_processing_id"); ("method","method"); ("num_tomograms","num_tomograms"); ("num_volumes_extracted","num_volumes_extracted"); ("reference_model","reference_model"); 
    ("angle_alpha","angle_alpha"); ("angle_beta","angle_beta"); ("angle_gamma","angle_gamma"); ("image_processing_id","image_processing_id"); ("id","id"); ("length_a","length_a"); ("length_b","length_b"); ("length_c","length_c"); ("space_group_name","space_group_name"); ("space_group_num","space_group_num"); 
    ("angle_gamma","angle_gamma"); ("c_sampling_length","c_sampling_length"); ("image_processing_id","image_processing_id"); ("id","id"); ("entity_assembly_id","entity_assembly_id"); ("length_a","length_a"); ("length_b","length_b"); ("length_c","length_c"); ("space_group_name_H-M","space_group_name_H-M"); 
    ("details","details"); ("id","id"); ("image_recording_id","image_recording_id"); 
    ("details","details"); ("id","id"); ("image_processing_id","image_processing_id"); ("method","method"); ("num_particles_selected","num_particles_selected"); ("reference_model","reference_model"); 
    ("annotation_details","annotation_details"); ("axis_order_fast","axis_order_fast"); ("axis_order_medium","axis_order_medium"); ("axis_order_slow","axis_order_slow"); ("cell_a","cell_a"); ("cell_b","cell_b"); ("cell_c","cell_c"); ("cell_alpha","cell_alpha"); ("cell_beta","cell_beta"); ("cell_gamma","cell_gamma"); ("contour_level","contour_level"); ("contour_level_source","contour_level_source"); ("data_type","data_type"); ("dimensions_col","dimensions_col"); ("dimensions_row","dimensions_row"); ("dimensions_sec","dimensions_sec"); ("endian_type","endian_type"); ("file","file"); ("format","format"); ("id","id"); ("partition","partition"); ("entry_id","entry_id"); ("label","label"); ("limit_col","limit_col"); ("limit_row","limit_row"); ("limit_sec","limit_sec"); ("origin_col","origin_col"); ("origin_row","origin_row"); ("origin_sec","origin_sec"); ("pixel_spacing_x","pixel_spacing_x"); ("pixel_spacing_y","pixel_spacing_y"); ("pixel_spacing_z","pixel_spacing_z"); ("size_kb","size_kb"); ("spacing_x","spacing_x"); ("spacing_y","spacing_y"); ("spacing_z","spacing_z"); ("statistics_average","statistics_average"); ("statistics_maximum","statistics_maximum"); ("statistics_minimum","statistics_minimum"); ("statistics_std","statistics_std"); ("symmetry_space_group","symmetry_space_group"); ("type","type"); 
    ("details","details"); ("file","file"); ("id","id"); 
    ("details","details"); ("file","file"); ("id","id"); 
    ("details","details"); ("experiment_id","experiment_id"); ("file","file"); ("id","id"); 
    ("details","details"); ("experiment_id","experiment_id"); ("file","file"); ("id","id"); 
    ("entry_id","entry_id"); ("em_method_selection","em_method_selection"); ("molecular_description_flag","molecular_description_flag"); 
    ("entry_id","entry_id"); ("experiment_id","experiment_id"); ("id","id"); ("map_type","map_type"); ("upload_file_name","upload_file_name"); ("upload_format","upload_format"); ("contour_level","contour_level"); ("annotation_details","annotation_details"); ("pixel_spacing_x","pixel_spacing_x"); ("pixel_spacing_y","pixel_spacing_y"); ("pixel_spacing_z","pixel_spacing_z"); 
    ("id","id"); ("upload_file_name","upload_file_name"); ("upload_format","upload_format"); ("contour_level","contour_level"); ("annotation_details","annotation_details"); ("pixel_spacing_x","pixel_spacing_x"); ("pixel_spacing_y","pixel_spacing_y"); ("pixel_spacing_z","pixel_spacing_z"); 
    ("id","id"); ("experiment_id","experiment_id"); ("upload_file_name","upload_file_name"); ("details","details"); 
    ("id","id"); ("experiment_id","experiment_id"); ("upload_file_name","upload_file_name"); ("details","details"); 
    ("id","id"); ("experiment_id","experiment_id"); ("upload_file_name","upload_file_name"); ("details","details"); 
    ("entity_id","entity_id"); ("auth_asym_id","auth_asym_id"); ("one_letter_code","one_letter_code"); ("one_letter_code_mod","one_letter_code_mod"); 
    ("ordinal","ordinal"); ("comp_id","comp_id"); ("alt_comp_id","alt_comp_id"); ("name","name"); ("formula","formula"); ("type","type"); ("descriptor","descriptor"); ("descriptor_type","descriptor_type"); ("in_dictionary_flag","in_dictionary_flag"); ("details","details"); 
    ("ref_id","ref_id"); ("entity_id","entity_id"); ("db_align_beg","db_align_beg"); ("db_align_end","db_align_end"); ("details","details"); ("db_accession","db_accession"); ("db_code","db_code"); ("db_name","db_name"); ("db_seq_one_letter_code","db_seq_one_letter_code"); ("seq_align_begin","seq_align_begin"); ("seq_align_end","seq_align_end"); 
    ("ordinal","ordinal"); ("ref_id","ref_id"); ("entity_id","entity_id"); ("db_mon_id","db_mon_id"); ("db_seq_id","db_seq_id"); ("details","details"); ("auth_mon_id","auth_mon_id"); ("auth_seq_id","auth_seq_id"); ("db_accession","db_accession"); ("db_code","db_code"); ("db_name","db_name"); ("annotation","annotation"); 
    ("biol_id","biol_id"); ("type","type"); ("value","value"); ("details","details"); 
    ("details","details"); ("id","id"); ("method_details","method_details"); ("oligomeric_details","oligomeric_details"); ("oligomeric_count","oligomeric_count"); ("matrix_flag","matrix_flag"); ("upload_file_name","upload_file_name"); 
    ("id","id"); ("asym_id_list","asym_id_list"); ("assembly_id","assembly_id"); ("oper_expression","oper_expression"); ("full_matrices","full_matrices"); ("symmetry_operation","symmetry_operation"); ("at_unit_matrix","at_unit_matrix"); ("chain_id_list","chain_id_list"); ("all_chains","all_chains"); ("helical_rotation","helical_rotation"); ("helical_rise","helical_rise"); 
    ("id","id"); ("type","type"); ("name","name"); ("symmetry_operation","symmetry_operation"); ("matrix[1][1]","matrix11"); ("matrix[1][2]","matrix12"); ("matrix[1][3]","matrix13"); ("matrix[2][1]","matrix21"); ("matrix[2][2]","matrix22"); ("matrix[2][3]","matrix23"); ("matrix[3][1]","matrix31"); ("matrix[3][2]","matrix32"); ("matrix[3][3]","matrix33"); ("vector[1]","vector1"); ("vector[2]","vector2"); ("vector[3]","vector3"); 
    ("entry_id","entry_id"); ("Schoenflies_symbol","Schoenflies_symbol"); ("circular_symmetry","circular_symmetry"); ("H-M_notation","H-M_notation"); ("status_flag","status_flag"); 
    ("entry_id","entry_id"); ("number_of_operations","number_of_operations"); ("rotation_per_n_subunits","rotation_per_n_subunits"); ("rise_per_n_subunits","rise_per_n_subunits"); ("n_subunits_divisor","n_subunits_divisor"); ("dyad_axis","dyad_axis"); ("circular_symmetry","circular_symmetry"); ("status_flag","status_flag"); 
    ("id","id"); ("assembly_id","assembly_id"); ("experimental_support","experimental_support"); ("details","details"); 
    ("id","id"); ("label_alt_id","label_alt_id"); ("label_asym_id","label_asym_id"); ("label_atom_id","label_atom_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("PDB_ins_code","PDB_ins_code"); ("pre_auth_asym_id","pre_auth_asym_id"); ("pre_auth_atom_id","pre_auth_atom_id"); ("pre_auth_comp_id","pre_auth_comp_id"); ("pre_auth_seq_id","pre_auth_seq_id"); ("pre_PDB_ins_code","pre_PDB_ins_code"); ("pre_auth_alt_id","pre_auth_alt_id"); ("auth_asym_id","auth_asym_id"); ("auth_atom_id","auth_atom_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_alt_id","auth_alt_id"); ("occupancy","occupancy"); ("Cartn_x","Cartn_x"); ("Cartn_y","Cartn_y"); ("Cartn_z","Cartn_z"); ("pre_Cartn_x","pre_Cartn_x"); ("pre_Cartn_y","pre_Cartn_y"); ("pre_Cartn_z","pre_Cartn_z"); ("symmetry","symmetry"); ("symmetry_as_xyz","symmetry_as_xyz"); 
    ("entity_id","entity_id"); ("class","class"); ("type","type"); ("name","name"); ("details","details"); 
    ("ordinal","ordinal"); ("label_alt_id","label_alt_id"); ("comp_id","comp_id"); ("PDB_ins_code","PDB_ins_code"); ("auth_asym_id","auth_asym_id"); ("auth_seq_id","auth_seq_id"); ("in_polymer_flag","in_polymer_flag"); ("author_provided_flag","author_provided_flag"); ("formula","formula"); 
    ("dep_dataset_id","dep_dataset_id"); ("primary_citation_status","primary_citation_status"); ("corresponding_author_status","corresponding_author_status"); ("reference_citation_status","reference_citation_status"); ("is_grant_funded","is_grant_funded"); ("has_ncs_data","has_ncs_data"); ("prediction_target","prediction_target"); ("has_helical_symmetry","has_helical_symmetry"); ("has_point_symmetry","has_point_symmetry"); ("has_cyclic_symmetry","has_cyclic_symmetry"); ("has_accepted_terms_and_conditions","has_accepted_terms_and_conditions"); ("has_viewed_validation_report","has_viewed_validation_report"); ("validated_model_file_name","validated_model_file_name"); ("merge_prior_model_file_name","merge_prior_model_file_name"); ("merge_replace_model_file_name","merge_replace_model_file_name"); ("merge_output_model_file_name","merge_output_model_file_name"); ("is_ligand_processing_complete","is_ligand_processing_complete"); ("sample_xyz_sequence_alignments_valid","sample_xyz_sequence_alignments_valid"); ("has_sas_data","has_sas_data"); ("is_sas_deposited","is_sas_deposited"); ("use_sas_refine","use_sas_refine"); 
    ("ordinal","ordinal"); ("file_content_type","file_content_type"); ("file_type","file_type"); ("file_name","file_name"); ("file_size","file_size"); ("valid_flag","valid_flag"); ("diagnostic_message","diagnostic_message"); ("sequence_align","sequence_align"); 
    ("dep_dataset_id","dep_dataset_id"); ("residual_B_factors_flag","residual_B_factors_flag"); ("occupancy_outliers_low","occupancy_outliers_low"); ("occupancy_outliers_high","occupancy_outliers_high"); ("adp_outliers_low","adp_outliers_low"); ("solvent_outliers","solvent_outliers"); 
    ("ordinal","ordinal"); ("comp_id","comp_id"); ("upload_file_type","upload_file_type"); ("upload_file_name","upload_file_name"); 
    ("dep_dataset_id","dep_dataset_id"); ("entity_id","entity_id"); ("has_mutation","has_mutation"); ("sample_xyz_sequence_alignments_valid","sample_xyz_sequence_alignments_valid"); 
    ("dep_dataset_id","dep_dataset_id"); ("entity_id","entity_id"); ("type","type"); 
    ("ordinal","ordinal"); ("deposition_data_set_id","deposition_data_set_id"); ("message_id","message_id"); ("timestamp","timestamp"); ("sender","sender"); ("content_type","content_type"); ("content_value","content_value"); ("parent_message_id","parent_message_id"); ("message_subject","message_subject"); ("message_text","message_text"); ("message_type","message_type"); ("send_status","send_status"); 
    ("ordinal","ordinal"); ("deposition_data_set_id","deposition_data_set_id"); ("message_id","message_id"); ("content_type","content_type"); ("content_format","content_format"); ("partition_number","partition_number"); ("version_id","version_id"); ("storage_type","storage_type"); 
    ("dep_dataset_id","dep_dataset_id"); ("wwpdb_site_id","wwpdb_site_id"); ("experimental_methods","experimental_methods"); ("requested_accession_types","requested_accession_types"); ("validated_contact_email","validated_contact_email"); ("country","country"); ("structural_genomics_flag","structural_genomics_flag"); ("related_database_name","related_database_name"); ("related_database_code","related_database_code"); ("replace_pdb_id","replace_pdb_id"); 
    ("task_name","task_name"); ("status","status"); 
    ("details","details"); ("feature_type","feature_type"); ("auth_asym_id","auth_asym_id"); ("asym_id","asym_id"); ("auth_seq_num","auth_seq_num"); ("seq_num","seq_num"); ("comp_id","comp_id"); ("auth_comp_id","auth_comp_id"); ("ordinal","ordinal"); 
    ("src_id","src_id"); ("entity_id","entity_id"); ("seq_type","seq_type"); ("beg_seq_num","beg_seq_num"); ("end_seq_num","end_seq_num"); ("gene_src_gene","gene_src_gene"); ("gene_src_scientific_name","gene_src_scientific_name"); ("host_org_gene","host_org_gene"); ("host_org_scientific_name","host_org_scientific_name"); ("host_org_strain","host_org_strain"); ("gene_src_ncbi_taxonomy_id","gene_src_ncbi_taxonomy_id"); ("host_org_ncbi_taxonomy_id","host_org_ncbi_taxonomy_id"); ("host_org_vector_type","host_org_vector_type"); ("plasmid_name","plasmid_name"); 
    ("id","id"); ("comp_id","comp_id"); 
    ("atom_id","atom_id"); ("ordinal_id","ordinal_id"); ("model_id","model_id"); ("charge","charge"); ("model_Cartn_x","model_Cartn_x"); ("model_Cartn_y","model_Cartn_y"); ("model_Cartn_z","model_Cartn_z"); ("type_symbol","type_symbol"); 
    ("atom_id_1","atom_id_1"); ("atom_id_2","atom_id_2"); ("model_id","model_id"); ("value_order","value_order"); ("ordinal_id","ordinal_id"); 
    ("model_id","model_id"); ("feature_name","feature_name"); ("feature_value","feature_value"); 
    ("model_id","model_id"); ("descriptor","descriptor"); ("type","type"); 
    ("model_id","model_id"); ("date","date"); ("annotator","annotator"); ("processing_site","processing_site"); ("details","details"); ("action_type","action_type"); 
    ("model_id","model_id"); ("db_name","db_name"); ("db_code","db_code"); 
    ("view_group_id","view_group_id"); ("description","description"); 
    ("view_group_id","view_group_id"); ("category_id","category_id"); ("category_view_name","category_view_name"); 
    ("item_name","item_name"); ("category_id","category_id"); ("item_view_name","item_view_name"); ("item_view_mandatory_code","item_view_mandatory_code"); ("item_view_allow_alternate_value","item_view_allow_alternate_value"); 
    ("entry_id","entry_id"); ("chain_atoms_Y_P","chain_atoms_Y_P"); ("hydrogen_atoms_Y_N","hydrogen_atoms_Y_N"); ("solvent_atoms_Y_N","solvent_atoms_Y_N"); ("structure_factors_Y_N","structure_factors_Y_N"); 
    ("res_name","res_name"); ("hetgroup_name","hetgroup_name"); ("formul","formul"); ("hetgroup_chemical_name","hetgroup_chemical_name"); ("parent_residue","parent_residue"); ("formal_charge","formal_charge"); ("class_1","class_1"); ("class_2","class_2"); ("type","type"); ("status","status"); ("date","date"); ("modified_date","modified_date"); 
    ("res_name","res_name"); ("ndbTokenType","ndbTokenType"); ("modified","modified"); 
    ("res_name","res_name"); ("modification","modification"); 
    ("res_name","res_name"); ("atom_name","atom_name"); ("connect_to","connect_to"); ("type_symbol","type_symbol"); ("charge","charge"); ("bond_type","bond_type"); ("align_pos","align_pos"); 
    ("entry_id","entry_id"); ("num_remark","num_remark"); ("num_ftnote","num_ftnote"); ("num_het","num_het"); ("num_helix","num_helix"); ("num_sheet","num_sheet"); ("num_turn","num_turn"); ("num_site","num_site"); ("num_trans","num_trans"); ("num_coord","num_coord"); ("num_ter","num_ter"); ("num_conect","num_conect"); ("num_seqres","num_seqres"); 
    ("entry_id","entry_id"); ("record_name","record_name"); 
    ("pdb_id_code","pdb_id_code"); ("chain_id","chain_id"); ("begin_res_number","begin_res_number"); ("begin_ins_code","begin_ins_code"); ("end_res_number","end_res_number"); ("end_ins_code","end_ins_code"); ("database_name","database_name"); ("database_accession","database_accession"); ("database_id_code","database_id_code"); ("database_begin_res_number","database_begin_res_number"); ("database_begin_ins_code","database_begin_ins_code"); ("database_end_res_number","database_end_res_number"); ("database_end_ins_code","database_end_ins_code"); 
    ("id","id"); ("name","name"); ("num_per_asym_unit","num_per_asym_unit"); ("num_of_whole_molecule","num_of_whole_molecule"); ("size_of_molecule_per_asym_unit","size_of_molecule_per_asym_unit"); 
    ("id","id"); ("name","name"); ("num_per_asym_unit","num_per_asym_unit"); 
    ("id","id"); ("name","name"); ("numb_per_asym_unit","numb_per_asym_unit"); 
    ("id","id"); ("sugar_name","sugar_name"); ("strand_id","strand_id"); ("residue_names","residue_names"); 
    ("id","id"); ("num_of_NA_strands_per_asym_unit","num_of_NA_strands_per_asym_unit"); ("num_of_NA_strands_per_biol_unit","num_of_NA_strands_per_biol_unit"); ("fract_NA_strand_per_asym_unit","fract_NA_strand_per_asym_unit"); 
    ("id","id"); ("auth_asym_id","auth_asym_id"); ("auth_seq_id","auth_seq_id"); ("label_asym_id","label_asym_id"); ("label_seq_num","label_seq_num"); ("label_seq_id","label_seq_id"); ("ins_code","ins_code"); ("number_atoms_nh","number_atoms_nh"); 
    ("id","id"); ("text","text"); 
    ("id","id"); ("text","text"); 
    ("id","id"); ("name","name"); ("num_per_asym_unit","num_per_asym_unit"); 
    ("id","id"); ("name","name"); ("numb_per_asym_unit","numb_per_asym_unit"); 
    ("src_method","src_method"); 
    ("id","id"); ("biol_id","biol_id"); ("function","function"); 
    ("id","id"); ("asym_id","asym_id"); ("symmetry","symmetry"); ("color_red","color_red"); ("color_green","color_green"); ("color_blue","color_blue"); ("crystal_type","crystal_type"); ("packing_type","packing_type"); 
    ("id","id"); ("name","name"); ("num_per_asym_unit","num_per_asym_unit"); 
    ("chain_id","chain_id"); ("residue_name","residue_name"); ("residue_number","residue_number"); 
    ("dom_id","dom_id"); ("type","type"); ("number","number"); ("rms_dev","rms_dev"); ("weight","weight"); 
    ("id","id"); ("oper_id","oper_id"); ("asym_id","asym_id"); ("pdb_chain_id","pdb_chain_id"); 
    ("pdb_chain_id","pdb_chain_id"); ("ncbi_taxid","ncbi_taxid"); 
    ("name","name"); ("synonym","synonym"); 
    ("entry_id","entry_id"); ("text","text"); ("seq_details","seq_details"); 
    ("entry_id","entry_id"); ("cycle_id","cycle_id"); ("date_begin","date_begin"); ("date_end","date_end"); ("details","details"); ("annotator","annotator"); 
    ("id","id"); ("type","type"); ("ptnr1_label_alt_id","ptnr1_label_alt_id"); ("ptnr1_label_asym_id","ptnr1_label_asym_id"); ("ptnr1_label_atom_id","ptnr1_label_atom_id"); ("ptnr1_label_comp_id","ptnr1_label_comp_id"); ("ptnr1_label_seq_id","ptnr1_label_seq_id"); ("ptnr1_label_ins_code","ptnr1_label_ins_code"); ("ptnr1_symmetry","ptnr1_symmetry"); ("ptnr2_label_alt_id","ptnr2_label_alt_id"); ("ptnr2_label_asym_id","ptnr2_label_asym_id"); ("ptnr2_label_atom_id","ptnr2_label_atom_id"); ("ptnr2_label_comp_id","ptnr2_label_comp_id"); ("ptnr2_label_seq_id","ptnr2_label_seq_id"); ("ptnr2_label_ins_code","ptnr2_label_ins_code"); ("ptnr2_symmetry","ptnr2_symmetry"); ("details","details"); ("pdbx_dist_value","pdbx_dist_value"); 
    ("pdb_model_id","pdb_model_id"); ("pdb_chain_id","pdb_chain_id"); ("pdb_residue_name","pdb_residue_name"); ("pdb_residue_number","pdb_residue_number"); ("pdb_insertion_code","pdb_insertion_code"); ("label_seq_id","label_seq_id"); 
    ("entry_id","entry_id"); ("a","a"); ("a_tolerance","a_tolerance"); ("b","b"); ("b_tolerance","b_tolerance"); ("c","c"); ("c_tolerance","c_tolerance"); ("alpha","alpha"); ("alpha_tolerance","alpha_tolerance"); ("beta","beta"); ("beta_tolerance","beta_tolerance"); ("gamma","gamma"); ("gamma_tolerance","gamma_tolerance"); ("volume","volume"); ("mosaicity","mosaicity"); ("resolution_range","resolution_range"); ("space_group","space_group"); 
    ("entry_id","entry_id"); ("number_all","number_all"); ("number_marked_reject","number_marked_reject"); ("percent_marked_reject","percent_marked_reject"); ("percent_rejected","percent_rejected"); ("R_factor_all_linear","R_factor_all_linear"); 
    ("entry_id","entry_id"); ("name","name"); ("wavelength","wavelength"); ("polarization","polarization"); ("beam_position_x","beam_position_x"); ("beam_position_y","beam_position_y"); ("cassette_rot_x","cassette_rot_x"); ("cassette_rot_y","cassette_rot_y"); ("cassette_rot_z","cassette_rot_z"); ("scale_y","scale_y"); ("skew","skew"); ("crossfire_x","crossfire_x"); ("crossfire_y","crossfire_y"); ("crossfire_xy","crossfire_xy"); ("date","date"); ("experimentor","experimentor"); ("crystal_data_id","crystal_data_id"); ("processing_path","processing_path"); ("processing_files","processing_files"); 
    ("comp_id","comp_id"); ("type","type"); 
    ("entity_id","entity_id"); ("class","class"); 
    ("id","id"); ("parent_id","parent_id"); 
    ("id","id"); ("name","name"); ("name_type","name_type"); 
    ("name","name"); ("pdb_id","pdb_id"); ("rcsb_id","rcsb_id"); ("entity_id","entity_id"); ("pdb_chain_id","pdb_chain_id"); ("pdb_mol_id","pdb_mol_id"); 
    ("tablename","tablename"); ("description","description"); ("type","type"); ("table_serial_no","table_serial_no"); ("group_name","group_name"); ("WWW_Selection_Criteria","WWW_Selection_Criteria"); ("WWW_Report_Criteria","WWW_Report_Criteria"); 
    ("columnname","columnname"); ("tablename","tablename"); ("description","description"); ("example","example"); ("type","type"); ("table_serial_no","table_serial_no"); ("column_serial_no","column_serial_no"); ("WWW_Selection_Criteria","WWW_Selection_Criteria"); ("WWW_Report_Criteria","WWW_Report_Criteria"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id_1","auth_asym_id_1"); ("auth_atom_id_1","auth_atom_id_1"); ("auth_comp_id_1","auth_comp_id_1"); ("auth_seq_id_1","auth_seq_id_1"); ("auth_atom_id_2","auth_atom_id_2"); ("auth_asym_id_2","auth_asym_id_2"); ("auth_comp_id_2","auth_comp_id_2"); ("auth_seq_id_2","auth_seq_id_2"); ("auth_atom_id_3","auth_atom_id_3"); ("auth_asym_id_3","auth_asym_id_3"); ("auth_comp_id_3","auth_comp_id_3"); ("auth_seq_id_3","auth_seq_id_3"); ("auth_PDB_insert_id_1","auth_PDB_insert_id_1"); ("auth_PDB_insert_id_2","auth_PDB_insert_id_2"); ("auth_PDB_insert_id_3","auth_PDB_insert_id_3"); ("label_alt_id_1","label_alt_id_1"); ("label_asym_id_1","label_asym_id_1"); ("label_atom_id_1","label_atom_id_1"); ("label_comp_id_1","label_comp_id_1"); ("label_seq_id_1","label_seq_id_1"); ("label_alt_id_2","label_alt_id_2"); ("label_asym_id_2","label_asym_id_2"); ("label_atom_id_2","label_atom_id_2"); ("label_comp_id_2","label_comp_id_2"); ("label_seq_id_2","label_seq_id_2"); ("label_alt_id_3","label_alt_id_3"); ("label_asym_id_3","label_asym_id_3"); ("label_atom_id_3","label_atom_id_3"); ("label_comp_id_3","label_comp_id_3"); ("label_seq_id_3","label_seq_id_3"); ("angle","angle"); ("angle_deviation","angle_deviation"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id_1","auth_asym_id_1"); ("auth_atom_id_1","auth_atom_id_1"); ("auth_comp_id_1","auth_comp_id_1"); ("auth_seq_id_1","auth_seq_id_1"); ("auth_atom_id_2","auth_atom_id_2"); ("auth_asym_id_2","auth_asym_id_2"); ("auth_comp_id_2","auth_comp_id_2"); ("auth_seq_id_2","auth_seq_id_2"); ("auth_PDB_insert_id_1","auth_PDB_insert_id_1"); ("auth_PDB_insert_id_2","auth_PDB_insert_id_2"); ("label_alt_id_1","label_alt_id_1"); ("label_asym_id_1","label_asym_id_1"); ("label_atom_id_1","label_atom_id_1"); ("label_comp_id_1","label_comp_id_1"); ("label_seq_id_1","label_seq_id_1"); ("label_alt_id_2","label_alt_id_2"); ("label_asym_id_2","label_asym_id_2"); ("label_atom_id_2","label_atom_id_2"); ("label_comp_id_2","label_comp_id_2"); ("label_seq_id_2","label_seq_id_2"); ("bond","bond"); ("bond_deviation","bond_deviation"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id_1","auth_asym_id_1"); ("auth_atom_id_1","auth_atom_id_1"); ("auth_comp_id_1","auth_comp_id_1"); ("auth_seq_id_1","auth_seq_id_1"); ("auth_atom_id_2","auth_atom_id_2"); ("auth_asym_id_2","auth_asym_id_2"); ("auth_comp_id_2","auth_comp_id_2"); ("auth_seq_id_2","auth_seq_id_2"); ("auth_PDB_insert_id_1","auth_PDB_insert_id_1"); ("auth_PDB_insert_id_2","auth_PDB_insert_id_2"); ("label_alt_id_1","label_alt_id_1"); ("label_asym_id_1","label_asym_id_1"); ("label_atom_id_1","label_atom_id_1"); ("label_comp_id_1","label_comp_id_1"); ("label_seq_id_1","label_seq_id_1"); ("label_alt_id_2","label_alt_id_2"); ("label_asym_id_2","label_asym_id_2"); ("label_atom_id_2","label_atom_id_2"); ("label_comp_id_2","label_comp_id_2"); ("label_seq_id_2","label_seq_id_2"); ("dist","dist"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id_1","auth_asym_id_1"); ("auth_atom_id_1","auth_atom_id_1"); ("auth_comp_id_1","auth_comp_id_1"); ("auth_seq_id_1","auth_seq_id_1"); ("auth_atom_id_2","auth_atom_id_2"); ("auth_asym_id_2","auth_asym_id_2"); ("auth_comp_id_2","auth_comp_id_2"); ("auth_seq_id_2","auth_seq_id_2"); ("auth_PDB_insert_id_1","auth_PDB_insert_id_1"); ("auth_PDB_insert_id_2","auth_PDB_insert_id_2"); ("label_alt_id_1","label_alt_id_1"); ("label_asym_id_1","label_asym_id_1"); ("label_atom_id_1","label_atom_id_1"); ("label_comp_id_1","label_comp_id_1"); ("label_seq_id_1","label_seq_id_1"); ("label_alt_id_2","label_alt_id_2"); ("label_asym_id_2","label_asym_id_2"); ("label_atom_id_2","label_atom_id_2"); ("label_comp_id_2","label_comp_id_2"); ("label_seq_id_2","label_seq_id_2"); ("site_symmetry_1","site_symmetry_1"); ("site_symmetry_2","site_symmetry_2"); ("dist","dist"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_PDB_insert_id","auth_PDB_insert_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("phi","phi"); ("psi","psi"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_PDB_insert_id","auth_PDB_insert_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("atom_name","atom_name"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_PDB_insert_id","auth_PDB_insert_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("atom_name","atom_name"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("auth_PDB_insert_id","auth_PDB_insert_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("label_seq_id","label_seq_id"); ("chiral_center_atom_name","chiral_center_atom_name"); ("chiral_neighbor_atom_name","chiral_neighbor_atom_name"); ("chiral_center_atom_alt_id","chiral_center_atom_alt_id"); ("chiral_neighbor_atom_alt_id","chiral_neighbor_atom_alt_id"); 
    ("entry_id","entry_id"); ("page_id","page_id"); ("page_name","page_name"); 
    ("entry_id","entry_id"); ("flag_id","flag_id"); ("flag_value","flag_value"); 
    ("id","id"); ("domain_id","domain_id"); ("entity_id","entity_id"); ("protein_binds_to","protein_binds_to"); ("type","type"); 
    ("bind_mode_id","bind_mode_id"); ("type","type"); 
    ("bind_mode_id","bind_mode_id"); ("type","type"); 
    ("bind_mode_id","bind_mode_id"); ("type","type"); 
    ("bind_mode_id","bind_mode_id"); ("type","type"); 
    ("id","id"); ("entity_id","entity_id"); ("begin_mon_id","begin_mon_id"); ("begin_seq_num","begin_seq_num"); ("end_mon_id","end_mon_id"); ("end_seq_num","end_seq_num"); 
    ("entry_id","entry_id"); ("conformation_type","conformation_type"); ("strand_description","strand_description"); ("special_feature","special_feature"); 
    ("entity_id","entity_id"); ("type","type"); 
    ("entity_id","entity_id"); ("feature","feature"); 
    ("model_id","model_id"); ("atom_site_id_1","atom_site_id_1"); ("atom_site_label_alt_id_1","atom_site_label_alt_id_1"); ("atom_site_label_atom_id_1","atom_site_label_atom_id_1"); ("atom_site_label_comp_id_1","atom_site_label_comp_id_1"); ("atom_site_label_seq_id_1","atom_site_label_seq_id_1"); ("atom_site_label_asym_id_1","atom_site_label_asym_id_1"); ("atom_site_id_2","atom_site_id_2"); ("atom_site_label_alt_id_2","atom_site_label_alt_id_2"); ("atom_site_label_atom_id_2","atom_site_label_atom_id_2"); ("atom_site_label_comp_id_2","atom_site_label_comp_id_2"); ("atom_site_label_seq_id_2","atom_site_label_seq_id_2"); ("atom_site_label_asym_id_2","atom_site_label_asym_id_2"); ("atom_site_id_3","atom_site_id_3"); ("atom_site_label_alt_id_3","atom_site_label_alt_id_3"); ("atom_site_label_atom_id_3","atom_site_label_atom_id_3"); ("atom_site_label_comp_id_3","atom_site_label_comp_id_3"); ("atom_site_label_seq_id_3","atom_site_label_seq_id_3"); ("atom_site_label_asym_id_3","atom_site_label_asym_id_3"); ("atom_site_auth_asym_id_1","atom_site_auth_asym_id_1"); ("atom_site_auth_atom_id_1","atom_site_auth_atom_id_1"); ("atom_site_auth_comp_id_1","atom_site_auth_comp_id_1"); ("atom_site_auth_seq_id_1","atom_site_auth_seq_id_1"); ("atom_site_auth_atom_id_2","atom_site_auth_atom_id_2"); ("atom_site_auth_asym_id_2","atom_site_auth_asym_id_2"); ("atom_site_auth_comp_id_2","atom_site_auth_comp_id_2"); ("atom_site_auth_seq_id_2","atom_site_auth_seq_id_2"); ("atom_site_auth_atom_id_3","atom_site_auth_atom_id_3"); ("atom_site_auth_asym_id_3","atom_site_auth_asym_id_3"); ("atom_site_auth_comp_id_3","atom_site_auth_comp_id_3"); ("atom_site_auth_seq_id_3","atom_site_auth_seq_id_3"); ("site_symmetry_1","site_symmetry_1"); ("site_symmetry_2","site_symmetry_2"); ("site_symmetry_3","site_symmetry_3"); ("value","value"); ("value_esd","value_esd"); 
    ("model_id","model_id"); ("atom_site_id_1","atom_site_id_1"); ("atom_site_label_alt_id_1","atom_site_label_alt_id_1"); ("atom_site_label_atom_id_1","atom_site_label_atom_id_1"); ("atom_site_label_comp_id_1","atom_site_label_comp_id_1"); ("atom_site_label_seq_id_1","atom_site_label_seq_id_1"); ("atom_site_label_asym_id_1","atom_site_label_asym_id_1"); ("atom_site_id_2","atom_site_id_2"); ("atom_site_label_alt_id_2","atom_site_label_alt_id_2"); ("atom_site_label_atom_id_2","atom_site_label_atom_id_2"); ("atom_site_label_comp_id_2","atom_site_label_comp_id_2"); ("atom_site_label_seq_id_2","atom_site_label_seq_id_2"); ("atom_site_label_asym_id_2","atom_site_label_asym_id_2"); ("atom_site_auth_atom_id_1","atom_site_auth_atom_id_1"); ("atom_site_auth_asym_id_1","atom_site_auth_asym_id_1"); ("atom_site_auth_comp_id_1","atom_site_auth_comp_id_1"); ("atom_site_auth_seq_id_1","atom_site_auth_seq_id_1"); ("atom_site_auth_atom_id_2","atom_site_auth_atom_id_2"); ("atom_site_auth_asym_id_2","atom_site_auth_asym_id_2"); ("atom_site_auth_comp_id_2","atom_site_auth_comp_id_2"); ("atom_site_auth_seq_id_2","atom_site_auth_seq_id_2"); ("dist","dist"); ("dist_esd","dist_esd"); ("site_symmetry_1","site_symmetry_1"); ("site_symmetry_2","site_symmetry_2"); 
    ("model_id","model_id"); ("atom_site_id_1","atom_site_id_1"); ("atom_site_label_alt_id_1","atom_site_label_alt_id_1"); ("atom_site_label_atom_id_1","atom_site_label_atom_id_1"); ("atom_site_label_comp_id_1","atom_site_label_comp_id_1"); ("atom_site_label_seq_id_1","atom_site_label_seq_id_1"); ("atom_site_label_asym_id_1","atom_site_label_asym_id_1"); ("atom_site_id_2","atom_site_id_2"); ("atom_site_label_alt_id_2","atom_site_label_alt_id_2"); ("atom_site_label_atom_id_2","atom_site_label_atom_id_2"); ("atom_site_label_comp_id_2","atom_site_label_comp_id_2"); ("atom_site_label_seq_id_2","atom_site_label_seq_id_2"); ("atom_site_label_asym_id_2","atom_site_label_asym_id_2"); ("atom_site_id_3","atom_site_id_3"); ("atom_site_label_alt_id_3","atom_site_label_alt_id_3"); ("atom_site_label_atom_id_3","atom_site_label_atom_id_3"); ("atom_site_label_comp_id_3","atom_site_label_comp_id_3"); ("atom_site_label_seq_id_3","atom_site_label_seq_id_3"); ("atom_site_label_asym_id_3","atom_site_label_asym_id_3"); ("atom_site_id_4","atom_site_id_4"); ("atom_site_label_alt_id_4","atom_site_label_alt_id_4"); ("atom_site_label_atom_id_4","atom_site_label_atom_id_4"); ("atom_site_label_comp_id_4","atom_site_label_comp_id_4"); ("atom_site_label_seq_id_4","atom_site_label_seq_id_4"); ("atom_site_label_asym_id_4","atom_site_label_asym_id_4"); ("atom_site_auth_atom_id_1","atom_site_auth_atom_id_1"); ("atom_site_auth_asym_id_1","atom_site_auth_asym_id_1"); ("atom_site_auth_comp_id_1","atom_site_auth_comp_id_1"); ("atom_site_auth_seq_id_1","atom_site_auth_seq_id_1"); ("atom_site_auth_atom_id_2","atom_site_auth_atom_id_2"); ("atom_site_auth_asym_id_2","atom_site_auth_asym_id_2"); ("atom_site_auth_comp_id_2","atom_site_auth_comp_id_2"); ("atom_site_auth_seq_id_2","atom_site_auth_seq_id_2"); ("atom_site_auth_atom_id_3","atom_site_auth_atom_id_3"); ("atom_site_auth_asym_id_3","atom_site_auth_asym_id_3"); ("atom_site_auth_comp_id_3","atom_site_auth_comp_id_3"); ("atom_site_auth_seq_id_3","atom_site_auth_seq_id_3"); ("atom_site_auth_atom_id_4","atom_site_auth_atom_id_4"); ("atom_site_auth_asym_id_4","atom_site_auth_asym_id_4"); ("atom_site_auth_comp_id_4","atom_site_auth_comp_id_4"); ("atom_site_auth_seq_id_4","atom_site_auth_seq_id_4"); ("site_symmetry_1","site_symmetry_1"); ("site_symmetry_2","site_symmetry_2"); ("site_symmetry_3","site_symmetry_3"); ("site_symmetry_4","site_symmetry_4"); ("value","value"); ("value_esd","value_esd"); 
    ("label_asym_id","label_asym_id"); ("auth_asym_id","auth_asym_id"); ("pattern_count","pattern_count"); ("sequence_pattern","sequence_pattern"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id","auth_asym_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_seq_id","label_seq_id"); ("label_atom_id","label_atom_id"); ("label_alt_id","label_alt_id"); ("label_atom_id_u","label_atom_id_u"); ("label_alt_id_u","label_alt_id_u"); ("label_atom_id_v","label_atom_id_v"); ("label_alt_id_v","label_alt_id_v"); ("label_atom_id_w","label_atom_id_w"); ("label_alt_id_w","label_alt_id_w"); ("volume3","volume3"); ("angle_out_of_plane","angle_out_of_plane"); 
    ("entry_id","entry_id"); ("rms_bonds","rms_bonds"); ("num_bonds","num_bonds"); ("rms_bonds_base","rms_bonds_base"); ("num_bonds_base","num_bonds_base"); ("rms_bonds_sugar","rms_bonds_sugar"); ("num_bonds_sugar","num_bonds_sugar"); ("rms_bonds_phosphate","rms_bonds_phosphate"); ("num_bonds_phosphate","num_bonds_phosphate"); ("rms_angles","rms_angles"); ("num_angles","num_angles"); ("rms_angles_base","rms_angles_base"); ("num_angles_base","num_angles_base"); ("rms_angles_sugar","rms_angles_sugar"); ("num_angles_sugar","num_angles_sugar"); ("rms_angles_phosphate","rms_angles_phosphate"); ("num_angles_phosphate","num_angles_phosphate"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id","auth_asym_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_seq_id","label_seq_id"); ("rms_bonds","rms_bonds"); ("num_bonds","num_bonds"); ("rms_angles","rms_angles"); ("num_angles","num_angles"); 
    ("id","id"); ("model_id","model_id"); ("auth_asym_id","auth_asym_id"); ("label_asym_id","label_asym_id"); ("label_comp_id","label_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_seq_id","label_seq_id"); ("neighbor_comp_id_5prime","neighbor_comp_id_5prime"); ("neighbor_comp_id_3prime","neighbor_comp_id_3prime"); ("o3_p_o5_c5","o3_p_o5_c5"); ("p_o5_c5_c4","p_o5_c5_c4"); ("o5_c5_c4_c3","o5_c5_c4_c3"); ("c5_c4_c3_o3","c5_c4_c3_o3"); ("c4_c3_o3_p","c4_c3_o3_p"); ("c3_o3_p_o5","c3_o3_p_o5"); ("c4_o4_c1_n1_9","c4_o4_c1_n1_9"); ("o4_c1_n1_9_c2_4","o4_c1_n1_9_c2_4"); ("o4_c1_n1_9_c6_8","o4_c1_n1_9_c6_8"); ("c4_o4_c1_c2","c4_o4_c1_c2"); ("o4_c1_c2_c3","o4_c1_c2_c3"); ("c1_c2_c3_c4","c1_c2_c3_c4"); ("c2_c3_c4_o4","c2_c3_c4_o4"); ("c3_c4_o4_c1","c3_c4_o4_c1"); ("c5_c4_c3_c2","c5_c4_c3_c2"); ("o4_c4_c3_o3","o4_c4_c3_o3"); ("o3_c3_c2_o2","o3_c3_c2_o2"); ("o5_c5_c4_o4","o5_c5_c4_o4"); ("pseudorot","pseudorot"); ("maxtorsion","maxtorsion"); ("next_label_comp_id","next_label_comp_id"); ("next_label_seq_id","next_label_seq_id"); ("next_o3_p_o5_c5","next_o3_p_o5_c5"); ("next_p_o5_c5_c4","next_p_o5_c5_c4"); ("next_o5_c5_c4_c3","next_o5_c5_c4_c3"); ("next_c5_c4_c3_o3","next_c5_c4_c3_o3"); ("next_c4_c3_o3_p","next_c4_c3_o3_p"); ("next_c3_o3_p_o5","next_c3_o3_p_o5"); ("next_c4_o4_c1_n1_9","next_c4_o4_c1_n1_9"); ("next_o4_c1_n1_9_c2_4","next_o4_c1_n1_9_c2_4"); ("c1_c2","c1_c2"); ("c2_c3","c2_c3"); ("c3_c4","c3_c4"); ("c4_o4","c4_o4"); ("o4_c1","o4_c1"); ("p_o5","p_o5"); ("o5_c5","o5_c5"); ("c5_c4","c5_c4"); ("c3_o3","c3_o3"); ("o3_p","o3_p"); ("p_o1p","p_o1p"); ("p_o2p","p_o2p"); ("c1_n9_1","c1_n9_1"); ("n1_c2","n1_c2"); ("n1_c6","n1_c6"); ("n9_c4","n9_c4"); ("n9_c8","n9_c8"); ("c1_c2_c3","c1_c2_c3"); ("c2_c3_c4","c2_c3_c4"); ("c3_c4_o4","c3_c4_o4"); ("c4_o4_c1","c4_o4_c1"); ("o4_c1_c2","o4_c1_c2"); ("p_o5_c5","p_o5_c5"); ("o5_c5_c4","o5_c5_c4"); ("c5_c4_c3","c5_c4_c3"); ("c4_c3_o3","c4_c3_o3"); ("c3_o3_p","c3_o3_p"); ("o3_p_o5","o3_p_o5"); ("o4_c1_n1_9","o4_c1_n1_9"); ("c1_n1_9_c2_4","c1_n1_9_c2_4"); ("c5_c4_o4","c5_c4_o4"); ("c2_c3_o3","c2_c3_o3"); ("o1p_p_o2p","o1p_p_o2p"); ("c2_c1_n1_9","c2_c1_n1_9"); ("c1_n1_9_c6_8","c1_n1_9_c6_8"); 
    ("entry_id","entry_id"); ("collection","collection"); ("collection_version","collection_version"); ("processing","processing"); ("processing_version","processing_version"); ("data_analysis","data_analysis"); ("data_analysis_version","data_analysis_version"); ("structure_solution","structure_solution"); ("structure_solution_version","structure_solution_version"); ("refinement","refinement"); ("refinement_version","refinement_version"); ("iterative_relaxation_matrix","iterative_relaxation_matrix"); ("iterative_relaxation_matrix_version","iterative_relaxation_matrix_version"); 
    ("extension_dict_location","extension_dict_location"); ("extension_dict_name","extension_dict_name"); ("extension_dict_version","extension_dict_version"); 
    ("pdbid","pdbid"); ("details","details"); 
    ("id","id"); ("model_id","model_id"); ("pdb_id","pdb_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_alt_id","label_alt_id"); ("label_ins_code","label_ins_code"); ("correlation","correlation"); ("real_space_R","real_space_R"); ("weighted_real_space_R","weighted_real_space_R"); ("real_space_Zscore","real_space_Zscore"); ("Biso_mean","Biso_mean"); ("occupancy_mean","occupancy_mean"); ("flag","flag"); 
    ("pdbid","pdbid"); ("correlation","correlation"); ("correlation_sigma","correlation_sigma"); ("real_space_R","real_space_R"); ("real_space_R_sigma","real_space_R_sigma"); 
    ("DCC_version","DCC_version"); ("pdbid","pdbid"); ("pdbtype","pdbtype"); ("unit_cell","unit_cell"); ("space_group_name_H-M","space_group_name_H-M"); ("space_group_pointless","space_group_pointless"); ("ls_d_res_high","ls_d_res_high"); ("ls_d_res_high_sf","ls_d_res_high_sf"); ("ls_d_res_low_sf","ls_d_res_low_sf"); ("R_value_R_work","R_value_R_work"); ("R_value_R_free","R_value_R_free"); ("working_set_count","working_set_count"); ("free_set_count","free_set_count"); ("occupancy_min","occupancy_min"); ("occupancy_max","occupancy_max"); ("occupancy_mean","occupancy_mean"); ("Biso_min","Biso_min"); ("Biso_max","Biso_max"); ("Biso_mean","Biso_mean"); ("B_wilson","B_wilson"); ("B_wilson_scale","B_wilson_scale"); ("mean_I2_over_mean_I_square","mean_I2_over_mean_I_square"); ("mean_F_square_over_mean_F2","mean_F_square_over_mean_F2"); ("mean_E2_1_abs","mean_E2_1_abs"); ("Padilla-Yeates_L_mean","Padilla-Yeates_L_mean"); ("Padilla-Yeates_L2_mean","Padilla-Yeates_L2_mean"); ("Padilla-Yeates_L2_mean_pointless","Padilla-Yeates_L2_mean_pointless"); ("Z_score_L_test","Z_score_L_test"); ("twin_type","twin_type"); ("twin_operator_xtriage","twin_operator_xtriage"); ("twin_fraction_xtriage","twin_fraction_xtriage"); ("twin_Rfactor","twin_Rfactor"); ("I_over_sigI_resh","I_over_sigI_resh"); ("I_over_sigI_diff","I_over_sigI_diff"); ("I_over_sigI_mean","I_over_sigI_mean"); ("ice_ring","ice_ring"); ("anisotropy","anisotropy"); ("Z-score","Z-score"); ("prob_peak_value","prob_peak_value"); ("translational_pseudo_symmetry","translational_pseudo_symmetry"); ("wavelength","wavelength"); ("B_solvent","B_solvent"); ("K_solvent","K_solvent"); ("TLS_refinement_reported","TLS_refinement_reported"); ("partial_B_value_correction_attempted","partial_B_value_correction_attempted"); ("partial_B_value_correction_success","partial_B_value_correction_success"); ("reflection_status_archived","reflection_status_archived"); ("reflection_status_used","reflection_status_used"); ("iso_B_value_type","iso_B_value_type"); ("reflns_twin","reflns_twin"); ("twin_by_xtriage","twin_by_xtriage"); ("twin_operator","twin_operator"); ("twin_fraction","twin_fraction"); ("tls_group_number","tls_group_number"); ("ncs_group_number","ncs_group_number"); ("mtrix_number","mtrix_number"); ("Matthew_coeff","Matthew_coeff"); ("solvent_content","solvent_content"); ("Cruickshank_dpi_xyz","Cruickshank_dpi_xyz"); ("dpi_free_R","dpi_free_R"); ("fom","fom"); ("correlation_overall","correlation_overall"); ("real_space_R_overall","real_space_R_overall"); ("mFo-DFc-3sigma_positive","mFo-DFc-3sigma_positive"); ("mFo-DFc-6sigma_positive","mFo-DFc-6sigma_positive"); ("mFo-DFc-3sigma_negative","mFo-DFc-3sigma_negative"); ("mFo-DFc-6sigma_negative","mFo-DFc-6sigma_negative"); ("Bmean-Bwilson","Bmean-Bwilson"); ("Rfree-Rwork","Rfree-Rwork"); ("error","error"); 
    ("pdbid","pdbid"); ("Ramachandran_outlier_percent","Ramachandran_outlier_percent"); ("Ramachandran_outlier_number","Ramachandran_outlier_number"); ("Ramachandran_allowed_percent","Ramachandran_allowed_percent"); ("Ramachandran_allowed_number","Ramachandran_allowed_number"); ("Ramachandran_favored_percent","Ramachandran_favored_percent"); ("Ramachandran_favored_number","Ramachandran_favored_number"); ("rotamer_outliers_percent","rotamer_outliers_percent"); ("rotamer_outliers_number","rotamer_outliers_number"); ("cbeta_deviations","cbeta_deviations"); ("all_atom_clashscore","all_atom_clashscore"); ("overall_score","overall_score"); ("bond_overall_rms","bond_overall_rms"); ("bond_overall_max","bond_overall_max"); ("bond_ligand_rms","bond_ligand_rms"); ("bond_ligand_max","bond_ligand_max"); ("angle_overall_rms","angle_overall_rms"); ("angle_overall_max","angle_overall_max"); ("angle_ligand_rms","angle_ligand_rms"); ("angle_ligand_max","angle_ligand_max"); ("dihedral_overall_rms","dihedral_overall_rms"); ("dihedral_overall_max","dihedral_overall_max"); ("chirality_overall_rms","chirality_overall_rms"); ("chirality_overall_max","chirality_overall_max"); ("planarity_overall_rms","planarity_overall_rms"); ("planarity_overall_max","planarity_overall_max"); ("non-bonded_rms","non-bonded_rms"); 
    ("ordinal","ordinal"); ("program","program"); ("ls_d_res_high","ls_d_res_high"); ("ls_d_res_low","ls_d_res_low"); ("ls_R_factor_R_all","ls_R_factor_R_all"); ("ls_R_factor_R_work","ls_R_factor_R_work"); ("ls_R_factor_R_free","ls_R_factor_R_free"); ("ls_number_reflns_obs","ls_number_reflns_obs"); ("ls_percent_reflns_obs","ls_percent_reflns_obs"); ("ls_number_reflns_R_free","ls_number_reflns_R_free"); ("correlation_coeff_Fo_to_Fc","correlation_coeff_Fo_to_Fc"); ("real_space_R","real_space_R"); ("correlation","correlation"); ("details","details"); 
    ("id","id"); ("model_id","model_id"); ("pdb_id","pdb_id"); ("auth_asym_id","auth_asym_id"); ("auth_comp_id","auth_comp_id"); ("auth_seq_id","auth_seq_id"); ("label_alt_id","label_alt_id"); ("label_ins_code","label_ins_code"); ("RSCC","RSCC"); ("RSR","RSR"); ("weighted_RSR","weighted_RSR"); ("RSRZ","RSRZ"); ("weighted_RSRZ","weighted_RSRZ"); ("Biso_mean","Biso_mean"); ("occupancy_mean","occupancy_mean"); ("RSCC_main_chain","RSCC_main_chain"); ("RSR_main_chain","RSR_main_chain"); ("wRSR_main_chain","wRSR_main_chain"); ("RSRZ_main_chain","RSRZ_main_chain"); ("wRSRZ_main_chain","wRSRZ_main_chain"); ("Biso_mean_main_chain","Biso_mean_main_chain"); ("occupancy_mean_main_chain","occupancy_mean_main_chain"); ("RSCC_side_chain","RSCC_side_chain"); ("RSR_side_chain","RSR_side_chain"); ("wRSR_side_chain","wRSR_side_chain"); ("RSRZ_side_chain","RSRZ_side_chain"); ("wRSRZ_side_chain","wRSRZ_side_chain"); ("Biso_mean_side_chain","Biso_mean_side_chain"); ("occupancy_mean_side_chain","occupancy_mean_side_chain"); ("RSCC_phosphate_group","RSCC_phosphate_group"); ("RSR_phosphate_group","RSR_phosphate_group"); ("wRSR_phosphate_group","wRSR_phosphate_group"); ("RSRZ_phosphate_group","RSRZ_phosphate_group"); ("wRSRZ_phosphate_group","wRSRZ_phosphate_group"); ("Biso_mean_phosphate_group","Biso_mean_phosphate_group"); ("occupancy_mean_phosphate_group","occupancy_mean_phosphate_group"); ("shift","shift"); ("shift_main_chain","shift_main_chain"); ("shift_side_chain","shift_side_chain"); ("density_connectivity","density_connectivity"); ("density_index_main_chain","density_index_main_chain"); ("density_index_side_chain","density_index_side_chain"); ("RSZD","RSZD"); ("RSZO","RSZO"); ("RSZO_Zscore","RSZO_Zscore"); ("LLDF","LLDF"); ("RSZD_main_chain","RSZD_main_chain"); ("RSZO_main_chain","RSZO_main_chain"); ("RSZD_side_chain","RSZD_side_chain"); ("RSZO_side_chain","RSZO_side_chain"); ("RSZD_phosphate_group","RSZD_phosphate_group"); ("RSZO_phosphate_group","RSZO_phosphate_group"); ("quality_indicator","quality_indicator"); 
    ("group_id","group_id"); ("group_title","group_title"); ("group_description","group_description"); ("group_type","group_type"); 
    ("group_id","group_id"); ("ordinal_id","ordinal_id"); ("dep_set_id","dep_set_id"); ("pdb_id_code","pdb_id_code"); ("group_file_name","group_file_name"); ("group_file_timestamp","group_file_timestamp"); ("auth_file_label","auth_file_label"); ("auth_file_content_type","auth_file_content_type"); ("auth_file_format_type","auth_file_format_type"); ("auth_file_name","auth_file_name"); ("auth_file_size","auth_file_size"); 
    ("id","id"); ("assembly_id","assembly_id"); ("experimental_support","experimental_support"); ("details","details"); 
    ("assembly_id","assembly_id"); ("reason_for_interest","reason_for_interest"); 
    ("crystal_id","crystal_id"); ("oscillation_range","oscillation_range"); ("oscillation_start","oscillation_start"); ("oscillation_end","oscillation_end"); ("xbeam","xbeam"); ("xbeam_esd","xbeam_esd"); ("ybeam","ybeam"); ("ybeam_esd","ybeam_esd"); ("crysx_spindle","crysx_spindle"); ("crysx_spindle_esd","crysx_spindle_esd"); ("crysy_vertical","crysy_vertical"); ("crysy_vertical_esd","crysy_vertical_esd"); ("crysz_beam","crysz_beam"); ("crysz_beam_esd","crysz_beam_esd"); ("crystal_to_detector_distance","crystal_to_detector_distance"); ("crystal_to_detector_distance_esd","crystal_to_detector_distance_esd"); ("crossfire_x","crossfire_x"); ("crossfire_x_esd","crossfire_x_esd"); ("crossfire_y","crossfire_y"); ("crossfire_y_esd","crossfire_y_esd"); ("crossfire_xy","crossfire_xy"); ("crossfire_xy_esd","crossfire_xy_esd"); 
    ("ordinal","ordinal"); ("data_content_type","data_content_type"); ("major_revision","major_revision"); ("minor_revision","minor_revision"); ("revision_date","revision_date"); ("internal_version","internal_version"); ("internal_deposition_id","internal_deposition_id"); 
    ("ordinal","ordinal"); ("revision_ordinal","revision_ordinal"); ("data_content_type","data_content_type"); ("group","group"); 
    ("ordinal","ordinal"); ("revision_ordinal","revision_ordinal"); ("data_content_type","data_content_type"); ("category","category"); 
    ("ordinal","ordinal"); ("revision_ordinal","revision_ordinal"); ("data_content_type","data_content_type"); ("provider","provider"); ("type","type"); ("description","description"); 
    ("ordinal","ordinal"); ("revision_ordinal","revision_ordinal"); ("data_content_type","data_content_type"); ("item","item"); 
    ("ordinal","ordinal"); ("data_content_type","data_content_type"); ("data_version_major","data_version_major"); ("data_version_minor","data_version_minor"); ("details","details"); 
    ];
    let ht2 = Hashtbl.create (Hashtbl.length ht) in
    Hashtbl.iter (fun k v -> Hashtbl.add ht2 v k) ht;
    (fun s -> Hashtbl.find ht s),(fun s -> Hashtbl.find ht2 s)

end

module JV_command = struct
  type t = {
    name: string option;
    command: string option;
    document: string option;
  }

  let default = {
    name = None;
    command = None;
    document = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "name" -> { b with name = (Some v) }
      | "command" -> { b with command = (Some v) }
      | "document" -> { b with document = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("command",  v)) a.command;
      Option.map (fun v -> ("document",  v)) a.document;
    ]

end

module Atom_site = struct
  type t = {
    aniso_B11: float option;
    aniso_B11_esd: float option;
    aniso_B12: float option;
    aniso_B12_esd: float option;
    aniso_B13: float option;
    aniso_B13_esd: float option;
    aniso_B22: float option;
    aniso_B22_esd: float option;
    aniso_B23: float option;
    aniso_B23_esd: float option;
    aniso_B33: float option;
    aniso_B33_esd: float option;
    aniso_ratio: float option;
    aniso_U11: float option;
    aniso_U11_esd: float option;
    aniso_U12: float option;
    aniso_U12_esd: float option;
    aniso_U13: float option;
    aniso_U13_esd: float option;
    aniso_U22: float option;
    aniso_U22_esd: float option;
    aniso_U23: float option;
    aniso_U23_esd: float option;
    aniso_U33: float option;
    aniso_U33_esd: float option;
    attached_hydrogens: int option;
    auth_asym_id: string option;
    auth_atom_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    b_equiv_geom_mean: float option;
    b_equiv_geom_mean_esd: float option;
    b_iso_or_equiv: float option;
    b_iso_or_equiv_esd: float option;
    calc_attached_atom: string option;
    calc_flag: string option;
    cartn_x: float option;
    cartn_x_esd: float option;
    cartn_y: float option;
    cartn_y_esd: float option;
    cartn_z: float option;
    cartn_z_esd: float option;
    chemical_conn_number: int option;
    constraints: string option;
    details: string option;
    disorder_assembly: string option;
    disorder_group: string option;
    footnote_id: string option;
    fract_x: float option;
    fract_x_esd: float option;
    fract_y: float option;
    fract_y_esd: float option;
    fract_z: float option;
    fract_z_esd: float option;
    group_PDB: string option;
    id: string option;
    label_alt_id: string option;
    label_asym_id: string option;
    label_atom_id: string option;
    label_comp_id: string option;
    label_entity_id: string option;
    label_seq_id: int option;
    occupancy: float option;
    occupancy_esd: float option;
    restraints: string option;
    symmetry_multiplicity: int option;
    thermal_displace_type: string option;
    type_symbol: string option;
    u_equiv_geom_mean: float option;
    u_equiv_geom_mean_esd: float option;
    u_iso_or_equiv: float option;
    u_iso_or_equiv_esd: float option;
    wyckoff_symbol: string option;
    adp_type: string option;
    refinement_flags: string option;
    refinement_flags_adp: string option;
    refinement_flags_occupancy: string option;
    refinement_flags_posn: string option;
    pdbx_auth_alt_id: string option;
    pdbx_PDB_ins_code: string option;
    pdbx_PDB_model_num: int option;
    pdbx_PDB_residue_no: string option;
    pdbx_PDB_residue_name: string option;
    pdbx_PDB_strand_id: string option;
    pdbx_PDB_atom_name: string option;
    pdbx_auth_atom_name: string option;
    pdbx_formal_charge: int option;
    pdbx_auth_comp_id: string option;
    pdbx_auth_asym_id: string option;
    pdbx_auth_seq_id: string option;
    pdbx_tls_group_id: string option;
    pdbx_ncs_dom_id: string option;
    pdbx_struct_group_id: string option;
    pdbx_group_NDB: string option;
    pdbx_atom_group: string option;
    pdbx_label_seq_num: string option;
    pdbx_not_in_asym: string option;
  }

  let default = {
    aniso_B11 = None;
    aniso_B11_esd = None;
    aniso_B12 = None;
    aniso_B12_esd = None;
    aniso_B13 = None;
    aniso_B13_esd = None;
    aniso_B22 = None;
    aniso_B22_esd = None;
    aniso_B23 = None;
    aniso_B23_esd = None;
    aniso_B33 = None;
    aniso_B33_esd = None;
    aniso_ratio = None;
    aniso_U11 = None;
    aniso_U11_esd = None;
    aniso_U12 = None;
    aniso_U12_esd = None;
    aniso_U13 = None;
    aniso_U13_esd = None;
    aniso_U22 = None;
    aniso_U22_esd = None;
    aniso_U23 = None;
    aniso_U23_esd = None;
    aniso_U33 = None;
    aniso_U33_esd = None;
    attached_hydrogens = None;
    auth_asym_id = None;
    auth_atom_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    b_equiv_geom_mean = None;
    b_equiv_geom_mean_esd = None;
    b_iso_or_equiv = None;
    b_iso_or_equiv_esd = None;
    calc_attached_atom = None;
    calc_flag = None;
    cartn_x = None;
    cartn_x_esd = None;
    cartn_y = None;
    cartn_y_esd = None;
    cartn_z = None;
    cartn_z_esd = None;
    chemical_conn_number = None;
    constraints = None;
    details = None;
    disorder_assembly = None;
    disorder_group = None;
    footnote_id = None;
    fract_x = None;
    fract_x_esd = None;
    fract_y = None;
    fract_y_esd = None;
    fract_z = None;
    fract_z_esd = None;
    group_PDB = None;
    id = None;
    label_alt_id = None;
    label_asym_id = None;
    label_atom_id = None;
    label_comp_id = None;
    label_entity_id = None;
    label_seq_id = None;
    occupancy = None;
    occupancy_esd = None;
    restraints = None;
    symmetry_multiplicity = None;
    thermal_displace_type = None;
    type_symbol = None;
    u_equiv_geom_mean = None;
    u_equiv_geom_mean_esd = None;
    u_iso_or_equiv = None;
    u_iso_or_equiv_esd = None;
    wyckoff_symbol = None;
    adp_type = None;
    refinement_flags = None;
    refinement_flags_adp = None;
    refinement_flags_occupancy = None;
    refinement_flags_posn = None;
    pdbx_auth_alt_id = None;
    pdbx_PDB_ins_code = None;
    pdbx_PDB_model_num = None;
    pdbx_PDB_residue_no = None;
    pdbx_PDB_residue_name = None;
    pdbx_PDB_strand_id = None;
    pdbx_PDB_atom_name = None;
    pdbx_auth_atom_name = None;
    pdbx_formal_charge = None;
    pdbx_auth_comp_id = None;
    pdbx_auth_asym_id = None;
    pdbx_auth_seq_id = None;
    pdbx_tls_group_id = None;
    pdbx_ncs_dom_id = None;
    pdbx_struct_group_id = None;
    pdbx_group_NDB = None;
    pdbx_atom_group = None;
    pdbx_label_seq_num = None;
    pdbx_not_in_asym = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "aniso_B[1][1]" -> { b with aniso_B11 = (PDBjDict.some_float v) }
      | "aniso_B[1][1]_esd" -> { b with aniso_B11_esd = (PDBjDict.some_float v) }
      | "aniso_B[1][2]" -> { b with aniso_B12 = (PDBjDict.some_float v) }
      | "aniso_B[1][2]_esd" -> { b with aniso_B12_esd = (PDBjDict.some_float v) }
      | "aniso_B[1][3]" -> { b with aniso_B13 = (PDBjDict.some_float v) }
      | "aniso_B[1][3]_esd" -> { b with aniso_B13_esd = (PDBjDict.some_float v) }
      | "aniso_B[2][2]" -> { b with aniso_B22 = (PDBjDict.some_float v) }
      | "aniso_B[2][2]_esd" -> { b with aniso_B22_esd = (PDBjDict.some_float v) }
      | "aniso_B[2][3]" -> { b with aniso_B23 = (PDBjDict.some_float v) }
      | "aniso_B[2][3]_esd" -> { b with aniso_B23_esd = (PDBjDict.some_float v) }
      | "aniso_B[3][3]" -> { b with aniso_B33 = (PDBjDict.some_float v) }
      | "aniso_B[3][3]_esd" -> { b with aniso_B33_esd = (PDBjDict.some_float v) }
      | "aniso_ratio" -> { b with aniso_ratio = (PDBjDict.some_float v) }
      | "aniso_U[1][1]" -> { b with aniso_U11 = (PDBjDict.some_float v) }
      | "aniso_U[1][1]_esd" -> { b with aniso_U11_esd = (PDBjDict.some_float v) }
      | "aniso_U[1][2]" -> { b with aniso_U12 = (PDBjDict.some_float v) }
      | "aniso_U[1][2]_esd" -> { b with aniso_U12_esd = (PDBjDict.some_float v) }
      | "aniso_U[1][3]" -> { b with aniso_U13 = (PDBjDict.some_float v) }
      | "aniso_U[1][3]_esd" -> { b with aniso_U13_esd = (PDBjDict.some_float v) }
      | "aniso_U[2][2]" -> { b with aniso_U22 = (PDBjDict.some_float v) }
      | "aniso_U[2][2]_esd" -> { b with aniso_U22_esd = (PDBjDict.some_float v) }
      | "aniso_U[2][3]" -> { b with aniso_U23 = (PDBjDict.some_float v) }
      | "aniso_U[2][3]_esd" -> { b with aniso_U23_esd = (PDBjDict.some_float v) }
      | "aniso_U[3][3]" -> { b with aniso_U33 = (PDBjDict.some_float v) }
      | "aniso_U[3][3]_esd" -> { b with aniso_U33_esd = (PDBjDict.some_float v) }
      | "attached_hydrogens" -> { b with attached_hydrogens = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_atom_id" -> { b with auth_atom_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "B_equiv_geom_mean" -> { b with b_equiv_geom_mean = (PDBjDict.some_float v) }
      | "B_equiv_geom_mean_esd" -> { b with b_equiv_geom_mean_esd = (PDBjDict.some_float v) }
      | "B_iso_or_equiv" -> { b with b_iso_or_equiv = (PDBjDict.some_float v) }
      | "B_iso_or_equiv_esd" -> { b with b_iso_or_equiv_esd = (PDBjDict.some_float v) }
      | "calc_attached_atom" -> { b with calc_attached_atom = (Some v) }
      | "calc_flag" -> { b with calc_flag = (Some v) }
      | "Cartn_x" -> { b with cartn_x = (PDBjDict.some_float v) }
      | "Cartn_x_esd" -> { b with cartn_x_esd = (PDBjDict.some_float v) }
      | "Cartn_y" -> { b with cartn_y = (PDBjDict.some_float v) }
      | "Cartn_y_esd" -> { b with cartn_y_esd = (PDBjDict.some_float v) }
      | "Cartn_z" -> { b with cartn_z = (PDBjDict.some_float v) }
      | "Cartn_z_esd" -> { b with cartn_z_esd = (PDBjDict.some_float v) }
      | "chemical_conn_number" -> { b with chemical_conn_number = (PDBjDict.some_int v) }
      | "constraints" -> { b with constraints = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "disorder_assembly" -> { b with disorder_assembly = (Some v) }
      | "disorder_group" -> { b with disorder_group = (Some v) }
      | "footnote_id" -> { b with footnote_id = (Some v) }
      | "fract_x" -> { b with fract_x = (PDBjDict.some_float v) }
      | "fract_x_esd" -> { b with fract_x_esd = (PDBjDict.some_float v) }
      | "fract_y" -> { b with fract_y = (PDBjDict.some_float v) }
      | "fract_y_esd" -> { b with fract_y_esd = (PDBjDict.some_float v) }
      | "fract_z" -> { b with fract_z = (PDBjDict.some_float v) }
      | "fract_z_esd" -> { b with fract_z_esd = (PDBjDict.some_float v) }
      | "group_PDB" -> { b with group_PDB = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_atom_id" -> { b with label_atom_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_entity_id" -> { b with label_entity_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "occupancy" -> { b with occupancy = (PDBjDict.some_float v) }
      | "occupancy_esd" -> { b with occupancy_esd = (PDBjDict.some_float v) }
      | "restraints" -> { b with restraints = (Some v) }
      | "symmetry_multiplicity" -> { b with symmetry_multiplicity = (PDBjDict.some_int v) }
      | "thermal_displace_type" -> { b with thermal_displace_type = (Some v) }
      | "type_symbol" -> { b with type_symbol = (Some v) }
      | "U_equiv_geom_mean" -> { b with u_equiv_geom_mean = (PDBjDict.some_float v) }
      | "U_equiv_geom_mean_esd" -> { b with u_equiv_geom_mean_esd = (PDBjDict.some_float v) }
      | "U_iso_or_equiv" -> { b with u_iso_or_equiv = (PDBjDict.some_float v) }
      | "U_iso_or_equiv_esd" -> { b with u_iso_or_equiv_esd = (PDBjDict.some_float v) }
      | "Wyckoff_symbol" -> { b with wyckoff_symbol = (Some v) }
      | "adp_type" -> { b with adp_type = (Some v) }
      | "refinement_flags" -> { b with refinement_flags = (Some v) }
      | "refinement_flags_adp" -> { b with refinement_flags_adp = (Some v) }
      | "refinement_flags_occupancy" -> { b with refinement_flags_occupancy = (Some v) }
      | "refinement_flags_posn" -> { b with refinement_flags_posn = (Some v) }
      | "pdbx_auth_alt_id" -> { b with pdbx_auth_alt_id = (Some v) }
      | "pdbx_PDB_ins_code" -> { b with pdbx_PDB_ins_code = (Some v) }
      | "pdbx_PDB_model_num" -> { b with pdbx_PDB_model_num = (PDBjDict.some_int v) }
      | "pdbx_PDB_residue_no" -> { b with pdbx_PDB_residue_no = (Some v) }
      | "pdbx_PDB_residue_name" -> { b with pdbx_PDB_residue_name = (Some v) }
      | "pdbx_PDB_strand_id" -> { b with pdbx_PDB_strand_id = (Some v) }
      | "pdbx_PDB_atom_name" -> { b with pdbx_PDB_atom_name = (Some v) }
      | "pdbx_auth_atom_name" -> { b with pdbx_auth_atom_name = (Some v) }
      | "pdbx_formal_charge" -> { b with pdbx_formal_charge = (PDBjDict.some_int v) }
      | "pdbx_auth_comp_id" -> { b with pdbx_auth_comp_id = (Some v) }
      | "pdbx_auth_asym_id" -> { b with pdbx_auth_asym_id = (Some v) }
      | "pdbx_auth_seq_id" -> { b with pdbx_auth_seq_id = (Some v) }
      | "pdbx_tls_group_id" -> { b with pdbx_tls_group_id = (Some v) }
      | "pdbx_ncs_dom_id" -> { b with pdbx_ncs_dom_id = (Some v) }
      | "pdbx_struct_group_id" -> { b with pdbx_struct_group_id = (Some v) }
      | "pdbx_group_NDB" -> { b with pdbx_group_NDB = (Some v) }
      | "pdbx_atom_group" -> { b with pdbx_atom_group = (Some v) }
      | "pdbx_label_seq_num" -> { b with pdbx_label_seq_num = (Some v) }
      | "pdbx_not_in_asym" -> { b with pdbx_not_in_asym = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("aniso_B[1][1]", string_of_float v)) a.aniso_B11;
      Option.map (fun v -> ("aniso_B[1][1]_esd", string_of_float v)) a.aniso_B11_esd;
      Option.map (fun v -> ("aniso_B[1][2]", string_of_float v)) a.aniso_B12;
      Option.map (fun v -> ("aniso_B[1][2]_esd", string_of_float v)) a.aniso_B12_esd;
      Option.map (fun v -> ("aniso_B[1][3]", string_of_float v)) a.aniso_B13;
      Option.map (fun v -> ("aniso_B[1][3]_esd", string_of_float v)) a.aniso_B13_esd;
      Option.map (fun v -> ("aniso_B[2][2]", string_of_float v)) a.aniso_B22;
      Option.map (fun v -> ("aniso_B[2][2]_esd", string_of_float v)) a.aniso_B22_esd;
      Option.map (fun v -> ("aniso_B[2][3]", string_of_float v)) a.aniso_B23;
      Option.map (fun v -> ("aniso_B[2][3]_esd", string_of_float v)) a.aniso_B23_esd;
      Option.map (fun v -> ("aniso_B[3][3]", string_of_float v)) a.aniso_B33;
      Option.map (fun v -> ("aniso_B[3][3]_esd", string_of_float v)) a.aniso_B33_esd;
      Option.map (fun v -> ("aniso_ratio", string_of_float v)) a.aniso_ratio;
      Option.map (fun v -> ("aniso_U[1][1]", string_of_float v)) a.aniso_U11;
      Option.map (fun v -> ("aniso_U[1][1]_esd", string_of_float v)) a.aniso_U11_esd;
      Option.map (fun v -> ("aniso_U[1][2]", string_of_float v)) a.aniso_U12;
      Option.map (fun v -> ("aniso_U[1][2]_esd", string_of_float v)) a.aniso_U12_esd;
      Option.map (fun v -> ("aniso_U[1][3]", string_of_float v)) a.aniso_U13;
      Option.map (fun v -> ("aniso_U[1][3]_esd", string_of_float v)) a.aniso_U13_esd;
      Option.map (fun v -> ("aniso_U[2][2]", string_of_float v)) a.aniso_U22;
      Option.map (fun v -> ("aniso_U[2][2]_esd", string_of_float v)) a.aniso_U22_esd;
      Option.map (fun v -> ("aniso_U[2][3]", string_of_float v)) a.aniso_U23;
      Option.map (fun v -> ("aniso_U[2][3]_esd", string_of_float v)) a.aniso_U23_esd;
      Option.map (fun v -> ("aniso_U[3][3]", string_of_float v)) a.aniso_U33;
      Option.map (fun v -> ("aniso_U[3][3]_esd", string_of_float v)) a.aniso_U33_esd;
      Option.map (fun v -> ("attached_hydrogens", string_of_int v)) a.attached_hydrogens;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_atom_id",  v)) a.auth_atom_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("B_equiv_geom_mean", string_of_float v)) a.b_equiv_geom_mean;
      Option.map (fun v -> ("B_equiv_geom_mean_esd", string_of_float v)) a.b_equiv_geom_mean_esd;
      Option.map (fun v -> ("B_iso_or_equiv", string_of_float v)) a.b_iso_or_equiv;
      Option.map (fun v -> ("B_iso_or_equiv_esd", string_of_float v)) a.b_iso_or_equiv_esd;
      Option.map (fun v -> ("calc_attached_atom",  v)) a.calc_attached_atom;
      Option.map (fun v -> ("calc_flag",  v)) a.calc_flag;
      Option.map (fun v -> ("Cartn_x", string_of_float v)) a.cartn_x;
      Option.map (fun v -> ("Cartn_x_esd", string_of_float v)) a.cartn_x_esd;
      Option.map (fun v -> ("Cartn_y", string_of_float v)) a.cartn_y;
      Option.map (fun v -> ("Cartn_y_esd", string_of_float v)) a.cartn_y_esd;
      Option.map (fun v -> ("Cartn_z", string_of_float v)) a.cartn_z;
      Option.map (fun v -> ("Cartn_z_esd", string_of_float v)) a.cartn_z_esd;
      Option.map (fun v -> ("chemical_conn_number", string_of_int v)) a.chemical_conn_number;
      Option.map (fun v -> ("constraints",  v)) a.constraints;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("disorder_assembly",  v)) a.disorder_assembly;
      Option.map (fun v -> ("disorder_group",  v)) a.disorder_group;
      Option.map (fun v -> ("footnote_id",  v)) a.footnote_id;
      Option.map (fun v -> ("fract_x", string_of_float v)) a.fract_x;
      Option.map (fun v -> ("fract_x_esd", string_of_float v)) a.fract_x_esd;
      Option.map (fun v -> ("fract_y", string_of_float v)) a.fract_y;
      Option.map (fun v -> ("fract_y_esd", string_of_float v)) a.fract_y_esd;
      Option.map (fun v -> ("fract_z", string_of_float v)) a.fract_z;
      Option.map (fun v -> ("fract_z_esd", string_of_float v)) a.fract_z_esd;
      Option.map (fun v -> ("group_PDB",  v)) a.group_PDB;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_atom_id",  v)) a.label_atom_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_entity_id",  v)) a.label_entity_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("occupancy", string_of_float v)) a.occupancy;
      Option.map (fun v -> ("occupancy_esd", string_of_float v)) a.occupancy_esd;
      Option.map (fun v -> ("restraints",  v)) a.restraints;
      Option.map (fun v -> ("symmetry_multiplicity", string_of_int v)) a.symmetry_multiplicity;
      Option.map (fun v -> ("thermal_displace_type",  v)) a.thermal_displace_type;
      Option.map (fun v -> ("type_symbol",  v)) a.type_symbol;
      Option.map (fun v -> ("U_equiv_geom_mean", string_of_float v)) a.u_equiv_geom_mean;
      Option.map (fun v -> ("U_equiv_geom_mean_esd", string_of_float v)) a.u_equiv_geom_mean_esd;
      Option.map (fun v -> ("U_iso_or_equiv", string_of_float v)) a.u_iso_or_equiv;
      Option.map (fun v -> ("U_iso_or_equiv_esd", string_of_float v)) a.u_iso_or_equiv_esd;
      Option.map (fun v -> ("Wyckoff_symbol",  v)) a.wyckoff_symbol;
      Option.map (fun v -> ("adp_type",  v)) a.adp_type;
      Option.map (fun v -> ("refinement_flags",  v)) a.refinement_flags;
      Option.map (fun v -> ("refinement_flags_adp",  v)) a.refinement_flags_adp;
      Option.map (fun v -> ("refinement_flags_occupancy",  v)) a.refinement_flags_occupancy;
      Option.map (fun v -> ("refinement_flags_posn",  v)) a.refinement_flags_posn;
      Option.map (fun v -> ("pdbx_auth_alt_id",  v)) a.pdbx_auth_alt_id;
      Option.map (fun v -> ("pdbx_PDB_ins_code",  v)) a.pdbx_PDB_ins_code;
      Option.map (fun v -> ("pdbx_PDB_model_num", string_of_int v)) a.pdbx_PDB_model_num;
      Option.map (fun v -> ("pdbx_PDB_residue_no",  v)) a.pdbx_PDB_residue_no;
      Option.map (fun v -> ("pdbx_PDB_residue_name",  v)) a.pdbx_PDB_residue_name;
      Option.map (fun v -> ("pdbx_PDB_strand_id",  v)) a.pdbx_PDB_strand_id;
      Option.map (fun v -> ("pdbx_PDB_atom_name",  v)) a.pdbx_PDB_atom_name;
      Option.map (fun v -> ("pdbx_auth_atom_name",  v)) a.pdbx_auth_atom_name;
      Option.map (fun v -> ("pdbx_formal_charge", string_of_int v)) a.pdbx_formal_charge;
      Option.map (fun v -> ("pdbx_auth_comp_id",  v)) a.pdbx_auth_comp_id;
      Option.map (fun v -> ("pdbx_auth_asym_id",  v)) a.pdbx_auth_asym_id;
      Option.map (fun v -> ("pdbx_auth_seq_id",  v)) a.pdbx_auth_seq_id;
      Option.map (fun v -> ("pdbx_tls_group_id",  v)) a.pdbx_tls_group_id;
      Option.map (fun v -> ("pdbx_ncs_dom_id",  v)) a.pdbx_ncs_dom_id;
      Option.map (fun v -> ("pdbx_struct_group_id",  v)) a.pdbx_struct_group_id;
      Option.map (fun v -> ("pdbx_group_NDB",  v)) a.pdbx_group_NDB;
      Option.map (fun v -> ("pdbx_atom_group",  v)) a.pdbx_atom_group;
      Option.map (fun v -> ("pdbx_label_seq_num",  v)) a.pdbx_label_seq_num;
      Option.map (fun v -> ("pdbx_not_in_asym",  v)) a.pdbx_not_in_asym;
    ]

end

module Atom_site_anisotrop = struct
  type t = {
    b11: float option;
    b11_esd: float option;
    b12: float option;
    b12_esd: float option;
    b13: float option;
    b13_esd: float option;
    b22: float option;
    b22_esd: float option;
    b23: float option;
    b23_esd: float option;
    b33: float option;
    b33_esd: float option;
    ratio: float option;
    id: string option;
    type_symbol: string option;
    u11: float option;
    u11_esd: float option;
    u12: float option;
    u12_esd: float option;
    u13: float option;
    u13_esd: float option;
    u22: float option;
    u22_esd: float option;
    u23: float option;
    u23_esd: float option;
    u33: float option;
    u33_esd: float option;
    pdbx_auth_seq_id: string option;
    pdbx_auth_alt_id: string option;
    pdbx_auth_asym_id: string option;
    pdbx_auth_atom_id: string option;
    pdbx_auth_comp_id: string option;
    pdbx_label_seq_id: int option;
    pdbx_label_alt_id: string option;
    pdbx_label_asym_id: string option;
    pdbx_label_atom_id: string option;
    pdbx_label_comp_id: string option;
    pdbx_PDB_ins_code: string option;
    pdbx_PDB_model_num: int option;
    pdbx_not_in_asym: string option;
    pdbx_PDB_residue_no: string option;
    pdbx_PDB_residue_name: string option;
    pdbx_PDB_strand_id: string option;
    pdbx_PDB_atom_name: string option;
    pdbx_auth_atom_name: string option;
    pdbx_label_ins_code: string option;
  }

  let default = {
    b11 = None;
    b11_esd = None;
    b12 = None;
    b12_esd = None;
    b13 = None;
    b13_esd = None;
    b22 = None;
    b22_esd = None;
    b23 = None;
    b23_esd = None;
    b33 = None;
    b33_esd = None;
    ratio = None;
    id = None;
    type_symbol = None;
    u11 = None;
    u11_esd = None;
    u12 = None;
    u12_esd = None;
    u13 = None;
    u13_esd = None;
    u22 = None;
    u22_esd = None;
    u23 = None;
    u23_esd = None;
    u33 = None;
    u33_esd = None;
    pdbx_auth_seq_id = None;
    pdbx_auth_alt_id = None;
    pdbx_auth_asym_id = None;
    pdbx_auth_atom_id = None;
    pdbx_auth_comp_id = None;
    pdbx_label_seq_id = None;
    pdbx_label_alt_id = None;
    pdbx_label_asym_id = None;
    pdbx_label_atom_id = None;
    pdbx_label_comp_id = None;
    pdbx_PDB_ins_code = None;
    pdbx_PDB_model_num = None;
    pdbx_not_in_asym = None;
    pdbx_PDB_residue_no = None;
    pdbx_PDB_residue_name = None;
    pdbx_PDB_strand_id = None;
    pdbx_PDB_atom_name = None;
    pdbx_auth_atom_name = None;
    pdbx_label_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "B[1][1]" -> { b with b11 = (PDBjDict.some_float v) }
      | "B[1][1]_esd" -> { b with b11_esd = (PDBjDict.some_float v) }
      | "B[1][2]" -> { b with b12 = (PDBjDict.some_float v) }
      | "B[1][2]_esd" -> { b with b12_esd = (PDBjDict.some_float v) }
      | "B[1][3]" -> { b with b13 = (PDBjDict.some_float v) }
      | "B[1][3]_esd" -> { b with b13_esd = (PDBjDict.some_float v) }
      | "B[2][2]" -> { b with b22 = (PDBjDict.some_float v) }
      | "B[2][2]_esd" -> { b with b22_esd = (PDBjDict.some_float v) }
      | "B[2][3]" -> { b with b23 = (PDBjDict.some_float v) }
      | "B[2][3]_esd" -> { b with b23_esd = (PDBjDict.some_float v) }
      | "B[3][3]" -> { b with b33 = (PDBjDict.some_float v) }
      | "B[3][3]_esd" -> { b with b33_esd = (PDBjDict.some_float v) }
      | "ratio" -> { b with ratio = (PDBjDict.some_float v) }
      | "id" -> { b with id = (Some v) }
      | "type_symbol" -> { b with type_symbol = (Some v) }
      | "U[1][1]" -> { b with u11 = (PDBjDict.some_float v) }
      | "U[1][1]_esd" -> { b with u11_esd = (PDBjDict.some_float v) }
      | "U[1][2]" -> { b with u12 = (PDBjDict.some_float v) }
      | "U[1][2]_esd" -> { b with u12_esd = (PDBjDict.some_float v) }
      | "U[1][3]" -> { b with u13 = (PDBjDict.some_float v) }
      | "U[1][3]_esd" -> { b with u13_esd = (PDBjDict.some_float v) }
      | "U[2][2]" -> { b with u22 = (PDBjDict.some_float v) }
      | "U[2][2]_esd" -> { b with u22_esd = (PDBjDict.some_float v) }
      | "U[2][3]" -> { b with u23 = (PDBjDict.some_float v) }
      | "U[2][3]_esd" -> { b with u23_esd = (PDBjDict.some_float v) }
      | "U[3][3]" -> { b with u33 = (PDBjDict.some_float v) }
      | "U[3][3]_esd" -> { b with u33_esd = (PDBjDict.some_float v) }
      | "pdbx_auth_seq_id" -> { b with pdbx_auth_seq_id = (Some v) }
      | "pdbx_auth_alt_id" -> { b with pdbx_auth_alt_id = (Some v) }
      | "pdbx_auth_asym_id" -> { b with pdbx_auth_asym_id = (Some v) }
      | "pdbx_auth_atom_id" -> { b with pdbx_auth_atom_id = (Some v) }
      | "pdbx_auth_comp_id" -> { b with pdbx_auth_comp_id = (Some v) }
      | "pdbx_label_seq_id" -> { b with pdbx_label_seq_id = (PDBjDict.some_int v) }
      | "pdbx_label_alt_id" -> { b with pdbx_label_alt_id = (Some v) }
      | "pdbx_label_asym_id" -> { b with pdbx_label_asym_id = (Some v) }
      | "pdbx_label_atom_id" -> { b with pdbx_label_atom_id = (Some v) }
      | "pdbx_label_comp_id" -> { b with pdbx_label_comp_id = (Some v) }
      | "pdbx_PDB_ins_code" -> { b with pdbx_PDB_ins_code = (Some v) }
      | "pdbx_PDB_model_num" -> { b with pdbx_PDB_model_num = (PDBjDict.some_int v) }
      | "pdbx_not_in_asym" -> { b with pdbx_not_in_asym = (Some v) }
      | "pdbx_PDB_residue_no" -> { b with pdbx_PDB_residue_no = (Some v) }
      | "pdbx_PDB_residue_name" -> { b with pdbx_PDB_residue_name = (Some v) }
      | "pdbx_PDB_strand_id" -> { b with pdbx_PDB_strand_id = (Some v) }
      | "pdbx_PDB_atom_name" -> { b with pdbx_PDB_atom_name = (Some v) }
      | "pdbx_auth_atom_name" -> { b with pdbx_auth_atom_name = (Some v) }
      | "pdbx_label_ins_code" -> { b with pdbx_label_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("B[1][1]", string_of_float v)) a.b11;
      Option.map (fun v -> ("B[1][1]_esd", string_of_float v)) a.b11_esd;
      Option.map (fun v -> ("B[1][2]", string_of_float v)) a.b12;
      Option.map (fun v -> ("B[1][2]_esd", string_of_float v)) a.b12_esd;
      Option.map (fun v -> ("B[1][3]", string_of_float v)) a.b13;
      Option.map (fun v -> ("B[1][3]_esd", string_of_float v)) a.b13_esd;
      Option.map (fun v -> ("B[2][2]", string_of_float v)) a.b22;
      Option.map (fun v -> ("B[2][2]_esd", string_of_float v)) a.b22_esd;
      Option.map (fun v -> ("B[2][3]", string_of_float v)) a.b23;
      Option.map (fun v -> ("B[2][3]_esd", string_of_float v)) a.b23_esd;
      Option.map (fun v -> ("B[3][3]", string_of_float v)) a.b33;
      Option.map (fun v -> ("B[3][3]_esd", string_of_float v)) a.b33_esd;
      Option.map (fun v -> ("ratio", string_of_float v)) a.ratio;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("type_symbol",  v)) a.type_symbol;
      Option.map (fun v -> ("U[1][1]", string_of_float v)) a.u11;
      Option.map (fun v -> ("U[1][1]_esd", string_of_float v)) a.u11_esd;
      Option.map (fun v -> ("U[1][2]", string_of_float v)) a.u12;
      Option.map (fun v -> ("U[1][2]_esd", string_of_float v)) a.u12_esd;
      Option.map (fun v -> ("U[1][3]", string_of_float v)) a.u13;
      Option.map (fun v -> ("U[1][3]_esd", string_of_float v)) a.u13_esd;
      Option.map (fun v -> ("U[2][2]", string_of_float v)) a.u22;
      Option.map (fun v -> ("U[2][2]_esd", string_of_float v)) a.u22_esd;
      Option.map (fun v -> ("U[2][3]", string_of_float v)) a.u23;
      Option.map (fun v -> ("U[2][3]_esd", string_of_float v)) a.u23_esd;
      Option.map (fun v -> ("U[3][3]", string_of_float v)) a.u33;
      Option.map (fun v -> ("U[3][3]_esd", string_of_float v)) a.u33_esd;
      Option.map (fun v -> ("pdbx_auth_seq_id",  v)) a.pdbx_auth_seq_id;
      Option.map (fun v -> ("pdbx_auth_alt_id",  v)) a.pdbx_auth_alt_id;
      Option.map (fun v -> ("pdbx_auth_asym_id",  v)) a.pdbx_auth_asym_id;
      Option.map (fun v -> ("pdbx_auth_atom_id",  v)) a.pdbx_auth_atom_id;
      Option.map (fun v -> ("pdbx_auth_comp_id",  v)) a.pdbx_auth_comp_id;
      Option.map (fun v -> ("pdbx_label_seq_id", string_of_int v)) a.pdbx_label_seq_id;
      Option.map (fun v -> ("pdbx_label_alt_id",  v)) a.pdbx_label_alt_id;
      Option.map (fun v -> ("pdbx_label_asym_id",  v)) a.pdbx_label_asym_id;
      Option.map (fun v -> ("pdbx_label_atom_id",  v)) a.pdbx_label_atom_id;
      Option.map (fun v -> ("pdbx_label_comp_id",  v)) a.pdbx_label_comp_id;
      Option.map (fun v -> ("pdbx_PDB_ins_code",  v)) a.pdbx_PDB_ins_code;
      Option.map (fun v -> ("pdbx_PDB_model_num", string_of_int v)) a.pdbx_PDB_model_num;
      Option.map (fun v -> ("pdbx_not_in_asym",  v)) a.pdbx_not_in_asym;
      Option.map (fun v -> ("pdbx_PDB_residue_no",  v)) a.pdbx_PDB_residue_no;
      Option.map (fun v -> ("pdbx_PDB_residue_name",  v)) a.pdbx_PDB_residue_name;
      Option.map (fun v -> ("pdbx_PDB_strand_id",  v)) a.pdbx_PDB_strand_id;
      Option.map (fun v -> ("pdbx_PDB_atom_name",  v)) a.pdbx_PDB_atom_name;
      Option.map (fun v -> ("pdbx_auth_atom_name",  v)) a.pdbx_auth_atom_name;
      Option.map (fun v -> ("pdbx_label_ins_code",  v)) a.pdbx_label_ins_code;
    ]

end

module Atom_sites = struct
  type t = {
    entry_id: string option;
    cartn_transf_matrix11: float option;
    cartn_transf_matrix12: float option;
    cartn_transf_matrix13: float option;
    cartn_transf_matrix21: float option;
    cartn_transf_matrix22: float option;
    cartn_transf_matrix23: float option;
    cartn_transf_matrix31: float option;
    cartn_transf_matrix32: float option;
    cartn_transf_matrix33: float option;
    cartn_transf_vector1: float option;
    cartn_transf_vector2: float option;
    cartn_transf_vector3: float option;
    cartn_transform_axes: string option;
    fract_transf_matrix11: float option;
    fract_transf_matrix12: float option;
    fract_transf_matrix13: float option;
    fract_transf_matrix21: float option;
    fract_transf_matrix22: float option;
    fract_transf_matrix23: float option;
    fract_transf_matrix31: float option;
    fract_transf_matrix32: float option;
    fract_transf_matrix33: float option;
    fract_transf_vector1: float option;
    fract_transf_vector2: float option;
    fract_transf_vector3: float option;
    solution_primary: string option;
    solution_secondary: string option;
    solution_hydrogens: string option;
    special_details: string option;
  }

  let default = {
    entry_id = None;
    cartn_transf_matrix11 = None;
    cartn_transf_matrix12 = None;
    cartn_transf_matrix13 = None;
    cartn_transf_matrix21 = None;
    cartn_transf_matrix22 = None;
    cartn_transf_matrix23 = None;
    cartn_transf_matrix31 = None;
    cartn_transf_matrix32 = None;
    cartn_transf_matrix33 = None;
    cartn_transf_vector1 = None;
    cartn_transf_vector2 = None;
    cartn_transf_vector3 = None;
    cartn_transform_axes = None;
    fract_transf_matrix11 = None;
    fract_transf_matrix12 = None;
    fract_transf_matrix13 = None;
    fract_transf_matrix21 = None;
    fract_transf_matrix22 = None;
    fract_transf_matrix23 = None;
    fract_transf_matrix31 = None;
    fract_transf_matrix32 = None;
    fract_transf_matrix33 = None;
    fract_transf_vector1 = None;
    fract_transf_vector2 = None;
    fract_transf_vector3 = None;
    solution_primary = None;
    solution_secondary = None;
    solution_hydrogens = None;
    special_details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "Cartn_transf_matrix[1][1]" -> { b with cartn_transf_matrix11 = (PDBjDict.some_float v) }
      | "Cartn_transf_matrix[1][2]" -> { b with cartn_transf_matrix12 = (PDBjDict.some_float v) }
      | "Cartn_transf_matrix[1][3]" -> { b with cartn_transf_matrix13 = (PDBjDict.some_float v) }
      | "Cartn_transf_matrix[2][1]" -> { b with cartn_transf_matrix21 = (PDBjDict.some_float v) }
      | "Cartn_transf_matrix[2][2]" -> { b with cartn_transf_matrix22 = (PDBjDict.some_float v) }
      | "Cartn_transf_matrix[2][3]" -> { b with cartn_transf_matrix23 = (PDBjDict.some_float v) }
      | "Cartn_transf_matrix[3][1]" -> { b with cartn_transf_matrix31 = (PDBjDict.some_float v) }
      | "Cartn_transf_matrix[3][2]" -> { b with cartn_transf_matrix32 = (PDBjDict.some_float v) }
      | "Cartn_transf_matrix[3][3]" -> { b with cartn_transf_matrix33 = (PDBjDict.some_float v) }
      | "Cartn_transf_vector[1]" -> { b with cartn_transf_vector1 = (PDBjDict.some_float v) }
      | "Cartn_transf_vector[2]" -> { b with cartn_transf_vector2 = (PDBjDict.some_float v) }
      | "Cartn_transf_vector[3]" -> { b with cartn_transf_vector3 = (PDBjDict.some_float v) }
      | "Cartn_transform_axes" -> { b with cartn_transform_axes = (Some v) }
      | "fract_transf_matrix[1][1]" -> { b with fract_transf_matrix11 = (PDBjDict.some_float v) }
      | "fract_transf_matrix[1][2]" -> { b with fract_transf_matrix12 = (PDBjDict.some_float v) }
      | "fract_transf_matrix[1][3]" -> { b with fract_transf_matrix13 = (PDBjDict.some_float v) }
      | "fract_transf_matrix[2][1]" -> { b with fract_transf_matrix21 = (PDBjDict.some_float v) }
      | "fract_transf_matrix[2][2]" -> { b with fract_transf_matrix22 = (PDBjDict.some_float v) }
      | "fract_transf_matrix[2][3]" -> { b with fract_transf_matrix23 = (PDBjDict.some_float v) }
      | "fract_transf_matrix[3][1]" -> { b with fract_transf_matrix31 = (PDBjDict.some_float v) }
      | "fract_transf_matrix[3][2]" -> { b with fract_transf_matrix32 = (PDBjDict.some_float v) }
      | "fract_transf_matrix[3][3]" -> { b with fract_transf_matrix33 = (PDBjDict.some_float v) }
      | "fract_transf_vector[1]" -> { b with fract_transf_vector1 = (PDBjDict.some_float v) }
      | "fract_transf_vector[2]" -> { b with fract_transf_vector2 = (PDBjDict.some_float v) }
      | "fract_transf_vector[3]" -> { b with fract_transf_vector3 = (PDBjDict.some_float v) }
      | "solution_primary" -> { b with solution_primary = (Some v) }
      | "solution_secondary" -> { b with solution_secondary = (Some v) }
      | "solution_hydrogens" -> { b with solution_hydrogens = (Some v) }
      | "special_details" -> { b with special_details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("Cartn_transf_matrix[1][1]", string_of_float v)) a.cartn_transf_matrix11;
      Option.map (fun v -> ("Cartn_transf_matrix[1][2]", string_of_float v)) a.cartn_transf_matrix12;
      Option.map (fun v -> ("Cartn_transf_matrix[1][3]", string_of_float v)) a.cartn_transf_matrix13;
      Option.map (fun v -> ("Cartn_transf_matrix[2][1]", string_of_float v)) a.cartn_transf_matrix21;
      Option.map (fun v -> ("Cartn_transf_matrix[2][2]", string_of_float v)) a.cartn_transf_matrix22;
      Option.map (fun v -> ("Cartn_transf_matrix[2][3]", string_of_float v)) a.cartn_transf_matrix23;
      Option.map (fun v -> ("Cartn_transf_matrix[3][1]", string_of_float v)) a.cartn_transf_matrix31;
      Option.map (fun v -> ("Cartn_transf_matrix[3][2]", string_of_float v)) a.cartn_transf_matrix32;
      Option.map (fun v -> ("Cartn_transf_matrix[3][3]", string_of_float v)) a.cartn_transf_matrix33;
      Option.map (fun v -> ("Cartn_transf_vector[1]", string_of_float v)) a.cartn_transf_vector1;
      Option.map (fun v -> ("Cartn_transf_vector[2]", string_of_float v)) a.cartn_transf_vector2;
      Option.map (fun v -> ("Cartn_transf_vector[3]", string_of_float v)) a.cartn_transf_vector3;
      Option.map (fun v -> ("Cartn_transform_axes",  v)) a.cartn_transform_axes;
      Option.map (fun v -> ("fract_transf_matrix[1][1]", string_of_float v)) a.fract_transf_matrix11;
      Option.map (fun v -> ("fract_transf_matrix[1][2]", string_of_float v)) a.fract_transf_matrix12;
      Option.map (fun v -> ("fract_transf_matrix[1][3]", string_of_float v)) a.fract_transf_matrix13;
      Option.map (fun v -> ("fract_transf_matrix[2][1]", string_of_float v)) a.fract_transf_matrix21;
      Option.map (fun v -> ("fract_transf_matrix[2][2]", string_of_float v)) a.fract_transf_matrix22;
      Option.map (fun v -> ("fract_transf_matrix[2][3]", string_of_float v)) a.fract_transf_matrix23;
      Option.map (fun v -> ("fract_transf_matrix[3][1]", string_of_float v)) a.fract_transf_matrix31;
      Option.map (fun v -> ("fract_transf_matrix[3][2]", string_of_float v)) a.fract_transf_matrix32;
      Option.map (fun v -> ("fract_transf_matrix[3][3]", string_of_float v)) a.fract_transf_matrix33;
      Option.map (fun v -> ("fract_transf_vector[1]", string_of_float v)) a.fract_transf_vector1;
      Option.map (fun v -> ("fract_transf_vector[2]", string_of_float v)) a.fract_transf_vector2;
      Option.map (fun v -> ("fract_transf_vector[3]", string_of_float v)) a.fract_transf_vector3;
      Option.map (fun v -> ("solution_primary",  v)) a.solution_primary;
      Option.map (fun v -> ("solution_secondary",  v)) a.solution_secondary;
      Option.map (fun v -> ("solution_hydrogens",  v)) a.solution_hydrogens;
      Option.map (fun v -> ("special_details",  v)) a.special_details;
    ]

end

module Atom_sites_alt = struct
  type t = {
    details: string option;
    id: string option;
  }

  let default = {
    details = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Atom_sites_alt_ens = struct
  type t = {
    details: string option;
    id: string option;
  }

  let default = {
    details = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Atom_sites_alt_gen = struct
  type t = {
    alt_id: string option;
    ens_id: string option;
  }

  let default = {
    alt_id = None;
    ens_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "alt_id" -> { b with alt_id = (Some v) }
      | "ens_id" -> { b with ens_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("alt_id",  v)) a.alt_id;
      Option.map (fun v -> ("ens_id",  v)) a.ens_id;
    ]

end

module Atom_sites_footnote = struct
  type t = {
    id: string option;
    text: string option;
  }

  let default = {
    id = None;
    text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "text" -> { b with text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("text",  v)) a.text;
    ]

end

module Atom_type = struct
  type t = {
    analytical_mass_percent: float option;
    description: string option;
    number_in_cell: int option;
    oxidation_number: int option;
    radius_bond: float option;
    radius_contact: float option;
    scat_Cromer_Mann_a1: float option;
    scat_Cromer_Mann_a2: float option;
    scat_Cromer_Mann_a3: float option;
    scat_Cromer_Mann_a4: float option;
    scat_Cromer_Mann_b1: float option;
    scat_Cromer_Mann_b2: float option;
    scat_Cromer_Mann_b3: float option;
    scat_Cromer_Mann_b4: float option;
    scat_Cromer_Mann_c: float option;
    scat_dispersion_imag: float option;
    scat_dispersion_real: float option;
    scat_length_neutron: string option;
    scat_source: string option;
    scat_versus_stol_list: string option;
    symbol: string option;
    scat_dispersion_source: string option;
    pdbx_scat_Cromer_Mann_a5: float option;
    pdbx_scat_Cromer_Mann_b5: float option;
  }

  let default = {
    analytical_mass_percent = None;
    description = None;
    number_in_cell = None;
    oxidation_number = None;
    radius_bond = None;
    radius_contact = None;
    scat_Cromer_Mann_a1 = None;
    scat_Cromer_Mann_a2 = None;
    scat_Cromer_Mann_a3 = None;
    scat_Cromer_Mann_a4 = None;
    scat_Cromer_Mann_b1 = None;
    scat_Cromer_Mann_b2 = None;
    scat_Cromer_Mann_b3 = None;
    scat_Cromer_Mann_b4 = None;
    scat_Cromer_Mann_c = None;
    scat_dispersion_imag = None;
    scat_dispersion_real = None;
    scat_length_neutron = None;
    scat_source = None;
    scat_versus_stol_list = None;
    symbol = None;
    scat_dispersion_source = None;
    pdbx_scat_Cromer_Mann_a5 = None;
    pdbx_scat_Cromer_Mann_b5 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "analytical_mass_percent" -> { b with analytical_mass_percent = (PDBjDict.some_float v) }
      | "description" -> { b with description = (Some v) }
      | "number_in_cell" -> { b with number_in_cell = (PDBjDict.some_int v) }
      | "oxidation_number" -> { b with oxidation_number = (PDBjDict.some_int v) }
      | "radius_bond" -> { b with radius_bond = (PDBjDict.some_float v) }
      | "radius_contact" -> { b with radius_contact = (PDBjDict.some_float v) }
      | "scat_Cromer_Mann_a1" -> { b with scat_Cromer_Mann_a1 = (PDBjDict.some_float v) }
      | "scat_Cromer_Mann_a2" -> { b with scat_Cromer_Mann_a2 = (PDBjDict.some_float v) }
      | "scat_Cromer_Mann_a3" -> { b with scat_Cromer_Mann_a3 = (PDBjDict.some_float v) }
      | "scat_Cromer_Mann_a4" -> { b with scat_Cromer_Mann_a4 = (PDBjDict.some_float v) }
      | "scat_Cromer_Mann_b1" -> { b with scat_Cromer_Mann_b1 = (PDBjDict.some_float v) }
      | "scat_Cromer_Mann_b2" -> { b with scat_Cromer_Mann_b2 = (PDBjDict.some_float v) }
      | "scat_Cromer_Mann_b3" -> { b with scat_Cromer_Mann_b3 = (PDBjDict.some_float v) }
      | "scat_Cromer_Mann_b4" -> { b with scat_Cromer_Mann_b4 = (PDBjDict.some_float v) }
      | "scat_Cromer_Mann_c" -> { b with scat_Cromer_Mann_c = (PDBjDict.some_float v) }
      | "scat_dispersion_imag" -> { b with scat_dispersion_imag = (PDBjDict.some_float v) }
      | "scat_dispersion_real" -> { b with scat_dispersion_real = (PDBjDict.some_float v) }
      | "scat_length_neutron" -> { b with scat_length_neutron = (Some v) }
      | "scat_source" -> { b with scat_source = (Some v) }
      | "scat_versus_stol_list" -> { b with scat_versus_stol_list = (Some v) }
      | "symbol" -> { b with symbol = (Some v) }
      | "scat_dispersion_source" -> { b with scat_dispersion_source = (Some v) }
      | "pdbx_scat_Cromer_Mann_a5" -> { b with pdbx_scat_Cromer_Mann_a5 = (PDBjDict.some_float v) }
      | "pdbx_scat_Cromer_Mann_b5" -> { b with pdbx_scat_Cromer_Mann_b5 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("analytical_mass_percent", string_of_float v)) a.analytical_mass_percent;
      Option.map (fun v -> ("description",  v)) a.description;
      Option.map (fun v -> ("number_in_cell", string_of_int v)) a.number_in_cell;
      Option.map (fun v -> ("oxidation_number", string_of_int v)) a.oxidation_number;
      Option.map (fun v -> ("radius_bond", string_of_float v)) a.radius_bond;
      Option.map (fun v -> ("radius_contact", string_of_float v)) a.radius_contact;
      Option.map (fun v -> ("scat_Cromer_Mann_a1", string_of_float v)) a.scat_Cromer_Mann_a1;
      Option.map (fun v -> ("scat_Cromer_Mann_a2", string_of_float v)) a.scat_Cromer_Mann_a2;
      Option.map (fun v -> ("scat_Cromer_Mann_a3", string_of_float v)) a.scat_Cromer_Mann_a3;
      Option.map (fun v -> ("scat_Cromer_Mann_a4", string_of_float v)) a.scat_Cromer_Mann_a4;
      Option.map (fun v -> ("scat_Cromer_Mann_b1", string_of_float v)) a.scat_Cromer_Mann_b1;
      Option.map (fun v -> ("scat_Cromer_Mann_b2", string_of_float v)) a.scat_Cromer_Mann_b2;
      Option.map (fun v -> ("scat_Cromer_Mann_b3", string_of_float v)) a.scat_Cromer_Mann_b3;
      Option.map (fun v -> ("scat_Cromer_Mann_b4", string_of_float v)) a.scat_Cromer_Mann_b4;
      Option.map (fun v -> ("scat_Cromer_Mann_c", string_of_float v)) a.scat_Cromer_Mann_c;
      Option.map (fun v -> ("scat_dispersion_imag", string_of_float v)) a.scat_dispersion_imag;
      Option.map (fun v -> ("scat_dispersion_real", string_of_float v)) a.scat_dispersion_real;
      Option.map (fun v -> ("scat_length_neutron",  v)) a.scat_length_neutron;
      Option.map (fun v -> ("scat_source",  v)) a.scat_source;
      Option.map (fun v -> ("scat_versus_stol_list",  v)) a.scat_versus_stol_list;
      Option.map (fun v -> ("symbol",  v)) a.symbol;
      Option.map (fun v -> ("scat_dispersion_source",  v)) a.scat_dispersion_source;
      Option.map (fun v -> ("pdbx_scat_Cromer_Mann_a5", string_of_float v)) a.pdbx_scat_Cromer_Mann_a5;
      Option.map (fun v -> ("pdbx_scat_Cromer_Mann_b5", string_of_float v)) a.pdbx_scat_Cromer_Mann_b5;
    ]

end

module Audit = struct
  type t = {
    creation_date: string option;
    creation_method: string option;
    revision_id: string option;
    update_record: string option;
  }

  let default = {
    creation_date = None;
    creation_method = None;
    revision_id = None;
    update_record = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "creation_date" -> { b with creation_date = (Some v) }
      | "creation_method" -> { b with creation_method = (Some v) }
      | "revision_id" -> { b with revision_id = (Some v) }
      | "update_record" -> { b with update_record = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("creation_date",  v)) a.creation_date;
      Option.map (fun v -> ("creation_method",  v)) a.creation_method;
      Option.map (fun v -> ("revision_id",  v)) a.revision_id;
      Option.map (fun v -> ("update_record",  v)) a.update_record;
    ]

end

module Audit_author = struct
  type t = {
    address: string option;
    name: string option;
    pdbx_ordinal: int option;
    identifier_ORCID: string option;
  }

  let default = {
    address = None;
    name = None;
    pdbx_ordinal = None;
    identifier_ORCID = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "address" -> { b with address = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "pdbx_ordinal" -> { b with pdbx_ordinal = (PDBjDict.some_int v) }
      | "identifier_ORCID" -> { b with identifier_ORCID = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("address",  v)) a.address;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("pdbx_ordinal", string_of_int v)) a.pdbx_ordinal;
      Option.map (fun v -> ("identifier_ORCID",  v)) a.identifier_ORCID;
    ]

end

module Audit_conform = struct
  type t = {
    dict_location: string option;
    dict_name: string option;
    dict_version: string option;
  }

  let default = {
    dict_location = None;
    dict_name = None;
    dict_version = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "dict_location" -> { b with dict_location = (Some v) }
      | "dict_name" -> { b with dict_name = (Some v) }
      | "dict_version" -> { b with dict_version = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("dict_location",  v)) a.dict_location;
      Option.map (fun v -> ("dict_name",  v)) a.dict_name;
      Option.map (fun v -> ("dict_version",  v)) a.dict_version;
    ]

end

module Audit_contact_author = struct
  type t = {
    address: string option;
    email: string option;
    fax: string option;
    name: string option;
    phone: string option;
  }

  let default = {
    address = None;
    email = None;
    fax = None;
    name = None;
    phone = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "address" -> { b with address = (Some v) }
      | "email" -> { b with email = (Some v) }
      | "fax" -> { b with fax = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "phone" -> { b with phone = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("address",  v)) a.address;
      Option.map (fun v -> ("email",  v)) a.email;
      Option.map (fun v -> ("fax",  v)) a.fax;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("phone",  v)) a.phone;
    ]

end

module Cell = struct
  type t = {
    angle_alpha: float option;
    angle_alpha_esd: float option;
    angle_beta: float option;
    angle_beta_esd: float option;
    angle_gamma: float option;
    angle_gamma_esd: float option;
    entry_id: string option;
    details: string option;
    formula_units_Z: int option;
    length_a: float option;
    length_a_esd: float option;
    length_b: float option;
    length_b_esd: float option;
    length_c: float option;
    length_c_esd: float option;
    volume: float option;
    volume_esd: float option;
    z_PDB: int option;
    reciprocal_angle_alpha: float option;
    reciprocal_angle_beta: float option;
    reciprocal_angle_gamma: float option;
    reciprocal_angle_alpha_esd: float option;
    reciprocal_angle_beta_esd: float option;
    reciprocal_angle_gamma_esd: float option;
    reciprocal_length_a: float option;
    reciprocal_length_b: float option;
    reciprocal_length_c: float option;
    reciprocal_length_a_esd: float option;
    reciprocal_length_b_esd: float option;
    reciprocal_length_c_esd: float option;
    pdbx_unique_axis: string option;
  }

  let default = {
    angle_alpha = None;
    angle_alpha_esd = None;
    angle_beta = None;
    angle_beta_esd = None;
    angle_gamma = None;
    angle_gamma_esd = None;
    entry_id = None;
    details = None;
    formula_units_Z = None;
    length_a = None;
    length_a_esd = None;
    length_b = None;
    length_b_esd = None;
    length_c = None;
    length_c_esd = None;
    volume = None;
    volume_esd = None;
    z_PDB = None;
    reciprocal_angle_alpha = None;
    reciprocal_angle_beta = None;
    reciprocal_angle_gamma = None;
    reciprocal_angle_alpha_esd = None;
    reciprocal_angle_beta_esd = None;
    reciprocal_angle_gamma_esd = None;
    reciprocal_length_a = None;
    reciprocal_length_b = None;
    reciprocal_length_c = None;
    reciprocal_length_a_esd = None;
    reciprocal_length_b_esd = None;
    reciprocal_length_c_esd = None;
    pdbx_unique_axis = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "angle_alpha" -> { b with angle_alpha = (PDBjDict.some_float v) }
      | "angle_alpha_esd" -> { b with angle_alpha_esd = (PDBjDict.some_float v) }
      | "angle_beta" -> { b with angle_beta = (PDBjDict.some_float v) }
      | "angle_beta_esd" -> { b with angle_beta_esd = (PDBjDict.some_float v) }
      | "angle_gamma" -> { b with angle_gamma = (PDBjDict.some_float v) }
      | "angle_gamma_esd" -> { b with angle_gamma_esd = (PDBjDict.some_float v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "formula_units_Z" -> { b with formula_units_Z = (PDBjDict.some_int v) }
      | "length_a" -> { b with length_a = (PDBjDict.some_float v) }
      | "length_a_esd" -> { b with length_a_esd = (PDBjDict.some_float v) }
      | "length_b" -> { b with length_b = (PDBjDict.some_float v) }
      | "length_b_esd" -> { b with length_b_esd = (PDBjDict.some_float v) }
      | "length_c" -> { b with length_c = (PDBjDict.some_float v) }
      | "length_c_esd" -> { b with length_c_esd = (PDBjDict.some_float v) }
      | "volume" -> { b with volume = (PDBjDict.some_float v) }
      | "volume_esd" -> { b with volume_esd = (PDBjDict.some_float v) }
      | "Z_PDB" -> { b with z_PDB = (PDBjDict.some_int v) }
      | "reciprocal_angle_alpha" -> { b with reciprocal_angle_alpha = (PDBjDict.some_float v) }
      | "reciprocal_angle_beta" -> { b with reciprocal_angle_beta = (PDBjDict.some_float v) }
      | "reciprocal_angle_gamma" -> { b with reciprocal_angle_gamma = (PDBjDict.some_float v) }
      | "reciprocal_angle_alpha_esd" -> { b with reciprocal_angle_alpha_esd = (PDBjDict.some_float v) }
      | "reciprocal_angle_beta_esd" -> { b with reciprocal_angle_beta_esd = (PDBjDict.some_float v) }
      | "reciprocal_angle_gamma_esd" -> { b with reciprocal_angle_gamma_esd = (PDBjDict.some_float v) }
      | "reciprocal_length_a" -> { b with reciprocal_length_a = (PDBjDict.some_float v) }
      | "reciprocal_length_b" -> { b with reciprocal_length_b = (PDBjDict.some_float v) }
      | "reciprocal_length_c" -> { b with reciprocal_length_c = (PDBjDict.some_float v) }
      | "reciprocal_length_a_esd" -> { b with reciprocal_length_a_esd = (PDBjDict.some_float v) }
      | "reciprocal_length_b_esd" -> { b with reciprocal_length_b_esd = (PDBjDict.some_float v) }
      | "reciprocal_length_c_esd" -> { b with reciprocal_length_c_esd = (PDBjDict.some_float v) }
      | "pdbx_unique_axis" -> { b with pdbx_unique_axis = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("angle_alpha", string_of_float v)) a.angle_alpha;
      Option.map (fun v -> ("angle_alpha_esd", string_of_float v)) a.angle_alpha_esd;
      Option.map (fun v -> ("angle_beta", string_of_float v)) a.angle_beta;
      Option.map (fun v -> ("angle_beta_esd", string_of_float v)) a.angle_beta_esd;
      Option.map (fun v -> ("angle_gamma", string_of_float v)) a.angle_gamma;
      Option.map (fun v -> ("angle_gamma_esd", string_of_float v)) a.angle_gamma_esd;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("formula_units_Z", string_of_int v)) a.formula_units_Z;
      Option.map (fun v -> ("length_a", string_of_float v)) a.length_a;
      Option.map (fun v -> ("length_a_esd", string_of_float v)) a.length_a_esd;
      Option.map (fun v -> ("length_b", string_of_float v)) a.length_b;
      Option.map (fun v -> ("length_b_esd", string_of_float v)) a.length_b_esd;
      Option.map (fun v -> ("length_c", string_of_float v)) a.length_c;
      Option.map (fun v -> ("length_c_esd", string_of_float v)) a.length_c_esd;
      Option.map (fun v -> ("volume", string_of_float v)) a.volume;
      Option.map (fun v -> ("volume_esd", string_of_float v)) a.volume_esd;
      Option.map (fun v -> ("Z_PDB", string_of_int v)) a.z_PDB;
      Option.map (fun v -> ("reciprocal_angle_alpha", string_of_float v)) a.reciprocal_angle_alpha;
      Option.map (fun v -> ("reciprocal_angle_beta", string_of_float v)) a.reciprocal_angle_beta;
      Option.map (fun v -> ("reciprocal_angle_gamma", string_of_float v)) a.reciprocal_angle_gamma;
      Option.map (fun v -> ("reciprocal_angle_alpha_esd", string_of_float v)) a.reciprocal_angle_alpha_esd;
      Option.map (fun v -> ("reciprocal_angle_beta_esd", string_of_float v)) a.reciprocal_angle_beta_esd;
      Option.map (fun v -> ("reciprocal_angle_gamma_esd", string_of_float v)) a.reciprocal_angle_gamma_esd;
      Option.map (fun v -> ("reciprocal_length_a", string_of_float v)) a.reciprocal_length_a;
      Option.map (fun v -> ("reciprocal_length_b", string_of_float v)) a.reciprocal_length_b;
      Option.map (fun v -> ("reciprocal_length_c", string_of_float v)) a.reciprocal_length_c;
      Option.map (fun v -> ("reciprocal_length_a_esd", string_of_float v)) a.reciprocal_length_a_esd;
      Option.map (fun v -> ("reciprocal_length_b_esd", string_of_float v)) a.reciprocal_length_b_esd;
      Option.map (fun v -> ("reciprocal_length_c_esd", string_of_float v)) a.reciprocal_length_c_esd;
      Option.map (fun v -> ("pdbx_unique_axis",  v)) a.pdbx_unique_axis;
    ]

end

module Cell_measurement = struct
  type t = {
    entry_id: string option;
    pressure: float option;
    pressure_esd: float option;
    radiation: string option;
    reflns_used: int option;
    temp: float option;
    temp_esd: float option;
    theta_max: float option;
    theta_min: float option;
    wavelength: float option;
  }

  let default = {
    entry_id = None;
    pressure = None;
    pressure_esd = None;
    radiation = None;
    reflns_used = None;
    temp = None;
    temp_esd = None;
    theta_max = None;
    theta_min = None;
    wavelength = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "pressure" -> { b with pressure = (PDBjDict.some_float v) }
      | "pressure_esd" -> { b with pressure_esd = (PDBjDict.some_float v) }
      | "radiation" -> { b with radiation = (Some v) }
      | "reflns_used" -> { b with reflns_used = (PDBjDict.some_int v) }
      | "temp" -> { b with temp = (PDBjDict.some_float v) }
      | "temp_esd" -> { b with temp_esd = (PDBjDict.some_float v) }
      | "theta_max" -> { b with theta_max = (PDBjDict.some_float v) }
      | "theta_min" -> { b with theta_min = (PDBjDict.some_float v) }
      | "wavelength" -> { b with wavelength = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("pressure", string_of_float v)) a.pressure;
      Option.map (fun v -> ("pressure_esd", string_of_float v)) a.pressure_esd;
      Option.map (fun v -> ("radiation",  v)) a.radiation;
      Option.map (fun v -> ("reflns_used", string_of_int v)) a.reflns_used;
      Option.map (fun v -> ("temp", string_of_float v)) a.temp;
      Option.map (fun v -> ("temp_esd", string_of_float v)) a.temp_esd;
      Option.map (fun v -> ("theta_max", string_of_float v)) a.theta_max;
      Option.map (fun v -> ("theta_min", string_of_float v)) a.theta_min;
      Option.map (fun v -> ("wavelength", string_of_float v)) a.wavelength;
    ]

end

module Cell_measurement_refln = struct
  type t = {
    index_h: int option;
    index_k: int option;
    index_l: int option;
    theta: float option;
  }

  let default = {
    index_h = None;
    index_k = None;
    index_l = None;
    theta = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "index_h" -> { b with index_h = (PDBjDict.some_int v) }
      | "index_k" -> { b with index_k = (PDBjDict.some_int v) }
      | "index_l" -> { b with index_l = (PDBjDict.some_int v) }
      | "theta" -> { b with theta = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("index_h", string_of_int v)) a.index_h;
      Option.map (fun v -> ("index_k", string_of_int v)) a.index_k;
      Option.map (fun v -> ("index_l", string_of_int v)) a.index_l;
      Option.map (fun v -> ("theta", string_of_float v)) a.theta;
    ]

end

module Chem_comp = struct
  type t = {
    formula: string option;
    formula_weight: float option;
    id: string option;
    model_details: string option;
    model_erf: string option;
    model_source: string option;
    mon_nstd_class: string option;
    mon_nstd_details: string option;
    mon_nstd_flag: string option;
    mon_nstd_parent: string option;
    mon_nstd_parent_comp_id: string option;
    name: string option;
    number_atoms_all: int option;
    number_atoms_nh: int option;
    one_letter_code: string option;
    three_letter_code: string option;
    type_: string option;
    pdbx_synonyms: string option;
    pdbx_modification_details: string option;
    pdbx_component_no: int option;
    pdbx_type: string option;
    pdbx_ambiguous_flag: string option;
    pdbx_replaced_by: string option;
    pdbx_replaces: string option;
    pdbx_formal_charge: int option;
    pdbx_subcomponent_list: string option;
    pdbx_model_coordinates_details: string option;
    pdbx_model_coordinates_db_code: string option;
    pdbx_ideal_coordinates_details: string option;
    pdbx_ideal_coordinates_missing_flag: string option;
    pdbx_model_coordinates_missing_flag: string option;
    pdbx_initial_date: string option;
    pdbx_modified_date: string option;
    pdbx_release_status: string option;
    pdbx_processing_site: string option;
    pdbx_number_subcomponents: int option;
    pdbx_class_1: string option;
    pdbx_class_2: string option;
    pdbx_comp_type: string option;
    pdbx_reserved_name: string option;
    pdbx_status: string option;
    pdbx_type_modified: int option;
    pdbx_casnum: string option;
    pdbx_smiles: string option;
    pdbx_nscnum: string option;
  }

  let default = {
    formula = None;
    formula_weight = None;
    id = None;
    model_details = None;
    model_erf = None;
    model_source = None;
    mon_nstd_class = None;
    mon_nstd_details = None;
    mon_nstd_flag = None;
    mon_nstd_parent = None;
    mon_nstd_parent_comp_id = None;
    name = None;
    number_atoms_all = None;
    number_atoms_nh = None;
    one_letter_code = None;
    three_letter_code = None;
    type_ = None;
    pdbx_synonyms = None;
    pdbx_modification_details = None;
    pdbx_component_no = None;
    pdbx_type = None;
    pdbx_ambiguous_flag = None;
    pdbx_replaced_by = None;
    pdbx_replaces = None;
    pdbx_formal_charge = None;
    pdbx_subcomponent_list = None;
    pdbx_model_coordinates_details = None;
    pdbx_model_coordinates_db_code = None;
    pdbx_ideal_coordinates_details = None;
    pdbx_ideal_coordinates_missing_flag = None;
    pdbx_model_coordinates_missing_flag = None;
    pdbx_initial_date = None;
    pdbx_modified_date = None;
    pdbx_release_status = None;
    pdbx_processing_site = None;
    pdbx_number_subcomponents = None;
    pdbx_class_1 = None;
    pdbx_class_2 = None;
    pdbx_comp_type = None;
    pdbx_reserved_name = None;
    pdbx_status = None;
    pdbx_type_modified = None;
    pdbx_casnum = None;
    pdbx_smiles = None;
    pdbx_nscnum = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "formula" -> { b with formula = (Some v) }
      | "formula_weight" -> { b with formula_weight = (PDBjDict.some_float v) }
      | "id" -> { b with id = (Some v) }
      | "model_details" -> { b with model_details = (Some v) }
      | "model_erf" -> { b with model_erf = (Some v) }
      | "model_source" -> { b with model_source = (Some v) }
      | "mon_nstd_class" -> { b with mon_nstd_class = (Some v) }
      | "mon_nstd_details" -> { b with mon_nstd_details = (Some v) }
      | "mon_nstd_flag" -> { b with mon_nstd_flag = (Some v) }
      | "mon_nstd_parent" -> { b with mon_nstd_parent = (Some v) }
      | "mon_nstd_parent_comp_id" -> { b with mon_nstd_parent_comp_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "number_atoms_all" -> { b with number_atoms_all = (PDBjDict.some_int v) }
      | "number_atoms_nh" -> { b with number_atoms_nh = (PDBjDict.some_int v) }
      | "one_letter_code" -> { b with one_letter_code = (Some v) }
      | "three_letter_code" -> { b with three_letter_code = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "pdbx_synonyms" -> { b with pdbx_synonyms = (Some v) }
      | "pdbx_modification_details" -> { b with pdbx_modification_details = (Some v) }
      | "pdbx_component_no" -> { b with pdbx_component_no = (PDBjDict.some_int v) }
      | "pdbx_type" -> { b with pdbx_type = (Some v) }
      | "pdbx_ambiguous_flag" -> { b with pdbx_ambiguous_flag = (Some v) }
      | "pdbx_replaced_by" -> { b with pdbx_replaced_by = (Some v) }
      | "pdbx_replaces" -> { b with pdbx_replaces = (Some v) }
      | "pdbx_formal_charge" -> { b with pdbx_formal_charge = (PDBjDict.some_int v) }
      | "pdbx_subcomponent_list" -> { b with pdbx_subcomponent_list = (Some v) }
      | "pdbx_model_coordinates_details" -> { b with pdbx_model_coordinates_details = (Some v) }
      | "pdbx_model_coordinates_db_code" -> { b with pdbx_model_coordinates_db_code = (Some v) }
      | "pdbx_ideal_coordinates_details" -> { b with pdbx_ideal_coordinates_details = (Some v) }
      | "pdbx_ideal_coordinates_missing_flag" -> { b with pdbx_ideal_coordinates_missing_flag = (Some v) }
      | "pdbx_model_coordinates_missing_flag" -> { b with pdbx_model_coordinates_missing_flag = (Some v) }
      | "pdbx_initial_date" -> { b with pdbx_initial_date = (Some v) }
      | "pdbx_modified_date" -> { b with pdbx_modified_date = (Some v) }
      | "pdbx_release_status" -> { b with pdbx_release_status = (Some v) }
      | "pdbx_processing_site" -> { b with pdbx_processing_site = (Some v) }
      | "pdbx_number_subcomponents" -> { b with pdbx_number_subcomponents = (PDBjDict.some_int v) }
      | "pdbx_class_1" -> { b with pdbx_class_1 = (Some v) }
      | "pdbx_class_2" -> { b with pdbx_class_2 = (Some v) }
      | "pdbx_comp_type" -> { b with pdbx_comp_type = (Some v) }
      | "pdbx_reserved_name" -> { b with pdbx_reserved_name = (Some v) }
      | "pdbx_status" -> { b with pdbx_status = (Some v) }
      | "pdbx_type_modified" -> { b with pdbx_type_modified = (PDBjDict.some_int v) }
      | "pdbx_casnum" -> { b with pdbx_casnum = (Some v) }
      | "pdbx_smiles" -> { b with pdbx_smiles = (Some v) }
      | "pdbx_nscnum" -> { b with pdbx_nscnum = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("formula",  v)) a.formula;
      Option.map (fun v -> ("formula_weight", string_of_float v)) a.formula_weight;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("model_details",  v)) a.model_details;
      Option.map (fun v -> ("model_erf",  v)) a.model_erf;
      Option.map (fun v -> ("model_source",  v)) a.model_source;
      Option.map (fun v -> ("mon_nstd_class",  v)) a.mon_nstd_class;
      Option.map (fun v -> ("mon_nstd_details",  v)) a.mon_nstd_details;
      Option.map (fun v -> ("mon_nstd_flag",  v)) a.mon_nstd_flag;
      Option.map (fun v -> ("mon_nstd_parent",  v)) a.mon_nstd_parent;
      Option.map (fun v -> ("mon_nstd_parent_comp_id",  v)) a.mon_nstd_parent_comp_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("number_atoms_all", string_of_int v)) a.number_atoms_all;
      Option.map (fun v -> ("number_atoms_nh", string_of_int v)) a.number_atoms_nh;
      Option.map (fun v -> ("one_letter_code",  v)) a.one_letter_code;
      Option.map (fun v -> ("three_letter_code",  v)) a.three_letter_code;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("pdbx_synonyms",  v)) a.pdbx_synonyms;
      Option.map (fun v -> ("pdbx_modification_details",  v)) a.pdbx_modification_details;
      Option.map (fun v -> ("pdbx_component_no", string_of_int v)) a.pdbx_component_no;
      Option.map (fun v -> ("pdbx_type",  v)) a.pdbx_type;
      Option.map (fun v -> ("pdbx_ambiguous_flag",  v)) a.pdbx_ambiguous_flag;
      Option.map (fun v -> ("pdbx_replaced_by",  v)) a.pdbx_replaced_by;
      Option.map (fun v -> ("pdbx_replaces",  v)) a.pdbx_replaces;
      Option.map (fun v -> ("pdbx_formal_charge", string_of_int v)) a.pdbx_formal_charge;
      Option.map (fun v -> ("pdbx_subcomponent_list",  v)) a.pdbx_subcomponent_list;
      Option.map (fun v -> ("pdbx_model_coordinates_details",  v)) a.pdbx_model_coordinates_details;
      Option.map (fun v -> ("pdbx_model_coordinates_db_code",  v)) a.pdbx_model_coordinates_db_code;
      Option.map (fun v -> ("pdbx_ideal_coordinates_details",  v)) a.pdbx_ideal_coordinates_details;
      Option.map (fun v -> ("pdbx_ideal_coordinates_missing_flag",  v)) a.pdbx_ideal_coordinates_missing_flag;
      Option.map (fun v -> ("pdbx_model_coordinates_missing_flag",  v)) a.pdbx_model_coordinates_missing_flag;
      Option.map (fun v -> ("pdbx_initial_date",  v)) a.pdbx_initial_date;
      Option.map (fun v -> ("pdbx_modified_date",  v)) a.pdbx_modified_date;
      Option.map (fun v -> ("pdbx_release_status",  v)) a.pdbx_release_status;
      Option.map (fun v -> ("pdbx_processing_site",  v)) a.pdbx_processing_site;
      Option.map (fun v -> ("pdbx_number_subcomponents", string_of_int v)) a.pdbx_number_subcomponents;
      Option.map (fun v -> ("pdbx_class_1",  v)) a.pdbx_class_1;
      Option.map (fun v -> ("pdbx_class_2",  v)) a.pdbx_class_2;
      Option.map (fun v -> ("pdbx_comp_type",  v)) a.pdbx_comp_type;
      Option.map (fun v -> ("pdbx_reserved_name",  v)) a.pdbx_reserved_name;
      Option.map (fun v -> ("pdbx_status",  v)) a.pdbx_status;
      Option.map (fun v -> ("pdbx_type_modified", string_of_int v)) a.pdbx_type_modified;
      Option.map (fun v -> ("pdbx_casnum",  v)) a.pdbx_casnum;
      Option.map (fun v -> ("pdbx_smiles",  v)) a.pdbx_smiles;
      Option.map (fun v -> ("pdbx_nscnum",  v)) a.pdbx_nscnum;
    ]

end

module Chem_comp_angle = struct
  type t = {
    atom_id_1: string option;
    atom_id_2: string option;
    atom_id_3: string option;
    comp_id: string option;
    value_angle: float option;
    value_angle_esd: float option;
    value_dist: float option;
    value_dist_esd: float option;
  }

  let default = {
    atom_id_1 = None;
    atom_id_2 = None;
    atom_id_3 = None;
    comp_id = None;
    value_angle = None;
    value_angle_esd = None;
    value_dist = None;
    value_dist_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "atom_id_3" -> { b with atom_id_3 = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "value_angle" -> { b with value_angle = (PDBjDict.some_float v) }
      | "value_angle_esd" -> { b with value_angle_esd = (PDBjDict.some_float v) }
      | "value_dist" -> { b with value_dist = (PDBjDict.some_float v) }
      | "value_dist_esd" -> { b with value_dist_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("atom_id_3",  v)) a.atom_id_3;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("value_angle", string_of_float v)) a.value_angle;
      Option.map (fun v -> ("value_angle_esd", string_of_float v)) a.value_angle_esd;
      Option.map (fun v -> ("value_dist", string_of_float v)) a.value_dist;
      Option.map (fun v -> ("value_dist_esd", string_of_float v)) a.value_dist_esd;
    ]

end

module Chem_comp_atom = struct
  type t = {
    alt_atom_id: string option;
    atom_id: string option;
    charge: int option;
    model_Cartn_x: float option;
    model_Cartn_x_esd: float option;
    model_Cartn_y: float option;
    model_Cartn_y_esd: float option;
    model_Cartn_z: float option;
    model_Cartn_z_esd: float option;
    comp_id: string option;
    partial_charge: float option;
    substruct_code: string option;
    type_symbol: string option;
    pdbx_align: int option;
    pdbx_ordinal: int option;
    pdbx_component_atom_id: string option;
    pdbx_component_comp_id: string option;
    pdbx_alt_atom_id: string option;
    pdbx_alt_comp_id: string option;
    pdbx_model_Cartn_x_ideal: float option;
    pdbx_model_Cartn_y_ideal: float option;
    pdbx_model_Cartn_z_ideal: float option;
    pdbx_stereo_config: string option;
    pdbx_aromatic_flag: string option;
    pdbx_leaving_atom_flag: string option;
    pdbx_residue_numbering: int option;
    pdbx_polymer_type: string option;
    pdbx_ref_id: string option;
    pdbx_component_id: int option;
    pdbx_component_entity_id: int option;
  }

  let default = {
    alt_atom_id = None;
    atom_id = None;
    charge = None;
    model_Cartn_x = None;
    model_Cartn_x_esd = None;
    model_Cartn_y = None;
    model_Cartn_y_esd = None;
    model_Cartn_z = None;
    model_Cartn_z_esd = None;
    comp_id = None;
    partial_charge = None;
    substruct_code = None;
    type_symbol = None;
    pdbx_align = None;
    pdbx_ordinal = None;
    pdbx_component_atom_id = None;
    pdbx_component_comp_id = None;
    pdbx_alt_atom_id = None;
    pdbx_alt_comp_id = None;
    pdbx_model_Cartn_x_ideal = None;
    pdbx_model_Cartn_y_ideal = None;
    pdbx_model_Cartn_z_ideal = None;
    pdbx_stereo_config = None;
    pdbx_aromatic_flag = None;
    pdbx_leaving_atom_flag = None;
    pdbx_residue_numbering = None;
    pdbx_polymer_type = None;
    pdbx_ref_id = None;
    pdbx_component_id = None;
    pdbx_component_entity_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "alt_atom_id" -> { b with alt_atom_id = (Some v) }
      | "atom_id" -> { b with atom_id = (Some v) }
      | "charge" -> { b with charge = (PDBjDict.some_int v) }
      | "model_Cartn_x" -> { b with model_Cartn_x = (PDBjDict.some_float v) }
      | "model_Cartn_x_esd" -> { b with model_Cartn_x_esd = (PDBjDict.some_float v) }
      | "model_Cartn_y" -> { b with model_Cartn_y = (PDBjDict.some_float v) }
      | "model_Cartn_y_esd" -> { b with model_Cartn_y_esd = (PDBjDict.some_float v) }
      | "model_Cartn_z" -> { b with model_Cartn_z = (PDBjDict.some_float v) }
      | "model_Cartn_z_esd" -> { b with model_Cartn_z_esd = (PDBjDict.some_float v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "partial_charge" -> { b with partial_charge = (PDBjDict.some_float v) }
      | "substruct_code" -> { b with substruct_code = (Some v) }
      | "type_symbol" -> { b with type_symbol = (Some v) }
      | "pdbx_align" -> { b with pdbx_align = (PDBjDict.some_int v) }
      | "pdbx_ordinal" -> { b with pdbx_ordinal = (PDBjDict.some_int v) }
      | "pdbx_component_atom_id" -> { b with pdbx_component_atom_id = (Some v) }
      | "pdbx_component_comp_id" -> { b with pdbx_component_comp_id = (Some v) }
      | "pdbx_alt_atom_id" -> { b with pdbx_alt_atom_id = (Some v) }
      | "pdbx_alt_comp_id" -> { b with pdbx_alt_comp_id = (Some v) }
      | "pdbx_model_Cartn_x_ideal" -> { b with pdbx_model_Cartn_x_ideal = (PDBjDict.some_float v) }
      | "pdbx_model_Cartn_y_ideal" -> { b with pdbx_model_Cartn_y_ideal = (PDBjDict.some_float v) }
      | "pdbx_model_Cartn_z_ideal" -> { b with pdbx_model_Cartn_z_ideal = (PDBjDict.some_float v) }
      | "pdbx_stereo_config" -> { b with pdbx_stereo_config = (Some v) }
      | "pdbx_aromatic_flag" -> { b with pdbx_aromatic_flag = (Some v) }
      | "pdbx_leaving_atom_flag" -> { b with pdbx_leaving_atom_flag = (Some v) }
      | "pdbx_residue_numbering" -> { b with pdbx_residue_numbering = (PDBjDict.some_int v) }
      | "pdbx_polymer_type" -> { b with pdbx_polymer_type = (Some v) }
      | "pdbx_ref_id" -> { b with pdbx_ref_id = (Some v) }
      | "pdbx_component_id" -> { b with pdbx_component_id = (PDBjDict.some_int v) }
      | "pdbx_component_entity_id" -> { b with pdbx_component_entity_id = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("alt_atom_id",  v)) a.alt_atom_id;
      Option.map (fun v -> ("atom_id",  v)) a.atom_id;
      Option.map (fun v -> ("charge", string_of_int v)) a.charge;
      Option.map (fun v -> ("model_Cartn_x", string_of_float v)) a.model_Cartn_x;
      Option.map (fun v -> ("model_Cartn_x_esd", string_of_float v)) a.model_Cartn_x_esd;
      Option.map (fun v -> ("model_Cartn_y", string_of_float v)) a.model_Cartn_y;
      Option.map (fun v -> ("model_Cartn_y_esd", string_of_float v)) a.model_Cartn_y_esd;
      Option.map (fun v -> ("model_Cartn_z", string_of_float v)) a.model_Cartn_z;
      Option.map (fun v -> ("model_Cartn_z_esd", string_of_float v)) a.model_Cartn_z_esd;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("partial_charge", string_of_float v)) a.partial_charge;
      Option.map (fun v -> ("substruct_code",  v)) a.substruct_code;
      Option.map (fun v -> ("type_symbol",  v)) a.type_symbol;
      Option.map (fun v -> ("pdbx_align", string_of_int v)) a.pdbx_align;
      Option.map (fun v -> ("pdbx_ordinal", string_of_int v)) a.pdbx_ordinal;
      Option.map (fun v -> ("pdbx_component_atom_id",  v)) a.pdbx_component_atom_id;
      Option.map (fun v -> ("pdbx_component_comp_id",  v)) a.pdbx_component_comp_id;
      Option.map (fun v -> ("pdbx_alt_atom_id",  v)) a.pdbx_alt_atom_id;
      Option.map (fun v -> ("pdbx_alt_comp_id",  v)) a.pdbx_alt_comp_id;
      Option.map (fun v -> ("pdbx_model_Cartn_x_ideal", string_of_float v)) a.pdbx_model_Cartn_x_ideal;
      Option.map (fun v -> ("pdbx_model_Cartn_y_ideal", string_of_float v)) a.pdbx_model_Cartn_y_ideal;
      Option.map (fun v -> ("pdbx_model_Cartn_z_ideal", string_of_float v)) a.pdbx_model_Cartn_z_ideal;
      Option.map (fun v -> ("pdbx_stereo_config",  v)) a.pdbx_stereo_config;
      Option.map (fun v -> ("pdbx_aromatic_flag",  v)) a.pdbx_aromatic_flag;
      Option.map (fun v -> ("pdbx_leaving_atom_flag",  v)) a.pdbx_leaving_atom_flag;
      Option.map (fun v -> ("pdbx_residue_numbering", string_of_int v)) a.pdbx_residue_numbering;
      Option.map (fun v -> ("pdbx_polymer_type",  v)) a.pdbx_polymer_type;
      Option.map (fun v -> ("pdbx_ref_id",  v)) a.pdbx_ref_id;
      Option.map (fun v -> ("pdbx_component_id", string_of_int v)) a.pdbx_component_id;
      Option.map (fun v -> ("pdbx_component_entity_id", string_of_int v)) a.pdbx_component_entity_id;
    ]

end

module Chem_comp_bond = struct
  type t = {
    atom_id_1: string option;
    atom_id_2: string option;
    comp_id: string option;
    value_order: string option;
    value_dist: float option;
    value_dist_esd: float option;
    pdbx_ordinal: int option;
    pdbx_stereo_config: string option;
    pdbx_aromatic_flag: string option;
  }

  let default = {
    atom_id_1 = None;
    atom_id_2 = None;
    comp_id = None;
    value_order = None;
    value_dist = None;
    value_dist_esd = None;
    pdbx_ordinal = None;
    pdbx_stereo_config = None;
    pdbx_aromatic_flag = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "value_order" -> { b with value_order = (Some v) }
      | "value_dist" -> { b with value_dist = (PDBjDict.some_float v) }
      | "value_dist_esd" -> { b with value_dist_esd = (PDBjDict.some_float v) }
      | "pdbx_ordinal" -> { b with pdbx_ordinal = (PDBjDict.some_int v) }
      | "pdbx_stereo_config" -> { b with pdbx_stereo_config = (Some v) }
      | "pdbx_aromatic_flag" -> { b with pdbx_aromatic_flag = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("value_order",  v)) a.value_order;
      Option.map (fun v -> ("value_dist", string_of_float v)) a.value_dist;
      Option.map (fun v -> ("value_dist_esd", string_of_float v)) a.value_dist_esd;
      Option.map (fun v -> ("pdbx_ordinal", string_of_int v)) a.pdbx_ordinal;
      Option.map (fun v -> ("pdbx_stereo_config",  v)) a.pdbx_stereo_config;
      Option.map (fun v -> ("pdbx_aromatic_flag",  v)) a.pdbx_aromatic_flag;
    ]

end

module Chem_comp_chir = struct
  type t = {
    atom_id: string option;
    atom_config: string option;
    id: string option;
    comp_id: string option;
    number_atoms_all: int option;
    number_atoms_nh: int option;
    volume_flag: string option;
    volume_three: float option;
    volume_three_esd: float option;
  }

  let default = {
    atom_id = None;
    atom_config = None;
    id = None;
    comp_id = None;
    number_atoms_all = None;
    number_atoms_nh = None;
    volume_flag = None;
    volume_three = None;
    volume_three_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_id" -> { b with atom_id = (Some v) }
      | "atom_config" -> { b with atom_config = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "number_atoms_all" -> { b with number_atoms_all = (PDBjDict.some_int v) }
      | "number_atoms_nh" -> { b with number_atoms_nh = (PDBjDict.some_int v) }
      | "volume_flag" -> { b with volume_flag = (Some v) }
      | "volume_three" -> { b with volume_three = (PDBjDict.some_float v) }
      | "volume_three_esd" -> { b with volume_three_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_id",  v)) a.atom_id;
      Option.map (fun v -> ("atom_config",  v)) a.atom_config;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("number_atoms_all", string_of_int v)) a.number_atoms_all;
      Option.map (fun v -> ("number_atoms_nh", string_of_int v)) a.number_atoms_nh;
      Option.map (fun v -> ("volume_flag",  v)) a.volume_flag;
      Option.map (fun v -> ("volume_three", string_of_float v)) a.volume_three;
      Option.map (fun v -> ("volume_three_esd", string_of_float v)) a.volume_three_esd;
    ]

end

module Chem_comp_chir_atom = struct
  type t = {
    atom_id: string option;
    chir_id: string option;
    comp_id: string option;
    dev: float option;
  }

  let default = {
    atom_id = None;
    chir_id = None;
    comp_id = None;
    dev = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_id" -> { b with atom_id = (Some v) }
      | "chir_id" -> { b with chir_id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "dev" -> { b with dev = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_id",  v)) a.atom_id;
      Option.map (fun v -> ("chir_id",  v)) a.chir_id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("dev", string_of_float v)) a.dev;
    ]

end

module Chem_comp_link = struct
  type t = {
    link_id: string option;
    details: string option;
    type_comp_1: string option;
    type_comp_2: string option;
  }

  let default = {
    link_id = None;
    details = None;
    type_comp_1 = None;
    type_comp_2 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "link_id" -> { b with link_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "type_comp_1" -> { b with type_comp_1 = (Some v) }
      | "type_comp_2" -> { b with type_comp_2 = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("link_id",  v)) a.link_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("type_comp_1",  v)) a.type_comp_1;
      Option.map (fun v -> ("type_comp_2",  v)) a.type_comp_2;
    ]

end

module Chem_comp_plane = struct
  type t = {
    id: string option;
    comp_id: string option;
    number_atoms_all: int option;
    number_atoms_nh: int option;
  }

  let default = {
    id = None;
    comp_id = None;
    number_atoms_all = None;
    number_atoms_nh = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "number_atoms_all" -> { b with number_atoms_all = (PDBjDict.some_int v) }
      | "number_atoms_nh" -> { b with number_atoms_nh = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("number_atoms_all", string_of_int v)) a.number_atoms_all;
      Option.map (fun v -> ("number_atoms_nh", string_of_int v)) a.number_atoms_nh;
    ]

end

module Chem_comp_plane_atom = struct
  type t = {
    atom_id: string option;
    comp_id: string option;
    plane_id: string option;
    dist_esd: float option;
  }

  let default = {
    atom_id = None;
    comp_id = None;
    plane_id = None;
    dist_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_id" -> { b with atom_id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "plane_id" -> { b with plane_id = (Some v) }
      | "dist_esd" -> { b with dist_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_id",  v)) a.atom_id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("plane_id",  v)) a.plane_id;
      Option.map (fun v -> ("dist_esd", string_of_float v)) a.dist_esd;
    ]

end

module Chem_comp_tor = struct
  type t = {
    atom_id_1: string option;
    atom_id_2: string option;
    atom_id_3: string option;
    atom_id_4: string option;
    id: string option;
    comp_id: string option;
  }

  let default = {
    atom_id_1 = None;
    atom_id_2 = None;
    atom_id_3 = None;
    atom_id_4 = None;
    id = None;
    comp_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "atom_id_3" -> { b with atom_id_3 = (Some v) }
      | "atom_id_4" -> { b with atom_id_4 = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("atom_id_3",  v)) a.atom_id_3;
      Option.map (fun v -> ("atom_id_4",  v)) a.atom_id_4;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
    ]

end

module Chem_comp_tor_value = struct
  type t = {
    comp_id: string option;
    tor_id: string option;
    angle: float option;
    angle_esd: float option;
    dist: float option;
    dist_esd: float option;
  }

  let default = {
    comp_id = None;
    tor_id = None;
    angle = None;
    angle_esd = None;
    dist = None;
    dist_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "comp_id" -> { b with comp_id = (Some v) }
      | "tor_id" -> { b with tor_id = (Some v) }
      | "angle" -> { b with angle = (PDBjDict.some_float v) }
      | "angle_esd" -> { b with angle_esd = (PDBjDict.some_float v) }
      | "dist" -> { b with dist = (PDBjDict.some_float v) }
      | "dist_esd" -> { b with dist_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("tor_id",  v)) a.tor_id;
      Option.map (fun v -> ("angle", string_of_float v)) a.angle;
      Option.map (fun v -> ("angle_esd", string_of_float v)) a.angle_esd;
      Option.map (fun v -> ("dist", string_of_float v)) a.dist;
      Option.map (fun v -> ("dist_esd", string_of_float v)) a.dist_esd;
    ]

end

module Chem_link = struct
  type t = {
    id: string option;
    details: string option;
  }

  let default = {
    id = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Chem_link_angle = struct
  type t = {
    atom_1_comp_id: string option;
    atom_2_comp_id: string option;
    atom_3_comp_id: string option;
    atom_id_1: string option;
    atom_id_2: string option;
    atom_id_3: string option;
    link_id: string option;
    value_angle: float option;
    value_angle_esd: float option;
    value_dist: float option;
    value_dist_esd: float option;
  }

  let default = {
    atom_1_comp_id = None;
    atom_2_comp_id = None;
    atom_3_comp_id = None;
    atom_id_1 = None;
    atom_id_2 = None;
    atom_id_3 = None;
    link_id = None;
    value_angle = None;
    value_angle_esd = None;
    value_dist = None;
    value_dist_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_1_comp_id" -> { b with atom_1_comp_id = (Some v) }
      | "atom_2_comp_id" -> { b with atom_2_comp_id = (Some v) }
      | "atom_3_comp_id" -> { b with atom_3_comp_id = (Some v) }
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "atom_id_3" -> { b with atom_id_3 = (Some v) }
      | "link_id" -> { b with link_id = (Some v) }
      | "value_angle" -> { b with value_angle = (PDBjDict.some_float v) }
      | "value_angle_esd" -> { b with value_angle_esd = (PDBjDict.some_float v) }
      | "value_dist" -> { b with value_dist = (PDBjDict.some_float v) }
      | "value_dist_esd" -> { b with value_dist_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_1_comp_id",  v)) a.atom_1_comp_id;
      Option.map (fun v -> ("atom_2_comp_id",  v)) a.atom_2_comp_id;
      Option.map (fun v -> ("atom_3_comp_id",  v)) a.atom_3_comp_id;
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("atom_id_3",  v)) a.atom_id_3;
      Option.map (fun v -> ("link_id",  v)) a.link_id;
      Option.map (fun v -> ("value_angle", string_of_float v)) a.value_angle;
      Option.map (fun v -> ("value_angle_esd", string_of_float v)) a.value_angle_esd;
      Option.map (fun v -> ("value_dist", string_of_float v)) a.value_dist;
      Option.map (fun v -> ("value_dist_esd", string_of_float v)) a.value_dist_esd;
    ]

end

module Chem_link_bond = struct
  type t = {
    atom_1_comp_id: string option;
    atom_2_comp_id: string option;
    atom_id_1: string option;
    atom_id_2: string option;
    link_id: string option;
    value_dist: float option;
    value_dist_esd: float option;
    value_order: string option;
  }

  let default = {
    atom_1_comp_id = None;
    atom_2_comp_id = None;
    atom_id_1 = None;
    atom_id_2 = None;
    link_id = None;
    value_dist = None;
    value_dist_esd = None;
    value_order = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_1_comp_id" -> { b with atom_1_comp_id = (Some v) }
      | "atom_2_comp_id" -> { b with atom_2_comp_id = (Some v) }
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "link_id" -> { b with link_id = (Some v) }
      | "value_dist" -> { b with value_dist = (PDBjDict.some_float v) }
      | "value_dist_esd" -> { b with value_dist_esd = (PDBjDict.some_float v) }
      | "value_order" -> { b with value_order = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_1_comp_id",  v)) a.atom_1_comp_id;
      Option.map (fun v -> ("atom_2_comp_id",  v)) a.atom_2_comp_id;
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("link_id",  v)) a.link_id;
      Option.map (fun v -> ("value_dist", string_of_float v)) a.value_dist;
      Option.map (fun v -> ("value_dist_esd", string_of_float v)) a.value_dist_esd;
      Option.map (fun v -> ("value_order",  v)) a.value_order;
    ]

end

module Chem_link_chir = struct
  type t = {
    atom_comp_id: string option;
    atom_id: string option;
    atom_config: string option;
    id: string option;
    link_id: string option;
    number_atoms_all: int option;
    number_atoms_nh: int option;
    volume_flag: string option;
    volume_three: float option;
    volume_three_esd: float option;
  }

  let default = {
    atom_comp_id = None;
    atom_id = None;
    atom_config = None;
    id = None;
    link_id = None;
    number_atoms_all = None;
    number_atoms_nh = None;
    volume_flag = None;
    volume_three = None;
    volume_three_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_comp_id" -> { b with atom_comp_id = (Some v) }
      | "atom_id" -> { b with atom_id = (Some v) }
      | "atom_config" -> { b with atom_config = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "link_id" -> { b with link_id = (Some v) }
      | "number_atoms_all" -> { b with number_atoms_all = (PDBjDict.some_int v) }
      | "number_atoms_nh" -> { b with number_atoms_nh = (PDBjDict.some_int v) }
      | "volume_flag" -> { b with volume_flag = (Some v) }
      | "volume_three" -> { b with volume_three = (PDBjDict.some_float v) }
      | "volume_three_esd" -> { b with volume_three_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_comp_id",  v)) a.atom_comp_id;
      Option.map (fun v -> ("atom_id",  v)) a.atom_id;
      Option.map (fun v -> ("atom_config",  v)) a.atom_config;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("link_id",  v)) a.link_id;
      Option.map (fun v -> ("number_atoms_all", string_of_int v)) a.number_atoms_all;
      Option.map (fun v -> ("number_atoms_nh", string_of_int v)) a.number_atoms_nh;
      Option.map (fun v -> ("volume_flag",  v)) a.volume_flag;
      Option.map (fun v -> ("volume_three", string_of_float v)) a.volume_three;
      Option.map (fun v -> ("volume_three_esd", string_of_float v)) a.volume_three_esd;
    ]

end

module Chem_link_chir_atom = struct
  type t = {
    atom_comp_id: string option;
    atom_id: string option;
    chir_id: string option;
    dev: float option;
  }

  let default = {
    atom_comp_id = None;
    atom_id = None;
    chir_id = None;
    dev = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_comp_id" -> { b with atom_comp_id = (Some v) }
      | "atom_id" -> { b with atom_id = (Some v) }
      | "chir_id" -> { b with chir_id = (Some v) }
      | "dev" -> { b with dev = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_comp_id",  v)) a.atom_comp_id;
      Option.map (fun v -> ("atom_id",  v)) a.atom_id;
      Option.map (fun v -> ("chir_id",  v)) a.chir_id;
      Option.map (fun v -> ("dev", string_of_float v)) a.dev;
    ]

end

module Chem_link_plane = struct
  type t = {
    id: string option;
    link_id: string option;
    number_atoms_all: int option;
    number_atoms_nh: int option;
  }

  let default = {
    id = None;
    link_id = None;
    number_atoms_all = None;
    number_atoms_nh = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "link_id" -> { b with link_id = (Some v) }
      | "number_atoms_all" -> { b with number_atoms_all = (PDBjDict.some_int v) }
      | "number_atoms_nh" -> { b with number_atoms_nh = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("link_id",  v)) a.link_id;
      Option.map (fun v -> ("number_atoms_all", string_of_int v)) a.number_atoms_all;
      Option.map (fun v -> ("number_atoms_nh", string_of_int v)) a.number_atoms_nh;
    ]

end

module Chem_link_plane_atom = struct
  type t = {
    atom_comp_id: string option;
    atom_id: string option;
    plane_id: string option;
  }

  let default = {
    atom_comp_id = None;
    atom_id = None;
    plane_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_comp_id" -> { b with atom_comp_id = (Some v) }
      | "atom_id" -> { b with atom_id = (Some v) }
      | "plane_id" -> { b with plane_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_comp_id",  v)) a.atom_comp_id;
      Option.map (fun v -> ("atom_id",  v)) a.atom_id;
      Option.map (fun v -> ("plane_id",  v)) a.plane_id;
    ]

end

module Chem_link_tor = struct
  type t = {
    atom_1_comp_id: string option;
    atom_2_comp_id: string option;
    atom_3_comp_id: string option;
    atom_4_comp_id: string option;
    atom_id_1: string option;
    atom_id_2: string option;
    atom_id_3: string option;
    atom_id_4: string option;
    id: string option;
    link_id: string option;
  }

  let default = {
    atom_1_comp_id = None;
    atom_2_comp_id = None;
    atom_3_comp_id = None;
    atom_4_comp_id = None;
    atom_id_1 = None;
    atom_id_2 = None;
    atom_id_3 = None;
    atom_id_4 = None;
    id = None;
    link_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_1_comp_id" -> { b with atom_1_comp_id = (Some v) }
      | "atom_2_comp_id" -> { b with atom_2_comp_id = (Some v) }
      | "atom_3_comp_id" -> { b with atom_3_comp_id = (Some v) }
      | "atom_4_comp_id" -> { b with atom_4_comp_id = (Some v) }
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "atom_id_3" -> { b with atom_id_3 = (Some v) }
      | "atom_id_4" -> { b with atom_id_4 = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "link_id" -> { b with link_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_1_comp_id",  v)) a.atom_1_comp_id;
      Option.map (fun v -> ("atom_2_comp_id",  v)) a.atom_2_comp_id;
      Option.map (fun v -> ("atom_3_comp_id",  v)) a.atom_3_comp_id;
      Option.map (fun v -> ("atom_4_comp_id",  v)) a.atom_4_comp_id;
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("atom_id_3",  v)) a.atom_id_3;
      Option.map (fun v -> ("atom_id_4",  v)) a.atom_id_4;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("link_id",  v)) a.link_id;
    ]

end

module Chem_link_tor_value = struct
  type t = {
    tor_id: string option;
    angle: float option;
    angle_esd: float option;
    dist: float option;
    dist_esd: float option;
  }

  let default = {
    tor_id = None;
    angle = None;
    angle_esd = None;
    dist = None;
    dist_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "tor_id" -> { b with tor_id = (Some v) }
      | "angle" -> { b with angle = (PDBjDict.some_float v) }
      | "angle_esd" -> { b with angle_esd = (PDBjDict.some_float v) }
      | "dist" -> { b with dist = (PDBjDict.some_float v) }
      | "dist_esd" -> { b with dist_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("tor_id",  v)) a.tor_id;
      Option.map (fun v -> ("angle", string_of_float v)) a.angle;
      Option.map (fun v -> ("angle_esd", string_of_float v)) a.angle_esd;
      Option.map (fun v -> ("dist", string_of_float v)) a.dist;
      Option.map (fun v -> ("dist_esd", string_of_float v)) a.dist_esd;
    ]

end

module Chemical = struct
  type t = {
    entry_id: string option;
    compound_source: string option;
    melting_point: float option;
    name_common: string option;
    name_mineral: string option;
    name_structure_type: string option;
    name_systematic: string option;
    absolute_configuration: string option;
    melting_point_gt: float option;
    melting_point_lt: float option;
    optical_rotation: string option;
    properties_biological: string option;
    properties_physical: string option;
    temperature_decomposition: float option;
    temperature_decomposition_esd: float option;
    temperature_decomposition_gt: float option;
    temperature_decomposition_lt: float option;
    temperature_sublimation: float option;
    temperature_sublimation_esd: float option;
    temperature_sublimation_gt: float option;
    temperature_sublimation_lt: float option;
  }

  let default = {
    entry_id = None;
    compound_source = None;
    melting_point = None;
    name_common = None;
    name_mineral = None;
    name_structure_type = None;
    name_systematic = None;
    absolute_configuration = None;
    melting_point_gt = None;
    melting_point_lt = None;
    optical_rotation = None;
    properties_biological = None;
    properties_physical = None;
    temperature_decomposition = None;
    temperature_decomposition_esd = None;
    temperature_decomposition_gt = None;
    temperature_decomposition_lt = None;
    temperature_sublimation = None;
    temperature_sublimation_esd = None;
    temperature_sublimation_gt = None;
    temperature_sublimation_lt = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "compound_source" -> { b with compound_source = (Some v) }
      | "melting_point" -> { b with melting_point = (PDBjDict.some_float v) }
      | "name_common" -> { b with name_common = (Some v) }
      | "name_mineral" -> { b with name_mineral = (Some v) }
      | "name_structure_type" -> { b with name_structure_type = (Some v) }
      | "name_systematic" -> { b with name_systematic = (Some v) }
      | "absolute_configuration" -> { b with absolute_configuration = (Some v) }
      | "melting_point_gt" -> { b with melting_point_gt = (PDBjDict.some_float v) }
      | "melting_point_lt" -> { b with melting_point_lt = (PDBjDict.some_float v) }
      | "optical_rotation" -> { b with optical_rotation = (Some v) }
      | "properties_biological" -> { b with properties_biological = (Some v) }
      | "properties_physical" -> { b with properties_physical = (Some v) }
      | "temperature_decomposition" -> { b with temperature_decomposition = (PDBjDict.some_float v) }
      | "temperature_decomposition_esd" -> { b with temperature_decomposition_esd = (PDBjDict.some_float v) }
      | "temperature_decomposition_gt" -> { b with temperature_decomposition_gt = (PDBjDict.some_float v) }
      | "temperature_decomposition_lt" -> { b with temperature_decomposition_lt = (PDBjDict.some_float v) }
      | "temperature_sublimation" -> { b with temperature_sublimation = (PDBjDict.some_float v) }
      | "temperature_sublimation_esd" -> { b with temperature_sublimation_esd = (PDBjDict.some_float v) }
      | "temperature_sublimation_gt" -> { b with temperature_sublimation_gt = (PDBjDict.some_float v) }
      | "temperature_sublimation_lt" -> { b with temperature_sublimation_lt = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("compound_source",  v)) a.compound_source;
      Option.map (fun v -> ("melting_point", string_of_float v)) a.melting_point;
      Option.map (fun v -> ("name_common",  v)) a.name_common;
      Option.map (fun v -> ("name_mineral",  v)) a.name_mineral;
      Option.map (fun v -> ("name_structure_type",  v)) a.name_structure_type;
      Option.map (fun v -> ("name_systematic",  v)) a.name_systematic;
      Option.map (fun v -> ("absolute_configuration",  v)) a.absolute_configuration;
      Option.map (fun v -> ("melting_point_gt", string_of_float v)) a.melting_point_gt;
      Option.map (fun v -> ("melting_point_lt", string_of_float v)) a.melting_point_lt;
      Option.map (fun v -> ("optical_rotation",  v)) a.optical_rotation;
      Option.map (fun v -> ("properties_biological",  v)) a.properties_biological;
      Option.map (fun v -> ("properties_physical",  v)) a.properties_physical;
      Option.map (fun v -> ("temperature_decomposition", string_of_float v)) a.temperature_decomposition;
      Option.map (fun v -> ("temperature_decomposition_esd", string_of_float v)) a.temperature_decomposition_esd;
      Option.map (fun v -> ("temperature_decomposition_gt", string_of_float v)) a.temperature_decomposition_gt;
      Option.map (fun v -> ("temperature_decomposition_lt", string_of_float v)) a.temperature_decomposition_lt;
      Option.map (fun v -> ("temperature_sublimation", string_of_float v)) a.temperature_sublimation;
      Option.map (fun v -> ("temperature_sublimation_esd", string_of_float v)) a.temperature_sublimation_esd;
      Option.map (fun v -> ("temperature_sublimation_gt", string_of_float v)) a.temperature_sublimation_gt;
      Option.map (fun v -> ("temperature_sublimation_lt", string_of_float v)) a.temperature_sublimation_lt;
    ]

end

module Chemical_conn_atom = struct
  type t = {
    charge: int option;
    display_x: float option;
    display_y: float option;
    nCA: int option;
    nH: int option;
    number: int option;
    type_symbol: string option;
  }

  let default = {
    charge = None;
    display_x = None;
    display_y = None;
    nCA = None;
    nH = None;
    number = None;
    type_symbol = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "charge" -> { b with charge = (PDBjDict.some_int v) }
      | "display_x" -> { b with display_x = (PDBjDict.some_float v) }
      | "display_y" -> { b with display_y = (PDBjDict.some_float v) }
      | "NCA" -> { b with nCA = (PDBjDict.some_int v) }
      | "NH" -> { b with nH = (PDBjDict.some_int v) }
      | "number" -> { b with number = (PDBjDict.some_int v) }
      | "type_symbol" -> { b with type_symbol = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("charge", string_of_int v)) a.charge;
      Option.map (fun v -> ("display_x", string_of_float v)) a.display_x;
      Option.map (fun v -> ("display_y", string_of_float v)) a.display_y;
      Option.map (fun v -> ("NCA", string_of_int v)) a.nCA;
      Option.map (fun v -> ("NH", string_of_int v)) a.nH;
      Option.map (fun v -> ("number", string_of_int v)) a.number;
      Option.map (fun v -> ("type_symbol",  v)) a.type_symbol;
    ]

end

module Chemical_conn_bond = struct
  type t = {
    atom_1: int option;
    atom_2: int option;
    type_: string option;
  }

  let default = {
    atom_1 = None;
    atom_2 = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_1" -> { b with atom_1 = (PDBjDict.some_int v) }
      | "atom_2" -> { b with atom_2 = (PDBjDict.some_int v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_1", string_of_int v)) a.atom_1;
      Option.map (fun v -> ("atom_2", string_of_int v)) a.atom_2;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Chemical_formula = struct
  type t = {
    analytical: string option;
    entry_id: string option;
    iupac: string option;
    moiety: string option;
    structural: string option;
    sum: string option;
    weight: float option;
    weight_meas: float option;
  }

  let default = {
    analytical = None;
    entry_id = None;
    iupac = None;
    moiety = None;
    structural = None;
    sum = None;
    weight = None;
    weight_meas = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "analytical" -> { b with analytical = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "iupac" -> { b with iupac = (Some v) }
      | "moiety" -> { b with moiety = (Some v) }
      | "structural" -> { b with structural = (Some v) }
      | "sum" -> { b with sum = (Some v) }
      | "weight" -> { b with weight = (PDBjDict.some_float v) }
      | "weight_meas" -> { b with weight_meas = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("analytical",  v)) a.analytical;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("iupac",  v)) a.iupac;
      Option.map (fun v -> ("moiety",  v)) a.moiety;
      Option.map (fun v -> ("structural",  v)) a.structural;
      Option.map (fun v -> ("sum",  v)) a.sum;
      Option.map (fun v -> ("weight", string_of_float v)) a.weight;
      Option.map (fun v -> ("weight_meas", string_of_float v)) a.weight_meas;
    ]

end

module Citation = struct
  type t = {
    abstract: string option;
    abstract_id_CAS: string option;
    book_id_ISBN: string option;
    book_publisher: string option;
    book_publisher_city: string option;
    book_title: string option;
    coordinate_linkage: string option;
    country: string option;
    database_id_Medline: int option;
    details: string option;
    id: string option;
    journal_abbrev: string option;
    journal_id_ASTM: string option;
    journal_id_CSD: string option;
    journal_id_ISSN: string option;
    journal_full: string option;
    journal_issue: string option;
    journal_volume: string option;
    language: string option;
    page_first: string option;
    page_last: string option;
    title: string option;
    year: int option;
    database_id_CSD: string option;
    pdbx_database_id_DOI: string option;
    pdbx_database_id_PubMed: int option;
    unpublished_flag: string option;
  }

  let default = {
    abstract = None;
    abstract_id_CAS = None;
    book_id_ISBN = None;
    book_publisher = None;
    book_publisher_city = None;
    book_title = None;
    coordinate_linkage = None;
    country = None;
    database_id_Medline = None;
    details = None;
    id = None;
    journal_abbrev = None;
    journal_id_ASTM = None;
    journal_id_CSD = None;
    journal_id_ISSN = None;
    journal_full = None;
    journal_issue = None;
    journal_volume = None;
    language = None;
    page_first = None;
    page_last = None;
    title = None;
    year = None;
    database_id_CSD = None;
    pdbx_database_id_DOI = None;
    pdbx_database_id_PubMed = None;
    unpublished_flag = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "abstract" -> { b with abstract = (Some v) }
      | "abstract_id_CAS" -> { b with abstract_id_CAS = (Some v) }
      | "book_id_ISBN" -> { b with book_id_ISBN = (Some v) }
      | "book_publisher" -> { b with book_publisher = (Some v) }
      | "book_publisher_city" -> { b with book_publisher_city = (Some v) }
      | "book_title" -> { b with book_title = (Some v) }
      | "coordinate_linkage" -> { b with coordinate_linkage = (Some v) }
      | "country" -> { b with country = (Some v) }
      | "database_id_Medline" -> { b with database_id_Medline = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "journal_abbrev" -> { b with journal_abbrev = (Some v) }
      | "journal_id_ASTM" -> { b with journal_id_ASTM = (Some v) }
      | "journal_id_CSD" -> { b with journal_id_CSD = (Some v) }
      | "journal_id_ISSN" -> { b with journal_id_ISSN = (Some v) }
      | "journal_full" -> { b with journal_full = (Some v) }
      | "journal_issue" -> { b with journal_issue = (Some v) }
      | "journal_volume" -> { b with journal_volume = (Some v) }
      | "language" -> { b with language = (Some v) }
      | "page_first" -> { b with page_first = (Some v) }
      | "page_last" -> { b with page_last = (Some v) }
      | "title" -> { b with title = (Some v) }
      | "year" -> { b with year = (PDBjDict.some_int v) }
      | "database_id_CSD" -> { b with database_id_CSD = (Some v) }
      | "pdbx_database_id_DOI" -> { b with pdbx_database_id_DOI = (Some v) }
      | "pdbx_database_id_PubMed" -> { b with pdbx_database_id_PubMed = (PDBjDict.some_int v) }
      | "unpublished_flag" -> { b with unpublished_flag = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("abstract",  v)) a.abstract;
      Option.map (fun v -> ("abstract_id_CAS",  v)) a.abstract_id_CAS;
      Option.map (fun v -> ("book_id_ISBN",  v)) a.book_id_ISBN;
      Option.map (fun v -> ("book_publisher",  v)) a.book_publisher;
      Option.map (fun v -> ("book_publisher_city",  v)) a.book_publisher_city;
      Option.map (fun v -> ("book_title",  v)) a.book_title;
      Option.map (fun v -> ("coordinate_linkage",  v)) a.coordinate_linkage;
      Option.map (fun v -> ("country",  v)) a.country;
      Option.map (fun v -> ("database_id_Medline", string_of_int v)) a.database_id_Medline;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("journal_abbrev",  v)) a.journal_abbrev;
      Option.map (fun v -> ("journal_id_ASTM",  v)) a.journal_id_ASTM;
      Option.map (fun v -> ("journal_id_CSD",  v)) a.journal_id_CSD;
      Option.map (fun v -> ("journal_id_ISSN",  v)) a.journal_id_ISSN;
      Option.map (fun v -> ("journal_full",  v)) a.journal_full;
      Option.map (fun v -> ("journal_issue",  v)) a.journal_issue;
      Option.map (fun v -> ("journal_volume",  v)) a.journal_volume;
      Option.map (fun v -> ("language",  v)) a.language;
      Option.map (fun v -> ("page_first",  v)) a.page_first;
      Option.map (fun v -> ("page_last",  v)) a.page_last;
      Option.map (fun v -> ("title",  v)) a.title;
      Option.map (fun v -> ("year", string_of_int v)) a.year;
      Option.map (fun v -> ("database_id_CSD",  v)) a.database_id_CSD;
      Option.map (fun v -> ("pdbx_database_id_DOI",  v)) a.pdbx_database_id_DOI;
      Option.map (fun v -> ("pdbx_database_id_PubMed", string_of_int v)) a.pdbx_database_id_PubMed;
      Option.map (fun v -> ("unpublished_flag",  v)) a.unpublished_flag;
    ]

end

module Citation_author = struct
  type t = {
    citation_id: string option;
    name: string option;
    ordinal: int option;
  }

  let default = {
    citation_id = None;
    name = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "citation_id" -> { b with citation_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Citation_editor = struct
  type t = {
    citation_id: string option;
    name: string option;
    ordinal: int option;
  }

  let default = {
    citation_id = None;
    name = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "citation_id" -> { b with citation_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Computing = struct
  type t = {
    entry_id: string option;
    cell_refinement: string option;
    data_collection: string option;
    data_reduction: string option;
    molecular_graphics: string option;
    publication_material: string option;
    structure_refinement: string option;
    structure_solution: string option;
    pdbx_structure_refinement_method: string option;
    pdbx_data_reduction_ii: string option;
    pdbx_data_reduction_ds: string option;
  }

  let default = {
    entry_id = None;
    cell_refinement = None;
    data_collection = None;
    data_reduction = None;
    molecular_graphics = None;
    publication_material = None;
    structure_refinement = None;
    structure_solution = None;
    pdbx_structure_refinement_method = None;
    pdbx_data_reduction_ii = None;
    pdbx_data_reduction_ds = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "cell_refinement" -> { b with cell_refinement = (Some v) }
      | "data_collection" -> { b with data_collection = (Some v) }
      | "data_reduction" -> { b with data_reduction = (Some v) }
      | "molecular_graphics" -> { b with molecular_graphics = (Some v) }
      | "publication_material" -> { b with publication_material = (Some v) }
      | "structure_refinement" -> { b with structure_refinement = (Some v) }
      | "structure_solution" -> { b with structure_solution = (Some v) }
      | "pdbx_structure_refinement_method" -> { b with pdbx_structure_refinement_method = (Some v) }
      | "pdbx_data_reduction_ii" -> { b with pdbx_data_reduction_ii = (Some v) }
      | "pdbx_data_reduction_ds" -> { b with pdbx_data_reduction_ds = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("cell_refinement",  v)) a.cell_refinement;
      Option.map (fun v -> ("data_collection",  v)) a.data_collection;
      Option.map (fun v -> ("data_reduction",  v)) a.data_reduction;
      Option.map (fun v -> ("molecular_graphics",  v)) a.molecular_graphics;
      Option.map (fun v -> ("publication_material",  v)) a.publication_material;
      Option.map (fun v -> ("structure_refinement",  v)) a.structure_refinement;
      Option.map (fun v -> ("structure_solution",  v)) a.structure_solution;
      Option.map (fun v -> ("pdbx_structure_refinement_method",  v)) a.pdbx_structure_refinement_method;
      Option.map (fun v -> ("pdbx_data_reduction_ii",  v)) a.pdbx_data_reduction_ii;
      Option.map (fun v -> ("pdbx_data_reduction_ds",  v)) a.pdbx_data_reduction_ds;
    ]

end

module Database = struct
  type t = {
    entry_id: string option;
    journal_ASTM: string option;
    journal_CSD: string option;
    cSD_history: string option;
    code_CAS: string option;
    code_CSD: string option;
    code_ICSD: string option;
    code_MDF: string option;
    code_NBS: string option;
    code_PDB: string option;
    code_PDF: string option;
    code_depnum_ccdc_fiz: string option;
    code_depnum_ccdc_journal: string option;
    code_depnum_ccdc_archive: string option;
    pdbx_code_NDB: string option;
    pdbx_code_PDB: string option;
    pdbx_related_codes_PDB: string option;
  }

  let default = {
    entry_id = None;
    journal_ASTM = None;
    journal_CSD = None;
    cSD_history = None;
    code_CAS = None;
    code_CSD = None;
    code_ICSD = None;
    code_MDF = None;
    code_NBS = None;
    code_PDB = None;
    code_PDF = None;
    code_depnum_ccdc_fiz = None;
    code_depnum_ccdc_journal = None;
    code_depnum_ccdc_archive = None;
    pdbx_code_NDB = None;
    pdbx_code_PDB = None;
    pdbx_related_codes_PDB = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "journal_ASTM" -> { b with journal_ASTM = (Some v) }
      | "journal_CSD" -> { b with journal_CSD = (Some v) }
      | "CSD_history" -> { b with cSD_history = (Some v) }
      | "code_CAS" -> { b with code_CAS = (Some v) }
      | "code_CSD" -> { b with code_CSD = (Some v) }
      | "code_ICSD" -> { b with code_ICSD = (Some v) }
      | "code_MDF" -> { b with code_MDF = (Some v) }
      | "code_NBS" -> { b with code_NBS = (Some v) }
      | "code_PDB" -> { b with code_PDB = (Some v) }
      | "code_PDF" -> { b with code_PDF = (Some v) }
      | "code_depnum_ccdc_fiz" -> { b with code_depnum_ccdc_fiz = (Some v) }
      | "code_depnum_ccdc_journal" -> { b with code_depnum_ccdc_journal = (Some v) }
      | "code_depnum_ccdc_archive" -> { b with code_depnum_ccdc_archive = (Some v) }
      | "pdbx_code_NDB" -> { b with pdbx_code_NDB = (Some v) }
      | "pdbx_code_PDB" -> { b with pdbx_code_PDB = (Some v) }
      | "pdbx_related_codes_PDB" -> { b with pdbx_related_codes_PDB = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("journal_ASTM",  v)) a.journal_ASTM;
      Option.map (fun v -> ("journal_CSD",  v)) a.journal_CSD;
      Option.map (fun v -> ("CSD_history",  v)) a.cSD_history;
      Option.map (fun v -> ("code_CAS",  v)) a.code_CAS;
      Option.map (fun v -> ("code_CSD",  v)) a.code_CSD;
      Option.map (fun v -> ("code_ICSD",  v)) a.code_ICSD;
      Option.map (fun v -> ("code_MDF",  v)) a.code_MDF;
      Option.map (fun v -> ("code_NBS",  v)) a.code_NBS;
      Option.map (fun v -> ("code_PDB",  v)) a.code_PDB;
      Option.map (fun v -> ("code_PDF",  v)) a.code_PDF;
      Option.map (fun v -> ("code_depnum_ccdc_fiz",  v)) a.code_depnum_ccdc_fiz;
      Option.map (fun v -> ("code_depnum_ccdc_journal",  v)) a.code_depnum_ccdc_journal;
      Option.map (fun v -> ("code_depnum_ccdc_archive",  v)) a.code_depnum_ccdc_archive;
      Option.map (fun v -> ("pdbx_code_NDB",  v)) a.pdbx_code_NDB;
      Option.map (fun v -> ("pdbx_code_PDB",  v)) a.pdbx_code_PDB;
      Option.map (fun v -> ("pdbx_related_codes_PDB",  v)) a.pdbx_related_codes_PDB;
    ]

end

module Database_2 = struct
  type t = {
    database_id: string option;
    database_code: string option;
  }

  let default = {
    database_id = None;
    database_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "database_id" -> { b with database_id = (Some v) }
      | "database_code" -> { b with database_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("database_id",  v)) a.database_id;
      Option.map (fun v -> ("database_code",  v)) a.database_code;
    ]

end

module Database_PDB_caveat = struct
  type t = {
    id: int option;
    text: string option;
  }

  let default = {
    id = None;
    text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "text" -> { b with text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("text",  v)) a.text;
    ]

end

module Database_PDB_matrix = struct
  type t = {
    entry_id: string option;
    origx11: float option;
    origx12: float option;
    origx13: float option;
    origx21: float option;
    origx22: float option;
    origx23: float option;
    origx31: float option;
    origx32: float option;
    origx33: float option;
    origx_vector1: float option;
    origx_vector2: float option;
    origx_vector3: float option;
    scale11: float option;
    scale12: float option;
    scale13: float option;
    scale21: float option;
    scale22: float option;
    scale23: float option;
    scale31: float option;
    scale32: float option;
    scale33: float option;
    scale_vector1: float option;
    scale_vector2: float option;
    scale_vector3: float option;
  }

  let default = {
    entry_id = None;
    origx11 = None;
    origx12 = None;
    origx13 = None;
    origx21 = None;
    origx22 = None;
    origx23 = None;
    origx31 = None;
    origx32 = None;
    origx33 = None;
    origx_vector1 = None;
    origx_vector2 = None;
    origx_vector3 = None;
    scale11 = None;
    scale12 = None;
    scale13 = None;
    scale21 = None;
    scale22 = None;
    scale23 = None;
    scale31 = None;
    scale32 = None;
    scale33 = None;
    scale_vector1 = None;
    scale_vector2 = None;
    scale_vector3 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "origx[1][1]" -> { b with origx11 = (PDBjDict.some_float v) }
      | "origx[1][2]" -> { b with origx12 = (PDBjDict.some_float v) }
      | "origx[1][3]" -> { b with origx13 = (PDBjDict.some_float v) }
      | "origx[2][1]" -> { b with origx21 = (PDBjDict.some_float v) }
      | "origx[2][2]" -> { b with origx22 = (PDBjDict.some_float v) }
      | "origx[2][3]" -> { b with origx23 = (PDBjDict.some_float v) }
      | "origx[3][1]" -> { b with origx31 = (PDBjDict.some_float v) }
      | "origx[3][2]" -> { b with origx32 = (PDBjDict.some_float v) }
      | "origx[3][3]" -> { b with origx33 = (PDBjDict.some_float v) }
      | "origx_vector[1]" -> { b with origx_vector1 = (PDBjDict.some_float v) }
      | "origx_vector[2]" -> { b with origx_vector2 = (PDBjDict.some_float v) }
      | "origx_vector[3]" -> { b with origx_vector3 = (PDBjDict.some_float v) }
      | "scale[1][1]" -> { b with scale11 = (PDBjDict.some_float v) }
      | "scale[1][2]" -> { b with scale12 = (PDBjDict.some_float v) }
      | "scale[1][3]" -> { b with scale13 = (PDBjDict.some_float v) }
      | "scale[2][1]" -> { b with scale21 = (PDBjDict.some_float v) }
      | "scale[2][2]" -> { b with scale22 = (PDBjDict.some_float v) }
      | "scale[2][3]" -> { b with scale23 = (PDBjDict.some_float v) }
      | "scale[3][1]" -> { b with scale31 = (PDBjDict.some_float v) }
      | "scale[3][2]" -> { b with scale32 = (PDBjDict.some_float v) }
      | "scale[3][3]" -> { b with scale33 = (PDBjDict.some_float v) }
      | "scale_vector[1]" -> { b with scale_vector1 = (PDBjDict.some_float v) }
      | "scale_vector[2]" -> { b with scale_vector2 = (PDBjDict.some_float v) }
      | "scale_vector[3]" -> { b with scale_vector3 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("origx[1][1]", string_of_float v)) a.origx11;
      Option.map (fun v -> ("origx[1][2]", string_of_float v)) a.origx12;
      Option.map (fun v -> ("origx[1][3]", string_of_float v)) a.origx13;
      Option.map (fun v -> ("origx[2][1]", string_of_float v)) a.origx21;
      Option.map (fun v -> ("origx[2][2]", string_of_float v)) a.origx22;
      Option.map (fun v -> ("origx[2][3]", string_of_float v)) a.origx23;
      Option.map (fun v -> ("origx[3][1]", string_of_float v)) a.origx31;
      Option.map (fun v -> ("origx[3][2]", string_of_float v)) a.origx32;
      Option.map (fun v -> ("origx[3][3]", string_of_float v)) a.origx33;
      Option.map (fun v -> ("origx_vector[1]", string_of_float v)) a.origx_vector1;
      Option.map (fun v -> ("origx_vector[2]", string_of_float v)) a.origx_vector2;
      Option.map (fun v -> ("origx_vector[3]", string_of_float v)) a.origx_vector3;
      Option.map (fun v -> ("scale[1][1]", string_of_float v)) a.scale11;
      Option.map (fun v -> ("scale[1][2]", string_of_float v)) a.scale12;
      Option.map (fun v -> ("scale[1][3]", string_of_float v)) a.scale13;
      Option.map (fun v -> ("scale[2][1]", string_of_float v)) a.scale21;
      Option.map (fun v -> ("scale[2][2]", string_of_float v)) a.scale22;
      Option.map (fun v -> ("scale[2][3]", string_of_float v)) a.scale23;
      Option.map (fun v -> ("scale[3][1]", string_of_float v)) a.scale31;
      Option.map (fun v -> ("scale[3][2]", string_of_float v)) a.scale32;
      Option.map (fun v -> ("scale[3][3]", string_of_float v)) a.scale33;
      Option.map (fun v -> ("scale_vector[1]", string_of_float v)) a.scale_vector1;
      Option.map (fun v -> ("scale_vector[2]", string_of_float v)) a.scale_vector2;
      Option.map (fun v -> ("scale_vector[3]", string_of_float v)) a.scale_vector3;
    ]

end

module Database_PDB_remark = struct
  type t = {
    id: int option;
    text: string option;
  }

  let default = {
    id = None;
    text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "text" -> { b with text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("text",  v)) a.text;
    ]

end

module Database_PDB_rev = struct
  type t = {
    author_name: string option;
    date: string option;
    date_original: string option;
    mod_type: int option;
    num: int option;
    replaced_by: string option;
    replaces: string option;
    status: string option;
    pdbx_record_revised_1: string option;
    pdbx_record_revised_2: string option;
    pdbx_record_revised_3: string option;
    pdbx_record_revised_4: string option;
  }

  let default = {
    author_name = None;
    date = None;
    date_original = None;
    mod_type = None;
    num = None;
    replaced_by = None;
    replaces = None;
    status = None;
    pdbx_record_revised_1 = None;
    pdbx_record_revised_2 = None;
    pdbx_record_revised_3 = None;
    pdbx_record_revised_4 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "author_name" -> { b with author_name = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "date_original" -> { b with date_original = (Some v) }
      | "mod_type" -> { b with mod_type = (PDBjDict.some_int v) }
      | "num" -> { b with num = (PDBjDict.some_int v) }
      | "replaced_by" -> { b with replaced_by = (Some v) }
      | "replaces" -> { b with replaces = (Some v) }
      | "status" -> { b with status = (Some v) }
      | "pdbx_record_revised_1" -> { b with pdbx_record_revised_1 = (Some v) }
      | "pdbx_record_revised_2" -> { b with pdbx_record_revised_2 = (Some v) }
      | "pdbx_record_revised_3" -> { b with pdbx_record_revised_3 = (Some v) }
      | "pdbx_record_revised_4" -> { b with pdbx_record_revised_4 = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("author_name",  v)) a.author_name;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("date_original",  v)) a.date_original;
      Option.map (fun v -> ("mod_type", string_of_int v)) a.mod_type;
      Option.map (fun v -> ("num", string_of_int v)) a.num;
      Option.map (fun v -> ("replaced_by",  v)) a.replaced_by;
      Option.map (fun v -> ("replaces",  v)) a.replaces;
      Option.map (fun v -> ("status",  v)) a.status;
      Option.map (fun v -> ("pdbx_record_revised_1",  v)) a.pdbx_record_revised_1;
      Option.map (fun v -> ("pdbx_record_revised_2",  v)) a.pdbx_record_revised_2;
      Option.map (fun v -> ("pdbx_record_revised_3",  v)) a.pdbx_record_revised_3;
      Option.map (fun v -> ("pdbx_record_revised_4",  v)) a.pdbx_record_revised_4;
    ]

end

module Database_PDB_rev_record = struct
  type t = {
    details: string option;
    rev_num: int option;
    type_: string option;
  }

  let default = {
    details = None;
    rev_num = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "rev_num" -> { b with rev_num = (PDBjDict.some_int v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("rev_num", string_of_int v)) a.rev_num;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Database_PDB_tvect = struct
  type t = {
    details: string option;
    id: string option;
    vector1: float option;
    vector2: float option;
    vector3: float option;
  }

  let default = {
    details = None;
    id = None;
    vector1 = None;
    vector2 = None;
    vector3 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "vector[1]" -> { b with vector1 = (PDBjDict.some_float v) }
      | "vector[2]" -> { b with vector2 = (PDBjDict.some_float v) }
      | "vector[3]" -> { b with vector3 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("vector[1]", string_of_float v)) a.vector1;
      Option.map (fun v -> ("vector[2]", string_of_float v)) a.vector2;
      Option.map (fun v -> ("vector[3]", string_of_float v)) a.vector3;
    ]

end

module Diffrn = struct
  type t = {
    ambient_environment: string option;
    ambient_temp: float option;
    ambient_temp_details: string option;
    ambient_temp_esd: float option;
    crystal_id: string option;
    crystal_support: string option;
    crystal_treatment: string option;
    details: string option;
    id: string option;
    ambient_pressure: float option;
    ambient_pressure_esd: float option;
    ambient_pressure_gt: float option;
    ambient_pressure_lt: float option;
    ambient_temp_gt: float option;
    ambient_temp_lt: float option;
  }

  let default = {
    ambient_environment = None;
    ambient_temp = None;
    ambient_temp_details = None;
    ambient_temp_esd = None;
    crystal_id = None;
    crystal_support = None;
    crystal_treatment = None;
    details = None;
    id = None;
    ambient_pressure = None;
    ambient_pressure_esd = None;
    ambient_pressure_gt = None;
    ambient_pressure_lt = None;
    ambient_temp_gt = None;
    ambient_temp_lt = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ambient_environment" -> { b with ambient_environment = (Some v) }
      | "ambient_temp" -> { b with ambient_temp = (PDBjDict.some_float v) }
      | "ambient_temp_details" -> { b with ambient_temp_details = (Some v) }
      | "ambient_temp_esd" -> { b with ambient_temp_esd = (PDBjDict.some_float v) }
      | "crystal_id" -> { b with crystal_id = (Some v) }
      | "crystal_support" -> { b with crystal_support = (Some v) }
      | "crystal_treatment" -> { b with crystal_treatment = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "ambient_pressure" -> { b with ambient_pressure = (PDBjDict.some_float v) }
      | "ambient_pressure_esd" -> { b with ambient_pressure_esd = (PDBjDict.some_float v) }
      | "ambient_pressure_gt" -> { b with ambient_pressure_gt = (PDBjDict.some_float v) }
      | "ambient_pressure_lt" -> { b with ambient_pressure_lt = (PDBjDict.some_float v) }
      | "ambient_temp_gt" -> { b with ambient_temp_gt = (PDBjDict.some_float v) }
      | "ambient_temp_lt" -> { b with ambient_temp_lt = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ambient_environment",  v)) a.ambient_environment;
      Option.map (fun v -> ("ambient_temp", string_of_float v)) a.ambient_temp;
      Option.map (fun v -> ("ambient_temp_details",  v)) a.ambient_temp_details;
      Option.map (fun v -> ("ambient_temp_esd", string_of_float v)) a.ambient_temp_esd;
      Option.map (fun v -> ("crystal_id",  v)) a.crystal_id;
      Option.map (fun v -> ("crystal_support",  v)) a.crystal_support;
      Option.map (fun v -> ("crystal_treatment",  v)) a.crystal_treatment;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("ambient_pressure", string_of_float v)) a.ambient_pressure;
      Option.map (fun v -> ("ambient_pressure_esd", string_of_float v)) a.ambient_pressure_esd;
      Option.map (fun v -> ("ambient_pressure_gt", string_of_float v)) a.ambient_pressure_gt;
      Option.map (fun v -> ("ambient_pressure_lt", string_of_float v)) a.ambient_pressure_lt;
      Option.map (fun v -> ("ambient_temp_gt", string_of_float v)) a.ambient_temp_gt;
      Option.map (fun v -> ("ambient_temp_lt", string_of_float v)) a.ambient_temp_lt;
    ]

end

module Diffrn_attenuator = struct
  type t = {
    code: string option;
    scale: float option;
    material: string option;
  }

  let default = {
    code = None;
    scale = None;
    material = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "code" -> { b with code = (Some v) }
      | "scale" -> { b with scale = (PDBjDict.some_float v) }
      | "material" -> { b with material = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("code",  v)) a.code;
      Option.map (fun v -> ("scale", string_of_float v)) a.scale;
      Option.map (fun v -> ("material",  v)) a.material;
    ]

end

module Diffrn_detector = struct
  type t = {
    details: string option;
    detector: string option;
    diffrn_id: string option;
    type_: string option;
    area_resol_mean: float option;
    dtime: float option;
    pdbx_frames_total: int option;
    pdbx_collection_time_total: float option;
    pdbx_collection_date: string option;
  }

  let default = {
    details = None;
    detector = None;
    diffrn_id = None;
    type_ = None;
    area_resol_mean = None;
    dtime = None;
    pdbx_frames_total = None;
    pdbx_collection_time_total = None;
    pdbx_collection_date = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "detector" -> { b with detector = (Some v) }
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "area_resol_mean" -> { b with area_resol_mean = (PDBjDict.some_float v) }
      | "dtime" -> { b with dtime = (PDBjDict.some_float v) }
      | "pdbx_frames_total" -> { b with pdbx_frames_total = (PDBjDict.some_int v) }
      | "pdbx_collection_time_total" -> { b with pdbx_collection_time_total = (PDBjDict.some_float v) }
      | "pdbx_collection_date" -> { b with pdbx_collection_date = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("detector",  v)) a.detector;
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("area_resol_mean", string_of_float v)) a.area_resol_mean;
      Option.map (fun v -> ("dtime", string_of_float v)) a.dtime;
      Option.map (fun v -> ("pdbx_frames_total", string_of_int v)) a.pdbx_frames_total;
      Option.map (fun v -> ("pdbx_collection_time_total", string_of_float v)) a.pdbx_collection_time_total;
      Option.map (fun v -> ("pdbx_collection_date",  v)) a.pdbx_collection_date;
    ]

end

module Diffrn_measurement = struct
  type t = {
    diffrn_id: string option;
    details: string option;
    device: string option;
    device_details: string option;
    device_type: string option;
    method_: string option;
    specimen_support: string option;
    pdbx_date: string option;
  }

  let default = {
    diffrn_id = None;
    details = None;
    device = None;
    device_details = None;
    device_type = None;
    method_ = None;
    specimen_support = None;
    pdbx_date = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "device" -> { b with device = (Some v) }
      | "device_details" -> { b with device_details = (Some v) }
      | "device_type" -> { b with device_type = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "specimen_support" -> { b with specimen_support = (Some v) }
      | "pdbx_date" -> { b with pdbx_date = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("device",  v)) a.device;
      Option.map (fun v -> ("device_details",  v)) a.device_details;
      Option.map (fun v -> ("device_type",  v)) a.device_type;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("specimen_support",  v)) a.specimen_support;
      Option.map (fun v -> ("pdbx_date",  v)) a.pdbx_date;
    ]

end

module Diffrn_orient_matrix = struct
  type t = {
    diffrn_id: string option;
    type_: string option;
    uB11: float option;
    uB12: float option;
    uB13: float option;
    uB21: float option;
    uB22: float option;
    uB23: float option;
    uB31: float option;
    uB32: float option;
    uB33: float option;
  }

  let default = {
    diffrn_id = None;
    type_ = None;
    uB11 = None;
    uB12 = None;
    uB13 = None;
    uB21 = None;
    uB22 = None;
    uB23 = None;
    uB31 = None;
    uB32 = None;
    uB33 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "UB[1][1]" -> { b with uB11 = (PDBjDict.some_float v) }
      | "UB[1][2]" -> { b with uB12 = (PDBjDict.some_float v) }
      | "UB[1][3]" -> { b with uB13 = (PDBjDict.some_float v) }
      | "UB[2][1]" -> { b with uB21 = (PDBjDict.some_float v) }
      | "UB[2][2]" -> { b with uB22 = (PDBjDict.some_float v) }
      | "UB[2][3]" -> { b with uB23 = (PDBjDict.some_float v) }
      | "UB[3][1]" -> { b with uB31 = (PDBjDict.some_float v) }
      | "UB[3][2]" -> { b with uB32 = (PDBjDict.some_float v) }
      | "UB[3][3]" -> { b with uB33 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("UB[1][1]", string_of_float v)) a.uB11;
      Option.map (fun v -> ("UB[1][2]", string_of_float v)) a.uB12;
      Option.map (fun v -> ("UB[1][3]", string_of_float v)) a.uB13;
      Option.map (fun v -> ("UB[2][1]", string_of_float v)) a.uB21;
      Option.map (fun v -> ("UB[2][2]", string_of_float v)) a.uB22;
      Option.map (fun v -> ("UB[2][3]", string_of_float v)) a.uB23;
      Option.map (fun v -> ("UB[3][1]", string_of_float v)) a.uB31;
      Option.map (fun v -> ("UB[3][2]", string_of_float v)) a.uB32;
      Option.map (fun v -> ("UB[3][3]", string_of_float v)) a.uB33;
    ]

end

module Diffrn_orient_refln = struct
  type t = {
    angle_chi: float option;
    angle_kappa: float option;
    angle_omega: float option;
    angle_phi: float option;
    angle_psi: float option;
    angle_theta: float option;
    diffrn_id: string option;
    index_h: int option;
    index_k: int option;
    index_l: int option;
  }

  let default = {
    angle_chi = None;
    angle_kappa = None;
    angle_omega = None;
    angle_phi = None;
    angle_psi = None;
    angle_theta = None;
    diffrn_id = None;
    index_h = None;
    index_k = None;
    index_l = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "angle_chi" -> { b with angle_chi = (PDBjDict.some_float v) }
      | "angle_kappa" -> { b with angle_kappa = (PDBjDict.some_float v) }
      | "angle_omega" -> { b with angle_omega = (PDBjDict.some_float v) }
      | "angle_phi" -> { b with angle_phi = (PDBjDict.some_float v) }
      | "angle_psi" -> { b with angle_psi = (PDBjDict.some_float v) }
      | "angle_theta" -> { b with angle_theta = (PDBjDict.some_float v) }
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "index_h" -> { b with index_h = (PDBjDict.some_int v) }
      | "index_k" -> { b with index_k = (PDBjDict.some_int v) }
      | "index_l" -> { b with index_l = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("angle_chi", string_of_float v)) a.angle_chi;
      Option.map (fun v -> ("angle_kappa", string_of_float v)) a.angle_kappa;
      Option.map (fun v -> ("angle_omega", string_of_float v)) a.angle_omega;
      Option.map (fun v -> ("angle_phi", string_of_float v)) a.angle_phi;
      Option.map (fun v -> ("angle_psi", string_of_float v)) a.angle_psi;
      Option.map (fun v -> ("angle_theta", string_of_float v)) a.angle_theta;
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("index_h", string_of_int v)) a.index_h;
      Option.map (fun v -> ("index_k", string_of_int v)) a.index_k;
      Option.map (fun v -> ("index_l", string_of_int v)) a.index_l;
    ]

end

module Diffrn_radiation = struct
  type t = {
    collimation: string option;
    diffrn_id: string option;
    filter_edge: float option;
    inhomogeneity: float option;
    monochromator: string option;
    polarisn_norm: float option;
    polarisn_ratio: float option;
    probe: string option;
    type_: string option;
    xray_symbol: string option;
    wavelength_id: string option;
    pdbx_monochromatic_or_laue_m_l: string option;
    pdbx_wavelength_list: string option;
    pdbx_wavelength: string option;
    pdbx_diffrn_protocol: string option;
    pdbx_analyzer: string option;
    pdbx_scattering_type: string option;
  }

  let default = {
    collimation = None;
    diffrn_id = None;
    filter_edge = None;
    inhomogeneity = None;
    monochromator = None;
    polarisn_norm = None;
    polarisn_ratio = None;
    probe = None;
    type_ = None;
    xray_symbol = None;
    wavelength_id = None;
    pdbx_monochromatic_or_laue_m_l = None;
    pdbx_wavelength_list = None;
    pdbx_wavelength = None;
    pdbx_diffrn_protocol = None;
    pdbx_analyzer = None;
    pdbx_scattering_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "collimation" -> { b with collimation = (Some v) }
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "filter_edge" -> { b with filter_edge = (PDBjDict.some_float v) }
      | "inhomogeneity" -> { b with inhomogeneity = (PDBjDict.some_float v) }
      | "monochromator" -> { b with monochromator = (Some v) }
      | "polarisn_norm" -> { b with polarisn_norm = (PDBjDict.some_float v) }
      | "polarisn_ratio" -> { b with polarisn_ratio = (PDBjDict.some_float v) }
      | "probe" -> { b with probe = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "xray_symbol" -> { b with xray_symbol = (Some v) }
      | "wavelength_id" -> { b with wavelength_id = (Some v) }
      | "pdbx_monochromatic_or_laue_m_l" -> { b with pdbx_monochromatic_or_laue_m_l = (Some v) }
      | "pdbx_wavelength_list" -> { b with pdbx_wavelength_list = (Some v) }
      | "pdbx_wavelength" -> { b with pdbx_wavelength = (Some v) }
      | "pdbx_diffrn_protocol" -> { b with pdbx_diffrn_protocol = (Some v) }
      | "pdbx_analyzer" -> { b with pdbx_analyzer = (Some v) }
      | "pdbx_scattering_type" -> { b with pdbx_scattering_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("collimation",  v)) a.collimation;
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("filter_edge", string_of_float v)) a.filter_edge;
      Option.map (fun v -> ("inhomogeneity", string_of_float v)) a.inhomogeneity;
      Option.map (fun v -> ("monochromator",  v)) a.monochromator;
      Option.map (fun v -> ("polarisn_norm", string_of_float v)) a.polarisn_norm;
      Option.map (fun v -> ("polarisn_ratio", string_of_float v)) a.polarisn_ratio;
      Option.map (fun v -> ("probe",  v)) a.probe;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("xray_symbol",  v)) a.xray_symbol;
      Option.map (fun v -> ("wavelength_id",  v)) a.wavelength_id;
      Option.map (fun v -> ("pdbx_monochromatic_or_laue_m_l",  v)) a.pdbx_monochromatic_or_laue_m_l;
      Option.map (fun v -> ("pdbx_wavelength_list",  v)) a.pdbx_wavelength_list;
      Option.map (fun v -> ("pdbx_wavelength",  v)) a.pdbx_wavelength;
      Option.map (fun v -> ("pdbx_diffrn_protocol",  v)) a.pdbx_diffrn_protocol;
      Option.map (fun v -> ("pdbx_analyzer",  v)) a.pdbx_analyzer;
      Option.map (fun v -> ("pdbx_scattering_type",  v)) a.pdbx_scattering_type;
    ]

end

module Diffrn_radiation_wavelength = struct
  type t = {
    id: string option;
    wavelength: float option;
    wt: float option;
  }

  let default = {
    id = None;
    wavelength = None;
    wt = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "wavelength" -> { b with wavelength = (PDBjDict.some_float v) }
      | "wt" -> { b with wt = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("wavelength", string_of_float v)) a.wavelength;
      Option.map (fun v -> ("wt", string_of_float v)) a.wt;
    ]

end

module Diffrn_refln = struct
  type t = {
    angle_chi: float option;
    angle_kappa: float option;
    angle_omega: float option;
    angle_phi: float option;
    angle_psi: float option;
    angle_theta: float option;
    attenuator_code: string option;
    counts_bg_1: int option;
    counts_bg_2: int option;
    counts_net: int option;
    counts_peak: int option;
    counts_total: int option;
    detect_slit_horiz: float option;
    detect_slit_vert: float option;
    diffrn_id: string option;
    elapsed_time: float option;
    id: string option;
    index_h: int option;
    index_k: int option;
    index_l: int option;
    intensity_net: float option;
    intensity_sigma: float option;
    scale_group_code: string option;
    scan_mode: string option;
    scan_mode_backgd: string option;
    scan_rate: float option;
    scan_time_backgd: float option;
    scan_width: float option;
    sint_over_lambda: float option;
    standard_code: string option;
    wavelength: float option;
    wavelength_id: string option;
    class_code: string option;
    intensity_u: float option;
  }

  let default = {
    angle_chi = None;
    angle_kappa = None;
    angle_omega = None;
    angle_phi = None;
    angle_psi = None;
    angle_theta = None;
    attenuator_code = None;
    counts_bg_1 = None;
    counts_bg_2 = None;
    counts_net = None;
    counts_peak = None;
    counts_total = None;
    detect_slit_horiz = None;
    detect_slit_vert = None;
    diffrn_id = None;
    elapsed_time = None;
    id = None;
    index_h = None;
    index_k = None;
    index_l = None;
    intensity_net = None;
    intensity_sigma = None;
    scale_group_code = None;
    scan_mode = None;
    scan_mode_backgd = None;
    scan_rate = None;
    scan_time_backgd = None;
    scan_width = None;
    sint_over_lambda = None;
    standard_code = None;
    wavelength = None;
    wavelength_id = None;
    class_code = None;
    intensity_u = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "angle_chi" -> { b with angle_chi = (PDBjDict.some_float v) }
      | "angle_kappa" -> { b with angle_kappa = (PDBjDict.some_float v) }
      | "angle_omega" -> { b with angle_omega = (PDBjDict.some_float v) }
      | "angle_phi" -> { b with angle_phi = (PDBjDict.some_float v) }
      | "angle_psi" -> { b with angle_psi = (PDBjDict.some_float v) }
      | "angle_theta" -> { b with angle_theta = (PDBjDict.some_float v) }
      | "attenuator_code" -> { b with attenuator_code = (Some v) }
      | "counts_bg_1" -> { b with counts_bg_1 = (PDBjDict.some_int v) }
      | "counts_bg_2" -> { b with counts_bg_2 = (PDBjDict.some_int v) }
      | "counts_net" -> { b with counts_net = (PDBjDict.some_int v) }
      | "counts_peak" -> { b with counts_peak = (PDBjDict.some_int v) }
      | "counts_total" -> { b with counts_total = (PDBjDict.some_int v) }
      | "detect_slit_horiz" -> { b with detect_slit_horiz = (PDBjDict.some_float v) }
      | "detect_slit_vert" -> { b with detect_slit_vert = (PDBjDict.some_float v) }
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "elapsed_time" -> { b with elapsed_time = (PDBjDict.some_float v) }
      | "id" -> { b with id = (Some v) }
      | "index_h" -> { b with index_h = (PDBjDict.some_int v) }
      | "index_k" -> { b with index_k = (PDBjDict.some_int v) }
      | "index_l" -> { b with index_l = (PDBjDict.some_int v) }
      | "intensity_net" -> { b with intensity_net = (PDBjDict.some_float v) }
      | "intensity_sigma" -> { b with intensity_sigma = (PDBjDict.some_float v) }
      | "scale_group_code" -> { b with scale_group_code = (Some v) }
      | "scan_mode" -> { b with scan_mode = (Some v) }
      | "scan_mode_backgd" -> { b with scan_mode_backgd = (Some v) }
      | "scan_rate" -> { b with scan_rate = (PDBjDict.some_float v) }
      | "scan_time_backgd" -> { b with scan_time_backgd = (PDBjDict.some_float v) }
      | "scan_width" -> { b with scan_width = (PDBjDict.some_float v) }
      | "sint_over_lambda" -> { b with sint_over_lambda = (PDBjDict.some_float v) }
      | "standard_code" -> { b with standard_code = (Some v) }
      | "wavelength" -> { b with wavelength = (PDBjDict.some_float v) }
      | "wavelength_id" -> { b with wavelength_id = (Some v) }
      | "class_code" -> { b with class_code = (Some v) }
      | "intensity_u" -> { b with intensity_u = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("angle_chi", string_of_float v)) a.angle_chi;
      Option.map (fun v -> ("angle_kappa", string_of_float v)) a.angle_kappa;
      Option.map (fun v -> ("angle_omega", string_of_float v)) a.angle_omega;
      Option.map (fun v -> ("angle_phi", string_of_float v)) a.angle_phi;
      Option.map (fun v -> ("angle_psi", string_of_float v)) a.angle_psi;
      Option.map (fun v -> ("angle_theta", string_of_float v)) a.angle_theta;
      Option.map (fun v -> ("attenuator_code",  v)) a.attenuator_code;
      Option.map (fun v -> ("counts_bg_1", string_of_int v)) a.counts_bg_1;
      Option.map (fun v -> ("counts_bg_2", string_of_int v)) a.counts_bg_2;
      Option.map (fun v -> ("counts_net", string_of_int v)) a.counts_net;
      Option.map (fun v -> ("counts_peak", string_of_int v)) a.counts_peak;
      Option.map (fun v -> ("counts_total", string_of_int v)) a.counts_total;
      Option.map (fun v -> ("detect_slit_horiz", string_of_float v)) a.detect_slit_horiz;
      Option.map (fun v -> ("detect_slit_vert", string_of_float v)) a.detect_slit_vert;
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("elapsed_time", string_of_float v)) a.elapsed_time;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("index_h", string_of_int v)) a.index_h;
      Option.map (fun v -> ("index_k", string_of_int v)) a.index_k;
      Option.map (fun v -> ("index_l", string_of_int v)) a.index_l;
      Option.map (fun v -> ("intensity_net", string_of_float v)) a.intensity_net;
      Option.map (fun v -> ("intensity_sigma", string_of_float v)) a.intensity_sigma;
      Option.map (fun v -> ("scale_group_code",  v)) a.scale_group_code;
      Option.map (fun v -> ("scan_mode",  v)) a.scan_mode;
      Option.map (fun v -> ("scan_mode_backgd",  v)) a.scan_mode_backgd;
      Option.map (fun v -> ("scan_rate", string_of_float v)) a.scan_rate;
      Option.map (fun v -> ("scan_time_backgd", string_of_float v)) a.scan_time_backgd;
      Option.map (fun v -> ("scan_width", string_of_float v)) a.scan_width;
      Option.map (fun v -> ("sint_over_lambda", string_of_float v)) a.sint_over_lambda;
      Option.map (fun v -> ("standard_code",  v)) a.standard_code;
      Option.map (fun v -> ("wavelength", string_of_float v)) a.wavelength;
      Option.map (fun v -> ("wavelength_id",  v)) a.wavelength_id;
      Option.map (fun v -> ("class_code",  v)) a.class_code;
      Option.map (fun v -> ("intensity_u", string_of_float v)) a.intensity_u;
    ]

end

module Diffrn_reflns = struct
  type t = {
    av_R_equivalents: float option;
    av_sigmaI_over_netI: float option;
    diffrn_id: string option;
    limit_h_max: int option;
    limit_h_min: int option;
    limit_k_max: int option;
    limit_k_min: int option;
    limit_l_max: int option;
    limit_l_min: int option;
    number: int option;
    reduction_process: string option;
    theta_max: float option;
    theta_min: float option;
    transf_matrix11: float option;
    transf_matrix12: float option;
    transf_matrix13: float option;
    transf_matrix21: float option;
    transf_matrix22: float option;
    transf_matrix23: float option;
    transf_matrix31: float option;
    transf_matrix32: float option;
    transf_matrix33: float option;
    av_unetI_over_netI: float option;
    pdbx_d_res_low: float option;
    pdbx_d_res_high: float option;
    pdbx_percent_possible_obs: float option;
    pdbx_Rmerge_I_obs: float option;
    pdbx_Rsym_value: float option;
    pdbx_chi_squared: float option;
    pdbx_redundancy: float option;
    pdbx_rejects: int option;
    pdbx_observed_criterion: float option;
    pdbx_number_obs: int option;
  }

  let default = {
    av_R_equivalents = None;
    av_sigmaI_over_netI = None;
    diffrn_id = None;
    limit_h_max = None;
    limit_h_min = None;
    limit_k_max = None;
    limit_k_min = None;
    limit_l_max = None;
    limit_l_min = None;
    number = None;
    reduction_process = None;
    theta_max = None;
    theta_min = None;
    transf_matrix11 = None;
    transf_matrix12 = None;
    transf_matrix13 = None;
    transf_matrix21 = None;
    transf_matrix22 = None;
    transf_matrix23 = None;
    transf_matrix31 = None;
    transf_matrix32 = None;
    transf_matrix33 = None;
    av_unetI_over_netI = None;
    pdbx_d_res_low = None;
    pdbx_d_res_high = None;
    pdbx_percent_possible_obs = None;
    pdbx_Rmerge_I_obs = None;
    pdbx_Rsym_value = None;
    pdbx_chi_squared = None;
    pdbx_redundancy = None;
    pdbx_rejects = None;
    pdbx_observed_criterion = None;
    pdbx_number_obs = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "av_R_equivalents" -> { b with av_R_equivalents = (PDBjDict.some_float v) }
      | "av_sigmaI_over_netI" -> { b with av_sigmaI_over_netI = (PDBjDict.some_float v) }
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "limit_h_max" -> { b with limit_h_max = (PDBjDict.some_int v) }
      | "limit_h_min" -> { b with limit_h_min = (PDBjDict.some_int v) }
      | "limit_k_max" -> { b with limit_k_max = (PDBjDict.some_int v) }
      | "limit_k_min" -> { b with limit_k_min = (PDBjDict.some_int v) }
      | "limit_l_max" -> { b with limit_l_max = (PDBjDict.some_int v) }
      | "limit_l_min" -> { b with limit_l_min = (PDBjDict.some_int v) }
      | "number" -> { b with number = (PDBjDict.some_int v) }
      | "reduction_process" -> { b with reduction_process = (Some v) }
      | "theta_max" -> { b with theta_max = (PDBjDict.some_float v) }
      | "theta_min" -> { b with theta_min = (PDBjDict.some_float v) }
      | "transf_matrix[1][1]" -> { b with transf_matrix11 = (PDBjDict.some_float v) }
      | "transf_matrix[1][2]" -> { b with transf_matrix12 = (PDBjDict.some_float v) }
      | "transf_matrix[1][3]" -> { b with transf_matrix13 = (PDBjDict.some_float v) }
      | "transf_matrix[2][1]" -> { b with transf_matrix21 = (PDBjDict.some_float v) }
      | "transf_matrix[2][2]" -> { b with transf_matrix22 = (PDBjDict.some_float v) }
      | "transf_matrix[2][3]" -> { b with transf_matrix23 = (PDBjDict.some_float v) }
      | "transf_matrix[3][1]" -> { b with transf_matrix31 = (PDBjDict.some_float v) }
      | "transf_matrix[3][2]" -> { b with transf_matrix32 = (PDBjDict.some_float v) }
      | "transf_matrix[3][3]" -> { b with transf_matrix33 = (PDBjDict.some_float v) }
      | "av_unetI/netI" -> { b with av_unetI_over_netI = (PDBjDict.some_float v) }
      | "pdbx_d_res_low" -> { b with pdbx_d_res_low = (PDBjDict.some_float v) }
      | "pdbx_d_res_high" -> { b with pdbx_d_res_high = (PDBjDict.some_float v) }
      | "pdbx_percent_possible_obs" -> { b with pdbx_percent_possible_obs = (PDBjDict.some_float v) }
      | "pdbx_Rmerge_I_obs" -> { b with pdbx_Rmerge_I_obs = (PDBjDict.some_float v) }
      | "pdbx_Rsym_value" -> { b with pdbx_Rsym_value = (PDBjDict.some_float v) }
      | "pdbx_chi_squared" -> { b with pdbx_chi_squared = (PDBjDict.some_float v) }
      | "pdbx_redundancy" -> { b with pdbx_redundancy = (PDBjDict.some_float v) }
      | "pdbx_rejects" -> { b with pdbx_rejects = (PDBjDict.some_int v) }
      | "pdbx_observed_criterion" -> { b with pdbx_observed_criterion = (PDBjDict.some_float v) }
      | "pdbx_number_obs" -> { b with pdbx_number_obs = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("av_R_equivalents", string_of_float v)) a.av_R_equivalents;
      Option.map (fun v -> ("av_sigmaI_over_netI", string_of_float v)) a.av_sigmaI_over_netI;
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("limit_h_max", string_of_int v)) a.limit_h_max;
      Option.map (fun v -> ("limit_h_min", string_of_int v)) a.limit_h_min;
      Option.map (fun v -> ("limit_k_max", string_of_int v)) a.limit_k_max;
      Option.map (fun v -> ("limit_k_min", string_of_int v)) a.limit_k_min;
      Option.map (fun v -> ("limit_l_max", string_of_int v)) a.limit_l_max;
      Option.map (fun v -> ("limit_l_min", string_of_int v)) a.limit_l_min;
      Option.map (fun v -> ("number", string_of_int v)) a.number;
      Option.map (fun v -> ("reduction_process",  v)) a.reduction_process;
      Option.map (fun v -> ("theta_max", string_of_float v)) a.theta_max;
      Option.map (fun v -> ("theta_min", string_of_float v)) a.theta_min;
      Option.map (fun v -> ("transf_matrix[1][1]", string_of_float v)) a.transf_matrix11;
      Option.map (fun v -> ("transf_matrix[1][2]", string_of_float v)) a.transf_matrix12;
      Option.map (fun v -> ("transf_matrix[1][3]", string_of_float v)) a.transf_matrix13;
      Option.map (fun v -> ("transf_matrix[2][1]", string_of_float v)) a.transf_matrix21;
      Option.map (fun v -> ("transf_matrix[2][2]", string_of_float v)) a.transf_matrix22;
      Option.map (fun v -> ("transf_matrix[2][3]", string_of_float v)) a.transf_matrix23;
      Option.map (fun v -> ("transf_matrix[3][1]", string_of_float v)) a.transf_matrix31;
      Option.map (fun v -> ("transf_matrix[3][2]", string_of_float v)) a.transf_matrix32;
      Option.map (fun v -> ("transf_matrix[3][3]", string_of_float v)) a.transf_matrix33;
      Option.map (fun v -> ("av_unetI/netI", string_of_float v)) a.av_unetI_over_netI;
      Option.map (fun v -> ("pdbx_d_res_low", string_of_float v)) a.pdbx_d_res_low;
      Option.map (fun v -> ("pdbx_d_res_high", string_of_float v)) a.pdbx_d_res_high;
      Option.map (fun v -> ("pdbx_percent_possible_obs", string_of_float v)) a.pdbx_percent_possible_obs;
      Option.map (fun v -> ("pdbx_Rmerge_I_obs", string_of_float v)) a.pdbx_Rmerge_I_obs;
      Option.map (fun v -> ("pdbx_Rsym_value", string_of_float v)) a.pdbx_Rsym_value;
      Option.map (fun v -> ("pdbx_chi_squared", string_of_float v)) a.pdbx_chi_squared;
      Option.map (fun v -> ("pdbx_redundancy", string_of_float v)) a.pdbx_redundancy;
      Option.map (fun v -> ("pdbx_rejects", string_of_int v)) a.pdbx_rejects;
      Option.map (fun v -> ("pdbx_observed_criterion", string_of_float v)) a.pdbx_observed_criterion;
      Option.map (fun v -> ("pdbx_number_obs", string_of_int v)) a.pdbx_number_obs;
    ]

end

module Diffrn_scale_group = struct
  type t = {
    code: string option;
    i_net: float option;
  }

  let default = {
    code = None;
    i_net = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "code" -> { b with code = (Some v) }
      | "I_net" -> { b with i_net = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("code",  v)) a.code;
      Option.map (fun v -> ("I_net", string_of_float v)) a.i_net;
    ]

end

module Diffrn_source = struct
  type t = {
    current: float option;
    details: string option;
    diffrn_id: string option;
    power: float option;
    size: string option;
    source: string option;
    target: string option;
    type_: string option;
    voltage: float option;
    take_off_angle: float option;
    pdbx_wavelength_list: string option;
    pdbx_wavelength: string option;
    pdbx_synchrotron_beamline: string option;
    pdbx_synchrotron_site: string option;
    pdbx_synchrotron_y_n: string option;
    pdbx_source_specific_beamline: string option;
  }

  let default = {
    current = None;
    details = None;
    diffrn_id = None;
    power = None;
    size = None;
    source = None;
    target = None;
    type_ = None;
    voltage = None;
    take_off_angle = None;
    pdbx_wavelength_list = None;
    pdbx_wavelength = None;
    pdbx_synchrotron_beamline = None;
    pdbx_synchrotron_site = None;
    pdbx_synchrotron_y_n = None;
    pdbx_source_specific_beamline = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "current" -> { b with current = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "power" -> { b with power = (PDBjDict.some_float v) }
      | "size" -> { b with size = (Some v) }
      | "source" -> { b with source = (Some v) }
      | "target" -> { b with target = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "voltage" -> { b with voltage = (PDBjDict.some_float v) }
      | "take-off_angle" -> { b with take_off_angle = (PDBjDict.some_float v) }
      | "pdbx_wavelength_list" -> { b with pdbx_wavelength_list = (Some v) }
      | "pdbx_wavelength" -> { b with pdbx_wavelength = (Some v) }
      | "pdbx_synchrotron_beamline" -> { b with pdbx_synchrotron_beamline = (Some v) }
      | "pdbx_synchrotron_site" -> { b with pdbx_synchrotron_site = (Some v) }
      | "pdbx_synchrotron_y_n" -> { b with pdbx_synchrotron_y_n = (Some v) }
      | "pdbx_source_specific_beamline" -> { b with pdbx_source_specific_beamline = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("current", string_of_float v)) a.current;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("power", string_of_float v)) a.power;
      Option.map (fun v -> ("size",  v)) a.size;
      Option.map (fun v -> ("source",  v)) a.source;
      Option.map (fun v -> ("target",  v)) a.target;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("voltage", string_of_float v)) a.voltage;
      Option.map (fun v -> ("take-off_angle", string_of_float v)) a.take_off_angle;
      Option.map (fun v -> ("pdbx_wavelength_list",  v)) a.pdbx_wavelength_list;
      Option.map (fun v -> ("pdbx_wavelength",  v)) a.pdbx_wavelength;
      Option.map (fun v -> ("pdbx_synchrotron_beamline",  v)) a.pdbx_synchrotron_beamline;
      Option.map (fun v -> ("pdbx_synchrotron_site",  v)) a.pdbx_synchrotron_site;
      Option.map (fun v -> ("pdbx_synchrotron_y_n",  v)) a.pdbx_synchrotron_y_n;
      Option.map (fun v -> ("pdbx_source_specific_beamline",  v)) a.pdbx_source_specific_beamline;
    ]

end

module Diffrn_standard_refln = struct
  type t = {
    code: string option;
    diffrn_id: string option;
    index_h: int option;
    index_k: int option;
    index_l: int option;
  }

  let default = {
    code = None;
    diffrn_id = None;
    index_h = None;
    index_k = None;
    index_l = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "code" -> { b with code = (Some v) }
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "index_h" -> { b with index_h = (PDBjDict.some_int v) }
      | "index_k" -> { b with index_k = (PDBjDict.some_int v) }
      | "index_l" -> { b with index_l = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("code",  v)) a.code;
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("index_h", string_of_int v)) a.index_h;
      Option.map (fun v -> ("index_k", string_of_int v)) a.index_k;
      Option.map (fun v -> ("index_l", string_of_int v)) a.index_l;
    ]

end

module Diffrn_standards = struct
  type t = {
    diffrn_id: string option;
    decay_: float option;
    interval_count: int option;
    interval_time: float option;
    number: int option;
    scale_sigma: float option;
    scale_u: float option;
  }

  let default = {
    diffrn_id = None;
    decay_ = None;
    interval_count = None;
    interval_time = None;
    number = None;
    scale_sigma = None;
    scale_u = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "decay_%" -> { b with decay_ = (PDBjDict.some_float v) }
      | "interval_count" -> { b with interval_count = (PDBjDict.some_int v) }
      | "interval_time" -> { b with interval_time = (PDBjDict.some_float v) }
      | "number" -> { b with number = (PDBjDict.some_int v) }
      | "scale_sigma" -> { b with scale_sigma = (PDBjDict.some_float v) }
      | "scale_u" -> { b with scale_u = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("decay_%", string_of_float v)) a.decay_;
      Option.map (fun v -> ("interval_count", string_of_int v)) a.interval_count;
      Option.map (fun v -> ("interval_time", string_of_float v)) a.interval_time;
      Option.map (fun v -> ("number", string_of_int v)) a.number;
      Option.map (fun v -> ("scale_sigma", string_of_float v)) a.scale_sigma;
      Option.map (fun v -> ("scale_u", string_of_float v)) a.scale_u;
    ]

end

module Entity = struct
  type t = {
    details: string option;
    formula_weight: float option;
    id: string option;
    src_method: string option;
    type_: string option;
    pdbx_description: string option;
    pdbx_number_of_molecules: float option;
    pdbx_parent_entity_id: string option;
    pdbx_mutation: string option;
    pdbx_fragment: string option;
    pdbx_ec: string option;
    pdbx_modification: string option;
    pdbx_formula_weight_exptl: float option;
    pdbx_formula_weight_exptl_method: string option;
    pdbx_target_id: string option;
    pdbx_entities_per_biological_unit: float option;
  }

  let default = {
    details = None;
    formula_weight = None;
    id = None;
    src_method = None;
    type_ = None;
    pdbx_description = None;
    pdbx_number_of_molecules = None;
    pdbx_parent_entity_id = None;
    pdbx_mutation = None;
    pdbx_fragment = None;
    pdbx_ec = None;
    pdbx_modification = None;
    pdbx_formula_weight_exptl = None;
    pdbx_formula_weight_exptl_method = None;
    pdbx_target_id = None;
    pdbx_entities_per_biological_unit = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "formula_weight" -> { b with formula_weight = (PDBjDict.some_float v) }
      | "id" -> { b with id = (Some v) }
      | "src_method" -> { b with src_method = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "pdbx_description" -> { b with pdbx_description = (Some v) }
      | "pdbx_number_of_molecules" -> { b with pdbx_number_of_molecules = (PDBjDict.some_float v) }
      | "pdbx_parent_entity_id" -> { b with pdbx_parent_entity_id = (Some v) }
      | "pdbx_mutation" -> { b with pdbx_mutation = (Some v) }
      | "pdbx_fragment" -> { b with pdbx_fragment = (Some v) }
      | "pdbx_ec" -> { b with pdbx_ec = (Some v) }
      | "pdbx_modification" -> { b with pdbx_modification = (Some v) }
      | "pdbx_formula_weight_exptl" -> { b with pdbx_formula_weight_exptl = (PDBjDict.some_float v) }
      | "pdbx_formula_weight_exptl_method" -> { b with pdbx_formula_weight_exptl_method = (Some v) }
      | "pdbx_target_id" -> { b with pdbx_target_id = (Some v) }
      | "pdbx_entities_per_biological_unit" -> { b with pdbx_entities_per_biological_unit = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("formula_weight", string_of_float v)) a.formula_weight;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("src_method",  v)) a.src_method;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("pdbx_description",  v)) a.pdbx_description;
      Option.map (fun v -> ("pdbx_number_of_molecules", string_of_float v)) a.pdbx_number_of_molecules;
      Option.map (fun v -> ("pdbx_parent_entity_id",  v)) a.pdbx_parent_entity_id;
      Option.map (fun v -> ("pdbx_mutation",  v)) a.pdbx_mutation;
      Option.map (fun v -> ("pdbx_fragment",  v)) a.pdbx_fragment;
      Option.map (fun v -> ("pdbx_ec",  v)) a.pdbx_ec;
      Option.map (fun v -> ("pdbx_modification",  v)) a.pdbx_modification;
      Option.map (fun v -> ("pdbx_formula_weight_exptl", string_of_float v)) a.pdbx_formula_weight_exptl;
      Option.map (fun v -> ("pdbx_formula_weight_exptl_method",  v)) a.pdbx_formula_weight_exptl_method;
      Option.map (fun v -> ("pdbx_target_id",  v)) a.pdbx_target_id;
      Option.map (fun v -> ("pdbx_entities_per_biological_unit", string_of_float v)) a.pdbx_entities_per_biological_unit;
    ]

end

module Entity_keywords = struct
  type t = {
    entity_id: string option;
    text: string option;
    pdbx_mutation: string option;
    pdbx_fragment: string option;
    pdbx_ec: string option;
    pdbx_antibody_isotype: string option;
  }

  let default = {
    entity_id = None;
    text = None;
    pdbx_mutation = None;
    pdbx_fragment = None;
    pdbx_ec = None;
    pdbx_antibody_isotype = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "text" -> { b with text = (Some v) }
      | "pdbx_mutation" -> { b with pdbx_mutation = (Some v) }
      | "pdbx_fragment" -> { b with pdbx_fragment = (Some v) }
      | "pdbx_ec" -> { b with pdbx_ec = (Some v) }
      | "pdbx_antibody_isotype" -> { b with pdbx_antibody_isotype = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("text",  v)) a.text;
      Option.map (fun v -> ("pdbx_mutation",  v)) a.pdbx_mutation;
      Option.map (fun v -> ("pdbx_fragment",  v)) a.pdbx_fragment;
      Option.map (fun v -> ("pdbx_ec",  v)) a.pdbx_ec;
      Option.map (fun v -> ("pdbx_antibody_isotype",  v)) a.pdbx_antibody_isotype;
    ]

end

module Entity_link = struct
  type t = {
    link_id: string option;
    details: string option;
    entity_id_1: string option;
    entity_id_2: string option;
    entity_seq_num_1: int option;
    entity_seq_num_2: int option;
  }

  let default = {
    link_id = None;
    details = None;
    entity_id_1 = None;
    entity_id_2 = None;
    entity_seq_num_1 = None;
    entity_seq_num_2 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "link_id" -> { b with link_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "entity_id_1" -> { b with entity_id_1 = (Some v) }
      | "entity_id_2" -> { b with entity_id_2 = (Some v) }
      | "entity_seq_num_1" -> { b with entity_seq_num_1 = (PDBjDict.some_int v) }
      | "entity_seq_num_2" -> { b with entity_seq_num_2 = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("link_id",  v)) a.link_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entity_id_1",  v)) a.entity_id_1;
      Option.map (fun v -> ("entity_id_2",  v)) a.entity_id_2;
      Option.map (fun v -> ("entity_seq_num_1", string_of_int v)) a.entity_seq_num_1;
      Option.map (fun v -> ("entity_seq_num_2", string_of_int v)) a.entity_seq_num_2;
    ]

end

module Entity_name_com = struct
  type t = {
    entity_id: string option;
    name: string option;
  }

  let default = {
    entity_id = None;
    name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("name",  v)) a.name;
    ]

end

module Entity_name_sys = struct
  type t = {
    entity_id: string option;
    name: string option;
    system: string option;
  }

  let default = {
    entity_id = None;
    name = None;
    system = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "system" -> { b with system = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("system",  v)) a.system;
    ]

end

module Entity_poly = struct
  type t = {
    entity_id: string option;
    nstd_chirality: string option;
    nstd_linkage: string option;
    nstd_monomer: string option;
    number_of_monomers: int option;
    type_: string option;
    type_details: string option;
    pdbx_strand_id: string option;
    pdbx_seq_one_letter_code: string option;
    pdbx_seq_one_letter_code_can: string option;
    pdbx_target_identifier: string option;
    pdbx_seq_one_letter_code_sample: string option;
    pdbx_explicit_linking_flag: string option;
    pdbx_sequence_evidence_code: string option;
    pdbx_build_self_reference: string option;
    pdbx_N_terminal_seq_one_letter_code: string option;
    pdbx_C_terminal_seq_one_letter_code: string option;
    pdbx_seq_three_letter_code: string option;
    pdbx_seq_db_name: string option;
    pdbx_seq_db_id: string option;
    pdbx_seq_align_begin: int option;
    pdbx_seq_align_end: int option;
  }

  let default = {
    entity_id = None;
    nstd_chirality = None;
    nstd_linkage = None;
    nstd_monomer = None;
    number_of_monomers = None;
    type_ = None;
    type_details = None;
    pdbx_strand_id = None;
    pdbx_seq_one_letter_code = None;
    pdbx_seq_one_letter_code_can = None;
    pdbx_target_identifier = None;
    pdbx_seq_one_letter_code_sample = None;
    pdbx_explicit_linking_flag = None;
    pdbx_sequence_evidence_code = None;
    pdbx_build_self_reference = None;
    pdbx_N_terminal_seq_one_letter_code = None;
    pdbx_C_terminal_seq_one_letter_code = None;
    pdbx_seq_three_letter_code = None;
    pdbx_seq_db_name = None;
    pdbx_seq_db_id = None;
    pdbx_seq_align_begin = None;
    pdbx_seq_align_end = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "nstd_chirality" -> { b with nstd_chirality = (Some v) }
      | "nstd_linkage" -> { b with nstd_linkage = (Some v) }
      | "nstd_monomer" -> { b with nstd_monomer = (Some v) }
      | "number_of_monomers" -> { b with number_of_monomers = (PDBjDict.some_int v) }
      | "type" -> { b with type_ = (Some v) }
      | "type_details" -> { b with type_details = (Some v) }
      | "pdbx_strand_id" -> { b with pdbx_strand_id = (Some v) }
      | "pdbx_seq_one_letter_code" -> { b with pdbx_seq_one_letter_code = (Some v) }
      | "pdbx_seq_one_letter_code_can" -> { b with pdbx_seq_one_letter_code_can = (Some v) }
      | "pdbx_target_identifier" -> { b with pdbx_target_identifier = (Some v) }
      | "pdbx_seq_one_letter_code_sample" -> { b with pdbx_seq_one_letter_code_sample = (Some v) }
      | "pdbx_explicit_linking_flag" -> { b with pdbx_explicit_linking_flag = (Some v) }
      | "pdbx_sequence_evidence_code" -> { b with pdbx_sequence_evidence_code = (Some v) }
      | "pdbx_build_self_reference" -> { b with pdbx_build_self_reference = (Some v) }
      | "pdbx_N_terminal_seq_one_letter_code" -> { b with pdbx_N_terminal_seq_one_letter_code = (Some v) }
      | "pdbx_C_terminal_seq_one_letter_code" -> { b with pdbx_C_terminal_seq_one_letter_code = (Some v) }
      | "pdbx_seq_three_letter_code" -> { b with pdbx_seq_three_letter_code = (Some v) }
      | "pdbx_seq_db_name" -> { b with pdbx_seq_db_name = (Some v) }
      | "pdbx_seq_db_id" -> { b with pdbx_seq_db_id = (Some v) }
      | "pdbx_seq_align_begin" -> { b with pdbx_seq_align_begin = (PDBjDict.some_int v) }
      | "pdbx_seq_align_end" -> { b with pdbx_seq_align_end = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("nstd_chirality",  v)) a.nstd_chirality;
      Option.map (fun v -> ("nstd_linkage",  v)) a.nstd_linkage;
      Option.map (fun v -> ("nstd_monomer",  v)) a.nstd_monomer;
      Option.map (fun v -> ("number_of_monomers", string_of_int v)) a.number_of_monomers;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("type_details",  v)) a.type_details;
      Option.map (fun v -> ("pdbx_strand_id",  v)) a.pdbx_strand_id;
      Option.map (fun v -> ("pdbx_seq_one_letter_code",  v)) a.pdbx_seq_one_letter_code;
      Option.map (fun v -> ("pdbx_seq_one_letter_code_can",  v)) a.pdbx_seq_one_letter_code_can;
      Option.map (fun v -> ("pdbx_target_identifier",  v)) a.pdbx_target_identifier;
      Option.map (fun v -> ("pdbx_seq_one_letter_code_sample",  v)) a.pdbx_seq_one_letter_code_sample;
      Option.map (fun v -> ("pdbx_explicit_linking_flag",  v)) a.pdbx_explicit_linking_flag;
      Option.map (fun v -> ("pdbx_sequence_evidence_code",  v)) a.pdbx_sequence_evidence_code;
      Option.map (fun v -> ("pdbx_build_self_reference",  v)) a.pdbx_build_self_reference;
      Option.map (fun v -> ("pdbx_N_terminal_seq_one_letter_code",  v)) a.pdbx_N_terminal_seq_one_letter_code;
      Option.map (fun v -> ("pdbx_C_terminal_seq_one_letter_code",  v)) a.pdbx_C_terminal_seq_one_letter_code;
      Option.map (fun v -> ("pdbx_seq_three_letter_code",  v)) a.pdbx_seq_three_letter_code;
      Option.map (fun v -> ("pdbx_seq_db_name",  v)) a.pdbx_seq_db_name;
      Option.map (fun v -> ("pdbx_seq_db_id",  v)) a.pdbx_seq_db_id;
      Option.map (fun v -> ("pdbx_seq_align_begin", string_of_int v)) a.pdbx_seq_align_begin;
      Option.map (fun v -> ("pdbx_seq_align_end", string_of_int v)) a.pdbx_seq_align_end;
    ]

end

module Entity_poly_seq = struct
  type t = {
    entity_id: string option;
    hetero: string option;
    mon_id: string option;
    num: int option;
  }

  let default = {
    entity_id = None;
    hetero = None;
    mon_id = None;
    num = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "hetero" -> { b with hetero = (Some v) }
      | "mon_id" -> { b with mon_id = (Some v) }
      | "num" -> { b with num = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("hetero",  v)) a.hetero;
      Option.map (fun v -> ("mon_id",  v)) a.mon_id;
      Option.map (fun v -> ("num", string_of_int v)) a.num;
    ]

end

module Entry = struct
  type t = {
    id: string option;
    pdbx_DOI: string option;
  }

  let default = {
    id = None;
    pdbx_DOI = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "pdbx_DOI" -> { b with pdbx_DOI = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("pdbx_DOI",  v)) a.pdbx_DOI;
    ]

end

module Entry_link = struct
  type t = {
    entry_id: string option;
    id: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Exptl = struct
  type t = {
    absorpt_coefficient_mu: float option;
    absorpt_correction_T_max: float option;
    absorpt_correction_T_min: float option;
    absorpt_correction_type: string option;
    absorpt_process_details: string option;
    entry_id: string option;
    crystals_number: int option;
    details: string option;
    method_: string option;
    method_details: string option;
  }

  let default = {
    absorpt_coefficient_mu = None;
    absorpt_correction_T_max = None;
    absorpt_correction_T_min = None;
    absorpt_correction_type = None;
    absorpt_process_details = None;
    entry_id = None;
    crystals_number = None;
    details = None;
    method_ = None;
    method_details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "absorpt_coefficient_mu" -> { b with absorpt_coefficient_mu = (PDBjDict.some_float v) }
      | "absorpt_correction_T_max" -> { b with absorpt_correction_T_max = (PDBjDict.some_float v) }
      | "absorpt_correction_T_min" -> { b with absorpt_correction_T_min = (PDBjDict.some_float v) }
      | "absorpt_correction_type" -> { b with absorpt_correction_type = (Some v) }
      | "absorpt_process_details" -> { b with absorpt_process_details = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "crystals_number" -> { b with crystals_number = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "method_details" -> { b with method_details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("absorpt_coefficient_mu", string_of_float v)) a.absorpt_coefficient_mu;
      Option.map (fun v -> ("absorpt_correction_T_max", string_of_float v)) a.absorpt_correction_T_max;
      Option.map (fun v -> ("absorpt_correction_T_min", string_of_float v)) a.absorpt_correction_T_min;
      Option.map (fun v -> ("absorpt_correction_type",  v)) a.absorpt_correction_type;
      Option.map (fun v -> ("absorpt_process_details",  v)) a.absorpt_process_details;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("crystals_number", string_of_int v)) a.crystals_number;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("method_details",  v)) a.method_details;
    ]

end

module Exptl_crystal = struct
  type t = {
    colour: string option;
    density_diffrn: float option;
    density_Matthews: float option;
    density_method: string option;
    density_percent_sol: float option;
    description: string option;
    f_000: int option;
    id: string option;
    preparation: string option;
    size_max: float option;
    size_mid: float option;
    size_min: float option;
    size_rad: float option;
    colour_lustre: string option;
    colour_modifier: string option;
    colour_primary: string option;
    density_meas: float option;
    density_meas_esd: float option;
    density_meas_gt: float option;
    density_meas_lt: float option;
    density_meas_temp: float option;
    density_meas_temp_esd: float option;
    density_meas_temp_gt: float option;
    density_meas_temp_lt: float option;
    pdbx_crystal_image_url: string option;
    pdbx_crystal_image_format: string option;
    pdbx_mosaicity: float option;
    pdbx_mosaicity_esd: float option;
    pdbx_crystal_image: string option;
    pdbx_x_ray_image: string option;
    pdbx_x_ray_image_type: string option;
    pdbx_crystal_diffrn_limit: float option;
    pdbx_crystal_diffrn_lifetime: float option;
    pdbx_crystal_direction_1: float option;
    pdbx_crystal_direction_2: float option;
    pdbx_crystal_direction_3: float option;
  }

  let default = {
    colour = None;
    density_diffrn = None;
    density_Matthews = None;
    density_method = None;
    density_percent_sol = None;
    description = None;
    f_000 = None;
    id = None;
    preparation = None;
    size_max = None;
    size_mid = None;
    size_min = None;
    size_rad = None;
    colour_lustre = None;
    colour_modifier = None;
    colour_primary = None;
    density_meas = None;
    density_meas_esd = None;
    density_meas_gt = None;
    density_meas_lt = None;
    density_meas_temp = None;
    density_meas_temp_esd = None;
    density_meas_temp_gt = None;
    density_meas_temp_lt = None;
    pdbx_crystal_image_url = None;
    pdbx_crystal_image_format = None;
    pdbx_mosaicity = None;
    pdbx_mosaicity_esd = None;
    pdbx_crystal_image = None;
    pdbx_x_ray_image = None;
    pdbx_x_ray_image_type = None;
    pdbx_crystal_diffrn_limit = None;
    pdbx_crystal_diffrn_lifetime = None;
    pdbx_crystal_direction_1 = None;
    pdbx_crystal_direction_2 = None;
    pdbx_crystal_direction_3 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "colour" -> { b with colour = (Some v) }
      | "density_diffrn" -> { b with density_diffrn = (PDBjDict.some_float v) }
      | "density_Matthews" -> { b with density_Matthews = (PDBjDict.some_float v) }
      | "density_method" -> { b with density_method = (Some v) }
      | "density_percent_sol" -> { b with density_percent_sol = (PDBjDict.some_float v) }
      | "description" -> { b with description = (Some v) }
      | "F_000" -> { b with f_000 = (PDBjDict.some_int v) }
      | "id" -> { b with id = (Some v) }
      | "preparation" -> { b with preparation = (Some v) }
      | "size_max" -> { b with size_max = (PDBjDict.some_float v) }
      | "size_mid" -> { b with size_mid = (PDBjDict.some_float v) }
      | "size_min" -> { b with size_min = (PDBjDict.some_float v) }
      | "size_rad" -> { b with size_rad = (PDBjDict.some_float v) }
      | "colour_lustre" -> { b with colour_lustre = (Some v) }
      | "colour_modifier" -> { b with colour_modifier = (Some v) }
      | "colour_primary" -> { b with colour_primary = (Some v) }
      | "density_meas" -> { b with density_meas = (PDBjDict.some_float v) }
      | "density_meas_esd" -> { b with density_meas_esd = (PDBjDict.some_float v) }
      | "density_meas_gt" -> { b with density_meas_gt = (PDBjDict.some_float v) }
      | "density_meas_lt" -> { b with density_meas_lt = (PDBjDict.some_float v) }
      | "density_meas_temp" -> { b with density_meas_temp = (PDBjDict.some_float v) }
      | "density_meas_temp_esd" -> { b with density_meas_temp_esd = (PDBjDict.some_float v) }
      | "density_meas_temp_gt" -> { b with density_meas_temp_gt = (PDBjDict.some_float v) }
      | "density_meas_temp_lt" -> { b with density_meas_temp_lt = (PDBjDict.some_float v) }
      | "pdbx_crystal_image_url" -> { b with pdbx_crystal_image_url = (Some v) }
      | "pdbx_crystal_image_format" -> { b with pdbx_crystal_image_format = (Some v) }
      | "pdbx_mosaicity" -> { b with pdbx_mosaicity = (PDBjDict.some_float v) }
      | "pdbx_mosaicity_esd" -> { b with pdbx_mosaicity_esd = (PDBjDict.some_float v) }
      | "pdbx_crystal_image" -> { b with pdbx_crystal_image = (Some v) }
      | "pdbx_x-ray_image" -> { b with pdbx_x_ray_image = (Some v) }
      | "pdbx_x-ray_image_type" -> { b with pdbx_x_ray_image_type = (Some v) }
      | "pdbx_crystal_diffrn_limit" -> { b with pdbx_crystal_diffrn_limit = (PDBjDict.some_float v) }
      | "pdbx_crystal_diffrn_lifetime" -> { b with pdbx_crystal_diffrn_lifetime = (PDBjDict.some_float v) }
      | "pdbx_crystal_direction_1" -> { b with pdbx_crystal_direction_1 = (PDBjDict.some_float v) }
      | "pdbx_crystal_direction_2" -> { b with pdbx_crystal_direction_2 = (PDBjDict.some_float v) }
      | "pdbx_crystal_direction_3" -> { b with pdbx_crystal_direction_3 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("colour",  v)) a.colour;
      Option.map (fun v -> ("density_diffrn", string_of_float v)) a.density_diffrn;
      Option.map (fun v -> ("density_Matthews", string_of_float v)) a.density_Matthews;
      Option.map (fun v -> ("density_method",  v)) a.density_method;
      Option.map (fun v -> ("density_percent_sol", string_of_float v)) a.density_percent_sol;
      Option.map (fun v -> ("description",  v)) a.description;
      Option.map (fun v -> ("F_000", string_of_int v)) a.f_000;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("preparation",  v)) a.preparation;
      Option.map (fun v -> ("size_max", string_of_float v)) a.size_max;
      Option.map (fun v -> ("size_mid", string_of_float v)) a.size_mid;
      Option.map (fun v -> ("size_min", string_of_float v)) a.size_min;
      Option.map (fun v -> ("size_rad", string_of_float v)) a.size_rad;
      Option.map (fun v -> ("colour_lustre",  v)) a.colour_lustre;
      Option.map (fun v -> ("colour_modifier",  v)) a.colour_modifier;
      Option.map (fun v -> ("colour_primary",  v)) a.colour_primary;
      Option.map (fun v -> ("density_meas", string_of_float v)) a.density_meas;
      Option.map (fun v -> ("density_meas_esd", string_of_float v)) a.density_meas_esd;
      Option.map (fun v -> ("density_meas_gt", string_of_float v)) a.density_meas_gt;
      Option.map (fun v -> ("density_meas_lt", string_of_float v)) a.density_meas_lt;
      Option.map (fun v -> ("density_meas_temp", string_of_float v)) a.density_meas_temp;
      Option.map (fun v -> ("density_meas_temp_esd", string_of_float v)) a.density_meas_temp_esd;
      Option.map (fun v -> ("density_meas_temp_gt", string_of_float v)) a.density_meas_temp_gt;
      Option.map (fun v -> ("density_meas_temp_lt", string_of_float v)) a.density_meas_temp_lt;
      Option.map (fun v -> ("pdbx_crystal_image_url",  v)) a.pdbx_crystal_image_url;
      Option.map (fun v -> ("pdbx_crystal_image_format",  v)) a.pdbx_crystal_image_format;
      Option.map (fun v -> ("pdbx_mosaicity", string_of_float v)) a.pdbx_mosaicity;
      Option.map (fun v -> ("pdbx_mosaicity_esd", string_of_float v)) a.pdbx_mosaicity_esd;
      Option.map (fun v -> ("pdbx_crystal_image",  v)) a.pdbx_crystal_image;
      Option.map (fun v -> ("pdbx_x-ray_image",  v)) a.pdbx_x_ray_image;
      Option.map (fun v -> ("pdbx_x-ray_image_type",  v)) a.pdbx_x_ray_image_type;
      Option.map (fun v -> ("pdbx_crystal_diffrn_limit", string_of_float v)) a.pdbx_crystal_diffrn_limit;
      Option.map (fun v -> ("pdbx_crystal_diffrn_lifetime", string_of_float v)) a.pdbx_crystal_diffrn_lifetime;
      Option.map (fun v -> ("pdbx_crystal_direction_1", string_of_float v)) a.pdbx_crystal_direction_1;
      Option.map (fun v -> ("pdbx_crystal_direction_2", string_of_float v)) a.pdbx_crystal_direction_2;
      Option.map (fun v -> ("pdbx_crystal_direction_3", string_of_float v)) a.pdbx_crystal_direction_3;
    ]

end

module Exptl_crystal_face = struct
  type t = {
    crystal_id: string option;
    diffr_chi: float option;
    diffr_kappa: float option;
    diffr_phi: float option;
    diffr_psi: float option;
    index_h: int option;
    index_k: int option;
    index_l: int option;
    perp_dist: float option;
  }

  let default = {
    crystal_id = None;
    diffr_chi = None;
    diffr_kappa = None;
    diffr_phi = None;
    diffr_psi = None;
    index_h = None;
    index_k = None;
    index_l = None;
    perp_dist = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "crystal_id" -> { b with crystal_id = (Some v) }
      | "diffr_chi" -> { b with diffr_chi = (PDBjDict.some_float v) }
      | "diffr_kappa" -> { b with diffr_kappa = (PDBjDict.some_float v) }
      | "diffr_phi" -> { b with diffr_phi = (PDBjDict.some_float v) }
      | "diffr_psi" -> { b with diffr_psi = (PDBjDict.some_float v) }
      | "index_h" -> { b with index_h = (PDBjDict.some_int v) }
      | "index_k" -> { b with index_k = (PDBjDict.some_int v) }
      | "index_l" -> { b with index_l = (PDBjDict.some_int v) }
      | "perp_dist" -> { b with perp_dist = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("crystal_id",  v)) a.crystal_id;
      Option.map (fun v -> ("diffr_chi", string_of_float v)) a.diffr_chi;
      Option.map (fun v -> ("diffr_kappa", string_of_float v)) a.diffr_kappa;
      Option.map (fun v -> ("diffr_phi", string_of_float v)) a.diffr_phi;
      Option.map (fun v -> ("diffr_psi", string_of_float v)) a.diffr_psi;
      Option.map (fun v -> ("index_h", string_of_int v)) a.index_h;
      Option.map (fun v -> ("index_k", string_of_int v)) a.index_k;
      Option.map (fun v -> ("index_l", string_of_int v)) a.index_l;
      Option.map (fun v -> ("perp_dist", string_of_float v)) a.perp_dist;
    ]

end

module Exptl_crystal_grow = struct
  type t = {
    apparatus: string option;
    atmosphere: string option;
    crystal_id: string option;
    details: string option;
    method_: string option;
    method_ref: string option;
    pH: float option;
    pressure: float option;
    pressure_esd: float option;
    seeding: string option;
    seeding_ref: string option;
    temp: float option;
    temp_details: string option;
    temp_esd: float option;
    time: string option;
    pdbx_details: string option;
    pdbx_pH_range: string option;
  }

  let default = {
    apparatus = None;
    atmosphere = None;
    crystal_id = None;
    details = None;
    method_ = None;
    method_ref = None;
    pH = None;
    pressure = None;
    pressure_esd = None;
    seeding = None;
    seeding_ref = None;
    temp = None;
    temp_details = None;
    temp_esd = None;
    time = None;
    pdbx_details = None;
    pdbx_pH_range = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "apparatus" -> { b with apparatus = (Some v) }
      | "atmosphere" -> { b with atmosphere = (Some v) }
      | "crystal_id" -> { b with crystal_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "method_ref" -> { b with method_ref = (Some v) }
      | "pH" -> { b with pH = (PDBjDict.some_float v) }
      | "pressure" -> { b with pressure = (PDBjDict.some_float v) }
      | "pressure_esd" -> { b with pressure_esd = (PDBjDict.some_float v) }
      | "seeding" -> { b with seeding = (Some v) }
      | "seeding_ref" -> { b with seeding_ref = (Some v) }
      | "temp" -> { b with temp = (PDBjDict.some_float v) }
      | "temp_details" -> { b with temp_details = (Some v) }
      | "temp_esd" -> { b with temp_esd = (PDBjDict.some_float v) }
      | "time" -> { b with time = (Some v) }
      | "pdbx_details" -> { b with pdbx_details = (Some v) }
      | "pdbx_pH_range" -> { b with pdbx_pH_range = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("apparatus",  v)) a.apparatus;
      Option.map (fun v -> ("atmosphere",  v)) a.atmosphere;
      Option.map (fun v -> ("crystal_id",  v)) a.crystal_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("method_ref",  v)) a.method_ref;
      Option.map (fun v -> ("pH", string_of_float v)) a.pH;
      Option.map (fun v -> ("pressure", string_of_float v)) a.pressure;
      Option.map (fun v -> ("pressure_esd", string_of_float v)) a.pressure_esd;
      Option.map (fun v -> ("seeding",  v)) a.seeding;
      Option.map (fun v -> ("seeding_ref",  v)) a.seeding_ref;
      Option.map (fun v -> ("temp", string_of_float v)) a.temp;
      Option.map (fun v -> ("temp_details",  v)) a.temp_details;
      Option.map (fun v -> ("temp_esd", string_of_float v)) a.temp_esd;
      Option.map (fun v -> ("time",  v)) a.time;
      Option.map (fun v -> ("pdbx_details",  v)) a.pdbx_details;
      Option.map (fun v -> ("pdbx_pH_range",  v)) a.pdbx_pH_range;
    ]

end

module Exptl_crystal_grow_comp = struct
  type t = {
    conc: string option;
    details: string option;
    crystal_id: string option;
    id: string option;
    name: string option;
    sol_id: string option;
    volume: string option;
    pdbx_conc_final: string option;
    pdbx_bath: string option;
    pdbx_salt: string option;
    pdbx_soak_salt: string option;
    pdbx_soak_solv: string option;
    pdbx_solv: string option;
  }

  let default = {
    conc = None;
    details = None;
    crystal_id = None;
    id = None;
    name = None;
    sol_id = None;
    volume = None;
    pdbx_conc_final = None;
    pdbx_bath = None;
    pdbx_salt = None;
    pdbx_soak_salt = None;
    pdbx_soak_solv = None;
    pdbx_solv = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "conc" -> { b with conc = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "crystal_id" -> { b with crystal_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "sol_id" -> { b with sol_id = (Some v) }
      | "volume" -> { b with volume = (Some v) }
      | "pdbx_conc_final" -> { b with pdbx_conc_final = (Some v) }
      | "pdbx_bath" -> { b with pdbx_bath = (Some v) }
      | "pdbx_salt" -> { b with pdbx_salt = (Some v) }
      | "pdbx_soak_salt" -> { b with pdbx_soak_salt = (Some v) }
      | "pdbx_soak_solv" -> { b with pdbx_soak_solv = (Some v) }
      | "pdbx_solv" -> { b with pdbx_solv = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("conc",  v)) a.conc;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("crystal_id",  v)) a.crystal_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("sol_id",  v)) a.sol_id;
      Option.map (fun v -> ("volume",  v)) a.volume;
      Option.map (fun v -> ("pdbx_conc_final",  v)) a.pdbx_conc_final;
      Option.map (fun v -> ("pdbx_bath",  v)) a.pdbx_bath;
      Option.map (fun v -> ("pdbx_salt",  v)) a.pdbx_salt;
      Option.map (fun v -> ("pdbx_soak_salt",  v)) a.pdbx_soak_salt;
      Option.map (fun v -> ("pdbx_soak_solv",  v)) a.pdbx_soak_solv;
      Option.map (fun v -> ("pdbx_solv",  v)) a.pdbx_solv;
    ]

end

module Geom = struct
  type t = {
    entry_id: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Geom_angle = struct
  type t = {
    atom_site_id_1: string option;
    atom_site_label_alt_id_1: string option;
    atom_site_label_atom_id_1: string option;
    atom_site_label_comp_id_1: string option;
    atom_site_label_seq_id_1: int option;
    atom_site_label_asym_id_1: string option;
    atom_site_id_2: string option;
    atom_site_label_alt_id_2: string option;
    atom_site_label_atom_id_2: string option;
    atom_site_label_comp_id_2: string option;
    atom_site_label_seq_id_2: int option;
    atom_site_label_asym_id_2: string option;
    atom_site_id_3: string option;
    atom_site_label_alt_id_3: string option;
    atom_site_label_atom_id_3: string option;
    atom_site_label_comp_id_3: string option;
    atom_site_label_seq_id_3: int option;
    atom_site_label_asym_id_3: string option;
    atom_site_auth_asym_id_1: string option;
    atom_site_auth_atom_id_1: string option;
    atom_site_auth_comp_id_1: string option;
    atom_site_auth_seq_id_1: string option;
    atom_site_auth_atom_id_2: string option;
    atom_site_auth_asym_id_2: string option;
    atom_site_auth_comp_id_2: string option;
    atom_site_auth_seq_id_2: string option;
    atom_site_auth_atom_id_3: string option;
    atom_site_auth_asym_id_3: string option;
    atom_site_auth_comp_id_3: string option;
    atom_site_auth_seq_id_3: string option;
    publ_flag: string option;
    site_symmetry_1: string option;
    site_symmetry_2: string option;
    site_symmetry_3: string option;
    value: float option;
    value_esd: float option;
    pdbx_atom_site_PDB_ins_code_1: string option;
    pdbx_atom_site_PDB_ins_code_2: string option;
    pdbx_atom_site_PDB_ins_code_3: string option;
    pdbx_PDB_model_num: int option;
  }

  let default = {
    atom_site_id_1 = None;
    atom_site_label_alt_id_1 = None;
    atom_site_label_atom_id_1 = None;
    atom_site_label_comp_id_1 = None;
    atom_site_label_seq_id_1 = None;
    atom_site_label_asym_id_1 = None;
    atom_site_id_2 = None;
    atom_site_label_alt_id_2 = None;
    atom_site_label_atom_id_2 = None;
    atom_site_label_comp_id_2 = None;
    atom_site_label_seq_id_2 = None;
    atom_site_label_asym_id_2 = None;
    atom_site_id_3 = None;
    atom_site_label_alt_id_3 = None;
    atom_site_label_atom_id_3 = None;
    atom_site_label_comp_id_3 = None;
    atom_site_label_seq_id_3 = None;
    atom_site_label_asym_id_3 = None;
    atom_site_auth_asym_id_1 = None;
    atom_site_auth_atom_id_1 = None;
    atom_site_auth_comp_id_1 = None;
    atom_site_auth_seq_id_1 = None;
    atom_site_auth_atom_id_2 = None;
    atom_site_auth_asym_id_2 = None;
    atom_site_auth_comp_id_2 = None;
    atom_site_auth_seq_id_2 = None;
    atom_site_auth_atom_id_3 = None;
    atom_site_auth_asym_id_3 = None;
    atom_site_auth_comp_id_3 = None;
    atom_site_auth_seq_id_3 = None;
    publ_flag = None;
    site_symmetry_1 = None;
    site_symmetry_2 = None;
    site_symmetry_3 = None;
    value = None;
    value_esd = None;
    pdbx_atom_site_PDB_ins_code_1 = None;
    pdbx_atom_site_PDB_ins_code_2 = None;
    pdbx_atom_site_PDB_ins_code_3 = None;
    pdbx_PDB_model_num = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_site_id_1" -> { b with atom_site_id_1 = (Some v) }
      | "atom_site_label_alt_id_1" -> { b with atom_site_label_alt_id_1 = (Some v) }
      | "atom_site_label_atom_id_1" -> { b with atom_site_label_atom_id_1 = (Some v) }
      | "atom_site_label_comp_id_1" -> { b with atom_site_label_comp_id_1 = (Some v) }
      | "atom_site_label_seq_id_1" -> { b with atom_site_label_seq_id_1 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_1" -> { b with atom_site_label_asym_id_1 = (Some v) }
      | "atom_site_id_2" -> { b with atom_site_id_2 = (Some v) }
      | "atom_site_label_alt_id_2" -> { b with atom_site_label_alt_id_2 = (Some v) }
      | "atom_site_label_atom_id_2" -> { b with atom_site_label_atom_id_2 = (Some v) }
      | "atom_site_label_comp_id_2" -> { b with atom_site_label_comp_id_2 = (Some v) }
      | "atom_site_label_seq_id_2" -> { b with atom_site_label_seq_id_2 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_2" -> { b with atom_site_label_asym_id_2 = (Some v) }
      | "atom_site_id_3" -> { b with atom_site_id_3 = (Some v) }
      | "atom_site_label_alt_id_3" -> { b with atom_site_label_alt_id_3 = (Some v) }
      | "atom_site_label_atom_id_3" -> { b with atom_site_label_atom_id_3 = (Some v) }
      | "atom_site_label_comp_id_3" -> { b with atom_site_label_comp_id_3 = (Some v) }
      | "atom_site_label_seq_id_3" -> { b with atom_site_label_seq_id_3 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_3" -> { b with atom_site_label_asym_id_3 = (Some v) }
      | "atom_site_auth_asym_id_1" -> { b with atom_site_auth_asym_id_1 = (Some v) }
      | "atom_site_auth_atom_id_1" -> { b with atom_site_auth_atom_id_1 = (Some v) }
      | "atom_site_auth_comp_id_1" -> { b with atom_site_auth_comp_id_1 = (Some v) }
      | "atom_site_auth_seq_id_1" -> { b with atom_site_auth_seq_id_1 = (Some v) }
      | "atom_site_auth_atom_id_2" -> { b with atom_site_auth_atom_id_2 = (Some v) }
      | "atom_site_auth_asym_id_2" -> { b with atom_site_auth_asym_id_2 = (Some v) }
      | "atom_site_auth_comp_id_2" -> { b with atom_site_auth_comp_id_2 = (Some v) }
      | "atom_site_auth_seq_id_2" -> { b with atom_site_auth_seq_id_2 = (Some v) }
      | "atom_site_auth_atom_id_3" -> { b with atom_site_auth_atom_id_3 = (Some v) }
      | "atom_site_auth_asym_id_3" -> { b with atom_site_auth_asym_id_3 = (Some v) }
      | "atom_site_auth_comp_id_3" -> { b with atom_site_auth_comp_id_3 = (Some v) }
      | "atom_site_auth_seq_id_3" -> { b with atom_site_auth_seq_id_3 = (Some v) }
      | "publ_flag" -> { b with publ_flag = (Some v) }
      | "site_symmetry_1" -> { b with site_symmetry_1 = (Some v) }
      | "site_symmetry_2" -> { b with site_symmetry_2 = (Some v) }
      | "site_symmetry_3" -> { b with site_symmetry_3 = (Some v) }
      | "value" -> { b with value = (PDBjDict.some_float v) }
      | "value_esd" -> { b with value_esd = (PDBjDict.some_float v) }
      | "pdbx_atom_site_PDB_ins_code_1" -> { b with pdbx_atom_site_PDB_ins_code_1 = (Some v) }
      | "pdbx_atom_site_PDB_ins_code_2" -> { b with pdbx_atom_site_PDB_ins_code_2 = (Some v) }
      | "pdbx_atom_site_PDB_ins_code_3" -> { b with pdbx_atom_site_PDB_ins_code_3 = (Some v) }
      | "pdbx_PDB_model_num" -> { b with pdbx_PDB_model_num = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_site_id_1",  v)) a.atom_site_id_1;
      Option.map (fun v -> ("atom_site_label_alt_id_1",  v)) a.atom_site_label_alt_id_1;
      Option.map (fun v -> ("atom_site_label_atom_id_1",  v)) a.atom_site_label_atom_id_1;
      Option.map (fun v -> ("atom_site_label_comp_id_1",  v)) a.atom_site_label_comp_id_1;
      Option.map (fun v -> ("atom_site_label_seq_id_1", string_of_int v)) a.atom_site_label_seq_id_1;
      Option.map (fun v -> ("atom_site_label_asym_id_1",  v)) a.atom_site_label_asym_id_1;
      Option.map (fun v -> ("atom_site_id_2",  v)) a.atom_site_id_2;
      Option.map (fun v -> ("atom_site_label_alt_id_2",  v)) a.atom_site_label_alt_id_2;
      Option.map (fun v -> ("atom_site_label_atom_id_2",  v)) a.atom_site_label_atom_id_2;
      Option.map (fun v -> ("atom_site_label_comp_id_2",  v)) a.atom_site_label_comp_id_2;
      Option.map (fun v -> ("atom_site_label_seq_id_2", string_of_int v)) a.atom_site_label_seq_id_2;
      Option.map (fun v -> ("atom_site_label_asym_id_2",  v)) a.atom_site_label_asym_id_2;
      Option.map (fun v -> ("atom_site_id_3",  v)) a.atom_site_id_3;
      Option.map (fun v -> ("atom_site_label_alt_id_3",  v)) a.atom_site_label_alt_id_3;
      Option.map (fun v -> ("atom_site_label_atom_id_3",  v)) a.atom_site_label_atom_id_3;
      Option.map (fun v -> ("atom_site_label_comp_id_3",  v)) a.atom_site_label_comp_id_3;
      Option.map (fun v -> ("atom_site_label_seq_id_3", string_of_int v)) a.atom_site_label_seq_id_3;
      Option.map (fun v -> ("atom_site_label_asym_id_3",  v)) a.atom_site_label_asym_id_3;
      Option.map (fun v -> ("atom_site_auth_asym_id_1",  v)) a.atom_site_auth_asym_id_1;
      Option.map (fun v -> ("atom_site_auth_atom_id_1",  v)) a.atom_site_auth_atom_id_1;
      Option.map (fun v -> ("atom_site_auth_comp_id_1",  v)) a.atom_site_auth_comp_id_1;
      Option.map (fun v -> ("atom_site_auth_seq_id_1",  v)) a.atom_site_auth_seq_id_1;
      Option.map (fun v -> ("atom_site_auth_atom_id_2",  v)) a.atom_site_auth_atom_id_2;
      Option.map (fun v -> ("atom_site_auth_asym_id_2",  v)) a.atom_site_auth_asym_id_2;
      Option.map (fun v -> ("atom_site_auth_comp_id_2",  v)) a.atom_site_auth_comp_id_2;
      Option.map (fun v -> ("atom_site_auth_seq_id_2",  v)) a.atom_site_auth_seq_id_2;
      Option.map (fun v -> ("atom_site_auth_atom_id_3",  v)) a.atom_site_auth_atom_id_3;
      Option.map (fun v -> ("atom_site_auth_asym_id_3",  v)) a.atom_site_auth_asym_id_3;
      Option.map (fun v -> ("atom_site_auth_comp_id_3",  v)) a.atom_site_auth_comp_id_3;
      Option.map (fun v -> ("atom_site_auth_seq_id_3",  v)) a.atom_site_auth_seq_id_3;
      Option.map (fun v -> ("publ_flag",  v)) a.publ_flag;
      Option.map (fun v -> ("site_symmetry_1",  v)) a.site_symmetry_1;
      Option.map (fun v -> ("site_symmetry_2",  v)) a.site_symmetry_2;
      Option.map (fun v -> ("site_symmetry_3",  v)) a.site_symmetry_3;
      Option.map (fun v -> ("value", string_of_float v)) a.value;
      Option.map (fun v -> ("value_esd", string_of_float v)) a.value_esd;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_1",  v)) a.pdbx_atom_site_PDB_ins_code_1;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_2",  v)) a.pdbx_atom_site_PDB_ins_code_2;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_3",  v)) a.pdbx_atom_site_PDB_ins_code_3;
      Option.map (fun v -> ("pdbx_PDB_model_num", string_of_int v)) a.pdbx_PDB_model_num;
    ]

end

module Geom_bond = struct
  type t = {
    atom_site_id_1: string option;
    atom_site_label_alt_id_1: string option;
    atom_site_label_atom_id_1: string option;
    atom_site_label_comp_id_1: string option;
    atom_site_label_seq_id_1: int option;
    atom_site_label_asym_id_1: string option;
    atom_site_id_2: string option;
    atom_site_label_alt_id_2: string option;
    atom_site_label_atom_id_2: string option;
    atom_site_label_comp_id_2: string option;
    atom_site_label_seq_id_2: int option;
    atom_site_label_asym_id_2: string option;
    atom_site_auth_atom_id_1: string option;
    atom_site_auth_asym_id_1: string option;
    atom_site_auth_comp_id_1: string option;
    atom_site_auth_seq_id_1: string option;
    atom_site_auth_atom_id_2: string option;
    atom_site_auth_asym_id_2: string option;
    atom_site_auth_comp_id_2: string option;
    atom_site_auth_seq_id_2: string option;
    dist: float option;
    dist_esd: float option;
    publ_flag: string option;
    site_symmetry_1: string option;
    site_symmetry_2: string option;
    valence: int option;
    pdbx_atom_site_PDB_ins_code_1: string option;
    pdbx_atom_site_PDB_ins_code_2: string option;
    pdbx_PDB_model_num: int option;
  }

  let default = {
    atom_site_id_1 = None;
    atom_site_label_alt_id_1 = None;
    atom_site_label_atom_id_1 = None;
    atom_site_label_comp_id_1 = None;
    atom_site_label_seq_id_1 = None;
    atom_site_label_asym_id_1 = None;
    atom_site_id_2 = None;
    atom_site_label_alt_id_2 = None;
    atom_site_label_atom_id_2 = None;
    atom_site_label_comp_id_2 = None;
    atom_site_label_seq_id_2 = None;
    atom_site_label_asym_id_2 = None;
    atom_site_auth_atom_id_1 = None;
    atom_site_auth_asym_id_1 = None;
    atom_site_auth_comp_id_1 = None;
    atom_site_auth_seq_id_1 = None;
    atom_site_auth_atom_id_2 = None;
    atom_site_auth_asym_id_2 = None;
    atom_site_auth_comp_id_2 = None;
    atom_site_auth_seq_id_2 = None;
    dist = None;
    dist_esd = None;
    publ_flag = None;
    site_symmetry_1 = None;
    site_symmetry_2 = None;
    valence = None;
    pdbx_atom_site_PDB_ins_code_1 = None;
    pdbx_atom_site_PDB_ins_code_2 = None;
    pdbx_PDB_model_num = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_site_id_1" -> { b with atom_site_id_1 = (Some v) }
      | "atom_site_label_alt_id_1" -> { b with atom_site_label_alt_id_1 = (Some v) }
      | "atom_site_label_atom_id_1" -> { b with atom_site_label_atom_id_1 = (Some v) }
      | "atom_site_label_comp_id_1" -> { b with atom_site_label_comp_id_1 = (Some v) }
      | "atom_site_label_seq_id_1" -> { b with atom_site_label_seq_id_1 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_1" -> { b with atom_site_label_asym_id_1 = (Some v) }
      | "atom_site_id_2" -> { b with atom_site_id_2 = (Some v) }
      | "atom_site_label_alt_id_2" -> { b with atom_site_label_alt_id_2 = (Some v) }
      | "atom_site_label_atom_id_2" -> { b with atom_site_label_atom_id_2 = (Some v) }
      | "atom_site_label_comp_id_2" -> { b with atom_site_label_comp_id_2 = (Some v) }
      | "atom_site_label_seq_id_2" -> { b with atom_site_label_seq_id_2 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_2" -> { b with atom_site_label_asym_id_2 = (Some v) }
      | "atom_site_auth_atom_id_1" -> { b with atom_site_auth_atom_id_1 = (Some v) }
      | "atom_site_auth_asym_id_1" -> { b with atom_site_auth_asym_id_1 = (Some v) }
      | "atom_site_auth_comp_id_1" -> { b with atom_site_auth_comp_id_1 = (Some v) }
      | "atom_site_auth_seq_id_1" -> { b with atom_site_auth_seq_id_1 = (Some v) }
      | "atom_site_auth_atom_id_2" -> { b with atom_site_auth_atom_id_2 = (Some v) }
      | "atom_site_auth_asym_id_2" -> { b with atom_site_auth_asym_id_2 = (Some v) }
      | "atom_site_auth_comp_id_2" -> { b with atom_site_auth_comp_id_2 = (Some v) }
      | "atom_site_auth_seq_id_2" -> { b with atom_site_auth_seq_id_2 = (Some v) }
      | "dist" -> { b with dist = (PDBjDict.some_float v) }
      | "dist_esd" -> { b with dist_esd = (PDBjDict.some_float v) }
      | "publ_flag" -> { b with publ_flag = (Some v) }
      | "site_symmetry_1" -> { b with site_symmetry_1 = (Some v) }
      | "site_symmetry_2" -> { b with site_symmetry_2 = (Some v) }
      | "valence" -> { b with valence = (PDBjDict.some_int v) }
      | "pdbx_atom_site_PDB_ins_code_1" -> { b with pdbx_atom_site_PDB_ins_code_1 = (Some v) }
      | "pdbx_atom_site_PDB_ins_code_2" -> { b with pdbx_atom_site_PDB_ins_code_2 = (Some v) }
      | "pdbx_PDB_model_num" -> { b with pdbx_PDB_model_num = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_site_id_1",  v)) a.atom_site_id_1;
      Option.map (fun v -> ("atom_site_label_alt_id_1",  v)) a.atom_site_label_alt_id_1;
      Option.map (fun v -> ("atom_site_label_atom_id_1",  v)) a.atom_site_label_atom_id_1;
      Option.map (fun v -> ("atom_site_label_comp_id_1",  v)) a.atom_site_label_comp_id_1;
      Option.map (fun v -> ("atom_site_label_seq_id_1", string_of_int v)) a.atom_site_label_seq_id_1;
      Option.map (fun v -> ("atom_site_label_asym_id_1",  v)) a.atom_site_label_asym_id_1;
      Option.map (fun v -> ("atom_site_id_2",  v)) a.atom_site_id_2;
      Option.map (fun v -> ("atom_site_label_alt_id_2",  v)) a.atom_site_label_alt_id_2;
      Option.map (fun v -> ("atom_site_label_atom_id_2",  v)) a.atom_site_label_atom_id_2;
      Option.map (fun v -> ("atom_site_label_comp_id_2",  v)) a.atom_site_label_comp_id_2;
      Option.map (fun v -> ("atom_site_label_seq_id_2", string_of_int v)) a.atom_site_label_seq_id_2;
      Option.map (fun v -> ("atom_site_label_asym_id_2",  v)) a.atom_site_label_asym_id_2;
      Option.map (fun v -> ("atom_site_auth_atom_id_1",  v)) a.atom_site_auth_atom_id_1;
      Option.map (fun v -> ("atom_site_auth_asym_id_1",  v)) a.atom_site_auth_asym_id_1;
      Option.map (fun v -> ("atom_site_auth_comp_id_1",  v)) a.atom_site_auth_comp_id_1;
      Option.map (fun v -> ("atom_site_auth_seq_id_1",  v)) a.atom_site_auth_seq_id_1;
      Option.map (fun v -> ("atom_site_auth_atom_id_2",  v)) a.atom_site_auth_atom_id_2;
      Option.map (fun v -> ("atom_site_auth_asym_id_2",  v)) a.atom_site_auth_asym_id_2;
      Option.map (fun v -> ("atom_site_auth_comp_id_2",  v)) a.atom_site_auth_comp_id_2;
      Option.map (fun v -> ("atom_site_auth_seq_id_2",  v)) a.atom_site_auth_seq_id_2;
      Option.map (fun v -> ("dist", string_of_float v)) a.dist;
      Option.map (fun v -> ("dist_esd", string_of_float v)) a.dist_esd;
      Option.map (fun v -> ("publ_flag",  v)) a.publ_flag;
      Option.map (fun v -> ("site_symmetry_1",  v)) a.site_symmetry_1;
      Option.map (fun v -> ("site_symmetry_2",  v)) a.site_symmetry_2;
      Option.map (fun v -> ("valence", string_of_int v)) a.valence;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_1",  v)) a.pdbx_atom_site_PDB_ins_code_1;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_2",  v)) a.pdbx_atom_site_PDB_ins_code_2;
      Option.map (fun v -> ("pdbx_PDB_model_num", string_of_int v)) a.pdbx_PDB_model_num;
    ]

end

module Geom_contact = struct
  type t = {
    atom_site_id_1: string option;
    atom_site_label_alt_id_1: string option;
    atom_site_label_atom_id_1: string option;
    atom_site_label_comp_id_1: string option;
    atom_site_label_seq_id_1: int option;
    atom_site_label_asym_id_1: string option;
    atom_site_id_2: string option;
    atom_site_label_alt_id_2: string option;
    atom_site_label_atom_id_2: string option;
    atom_site_label_comp_id_2: string option;
    atom_site_label_seq_id_2: int option;
    atom_site_label_asym_id_2: string option;
    atom_site_auth_atom_id_1: string option;
    atom_site_auth_asym_id_1: string option;
    atom_site_auth_comp_id_1: string option;
    atom_site_auth_seq_id_1: string option;
    atom_site_auth_atom_id_2: string option;
    atom_site_auth_asym_id_2: string option;
    atom_site_auth_comp_id_2: string option;
    atom_site_auth_seq_id_2: string option;
    dist: float option;
    dist_esd: float option;
    publ_flag: string option;
    site_symmetry_1: string option;
    site_symmetry_2: string option;
    pdbx_atom_site_PDB_ins_code_1: string option;
    pdbx_atom_site_PDB_ins_code_2: string option;
    pdbx_PDB_model_num: int option;
  }

  let default = {
    atom_site_id_1 = None;
    atom_site_label_alt_id_1 = None;
    atom_site_label_atom_id_1 = None;
    atom_site_label_comp_id_1 = None;
    atom_site_label_seq_id_1 = None;
    atom_site_label_asym_id_1 = None;
    atom_site_id_2 = None;
    atom_site_label_alt_id_2 = None;
    atom_site_label_atom_id_2 = None;
    atom_site_label_comp_id_2 = None;
    atom_site_label_seq_id_2 = None;
    atom_site_label_asym_id_2 = None;
    atom_site_auth_atom_id_1 = None;
    atom_site_auth_asym_id_1 = None;
    atom_site_auth_comp_id_1 = None;
    atom_site_auth_seq_id_1 = None;
    atom_site_auth_atom_id_2 = None;
    atom_site_auth_asym_id_2 = None;
    atom_site_auth_comp_id_2 = None;
    atom_site_auth_seq_id_2 = None;
    dist = None;
    dist_esd = None;
    publ_flag = None;
    site_symmetry_1 = None;
    site_symmetry_2 = None;
    pdbx_atom_site_PDB_ins_code_1 = None;
    pdbx_atom_site_PDB_ins_code_2 = None;
    pdbx_PDB_model_num = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_site_id_1" -> { b with atom_site_id_1 = (Some v) }
      | "atom_site_label_alt_id_1" -> { b with atom_site_label_alt_id_1 = (Some v) }
      | "atom_site_label_atom_id_1" -> { b with atom_site_label_atom_id_1 = (Some v) }
      | "atom_site_label_comp_id_1" -> { b with atom_site_label_comp_id_1 = (Some v) }
      | "atom_site_label_seq_id_1" -> { b with atom_site_label_seq_id_1 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_1" -> { b with atom_site_label_asym_id_1 = (Some v) }
      | "atom_site_id_2" -> { b with atom_site_id_2 = (Some v) }
      | "atom_site_label_alt_id_2" -> { b with atom_site_label_alt_id_2 = (Some v) }
      | "atom_site_label_atom_id_2" -> { b with atom_site_label_atom_id_2 = (Some v) }
      | "atom_site_label_comp_id_2" -> { b with atom_site_label_comp_id_2 = (Some v) }
      | "atom_site_label_seq_id_2" -> { b with atom_site_label_seq_id_2 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_2" -> { b with atom_site_label_asym_id_2 = (Some v) }
      | "atom_site_auth_atom_id_1" -> { b with atom_site_auth_atom_id_1 = (Some v) }
      | "atom_site_auth_asym_id_1" -> { b with atom_site_auth_asym_id_1 = (Some v) }
      | "atom_site_auth_comp_id_1" -> { b with atom_site_auth_comp_id_1 = (Some v) }
      | "atom_site_auth_seq_id_1" -> { b with atom_site_auth_seq_id_1 = (Some v) }
      | "atom_site_auth_atom_id_2" -> { b with atom_site_auth_atom_id_2 = (Some v) }
      | "atom_site_auth_asym_id_2" -> { b with atom_site_auth_asym_id_2 = (Some v) }
      | "atom_site_auth_comp_id_2" -> { b with atom_site_auth_comp_id_2 = (Some v) }
      | "atom_site_auth_seq_id_2" -> { b with atom_site_auth_seq_id_2 = (Some v) }
      | "dist" -> { b with dist = (PDBjDict.some_float v) }
      | "dist_esd" -> { b with dist_esd = (PDBjDict.some_float v) }
      | "publ_flag" -> { b with publ_flag = (Some v) }
      | "site_symmetry_1" -> { b with site_symmetry_1 = (Some v) }
      | "site_symmetry_2" -> { b with site_symmetry_2 = (Some v) }
      | "pdbx_atom_site_PDB_ins_code_1" -> { b with pdbx_atom_site_PDB_ins_code_1 = (Some v) }
      | "pdbx_atom_site_PDB_ins_code_2" -> { b with pdbx_atom_site_PDB_ins_code_2 = (Some v) }
      | "pdbx_PDB_model_num" -> { b with pdbx_PDB_model_num = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_site_id_1",  v)) a.atom_site_id_1;
      Option.map (fun v -> ("atom_site_label_alt_id_1",  v)) a.atom_site_label_alt_id_1;
      Option.map (fun v -> ("atom_site_label_atom_id_1",  v)) a.atom_site_label_atom_id_1;
      Option.map (fun v -> ("atom_site_label_comp_id_1",  v)) a.atom_site_label_comp_id_1;
      Option.map (fun v -> ("atom_site_label_seq_id_1", string_of_int v)) a.atom_site_label_seq_id_1;
      Option.map (fun v -> ("atom_site_label_asym_id_1",  v)) a.atom_site_label_asym_id_1;
      Option.map (fun v -> ("atom_site_id_2",  v)) a.atom_site_id_2;
      Option.map (fun v -> ("atom_site_label_alt_id_2",  v)) a.atom_site_label_alt_id_2;
      Option.map (fun v -> ("atom_site_label_atom_id_2",  v)) a.atom_site_label_atom_id_2;
      Option.map (fun v -> ("atom_site_label_comp_id_2",  v)) a.atom_site_label_comp_id_2;
      Option.map (fun v -> ("atom_site_label_seq_id_2", string_of_int v)) a.atom_site_label_seq_id_2;
      Option.map (fun v -> ("atom_site_label_asym_id_2",  v)) a.atom_site_label_asym_id_2;
      Option.map (fun v -> ("atom_site_auth_atom_id_1",  v)) a.atom_site_auth_atom_id_1;
      Option.map (fun v -> ("atom_site_auth_asym_id_1",  v)) a.atom_site_auth_asym_id_1;
      Option.map (fun v -> ("atom_site_auth_comp_id_1",  v)) a.atom_site_auth_comp_id_1;
      Option.map (fun v -> ("atom_site_auth_seq_id_1",  v)) a.atom_site_auth_seq_id_1;
      Option.map (fun v -> ("atom_site_auth_atom_id_2",  v)) a.atom_site_auth_atom_id_2;
      Option.map (fun v -> ("atom_site_auth_asym_id_2",  v)) a.atom_site_auth_asym_id_2;
      Option.map (fun v -> ("atom_site_auth_comp_id_2",  v)) a.atom_site_auth_comp_id_2;
      Option.map (fun v -> ("atom_site_auth_seq_id_2",  v)) a.atom_site_auth_seq_id_2;
      Option.map (fun v -> ("dist", string_of_float v)) a.dist;
      Option.map (fun v -> ("dist_esd", string_of_float v)) a.dist_esd;
      Option.map (fun v -> ("publ_flag",  v)) a.publ_flag;
      Option.map (fun v -> ("site_symmetry_1",  v)) a.site_symmetry_1;
      Option.map (fun v -> ("site_symmetry_2",  v)) a.site_symmetry_2;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_1",  v)) a.pdbx_atom_site_PDB_ins_code_1;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_2",  v)) a.pdbx_atom_site_PDB_ins_code_2;
      Option.map (fun v -> ("pdbx_PDB_model_num", string_of_int v)) a.pdbx_PDB_model_num;
    ]

end

module Geom_hbond = struct
  type t = {
    angle_DHA: float option;
    angle_DHA_esd: float option;
    atom_site_id_A: string option;
    atom_site_label_alt_id_A: string option;
    atom_site_label_asym_id_A: string option;
    atom_site_label_atom_id_A: string option;
    atom_site_label_comp_id_A: string option;
    atom_site_label_seq_id_A: int option;
    atom_site_id_D: string option;
    atom_site_label_alt_id_D: string option;
    atom_site_label_asym_id_D: string option;
    atom_site_label_atom_id_D: string option;
    atom_site_label_comp_id_D: string option;
    atom_site_label_seq_id_D: int option;
    atom_site_id_H: string option;
    atom_site_label_alt_id_H: string option;
    atom_site_label_asym_id_H: string option;
    atom_site_label_atom_id_H: string option;
    atom_site_label_comp_id_H: string option;
    atom_site_label_seq_id_H: int option;
    atom_site_auth_asym_id_A: string option;
    atom_site_auth_atom_id_A: string option;
    atom_site_auth_comp_id_A: string option;
    atom_site_auth_seq_id_A: string option;
    atom_site_auth_asym_id_D: string option;
    atom_site_auth_atom_id_D: string option;
    atom_site_auth_comp_id_D: string option;
    atom_site_auth_seq_id_D: string option;
    atom_site_auth_asym_id_H: string option;
    atom_site_auth_atom_id_H: string option;
    atom_site_auth_comp_id_H: string option;
    atom_site_auth_seq_id_H: string option;
    dist_DA: float option;
    dist_DA_esd: float option;
    dist_DH: float option;
    dist_DH_esd: float option;
    dist_HA: float option;
    dist_HA_esd: float option;
    publ_flag: string option;
    site_symmetry_A: string option;
    site_symmetry_D: string option;
    site_symmetry_H: string option;
  }

  let default = {
    angle_DHA = None;
    angle_DHA_esd = None;
    atom_site_id_A = None;
    atom_site_label_alt_id_A = None;
    atom_site_label_asym_id_A = None;
    atom_site_label_atom_id_A = None;
    atom_site_label_comp_id_A = None;
    atom_site_label_seq_id_A = None;
    atom_site_id_D = None;
    atom_site_label_alt_id_D = None;
    atom_site_label_asym_id_D = None;
    atom_site_label_atom_id_D = None;
    atom_site_label_comp_id_D = None;
    atom_site_label_seq_id_D = None;
    atom_site_id_H = None;
    atom_site_label_alt_id_H = None;
    atom_site_label_asym_id_H = None;
    atom_site_label_atom_id_H = None;
    atom_site_label_comp_id_H = None;
    atom_site_label_seq_id_H = None;
    atom_site_auth_asym_id_A = None;
    atom_site_auth_atom_id_A = None;
    atom_site_auth_comp_id_A = None;
    atom_site_auth_seq_id_A = None;
    atom_site_auth_asym_id_D = None;
    atom_site_auth_atom_id_D = None;
    atom_site_auth_comp_id_D = None;
    atom_site_auth_seq_id_D = None;
    atom_site_auth_asym_id_H = None;
    atom_site_auth_atom_id_H = None;
    atom_site_auth_comp_id_H = None;
    atom_site_auth_seq_id_H = None;
    dist_DA = None;
    dist_DA_esd = None;
    dist_DH = None;
    dist_DH_esd = None;
    dist_HA = None;
    dist_HA_esd = None;
    publ_flag = None;
    site_symmetry_A = None;
    site_symmetry_D = None;
    site_symmetry_H = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "angle_DHA" -> { b with angle_DHA = (PDBjDict.some_float v) }
      | "angle_DHA_esd" -> { b with angle_DHA_esd = (PDBjDict.some_float v) }
      | "atom_site_id_A" -> { b with atom_site_id_A = (Some v) }
      | "atom_site_label_alt_id_A" -> { b with atom_site_label_alt_id_A = (Some v) }
      | "atom_site_label_asym_id_A" -> { b with atom_site_label_asym_id_A = (Some v) }
      | "atom_site_label_atom_id_A" -> { b with atom_site_label_atom_id_A = (Some v) }
      | "atom_site_label_comp_id_A" -> { b with atom_site_label_comp_id_A = (Some v) }
      | "atom_site_label_seq_id_A" -> { b with atom_site_label_seq_id_A = (PDBjDict.some_int v) }
      | "atom_site_id_D" -> { b with atom_site_id_D = (Some v) }
      | "atom_site_label_alt_id_D" -> { b with atom_site_label_alt_id_D = (Some v) }
      | "atom_site_label_asym_id_D" -> { b with atom_site_label_asym_id_D = (Some v) }
      | "atom_site_label_atom_id_D" -> { b with atom_site_label_atom_id_D = (Some v) }
      | "atom_site_label_comp_id_D" -> { b with atom_site_label_comp_id_D = (Some v) }
      | "atom_site_label_seq_id_D" -> { b with atom_site_label_seq_id_D = (PDBjDict.some_int v) }
      | "atom_site_id_H" -> { b with atom_site_id_H = (Some v) }
      | "atom_site_label_alt_id_H" -> { b with atom_site_label_alt_id_H = (Some v) }
      | "atom_site_label_asym_id_H" -> { b with atom_site_label_asym_id_H = (Some v) }
      | "atom_site_label_atom_id_H" -> { b with atom_site_label_atom_id_H = (Some v) }
      | "atom_site_label_comp_id_H" -> { b with atom_site_label_comp_id_H = (Some v) }
      | "atom_site_label_seq_id_H" -> { b with atom_site_label_seq_id_H = (PDBjDict.some_int v) }
      | "atom_site_auth_asym_id_A" -> { b with atom_site_auth_asym_id_A = (Some v) }
      | "atom_site_auth_atom_id_A" -> { b with atom_site_auth_atom_id_A = (Some v) }
      | "atom_site_auth_comp_id_A" -> { b with atom_site_auth_comp_id_A = (Some v) }
      | "atom_site_auth_seq_id_A" -> { b with atom_site_auth_seq_id_A = (Some v) }
      | "atom_site_auth_asym_id_D" -> { b with atom_site_auth_asym_id_D = (Some v) }
      | "atom_site_auth_atom_id_D" -> { b with atom_site_auth_atom_id_D = (Some v) }
      | "atom_site_auth_comp_id_D" -> { b with atom_site_auth_comp_id_D = (Some v) }
      | "atom_site_auth_seq_id_D" -> { b with atom_site_auth_seq_id_D = (Some v) }
      | "atom_site_auth_asym_id_H" -> { b with atom_site_auth_asym_id_H = (Some v) }
      | "atom_site_auth_atom_id_H" -> { b with atom_site_auth_atom_id_H = (Some v) }
      | "atom_site_auth_comp_id_H" -> { b with atom_site_auth_comp_id_H = (Some v) }
      | "atom_site_auth_seq_id_H" -> { b with atom_site_auth_seq_id_H = (Some v) }
      | "dist_DA" -> { b with dist_DA = (PDBjDict.some_float v) }
      | "dist_DA_esd" -> { b with dist_DA_esd = (PDBjDict.some_float v) }
      | "dist_DH" -> { b with dist_DH = (PDBjDict.some_float v) }
      | "dist_DH_esd" -> { b with dist_DH_esd = (PDBjDict.some_float v) }
      | "dist_HA" -> { b with dist_HA = (PDBjDict.some_float v) }
      | "dist_HA_esd" -> { b with dist_HA_esd = (PDBjDict.some_float v) }
      | "publ_flag" -> { b with publ_flag = (Some v) }
      | "site_symmetry_A" -> { b with site_symmetry_A = (Some v) }
      | "site_symmetry_D" -> { b with site_symmetry_D = (Some v) }
      | "site_symmetry_H" -> { b with site_symmetry_H = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("angle_DHA", string_of_float v)) a.angle_DHA;
      Option.map (fun v -> ("angle_DHA_esd", string_of_float v)) a.angle_DHA_esd;
      Option.map (fun v -> ("atom_site_id_A",  v)) a.atom_site_id_A;
      Option.map (fun v -> ("atom_site_label_alt_id_A",  v)) a.atom_site_label_alt_id_A;
      Option.map (fun v -> ("atom_site_label_asym_id_A",  v)) a.atom_site_label_asym_id_A;
      Option.map (fun v -> ("atom_site_label_atom_id_A",  v)) a.atom_site_label_atom_id_A;
      Option.map (fun v -> ("atom_site_label_comp_id_A",  v)) a.atom_site_label_comp_id_A;
      Option.map (fun v -> ("atom_site_label_seq_id_A", string_of_int v)) a.atom_site_label_seq_id_A;
      Option.map (fun v -> ("atom_site_id_D",  v)) a.atom_site_id_D;
      Option.map (fun v -> ("atom_site_label_alt_id_D",  v)) a.atom_site_label_alt_id_D;
      Option.map (fun v -> ("atom_site_label_asym_id_D",  v)) a.atom_site_label_asym_id_D;
      Option.map (fun v -> ("atom_site_label_atom_id_D",  v)) a.atom_site_label_atom_id_D;
      Option.map (fun v -> ("atom_site_label_comp_id_D",  v)) a.atom_site_label_comp_id_D;
      Option.map (fun v -> ("atom_site_label_seq_id_D", string_of_int v)) a.atom_site_label_seq_id_D;
      Option.map (fun v -> ("atom_site_id_H",  v)) a.atom_site_id_H;
      Option.map (fun v -> ("atom_site_label_alt_id_H",  v)) a.atom_site_label_alt_id_H;
      Option.map (fun v -> ("atom_site_label_asym_id_H",  v)) a.atom_site_label_asym_id_H;
      Option.map (fun v -> ("atom_site_label_atom_id_H",  v)) a.atom_site_label_atom_id_H;
      Option.map (fun v -> ("atom_site_label_comp_id_H",  v)) a.atom_site_label_comp_id_H;
      Option.map (fun v -> ("atom_site_label_seq_id_H", string_of_int v)) a.atom_site_label_seq_id_H;
      Option.map (fun v -> ("atom_site_auth_asym_id_A",  v)) a.atom_site_auth_asym_id_A;
      Option.map (fun v -> ("atom_site_auth_atom_id_A",  v)) a.atom_site_auth_atom_id_A;
      Option.map (fun v -> ("atom_site_auth_comp_id_A",  v)) a.atom_site_auth_comp_id_A;
      Option.map (fun v -> ("atom_site_auth_seq_id_A",  v)) a.atom_site_auth_seq_id_A;
      Option.map (fun v -> ("atom_site_auth_asym_id_D",  v)) a.atom_site_auth_asym_id_D;
      Option.map (fun v -> ("atom_site_auth_atom_id_D",  v)) a.atom_site_auth_atom_id_D;
      Option.map (fun v -> ("atom_site_auth_comp_id_D",  v)) a.atom_site_auth_comp_id_D;
      Option.map (fun v -> ("atom_site_auth_seq_id_D",  v)) a.atom_site_auth_seq_id_D;
      Option.map (fun v -> ("atom_site_auth_asym_id_H",  v)) a.atom_site_auth_asym_id_H;
      Option.map (fun v -> ("atom_site_auth_atom_id_H",  v)) a.atom_site_auth_atom_id_H;
      Option.map (fun v -> ("atom_site_auth_comp_id_H",  v)) a.atom_site_auth_comp_id_H;
      Option.map (fun v -> ("atom_site_auth_seq_id_H",  v)) a.atom_site_auth_seq_id_H;
      Option.map (fun v -> ("dist_DA", string_of_float v)) a.dist_DA;
      Option.map (fun v -> ("dist_DA_esd", string_of_float v)) a.dist_DA_esd;
      Option.map (fun v -> ("dist_DH", string_of_float v)) a.dist_DH;
      Option.map (fun v -> ("dist_DH_esd", string_of_float v)) a.dist_DH_esd;
      Option.map (fun v -> ("dist_HA", string_of_float v)) a.dist_HA;
      Option.map (fun v -> ("dist_HA_esd", string_of_float v)) a.dist_HA_esd;
      Option.map (fun v -> ("publ_flag",  v)) a.publ_flag;
      Option.map (fun v -> ("site_symmetry_A",  v)) a.site_symmetry_A;
      Option.map (fun v -> ("site_symmetry_D",  v)) a.site_symmetry_D;
      Option.map (fun v -> ("site_symmetry_H",  v)) a.site_symmetry_H;
    ]

end

module Geom_torsion = struct
  type t = {
    atom_site_id_1: string option;
    atom_site_label_alt_id_1: string option;
    atom_site_label_atom_id_1: string option;
    atom_site_label_comp_id_1: string option;
    atom_site_label_seq_id_1: int option;
    atom_site_label_asym_id_1: string option;
    atom_site_id_2: string option;
    atom_site_label_alt_id_2: string option;
    atom_site_label_atom_id_2: string option;
    atom_site_label_comp_id_2: string option;
    atom_site_label_seq_id_2: int option;
    atom_site_label_asym_id_2: string option;
    atom_site_id_3: string option;
    atom_site_label_alt_id_3: string option;
    atom_site_label_atom_id_3: string option;
    atom_site_label_comp_id_3: string option;
    atom_site_label_seq_id_3: int option;
    atom_site_label_asym_id_3: string option;
    atom_site_id_4: string option;
    atom_site_label_alt_id_4: string option;
    atom_site_label_atom_id_4: string option;
    atom_site_label_comp_id_4: string option;
    atom_site_label_seq_id_4: int option;
    atom_site_label_asym_id_4: string option;
    atom_site_auth_atom_id_1: string option;
    atom_site_auth_asym_id_1: string option;
    atom_site_auth_comp_id_1: string option;
    atom_site_auth_seq_id_1: string option;
    atom_site_auth_atom_id_2: string option;
    atom_site_auth_asym_id_2: string option;
    atom_site_auth_comp_id_2: string option;
    atom_site_auth_seq_id_2: string option;
    atom_site_auth_atom_id_3: string option;
    atom_site_auth_asym_id_3: string option;
    atom_site_auth_comp_id_3: string option;
    atom_site_auth_seq_id_3: string option;
    atom_site_auth_atom_id_4: string option;
    atom_site_auth_asym_id_4: string option;
    atom_site_auth_comp_id_4: string option;
    atom_site_auth_seq_id_4: string option;
    publ_flag: string option;
    site_symmetry_1: string option;
    site_symmetry_2: string option;
    site_symmetry_3: string option;
    site_symmetry_4: string option;
    value: float option;
    value_esd: float option;
    pdbx_atom_site_PDB_ins_code_1: string option;
    pdbx_atom_site_PDB_ins_code_2: string option;
    pdbx_atom_site_PDB_ins_code_3: string option;
    pdbx_atom_site_PDB_ins_code_4: string option;
    pdbx_PDB_model_num: int option;
  }

  let default = {
    atom_site_id_1 = None;
    atom_site_label_alt_id_1 = None;
    atom_site_label_atom_id_1 = None;
    atom_site_label_comp_id_1 = None;
    atom_site_label_seq_id_1 = None;
    atom_site_label_asym_id_1 = None;
    atom_site_id_2 = None;
    atom_site_label_alt_id_2 = None;
    atom_site_label_atom_id_2 = None;
    atom_site_label_comp_id_2 = None;
    atom_site_label_seq_id_2 = None;
    atom_site_label_asym_id_2 = None;
    atom_site_id_3 = None;
    atom_site_label_alt_id_3 = None;
    atom_site_label_atom_id_3 = None;
    atom_site_label_comp_id_3 = None;
    atom_site_label_seq_id_3 = None;
    atom_site_label_asym_id_3 = None;
    atom_site_id_4 = None;
    atom_site_label_alt_id_4 = None;
    atom_site_label_atom_id_4 = None;
    atom_site_label_comp_id_4 = None;
    atom_site_label_seq_id_4 = None;
    atom_site_label_asym_id_4 = None;
    atom_site_auth_atom_id_1 = None;
    atom_site_auth_asym_id_1 = None;
    atom_site_auth_comp_id_1 = None;
    atom_site_auth_seq_id_1 = None;
    atom_site_auth_atom_id_2 = None;
    atom_site_auth_asym_id_2 = None;
    atom_site_auth_comp_id_2 = None;
    atom_site_auth_seq_id_2 = None;
    atom_site_auth_atom_id_3 = None;
    atom_site_auth_asym_id_3 = None;
    atom_site_auth_comp_id_3 = None;
    atom_site_auth_seq_id_3 = None;
    atom_site_auth_atom_id_4 = None;
    atom_site_auth_asym_id_4 = None;
    atom_site_auth_comp_id_4 = None;
    atom_site_auth_seq_id_4 = None;
    publ_flag = None;
    site_symmetry_1 = None;
    site_symmetry_2 = None;
    site_symmetry_3 = None;
    site_symmetry_4 = None;
    value = None;
    value_esd = None;
    pdbx_atom_site_PDB_ins_code_1 = None;
    pdbx_atom_site_PDB_ins_code_2 = None;
    pdbx_atom_site_PDB_ins_code_3 = None;
    pdbx_atom_site_PDB_ins_code_4 = None;
    pdbx_PDB_model_num = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_site_id_1" -> { b with atom_site_id_1 = (Some v) }
      | "atom_site_label_alt_id_1" -> { b with atom_site_label_alt_id_1 = (Some v) }
      | "atom_site_label_atom_id_1" -> { b with atom_site_label_atom_id_1 = (Some v) }
      | "atom_site_label_comp_id_1" -> { b with atom_site_label_comp_id_1 = (Some v) }
      | "atom_site_label_seq_id_1" -> { b with atom_site_label_seq_id_1 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_1" -> { b with atom_site_label_asym_id_1 = (Some v) }
      | "atom_site_id_2" -> { b with atom_site_id_2 = (Some v) }
      | "atom_site_label_alt_id_2" -> { b with atom_site_label_alt_id_2 = (Some v) }
      | "atom_site_label_atom_id_2" -> { b with atom_site_label_atom_id_2 = (Some v) }
      | "atom_site_label_comp_id_2" -> { b with atom_site_label_comp_id_2 = (Some v) }
      | "atom_site_label_seq_id_2" -> { b with atom_site_label_seq_id_2 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_2" -> { b with atom_site_label_asym_id_2 = (Some v) }
      | "atom_site_id_3" -> { b with atom_site_id_3 = (Some v) }
      | "atom_site_label_alt_id_3" -> { b with atom_site_label_alt_id_3 = (Some v) }
      | "atom_site_label_atom_id_3" -> { b with atom_site_label_atom_id_3 = (Some v) }
      | "atom_site_label_comp_id_3" -> { b with atom_site_label_comp_id_3 = (Some v) }
      | "atom_site_label_seq_id_3" -> { b with atom_site_label_seq_id_3 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_3" -> { b with atom_site_label_asym_id_3 = (Some v) }
      | "atom_site_id_4" -> { b with atom_site_id_4 = (Some v) }
      | "atom_site_label_alt_id_4" -> { b with atom_site_label_alt_id_4 = (Some v) }
      | "atom_site_label_atom_id_4" -> { b with atom_site_label_atom_id_4 = (Some v) }
      | "atom_site_label_comp_id_4" -> { b with atom_site_label_comp_id_4 = (Some v) }
      | "atom_site_label_seq_id_4" -> { b with atom_site_label_seq_id_4 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_4" -> { b with atom_site_label_asym_id_4 = (Some v) }
      | "atom_site_auth_atom_id_1" -> { b with atom_site_auth_atom_id_1 = (Some v) }
      | "atom_site_auth_asym_id_1" -> { b with atom_site_auth_asym_id_1 = (Some v) }
      | "atom_site_auth_comp_id_1" -> { b with atom_site_auth_comp_id_1 = (Some v) }
      | "atom_site_auth_seq_id_1" -> { b with atom_site_auth_seq_id_1 = (Some v) }
      | "atom_site_auth_atom_id_2" -> { b with atom_site_auth_atom_id_2 = (Some v) }
      | "atom_site_auth_asym_id_2" -> { b with atom_site_auth_asym_id_2 = (Some v) }
      | "atom_site_auth_comp_id_2" -> { b with atom_site_auth_comp_id_2 = (Some v) }
      | "atom_site_auth_seq_id_2" -> { b with atom_site_auth_seq_id_2 = (Some v) }
      | "atom_site_auth_atom_id_3" -> { b with atom_site_auth_atom_id_3 = (Some v) }
      | "atom_site_auth_asym_id_3" -> { b with atom_site_auth_asym_id_3 = (Some v) }
      | "atom_site_auth_comp_id_3" -> { b with atom_site_auth_comp_id_3 = (Some v) }
      | "atom_site_auth_seq_id_3" -> { b with atom_site_auth_seq_id_3 = (Some v) }
      | "atom_site_auth_atom_id_4" -> { b with atom_site_auth_atom_id_4 = (Some v) }
      | "atom_site_auth_asym_id_4" -> { b with atom_site_auth_asym_id_4 = (Some v) }
      | "atom_site_auth_comp_id_4" -> { b with atom_site_auth_comp_id_4 = (Some v) }
      | "atom_site_auth_seq_id_4" -> { b with atom_site_auth_seq_id_4 = (Some v) }
      | "publ_flag" -> { b with publ_flag = (Some v) }
      | "site_symmetry_1" -> { b with site_symmetry_1 = (Some v) }
      | "site_symmetry_2" -> { b with site_symmetry_2 = (Some v) }
      | "site_symmetry_3" -> { b with site_symmetry_3 = (Some v) }
      | "site_symmetry_4" -> { b with site_symmetry_4 = (Some v) }
      | "value" -> { b with value = (PDBjDict.some_float v) }
      | "value_esd" -> { b with value_esd = (PDBjDict.some_float v) }
      | "pdbx_atom_site_PDB_ins_code_1" -> { b with pdbx_atom_site_PDB_ins_code_1 = (Some v) }
      | "pdbx_atom_site_PDB_ins_code_2" -> { b with pdbx_atom_site_PDB_ins_code_2 = (Some v) }
      | "pdbx_atom_site_PDB_ins_code_3" -> { b with pdbx_atom_site_PDB_ins_code_3 = (Some v) }
      | "pdbx_atom_site_PDB_ins_code_4" -> { b with pdbx_atom_site_PDB_ins_code_4 = (Some v) }
      | "pdbx_PDB_model_num" -> { b with pdbx_PDB_model_num = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_site_id_1",  v)) a.atom_site_id_1;
      Option.map (fun v -> ("atom_site_label_alt_id_1",  v)) a.atom_site_label_alt_id_1;
      Option.map (fun v -> ("atom_site_label_atom_id_1",  v)) a.atom_site_label_atom_id_1;
      Option.map (fun v -> ("atom_site_label_comp_id_1",  v)) a.atom_site_label_comp_id_1;
      Option.map (fun v -> ("atom_site_label_seq_id_1", string_of_int v)) a.atom_site_label_seq_id_1;
      Option.map (fun v -> ("atom_site_label_asym_id_1",  v)) a.atom_site_label_asym_id_1;
      Option.map (fun v -> ("atom_site_id_2",  v)) a.atom_site_id_2;
      Option.map (fun v -> ("atom_site_label_alt_id_2",  v)) a.atom_site_label_alt_id_2;
      Option.map (fun v -> ("atom_site_label_atom_id_2",  v)) a.atom_site_label_atom_id_2;
      Option.map (fun v -> ("atom_site_label_comp_id_2",  v)) a.atom_site_label_comp_id_2;
      Option.map (fun v -> ("atom_site_label_seq_id_2", string_of_int v)) a.atom_site_label_seq_id_2;
      Option.map (fun v -> ("atom_site_label_asym_id_2",  v)) a.atom_site_label_asym_id_2;
      Option.map (fun v -> ("atom_site_id_3",  v)) a.atom_site_id_3;
      Option.map (fun v -> ("atom_site_label_alt_id_3",  v)) a.atom_site_label_alt_id_3;
      Option.map (fun v -> ("atom_site_label_atom_id_3",  v)) a.atom_site_label_atom_id_3;
      Option.map (fun v -> ("atom_site_label_comp_id_3",  v)) a.atom_site_label_comp_id_3;
      Option.map (fun v -> ("atom_site_label_seq_id_3", string_of_int v)) a.atom_site_label_seq_id_3;
      Option.map (fun v -> ("atom_site_label_asym_id_3",  v)) a.atom_site_label_asym_id_3;
      Option.map (fun v -> ("atom_site_id_4",  v)) a.atom_site_id_4;
      Option.map (fun v -> ("atom_site_label_alt_id_4",  v)) a.atom_site_label_alt_id_4;
      Option.map (fun v -> ("atom_site_label_atom_id_4",  v)) a.atom_site_label_atom_id_4;
      Option.map (fun v -> ("atom_site_label_comp_id_4",  v)) a.atom_site_label_comp_id_4;
      Option.map (fun v -> ("atom_site_label_seq_id_4", string_of_int v)) a.atom_site_label_seq_id_4;
      Option.map (fun v -> ("atom_site_label_asym_id_4",  v)) a.atom_site_label_asym_id_4;
      Option.map (fun v -> ("atom_site_auth_atom_id_1",  v)) a.atom_site_auth_atom_id_1;
      Option.map (fun v -> ("atom_site_auth_asym_id_1",  v)) a.atom_site_auth_asym_id_1;
      Option.map (fun v -> ("atom_site_auth_comp_id_1",  v)) a.atom_site_auth_comp_id_1;
      Option.map (fun v -> ("atom_site_auth_seq_id_1",  v)) a.atom_site_auth_seq_id_1;
      Option.map (fun v -> ("atom_site_auth_atom_id_2",  v)) a.atom_site_auth_atom_id_2;
      Option.map (fun v -> ("atom_site_auth_asym_id_2",  v)) a.atom_site_auth_asym_id_2;
      Option.map (fun v -> ("atom_site_auth_comp_id_2",  v)) a.atom_site_auth_comp_id_2;
      Option.map (fun v -> ("atom_site_auth_seq_id_2",  v)) a.atom_site_auth_seq_id_2;
      Option.map (fun v -> ("atom_site_auth_atom_id_3",  v)) a.atom_site_auth_atom_id_3;
      Option.map (fun v -> ("atom_site_auth_asym_id_3",  v)) a.atom_site_auth_asym_id_3;
      Option.map (fun v -> ("atom_site_auth_comp_id_3",  v)) a.atom_site_auth_comp_id_3;
      Option.map (fun v -> ("atom_site_auth_seq_id_3",  v)) a.atom_site_auth_seq_id_3;
      Option.map (fun v -> ("atom_site_auth_atom_id_4",  v)) a.atom_site_auth_atom_id_4;
      Option.map (fun v -> ("atom_site_auth_asym_id_4",  v)) a.atom_site_auth_asym_id_4;
      Option.map (fun v -> ("atom_site_auth_comp_id_4",  v)) a.atom_site_auth_comp_id_4;
      Option.map (fun v -> ("atom_site_auth_seq_id_4",  v)) a.atom_site_auth_seq_id_4;
      Option.map (fun v -> ("publ_flag",  v)) a.publ_flag;
      Option.map (fun v -> ("site_symmetry_1",  v)) a.site_symmetry_1;
      Option.map (fun v -> ("site_symmetry_2",  v)) a.site_symmetry_2;
      Option.map (fun v -> ("site_symmetry_3",  v)) a.site_symmetry_3;
      Option.map (fun v -> ("site_symmetry_4",  v)) a.site_symmetry_4;
      Option.map (fun v -> ("value", string_of_float v)) a.value;
      Option.map (fun v -> ("value_esd", string_of_float v)) a.value_esd;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_1",  v)) a.pdbx_atom_site_PDB_ins_code_1;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_2",  v)) a.pdbx_atom_site_PDB_ins_code_2;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_3",  v)) a.pdbx_atom_site_PDB_ins_code_3;
      Option.map (fun v -> ("pdbx_atom_site_PDB_ins_code_4",  v)) a.pdbx_atom_site_PDB_ins_code_4;
      Option.map (fun v -> ("pdbx_PDB_model_num", string_of_int v)) a.pdbx_PDB_model_num;
    ]

end

module Journal = struct
  type t = {
    entry_id: string option;
    coden_ASTM: string option;
    coden_Cambridge: string option;
    coeditor_address: string option;
    coeditor_code: string option;
    coeditor_email: string option;
    coeditor_fax: string option;
    coeditor_name: string option;
    coeditor_notes: string option;
    coeditor_phone: string option;
    data_validation_number: string option;
    date_accepted: string option;
    date_from_coeditor: string option;
    date_to_coeditor: string option;
    date_printers_final: string option;
    date_printers_first: string option;
    date_proofs_in: string option;
    date_proofs_out: string option;
    date_recd_copyright: string option;
    date_recd_electronic: string option;
    date_recd_hard_copy: string option;
    issue: string option;
    language: string option;
    name_full: string option;
    page_first: string option;
    page_last: string option;
    paper_category: string option;
    suppl_publ_number: string option;
    suppl_publ_pages: string option;
    techeditor_address: string option;
    techeditor_code: string option;
    techeditor_email: string option;
    techeditor_fax: string option;
    techeditor_name: string option;
    techeditor_notes: string option;
    techeditor_phone: string option;
    volume: string option;
    year: string option;
  }

  let default = {
    entry_id = None;
    coden_ASTM = None;
    coden_Cambridge = None;
    coeditor_address = None;
    coeditor_code = None;
    coeditor_email = None;
    coeditor_fax = None;
    coeditor_name = None;
    coeditor_notes = None;
    coeditor_phone = None;
    data_validation_number = None;
    date_accepted = None;
    date_from_coeditor = None;
    date_to_coeditor = None;
    date_printers_final = None;
    date_printers_first = None;
    date_proofs_in = None;
    date_proofs_out = None;
    date_recd_copyright = None;
    date_recd_electronic = None;
    date_recd_hard_copy = None;
    issue = None;
    language = None;
    name_full = None;
    page_first = None;
    page_last = None;
    paper_category = None;
    suppl_publ_number = None;
    suppl_publ_pages = None;
    techeditor_address = None;
    techeditor_code = None;
    techeditor_email = None;
    techeditor_fax = None;
    techeditor_name = None;
    techeditor_notes = None;
    techeditor_phone = None;
    volume = None;
    year = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "coden_ASTM" -> { b with coden_ASTM = (Some v) }
      | "coden_Cambridge" -> { b with coden_Cambridge = (Some v) }
      | "coeditor_address" -> { b with coeditor_address = (Some v) }
      | "coeditor_code" -> { b with coeditor_code = (Some v) }
      | "coeditor_email" -> { b with coeditor_email = (Some v) }
      | "coeditor_fax" -> { b with coeditor_fax = (Some v) }
      | "coeditor_name" -> { b with coeditor_name = (Some v) }
      | "coeditor_notes" -> { b with coeditor_notes = (Some v) }
      | "coeditor_phone" -> { b with coeditor_phone = (Some v) }
      | "data_validation_number" -> { b with data_validation_number = (Some v) }
      | "date_accepted" -> { b with date_accepted = (Some v) }
      | "date_from_coeditor" -> { b with date_from_coeditor = (Some v) }
      | "date_to_coeditor" -> { b with date_to_coeditor = (Some v) }
      | "date_printers_final" -> { b with date_printers_final = (Some v) }
      | "date_printers_first" -> { b with date_printers_first = (Some v) }
      | "date_proofs_in" -> { b with date_proofs_in = (Some v) }
      | "date_proofs_out" -> { b with date_proofs_out = (Some v) }
      | "date_recd_copyright" -> { b with date_recd_copyright = (Some v) }
      | "date_recd_electronic" -> { b with date_recd_electronic = (Some v) }
      | "date_recd_hard_copy" -> { b with date_recd_hard_copy = (Some v) }
      | "issue" -> { b with issue = (Some v) }
      | "language" -> { b with language = (Some v) }
      | "name_full" -> { b with name_full = (Some v) }
      | "page_first" -> { b with page_first = (Some v) }
      | "page_last" -> { b with page_last = (Some v) }
      | "paper_category" -> { b with paper_category = (Some v) }
      | "suppl_publ_number" -> { b with suppl_publ_number = (Some v) }
      | "suppl_publ_pages" -> { b with suppl_publ_pages = (Some v) }
      | "techeditor_address" -> { b with techeditor_address = (Some v) }
      | "techeditor_code" -> { b with techeditor_code = (Some v) }
      | "techeditor_email" -> { b with techeditor_email = (Some v) }
      | "techeditor_fax" -> { b with techeditor_fax = (Some v) }
      | "techeditor_name" -> { b with techeditor_name = (Some v) }
      | "techeditor_notes" -> { b with techeditor_notes = (Some v) }
      | "techeditor_phone" -> { b with techeditor_phone = (Some v) }
      | "volume" -> { b with volume = (Some v) }
      | "year" -> { b with year = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("coden_ASTM",  v)) a.coden_ASTM;
      Option.map (fun v -> ("coden_Cambridge",  v)) a.coden_Cambridge;
      Option.map (fun v -> ("coeditor_address",  v)) a.coeditor_address;
      Option.map (fun v -> ("coeditor_code",  v)) a.coeditor_code;
      Option.map (fun v -> ("coeditor_email",  v)) a.coeditor_email;
      Option.map (fun v -> ("coeditor_fax",  v)) a.coeditor_fax;
      Option.map (fun v -> ("coeditor_name",  v)) a.coeditor_name;
      Option.map (fun v -> ("coeditor_notes",  v)) a.coeditor_notes;
      Option.map (fun v -> ("coeditor_phone",  v)) a.coeditor_phone;
      Option.map (fun v -> ("data_validation_number",  v)) a.data_validation_number;
      Option.map (fun v -> ("date_accepted",  v)) a.date_accepted;
      Option.map (fun v -> ("date_from_coeditor",  v)) a.date_from_coeditor;
      Option.map (fun v -> ("date_to_coeditor",  v)) a.date_to_coeditor;
      Option.map (fun v -> ("date_printers_final",  v)) a.date_printers_final;
      Option.map (fun v -> ("date_printers_first",  v)) a.date_printers_first;
      Option.map (fun v -> ("date_proofs_in",  v)) a.date_proofs_in;
      Option.map (fun v -> ("date_proofs_out",  v)) a.date_proofs_out;
      Option.map (fun v -> ("date_recd_copyright",  v)) a.date_recd_copyright;
      Option.map (fun v -> ("date_recd_electronic",  v)) a.date_recd_electronic;
      Option.map (fun v -> ("date_recd_hard_copy",  v)) a.date_recd_hard_copy;
      Option.map (fun v -> ("issue",  v)) a.issue;
      Option.map (fun v -> ("language",  v)) a.language;
      Option.map (fun v -> ("name_full",  v)) a.name_full;
      Option.map (fun v -> ("page_first",  v)) a.page_first;
      Option.map (fun v -> ("page_last",  v)) a.page_last;
      Option.map (fun v -> ("paper_category",  v)) a.paper_category;
      Option.map (fun v -> ("suppl_publ_number",  v)) a.suppl_publ_number;
      Option.map (fun v -> ("suppl_publ_pages",  v)) a.suppl_publ_pages;
      Option.map (fun v -> ("techeditor_address",  v)) a.techeditor_address;
      Option.map (fun v -> ("techeditor_code",  v)) a.techeditor_code;
      Option.map (fun v -> ("techeditor_email",  v)) a.techeditor_email;
      Option.map (fun v -> ("techeditor_fax",  v)) a.techeditor_fax;
      Option.map (fun v -> ("techeditor_name",  v)) a.techeditor_name;
      Option.map (fun v -> ("techeditor_notes",  v)) a.techeditor_notes;
      Option.map (fun v -> ("techeditor_phone",  v)) a.techeditor_phone;
      Option.map (fun v -> ("volume",  v)) a.volume;
      Option.map (fun v -> ("year",  v)) a.year;
    ]

end

module Journal_index = struct
  type t = {
    subterm: string option;
    term: string option;
    type_: string option;
  }

  let default = {
    subterm = None;
    term = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "subterm" -> { b with subterm = (Some v) }
      | "term" -> { b with term = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("subterm",  v)) a.subterm;
      Option.map (fun v -> ("term",  v)) a.term;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Phasing = struct
  type t = {
    method_: string option;
  }

  let default = {
    method_ = None;
  }

  let of_mmCIF items =
    match items with
    | [] -> default
    | (_,v)::_ -> { method_ = (Some v) }

  let to_mmCIF a =
    match a.method_ with
    | None -> []
    | Some v -> [ ("method",( v)) ]

end

module Phasing_averaging = struct
  type t = {
    details: string option;
    entry_id: string option;
    method_: string option;
  }

  let default = {
    details = None;
    entry_id = None;
    method_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("method",  v)) a.method_;
    ]

end

module Phasing_isomorphous = struct
  type t = {
    details: string option;
    entry_id: string option;
    method_: string option;
    parent: string option;
  }

  let default = {
    details = None;
    entry_id = None;
    method_ = None;
    parent = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "parent" -> { b with parent = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("parent",  v)) a.parent;
    ]

end

module Phasing_MAD = struct
  type t = {
    details: string option;
    entry_id: string option;
    method_: string option;
    pdbx_d_res_low: float option;
    pdbx_d_res_high: float option;
    pdbx_reflns_acentric: int option;
    pdbx_reflns_centric: int option;
    pdbx_reflns: int option;
    pdbx_fom_acentric: float option;
    pdbx_fom_centric: float option;
    pdbx_fom: float option;
    pdbx_R_cullis_centric: float option;
    pdbx_R_cullis_acentric: float option;
    pdbx_R_cullis: float option;
    pdbx_R_kraut_centric: float option;
    pdbx_R_kraut_acentric: float option;
    pdbx_R_kraut: float option;
    pdbx_loc_centric: float option;
    pdbx_loc_acentric: float option;
    pdbx_loc: float option;
    pdbx_power_centric: float option;
    pdbx_power_acentric: float option;
    pdbx_power: float option;
    pdbx_number_data_sets: int option;
    pdbx_anom_scat_method: string option;
  }

  let default = {
    details = None;
    entry_id = None;
    method_ = None;
    pdbx_d_res_low = None;
    pdbx_d_res_high = None;
    pdbx_reflns_acentric = None;
    pdbx_reflns_centric = None;
    pdbx_reflns = None;
    pdbx_fom_acentric = None;
    pdbx_fom_centric = None;
    pdbx_fom = None;
    pdbx_R_cullis_centric = None;
    pdbx_R_cullis_acentric = None;
    pdbx_R_cullis = None;
    pdbx_R_kraut_centric = None;
    pdbx_R_kraut_acentric = None;
    pdbx_R_kraut = None;
    pdbx_loc_centric = None;
    pdbx_loc_acentric = None;
    pdbx_loc = None;
    pdbx_power_centric = None;
    pdbx_power_acentric = None;
    pdbx_power = None;
    pdbx_number_data_sets = None;
    pdbx_anom_scat_method = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "pdbx_d_res_low" -> { b with pdbx_d_res_low = (PDBjDict.some_float v) }
      | "pdbx_d_res_high" -> { b with pdbx_d_res_high = (PDBjDict.some_float v) }
      | "pdbx_reflns_acentric" -> { b with pdbx_reflns_acentric = (PDBjDict.some_int v) }
      | "pdbx_reflns_centric" -> { b with pdbx_reflns_centric = (PDBjDict.some_int v) }
      | "pdbx_reflns" -> { b with pdbx_reflns = (PDBjDict.some_int v) }
      | "pdbx_fom_acentric" -> { b with pdbx_fom_acentric = (PDBjDict.some_float v) }
      | "pdbx_fom_centric" -> { b with pdbx_fom_centric = (PDBjDict.some_float v) }
      | "pdbx_fom" -> { b with pdbx_fom = (PDBjDict.some_float v) }
      | "pdbx_R_cullis_centric" -> { b with pdbx_R_cullis_centric = (PDBjDict.some_float v) }
      | "pdbx_R_cullis_acentric" -> { b with pdbx_R_cullis_acentric = (PDBjDict.some_float v) }
      | "pdbx_R_cullis" -> { b with pdbx_R_cullis = (PDBjDict.some_float v) }
      | "pdbx_R_kraut_centric" -> { b with pdbx_R_kraut_centric = (PDBjDict.some_float v) }
      | "pdbx_R_kraut_acentric" -> { b with pdbx_R_kraut_acentric = (PDBjDict.some_float v) }
      | "pdbx_R_kraut" -> { b with pdbx_R_kraut = (PDBjDict.some_float v) }
      | "pdbx_loc_centric" -> { b with pdbx_loc_centric = (PDBjDict.some_float v) }
      | "pdbx_loc_acentric" -> { b with pdbx_loc_acentric = (PDBjDict.some_float v) }
      | "pdbx_loc" -> { b with pdbx_loc = (PDBjDict.some_float v) }
      | "pdbx_power_centric" -> { b with pdbx_power_centric = (PDBjDict.some_float v) }
      | "pdbx_power_acentric" -> { b with pdbx_power_acentric = (PDBjDict.some_float v) }
      | "pdbx_power" -> { b with pdbx_power = (PDBjDict.some_float v) }
      | "pdbx_number_data_sets" -> { b with pdbx_number_data_sets = (PDBjDict.some_int v) }
      | "pdbx_anom_scat_method" -> { b with pdbx_anom_scat_method = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("pdbx_d_res_low", string_of_float v)) a.pdbx_d_res_low;
      Option.map (fun v -> ("pdbx_d_res_high", string_of_float v)) a.pdbx_d_res_high;
      Option.map (fun v -> ("pdbx_reflns_acentric", string_of_int v)) a.pdbx_reflns_acentric;
      Option.map (fun v -> ("pdbx_reflns_centric", string_of_int v)) a.pdbx_reflns_centric;
      Option.map (fun v -> ("pdbx_reflns", string_of_int v)) a.pdbx_reflns;
      Option.map (fun v -> ("pdbx_fom_acentric", string_of_float v)) a.pdbx_fom_acentric;
      Option.map (fun v -> ("pdbx_fom_centric", string_of_float v)) a.pdbx_fom_centric;
      Option.map (fun v -> ("pdbx_fom", string_of_float v)) a.pdbx_fom;
      Option.map (fun v -> ("pdbx_R_cullis_centric", string_of_float v)) a.pdbx_R_cullis_centric;
      Option.map (fun v -> ("pdbx_R_cullis_acentric", string_of_float v)) a.pdbx_R_cullis_acentric;
      Option.map (fun v -> ("pdbx_R_cullis", string_of_float v)) a.pdbx_R_cullis;
      Option.map (fun v -> ("pdbx_R_kraut_centric", string_of_float v)) a.pdbx_R_kraut_centric;
      Option.map (fun v -> ("pdbx_R_kraut_acentric", string_of_float v)) a.pdbx_R_kraut_acentric;
      Option.map (fun v -> ("pdbx_R_kraut", string_of_float v)) a.pdbx_R_kraut;
      Option.map (fun v -> ("pdbx_loc_centric", string_of_float v)) a.pdbx_loc_centric;
      Option.map (fun v -> ("pdbx_loc_acentric", string_of_float v)) a.pdbx_loc_acentric;
      Option.map (fun v -> ("pdbx_loc", string_of_float v)) a.pdbx_loc;
      Option.map (fun v -> ("pdbx_power_centric", string_of_float v)) a.pdbx_power_centric;
      Option.map (fun v -> ("pdbx_power_acentric", string_of_float v)) a.pdbx_power_acentric;
      Option.map (fun v -> ("pdbx_power", string_of_float v)) a.pdbx_power;
      Option.map (fun v -> ("pdbx_number_data_sets", string_of_int v)) a.pdbx_number_data_sets;
      Option.map (fun v -> ("pdbx_anom_scat_method",  v)) a.pdbx_anom_scat_method;
    ]

end

module Phasing_MAD_clust = struct
  type t = {
    expt_id: string option;
    id: string option;
    number_set: int option;
  }

  let default = {
    expt_id = None;
    id = None;
    number_set = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "expt_id" -> { b with expt_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "number_set" -> { b with number_set = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("expt_id",  v)) a.expt_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("number_set", string_of_int v)) a.number_set;
    ]

end

module Phasing_MAD_expt = struct
  type t = {
    delta_delta_phi: float option;
    delta_phi: float option;
    delta_phi_sigma: float option;
    id: string option;
    mean_fom: float option;
    number_clust: int option;
    r_normal_all: float option;
    r_normal_anom_scat: float option;
  }

  let default = {
    delta_delta_phi = None;
    delta_phi = None;
    delta_phi_sigma = None;
    id = None;
    mean_fom = None;
    number_clust = None;
    r_normal_all = None;
    r_normal_anom_scat = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "delta_delta_phi" -> { b with delta_delta_phi = (PDBjDict.some_float v) }
      | "delta_phi" -> { b with delta_phi = (PDBjDict.some_float v) }
      | "delta_phi_sigma" -> { b with delta_phi_sigma = (PDBjDict.some_float v) }
      | "id" -> { b with id = (Some v) }
      | "mean_fom" -> { b with mean_fom = (PDBjDict.some_float v) }
      | "number_clust" -> { b with number_clust = (PDBjDict.some_int v) }
      | "R_normal_all" -> { b with r_normal_all = (PDBjDict.some_float v) }
      | "R_normal_anom_scat" -> { b with r_normal_anom_scat = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("delta_delta_phi", string_of_float v)) a.delta_delta_phi;
      Option.map (fun v -> ("delta_phi", string_of_float v)) a.delta_phi;
      Option.map (fun v -> ("delta_phi_sigma", string_of_float v)) a.delta_phi_sigma;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("mean_fom", string_of_float v)) a.mean_fom;
      Option.map (fun v -> ("number_clust", string_of_int v)) a.number_clust;
      Option.map (fun v -> ("R_normal_all", string_of_float v)) a.r_normal_all;
      Option.map (fun v -> ("R_normal_anom_scat", string_of_float v)) a.r_normal_anom_scat;
    ]

end

module Phasing_MAD_ratio = struct
  type t = {
    d_res_high: float option;
    d_res_low: float option;
    expt_id: string option;
    clust_id: string option;
    ratio_one_wl: float option;
    ratio_one_wl_centric: float option;
    ratio_two_wl: float option;
    wavelength_1: float option;
    wavelength_2: float option;
  }

  let default = {
    d_res_high = None;
    d_res_low = None;
    expt_id = None;
    clust_id = None;
    ratio_one_wl = None;
    ratio_one_wl_centric = None;
    ratio_two_wl = None;
    wavelength_1 = None;
    wavelength_2 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "expt_id" -> { b with expt_id = (Some v) }
      | "clust_id" -> { b with clust_id = (Some v) }
      | "ratio_one_wl" -> { b with ratio_one_wl = (PDBjDict.some_float v) }
      | "ratio_one_wl_centric" -> { b with ratio_one_wl_centric = (PDBjDict.some_float v) }
      | "ratio_two_wl" -> { b with ratio_two_wl = (PDBjDict.some_float v) }
      | "wavelength_1" -> { b with wavelength_1 = (PDBjDict.some_float v) }
      | "wavelength_2" -> { b with wavelength_2 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("expt_id",  v)) a.expt_id;
      Option.map (fun v -> ("clust_id",  v)) a.clust_id;
      Option.map (fun v -> ("ratio_one_wl", string_of_float v)) a.ratio_one_wl;
      Option.map (fun v -> ("ratio_one_wl_centric", string_of_float v)) a.ratio_one_wl_centric;
      Option.map (fun v -> ("ratio_two_wl", string_of_float v)) a.ratio_two_wl;
      Option.map (fun v -> ("wavelength_1", string_of_float v)) a.wavelength_1;
      Option.map (fun v -> ("wavelength_2", string_of_float v)) a.wavelength_2;
    ]

end

module Phasing_MAD_set = struct
  type t = {
    clust_id: string option;
    d_res_high: float option;
    d_res_low: float option;
    expt_id: string option;
    f_double_prime: float option;
    f_prime: float option;
    set_id: string option;
    wavelength: float option;
    wavelength_details: string option;
    pdbx_atom_type: string option;
    pdbx_f_prime_refined: float option;
    pdbx_f_double_prime_refined: float option;
  }

  let default = {
    clust_id = None;
    d_res_high = None;
    d_res_low = None;
    expt_id = None;
    f_double_prime = None;
    f_prime = None;
    set_id = None;
    wavelength = None;
    wavelength_details = None;
    pdbx_atom_type = None;
    pdbx_f_prime_refined = None;
    pdbx_f_double_prime_refined = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "clust_id" -> { b with clust_id = (Some v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "expt_id" -> { b with expt_id = (Some v) }
      | "f_double_prime" -> { b with f_double_prime = (PDBjDict.some_float v) }
      | "f_prime" -> { b with f_prime = (PDBjDict.some_float v) }
      | "set_id" -> { b with set_id = (Some v) }
      | "wavelength" -> { b with wavelength = (PDBjDict.some_float v) }
      | "wavelength_details" -> { b with wavelength_details = (Some v) }
      | "pdbx_atom_type" -> { b with pdbx_atom_type = (Some v) }
      | "pdbx_f_prime_refined" -> { b with pdbx_f_prime_refined = (PDBjDict.some_float v) }
      | "pdbx_f_double_prime_refined" -> { b with pdbx_f_double_prime_refined = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("clust_id",  v)) a.clust_id;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("expt_id",  v)) a.expt_id;
      Option.map (fun v -> ("f_double_prime", string_of_float v)) a.f_double_prime;
      Option.map (fun v -> ("f_prime", string_of_float v)) a.f_prime;
      Option.map (fun v -> ("set_id",  v)) a.set_id;
      Option.map (fun v -> ("wavelength", string_of_float v)) a.wavelength;
      Option.map (fun v -> ("wavelength_details",  v)) a.wavelength_details;
      Option.map (fun v -> ("pdbx_atom_type",  v)) a.pdbx_atom_type;
      Option.map (fun v -> ("pdbx_f_prime_refined", string_of_float v)) a.pdbx_f_prime_refined;
      Option.map (fun v -> ("pdbx_f_double_prime_refined", string_of_float v)) a.pdbx_f_double_prime_refined;
    ]

end

module Phasing_MIR = struct
  type t = {
    details: string option;
    d_res_high: float option;
    d_res_low: float option;
    entry_id: string option;
    fOM: float option;
    fOM_acentric: float option;
    fOM_centric: float option;
    method_: string option;
    reflns: int option;
    reflns_acentric: int option;
    reflns_centric: int option;
    reflns_criterion: string option;
    pdbx_number_derivatives: int option;
  }

  let default = {
    details = None;
    d_res_high = None;
    d_res_low = None;
    entry_id = None;
    fOM = None;
    fOM_acentric = None;
    fOM_centric = None;
    method_ = None;
    reflns = None;
    reflns_acentric = None;
    reflns_centric = None;
    reflns_criterion = None;
    pdbx_number_derivatives = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "FOM" -> { b with fOM = (PDBjDict.some_float v) }
      | "FOM_acentric" -> { b with fOM_acentric = (PDBjDict.some_float v) }
      | "FOM_centric" -> { b with fOM_centric = (PDBjDict.some_float v) }
      | "method" -> { b with method_ = (Some v) }
      | "reflns" -> { b with reflns = (PDBjDict.some_int v) }
      | "reflns_acentric" -> { b with reflns_acentric = (PDBjDict.some_int v) }
      | "reflns_centric" -> { b with reflns_centric = (PDBjDict.some_int v) }
      | "reflns_criterion" -> { b with reflns_criterion = (Some v) }
      | "pdbx_number_derivatives" -> { b with pdbx_number_derivatives = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("FOM", string_of_float v)) a.fOM;
      Option.map (fun v -> ("FOM_acentric", string_of_float v)) a.fOM_acentric;
      Option.map (fun v -> ("FOM_centric", string_of_float v)) a.fOM_centric;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("reflns", string_of_int v)) a.reflns;
      Option.map (fun v -> ("reflns_acentric", string_of_int v)) a.reflns_acentric;
      Option.map (fun v -> ("reflns_centric", string_of_int v)) a.reflns_centric;
      Option.map (fun v -> ("reflns_criterion",  v)) a.reflns_criterion;
      Option.map (fun v -> ("pdbx_number_derivatives", string_of_int v)) a.pdbx_number_derivatives;
    ]

end

module Phasing_MIR_der = struct
  type t = {
    d_res_high: float option;
    d_res_low: float option;
    der_set_id: string option;
    details: string option;
    id: string option;
    native_set_id: string option;
    number_of_sites: int option;
    power_acentric: float option;
    power_centric: float option;
    r_cullis_acentric: float option;
    r_cullis_anomalous: float option;
    r_cullis_centric: float option;
    reflns_acentric: int option;
    reflns_anomalous: int option;
    reflns_centric: int option;
    reflns_criteria: string option;
    pdbx_R_kraut_centric: float option;
    pdbx_R_kraut_acentric: float option;
    pdbx_R_kraut: float option;
    pdbx_loc_centric: float option;
    pdbx_loc_acentric: float option;
    pdbx_loc: float option;
    pdbx_fom_centric: float option;
    pdbx_fom_acentric: float option;
    pdbx_fom: float option;
    pdbx_power: float option;
    pdbx_R_cullis: float option;
    pdbx_reflns: int option;
  }

  let default = {
    d_res_high = None;
    d_res_low = None;
    der_set_id = None;
    details = None;
    id = None;
    native_set_id = None;
    number_of_sites = None;
    power_acentric = None;
    power_centric = None;
    r_cullis_acentric = None;
    r_cullis_anomalous = None;
    r_cullis_centric = None;
    reflns_acentric = None;
    reflns_anomalous = None;
    reflns_centric = None;
    reflns_criteria = None;
    pdbx_R_kraut_centric = None;
    pdbx_R_kraut_acentric = None;
    pdbx_R_kraut = None;
    pdbx_loc_centric = None;
    pdbx_loc_acentric = None;
    pdbx_loc = None;
    pdbx_fom_centric = None;
    pdbx_fom_acentric = None;
    pdbx_fom = None;
    pdbx_power = None;
    pdbx_R_cullis = None;
    pdbx_reflns = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "der_set_id" -> { b with der_set_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "native_set_id" -> { b with native_set_id = (Some v) }
      | "number_of_sites" -> { b with number_of_sites = (PDBjDict.some_int v) }
      | "power_acentric" -> { b with power_acentric = (PDBjDict.some_float v) }
      | "power_centric" -> { b with power_centric = (PDBjDict.some_float v) }
      | "R_cullis_acentric" -> { b with r_cullis_acentric = (PDBjDict.some_float v) }
      | "R_cullis_anomalous" -> { b with r_cullis_anomalous = (PDBjDict.some_float v) }
      | "R_cullis_centric" -> { b with r_cullis_centric = (PDBjDict.some_float v) }
      | "reflns_acentric" -> { b with reflns_acentric = (PDBjDict.some_int v) }
      | "reflns_anomalous" -> { b with reflns_anomalous = (PDBjDict.some_int v) }
      | "reflns_centric" -> { b with reflns_centric = (PDBjDict.some_int v) }
      | "reflns_criteria" -> { b with reflns_criteria = (Some v) }
      | "pdbx_R_kraut_centric" -> { b with pdbx_R_kraut_centric = (PDBjDict.some_float v) }
      | "pdbx_R_kraut_acentric" -> { b with pdbx_R_kraut_acentric = (PDBjDict.some_float v) }
      | "pdbx_R_kraut" -> { b with pdbx_R_kraut = (PDBjDict.some_float v) }
      | "pdbx_loc_centric" -> { b with pdbx_loc_centric = (PDBjDict.some_float v) }
      | "pdbx_loc_acentric" -> { b with pdbx_loc_acentric = (PDBjDict.some_float v) }
      | "pdbx_loc" -> { b with pdbx_loc = (PDBjDict.some_float v) }
      | "pdbx_fom_centric" -> { b with pdbx_fom_centric = (PDBjDict.some_float v) }
      | "pdbx_fom_acentric" -> { b with pdbx_fom_acentric = (PDBjDict.some_float v) }
      | "pdbx_fom" -> { b with pdbx_fom = (PDBjDict.some_float v) }
      | "pdbx_power" -> { b with pdbx_power = (PDBjDict.some_float v) }
      | "pdbx_R_cullis" -> { b with pdbx_R_cullis = (PDBjDict.some_float v) }
      | "pdbx_reflns" -> { b with pdbx_reflns = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("der_set_id",  v)) a.der_set_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("native_set_id",  v)) a.native_set_id;
      Option.map (fun v -> ("number_of_sites", string_of_int v)) a.number_of_sites;
      Option.map (fun v -> ("power_acentric", string_of_float v)) a.power_acentric;
      Option.map (fun v -> ("power_centric", string_of_float v)) a.power_centric;
      Option.map (fun v -> ("R_cullis_acentric", string_of_float v)) a.r_cullis_acentric;
      Option.map (fun v -> ("R_cullis_anomalous", string_of_float v)) a.r_cullis_anomalous;
      Option.map (fun v -> ("R_cullis_centric", string_of_float v)) a.r_cullis_centric;
      Option.map (fun v -> ("reflns_acentric", string_of_int v)) a.reflns_acentric;
      Option.map (fun v -> ("reflns_anomalous", string_of_int v)) a.reflns_anomalous;
      Option.map (fun v -> ("reflns_centric", string_of_int v)) a.reflns_centric;
      Option.map (fun v -> ("reflns_criteria",  v)) a.reflns_criteria;
      Option.map (fun v -> ("pdbx_R_kraut_centric", string_of_float v)) a.pdbx_R_kraut_centric;
      Option.map (fun v -> ("pdbx_R_kraut_acentric", string_of_float v)) a.pdbx_R_kraut_acentric;
      Option.map (fun v -> ("pdbx_R_kraut", string_of_float v)) a.pdbx_R_kraut;
      Option.map (fun v -> ("pdbx_loc_centric", string_of_float v)) a.pdbx_loc_centric;
      Option.map (fun v -> ("pdbx_loc_acentric", string_of_float v)) a.pdbx_loc_acentric;
      Option.map (fun v -> ("pdbx_loc", string_of_float v)) a.pdbx_loc;
      Option.map (fun v -> ("pdbx_fom_centric", string_of_float v)) a.pdbx_fom_centric;
      Option.map (fun v -> ("pdbx_fom_acentric", string_of_float v)) a.pdbx_fom_acentric;
      Option.map (fun v -> ("pdbx_fom", string_of_float v)) a.pdbx_fom;
      Option.map (fun v -> ("pdbx_power", string_of_float v)) a.pdbx_power;
      Option.map (fun v -> ("pdbx_R_cullis", string_of_float v)) a.pdbx_R_cullis;
      Option.map (fun v -> ("pdbx_reflns", string_of_int v)) a.pdbx_reflns;
    ]

end

module Phasing_MIR_der_refln = struct
  type t = {
    der_id: string option;
    f_calc: float option;
    f_calc_au: float option;
    f_meas: float option;
    f_meas_au: float option;
    f_meas_sigma: float option;
    f_meas_sigma_au: float option;
    hL_A_iso: float option;
    hL_B_iso: float option;
    hL_C_iso: float option;
    hL_D_iso: float option;
    index_h: int option;
    index_k: int option;
    index_l: int option;
    phase_calc: float option;
    set_id: string option;
  }

  let default = {
    der_id = None;
    f_calc = None;
    f_calc_au = None;
    f_meas = None;
    f_meas_au = None;
    f_meas_sigma = None;
    f_meas_sigma_au = None;
    hL_A_iso = None;
    hL_B_iso = None;
    hL_C_iso = None;
    hL_D_iso = None;
    index_h = None;
    index_k = None;
    index_l = None;
    phase_calc = None;
    set_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "der_id" -> { b with der_id = (Some v) }
      | "F_calc" -> { b with f_calc = (PDBjDict.some_float v) }
      | "F_calc_au" -> { b with f_calc_au = (PDBjDict.some_float v) }
      | "F_meas" -> { b with f_meas = (PDBjDict.some_float v) }
      | "F_meas_au" -> { b with f_meas_au = (PDBjDict.some_float v) }
      | "F_meas_sigma" -> { b with f_meas_sigma = (PDBjDict.some_float v) }
      | "F_meas_sigma_au" -> { b with f_meas_sigma_au = (PDBjDict.some_float v) }
      | "HL_A_iso" -> { b with hL_A_iso = (PDBjDict.some_float v) }
      | "HL_B_iso" -> { b with hL_B_iso = (PDBjDict.some_float v) }
      | "HL_C_iso" -> { b with hL_C_iso = (PDBjDict.some_float v) }
      | "HL_D_iso" -> { b with hL_D_iso = (PDBjDict.some_float v) }
      | "index_h" -> { b with index_h = (PDBjDict.some_int v) }
      | "index_k" -> { b with index_k = (PDBjDict.some_int v) }
      | "index_l" -> { b with index_l = (PDBjDict.some_int v) }
      | "phase_calc" -> { b with phase_calc = (PDBjDict.some_float v) }
      | "set_id" -> { b with set_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("der_id",  v)) a.der_id;
      Option.map (fun v -> ("F_calc", string_of_float v)) a.f_calc;
      Option.map (fun v -> ("F_calc_au", string_of_float v)) a.f_calc_au;
      Option.map (fun v -> ("F_meas", string_of_float v)) a.f_meas;
      Option.map (fun v -> ("F_meas_au", string_of_float v)) a.f_meas_au;
      Option.map (fun v -> ("F_meas_sigma", string_of_float v)) a.f_meas_sigma;
      Option.map (fun v -> ("F_meas_sigma_au", string_of_float v)) a.f_meas_sigma_au;
      Option.map (fun v -> ("HL_A_iso", string_of_float v)) a.hL_A_iso;
      Option.map (fun v -> ("HL_B_iso", string_of_float v)) a.hL_B_iso;
      Option.map (fun v -> ("HL_C_iso", string_of_float v)) a.hL_C_iso;
      Option.map (fun v -> ("HL_D_iso", string_of_float v)) a.hL_D_iso;
      Option.map (fun v -> ("index_h", string_of_int v)) a.index_h;
      Option.map (fun v -> ("index_k", string_of_int v)) a.index_k;
      Option.map (fun v -> ("index_l", string_of_int v)) a.index_l;
      Option.map (fun v -> ("phase_calc", string_of_float v)) a.phase_calc;
      Option.map (fun v -> ("set_id",  v)) a.set_id;
    ]

end

module Phasing_MIR_der_shell = struct
  type t = {
    d_res_high: float option;
    d_res_low: float option;
    der_id: string option;
    fom: float option;
    ha_ampl: float option;
    loc: float option;
    phase: float option;
    power: float option;
    r_cullis: float option;
    r_kraut: float option;
    reflns: int option;
    pdbx_R_cullis_centric: float option;
    pdbx_R_cullis_acentric: float option;
    pdbx_R_kraut_centric: float option;
    pdbx_R_kraut_acentric: float option;
    pdbx_loc_centric: float option;
    pdbx_loc_acentric: float option;
    pdbx_power_centric: float option;
    pdbx_power_acentric: float option;
    pdbx_fom_centric: float option;
    pdbx_fom_acentric: float option;
    pdbx_reflns_centric: float option;
    pdbx_reflns_acentric: int option;
  }

  let default = {
    d_res_high = None;
    d_res_low = None;
    der_id = None;
    fom = None;
    ha_ampl = None;
    loc = None;
    phase = None;
    power = None;
    r_cullis = None;
    r_kraut = None;
    reflns = None;
    pdbx_R_cullis_centric = None;
    pdbx_R_cullis_acentric = None;
    pdbx_R_kraut_centric = None;
    pdbx_R_kraut_acentric = None;
    pdbx_loc_centric = None;
    pdbx_loc_acentric = None;
    pdbx_power_centric = None;
    pdbx_power_acentric = None;
    pdbx_fom_centric = None;
    pdbx_fom_acentric = None;
    pdbx_reflns_centric = None;
    pdbx_reflns_acentric = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "der_id" -> { b with der_id = (Some v) }
      | "fom" -> { b with fom = (PDBjDict.some_float v) }
      | "ha_ampl" -> { b with ha_ampl = (PDBjDict.some_float v) }
      | "loc" -> { b with loc = (PDBjDict.some_float v) }
      | "phase" -> { b with phase = (PDBjDict.some_float v) }
      | "power" -> { b with power = (PDBjDict.some_float v) }
      | "R_cullis" -> { b with r_cullis = (PDBjDict.some_float v) }
      | "R_kraut" -> { b with r_kraut = (PDBjDict.some_float v) }
      | "reflns" -> { b with reflns = (PDBjDict.some_int v) }
      | "pdbx_R_cullis_centric" -> { b with pdbx_R_cullis_centric = (PDBjDict.some_float v) }
      | "pdbx_R_cullis_acentric" -> { b with pdbx_R_cullis_acentric = (PDBjDict.some_float v) }
      | "pdbx_R_kraut_centric" -> { b with pdbx_R_kraut_centric = (PDBjDict.some_float v) }
      | "pdbx_R_kraut_acentric" -> { b with pdbx_R_kraut_acentric = (PDBjDict.some_float v) }
      | "pdbx_loc_centric" -> { b with pdbx_loc_centric = (PDBjDict.some_float v) }
      | "pdbx_loc_acentric" -> { b with pdbx_loc_acentric = (PDBjDict.some_float v) }
      | "pdbx_power_centric" -> { b with pdbx_power_centric = (PDBjDict.some_float v) }
      | "pdbx_power_acentric" -> { b with pdbx_power_acentric = (PDBjDict.some_float v) }
      | "pdbx_fom_centric" -> { b with pdbx_fom_centric = (PDBjDict.some_float v) }
      | "pdbx_fom_acentric" -> { b with pdbx_fom_acentric = (PDBjDict.some_float v) }
      | "pdbx_reflns_centric" -> { b with pdbx_reflns_centric = (PDBjDict.some_float v) }
      | "pdbx_reflns_acentric" -> { b with pdbx_reflns_acentric = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("der_id",  v)) a.der_id;
      Option.map (fun v -> ("fom", string_of_float v)) a.fom;
      Option.map (fun v -> ("ha_ampl", string_of_float v)) a.ha_ampl;
      Option.map (fun v -> ("loc", string_of_float v)) a.loc;
      Option.map (fun v -> ("phase", string_of_float v)) a.phase;
      Option.map (fun v -> ("power", string_of_float v)) a.power;
      Option.map (fun v -> ("R_cullis", string_of_float v)) a.r_cullis;
      Option.map (fun v -> ("R_kraut", string_of_float v)) a.r_kraut;
      Option.map (fun v -> ("reflns", string_of_int v)) a.reflns;
      Option.map (fun v -> ("pdbx_R_cullis_centric", string_of_float v)) a.pdbx_R_cullis_centric;
      Option.map (fun v -> ("pdbx_R_cullis_acentric", string_of_float v)) a.pdbx_R_cullis_acentric;
      Option.map (fun v -> ("pdbx_R_kraut_centric", string_of_float v)) a.pdbx_R_kraut_centric;
      Option.map (fun v -> ("pdbx_R_kraut_acentric", string_of_float v)) a.pdbx_R_kraut_acentric;
      Option.map (fun v -> ("pdbx_loc_centric", string_of_float v)) a.pdbx_loc_centric;
      Option.map (fun v -> ("pdbx_loc_acentric", string_of_float v)) a.pdbx_loc_acentric;
      Option.map (fun v -> ("pdbx_power_centric", string_of_float v)) a.pdbx_power_centric;
      Option.map (fun v -> ("pdbx_power_acentric", string_of_float v)) a.pdbx_power_acentric;
      Option.map (fun v -> ("pdbx_fom_centric", string_of_float v)) a.pdbx_fom_centric;
      Option.map (fun v -> ("pdbx_fom_acentric", string_of_float v)) a.pdbx_fom_acentric;
      Option.map (fun v -> ("pdbx_reflns_centric", string_of_float v)) a.pdbx_reflns_centric;
      Option.map (fun v -> ("pdbx_reflns_acentric", string_of_int v)) a.pdbx_reflns_acentric;
    ]

end

module Phasing_MIR_der_site = struct
  type t = {
    atom_type_symbol: string option;
    b_iso: float option;
    b_iso_esd: float option;
    cartn_x: float option;
    cartn_x_esd: float option;
    cartn_y: float option;
    cartn_y_esd: float option;
    cartn_z: float option;
    cartn_z_esd: float option;
    der_id: string option;
    details: string option;
    fract_x: float option;
    fract_x_esd: float option;
    fract_y: float option;
    fract_y_esd: float option;
    fract_z: float option;
    fract_z_esd: float option;
    id: string option;
    occupancy: float option;
    occupancy_anom: float option;
    occupancy_anom_su: float option;
    occupancy_iso: float option;
    occupancy_iso_su: float option;
  }

  let default = {
    atom_type_symbol = None;
    b_iso = None;
    b_iso_esd = None;
    cartn_x = None;
    cartn_x_esd = None;
    cartn_y = None;
    cartn_y_esd = None;
    cartn_z = None;
    cartn_z_esd = None;
    der_id = None;
    details = None;
    fract_x = None;
    fract_x_esd = None;
    fract_y = None;
    fract_y_esd = None;
    fract_z = None;
    fract_z_esd = None;
    id = None;
    occupancy = None;
    occupancy_anom = None;
    occupancy_anom_su = None;
    occupancy_iso = None;
    occupancy_iso_su = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_type_symbol" -> { b with atom_type_symbol = (Some v) }
      | "B_iso" -> { b with b_iso = (PDBjDict.some_float v) }
      | "B_iso_esd" -> { b with b_iso_esd = (PDBjDict.some_float v) }
      | "Cartn_x" -> { b with cartn_x = (PDBjDict.some_float v) }
      | "Cartn_x_esd" -> { b with cartn_x_esd = (PDBjDict.some_float v) }
      | "Cartn_y" -> { b with cartn_y = (PDBjDict.some_float v) }
      | "Cartn_y_esd" -> { b with cartn_y_esd = (PDBjDict.some_float v) }
      | "Cartn_z" -> { b with cartn_z = (PDBjDict.some_float v) }
      | "Cartn_z_esd" -> { b with cartn_z_esd = (PDBjDict.some_float v) }
      | "der_id" -> { b with der_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "fract_x" -> { b with fract_x = (PDBjDict.some_float v) }
      | "fract_x_esd" -> { b with fract_x_esd = (PDBjDict.some_float v) }
      | "fract_y" -> { b with fract_y = (PDBjDict.some_float v) }
      | "fract_y_esd" -> { b with fract_y_esd = (PDBjDict.some_float v) }
      | "fract_z" -> { b with fract_z = (PDBjDict.some_float v) }
      | "fract_z_esd" -> { b with fract_z_esd = (PDBjDict.some_float v) }
      | "id" -> { b with id = (Some v) }
      | "occupancy" -> { b with occupancy = (PDBjDict.some_float v) }
      | "occupancy_anom" -> { b with occupancy_anom = (PDBjDict.some_float v) }
      | "occupancy_anom_su" -> { b with occupancy_anom_su = (PDBjDict.some_float v) }
      | "occupancy_iso" -> { b with occupancy_iso = (PDBjDict.some_float v) }
      | "occupancy_iso_su" -> { b with occupancy_iso_su = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_type_symbol",  v)) a.atom_type_symbol;
      Option.map (fun v -> ("B_iso", string_of_float v)) a.b_iso;
      Option.map (fun v -> ("B_iso_esd", string_of_float v)) a.b_iso_esd;
      Option.map (fun v -> ("Cartn_x", string_of_float v)) a.cartn_x;
      Option.map (fun v -> ("Cartn_x_esd", string_of_float v)) a.cartn_x_esd;
      Option.map (fun v -> ("Cartn_y", string_of_float v)) a.cartn_y;
      Option.map (fun v -> ("Cartn_y_esd", string_of_float v)) a.cartn_y_esd;
      Option.map (fun v -> ("Cartn_z", string_of_float v)) a.cartn_z;
      Option.map (fun v -> ("Cartn_z_esd", string_of_float v)) a.cartn_z_esd;
      Option.map (fun v -> ("der_id",  v)) a.der_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("fract_x", string_of_float v)) a.fract_x;
      Option.map (fun v -> ("fract_x_esd", string_of_float v)) a.fract_x_esd;
      Option.map (fun v -> ("fract_y", string_of_float v)) a.fract_y;
      Option.map (fun v -> ("fract_y_esd", string_of_float v)) a.fract_y_esd;
      Option.map (fun v -> ("fract_z", string_of_float v)) a.fract_z;
      Option.map (fun v -> ("fract_z_esd", string_of_float v)) a.fract_z_esd;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("occupancy", string_of_float v)) a.occupancy;
      Option.map (fun v -> ("occupancy_anom", string_of_float v)) a.occupancy_anom;
      Option.map (fun v -> ("occupancy_anom_su", string_of_float v)) a.occupancy_anom_su;
      Option.map (fun v -> ("occupancy_iso", string_of_float v)) a.occupancy_iso;
      Option.map (fun v -> ("occupancy_iso_su", string_of_float v)) a.occupancy_iso_su;
    ]

end

module Phasing_MIR_shell = struct
  type t = {
    d_res_high: float option;
    d_res_low: float option;
    fOM: float option;
    fOM_acentric: float option;
    fOM_centric: float option;
    loc: float option;
    mean_phase: float option;
    power: float option;
    r_cullis: float option;
    r_kraut: float option;
    reflns: int option;
    reflns_acentric: int option;
    reflns_anomalous: int option;
    reflns_centric: int option;
    pdbx_loc_centric: float option;
    pdbx_loc_acentric: float option;
    pdbx_power_centric: float option;
    pdbx_power_acentric: float option;
    pdbx_R_kraut_centric: float option;
    pdbx_R_kraut_acentric: float option;
    pdbx_R_cullis_centric: float option;
    pdbx_R_cullis_acentric: float option;
  }

  let default = {
    d_res_high = None;
    d_res_low = None;
    fOM = None;
    fOM_acentric = None;
    fOM_centric = None;
    loc = None;
    mean_phase = None;
    power = None;
    r_cullis = None;
    r_kraut = None;
    reflns = None;
    reflns_acentric = None;
    reflns_anomalous = None;
    reflns_centric = None;
    pdbx_loc_centric = None;
    pdbx_loc_acentric = None;
    pdbx_power_centric = None;
    pdbx_power_acentric = None;
    pdbx_R_kraut_centric = None;
    pdbx_R_kraut_acentric = None;
    pdbx_R_cullis_centric = None;
    pdbx_R_cullis_acentric = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "FOM" -> { b with fOM = (PDBjDict.some_float v) }
      | "FOM_acentric" -> { b with fOM_acentric = (PDBjDict.some_float v) }
      | "FOM_centric" -> { b with fOM_centric = (PDBjDict.some_float v) }
      | "loc" -> { b with loc = (PDBjDict.some_float v) }
      | "mean_phase" -> { b with mean_phase = (PDBjDict.some_float v) }
      | "power" -> { b with power = (PDBjDict.some_float v) }
      | "R_cullis" -> { b with r_cullis = (PDBjDict.some_float v) }
      | "R_kraut" -> { b with r_kraut = (PDBjDict.some_float v) }
      | "reflns" -> { b with reflns = (PDBjDict.some_int v) }
      | "reflns_acentric" -> { b with reflns_acentric = (PDBjDict.some_int v) }
      | "reflns_anomalous" -> { b with reflns_anomalous = (PDBjDict.some_int v) }
      | "reflns_centric" -> { b with reflns_centric = (PDBjDict.some_int v) }
      | "pdbx_loc_centric" -> { b with pdbx_loc_centric = (PDBjDict.some_float v) }
      | "pdbx_loc_acentric" -> { b with pdbx_loc_acentric = (PDBjDict.some_float v) }
      | "pdbx_power_centric" -> { b with pdbx_power_centric = (PDBjDict.some_float v) }
      | "pdbx_power_acentric" -> { b with pdbx_power_acentric = (PDBjDict.some_float v) }
      | "pdbx_R_kraut_centric" -> { b with pdbx_R_kraut_centric = (PDBjDict.some_float v) }
      | "pdbx_R_kraut_acentric" -> { b with pdbx_R_kraut_acentric = (PDBjDict.some_float v) }
      | "pdbx_R_cullis_centric" -> { b with pdbx_R_cullis_centric = (PDBjDict.some_float v) }
      | "pdbx_R_cullis_acentric" -> { b with pdbx_R_cullis_acentric = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("FOM", string_of_float v)) a.fOM;
      Option.map (fun v -> ("FOM_acentric", string_of_float v)) a.fOM_acentric;
      Option.map (fun v -> ("FOM_centric", string_of_float v)) a.fOM_centric;
      Option.map (fun v -> ("loc", string_of_float v)) a.loc;
      Option.map (fun v -> ("mean_phase", string_of_float v)) a.mean_phase;
      Option.map (fun v -> ("power", string_of_float v)) a.power;
      Option.map (fun v -> ("R_cullis", string_of_float v)) a.r_cullis;
      Option.map (fun v -> ("R_kraut", string_of_float v)) a.r_kraut;
      Option.map (fun v -> ("reflns", string_of_int v)) a.reflns;
      Option.map (fun v -> ("reflns_acentric", string_of_int v)) a.reflns_acentric;
      Option.map (fun v -> ("reflns_anomalous", string_of_int v)) a.reflns_anomalous;
      Option.map (fun v -> ("reflns_centric", string_of_int v)) a.reflns_centric;
      Option.map (fun v -> ("pdbx_loc_centric", string_of_float v)) a.pdbx_loc_centric;
      Option.map (fun v -> ("pdbx_loc_acentric", string_of_float v)) a.pdbx_loc_acentric;
      Option.map (fun v -> ("pdbx_power_centric", string_of_float v)) a.pdbx_power_centric;
      Option.map (fun v -> ("pdbx_power_acentric", string_of_float v)) a.pdbx_power_acentric;
      Option.map (fun v -> ("pdbx_R_kraut_centric", string_of_float v)) a.pdbx_R_kraut_centric;
      Option.map (fun v -> ("pdbx_R_kraut_acentric", string_of_float v)) a.pdbx_R_kraut_acentric;
      Option.map (fun v -> ("pdbx_R_cullis_centric", string_of_float v)) a.pdbx_R_cullis_centric;
      Option.map (fun v -> ("pdbx_R_cullis_acentric", string_of_float v)) a.pdbx_R_cullis_acentric;
    ]

end

module Phasing_set = struct
  type t = {
    cell_angle_alpha: float option;
    cell_angle_beta: float option;
    cell_angle_gamma: float option;
    cell_length_a: float option;
    cell_length_b: float option;
    cell_length_c: float option;
    detector_specific: string option;
    detector_type: string option;
    id: string option;
    radiation_source_specific: string option;
    radiation_wavelength: float option;
    temp: float option;
    pdbx_temp_details: string option;
    pdbx_d_res_high: float option;
    pdbx_d_res_low: float option;
  }

  let default = {
    cell_angle_alpha = None;
    cell_angle_beta = None;
    cell_angle_gamma = None;
    cell_length_a = None;
    cell_length_b = None;
    cell_length_c = None;
    detector_specific = None;
    detector_type = None;
    id = None;
    radiation_source_specific = None;
    radiation_wavelength = None;
    temp = None;
    pdbx_temp_details = None;
    pdbx_d_res_high = None;
    pdbx_d_res_low = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "cell_angle_alpha" -> { b with cell_angle_alpha = (PDBjDict.some_float v) }
      | "cell_angle_beta" -> { b with cell_angle_beta = (PDBjDict.some_float v) }
      | "cell_angle_gamma" -> { b with cell_angle_gamma = (PDBjDict.some_float v) }
      | "cell_length_a" -> { b with cell_length_a = (PDBjDict.some_float v) }
      | "cell_length_b" -> { b with cell_length_b = (PDBjDict.some_float v) }
      | "cell_length_c" -> { b with cell_length_c = (PDBjDict.some_float v) }
      | "detector_specific" -> { b with detector_specific = (Some v) }
      | "detector_type" -> { b with detector_type = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "radiation_source_specific" -> { b with radiation_source_specific = (Some v) }
      | "radiation_wavelength" -> { b with radiation_wavelength = (PDBjDict.some_float v) }
      | "temp" -> { b with temp = (PDBjDict.some_float v) }
      | "pdbx_temp_details" -> { b with pdbx_temp_details = (Some v) }
      | "pdbx_d_res_high" -> { b with pdbx_d_res_high = (PDBjDict.some_float v) }
      | "pdbx_d_res_low" -> { b with pdbx_d_res_low = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("cell_angle_alpha", string_of_float v)) a.cell_angle_alpha;
      Option.map (fun v -> ("cell_angle_beta", string_of_float v)) a.cell_angle_beta;
      Option.map (fun v -> ("cell_angle_gamma", string_of_float v)) a.cell_angle_gamma;
      Option.map (fun v -> ("cell_length_a", string_of_float v)) a.cell_length_a;
      Option.map (fun v -> ("cell_length_b", string_of_float v)) a.cell_length_b;
      Option.map (fun v -> ("cell_length_c", string_of_float v)) a.cell_length_c;
      Option.map (fun v -> ("detector_specific",  v)) a.detector_specific;
      Option.map (fun v -> ("detector_type",  v)) a.detector_type;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("radiation_source_specific",  v)) a.radiation_source_specific;
      Option.map (fun v -> ("radiation_wavelength", string_of_float v)) a.radiation_wavelength;
      Option.map (fun v -> ("temp", string_of_float v)) a.temp;
      Option.map (fun v -> ("pdbx_temp_details",  v)) a.pdbx_temp_details;
      Option.map (fun v -> ("pdbx_d_res_high", string_of_float v)) a.pdbx_d_res_high;
      Option.map (fun v -> ("pdbx_d_res_low", string_of_float v)) a.pdbx_d_res_low;
    ]

end

module Phasing_set_refln = struct
  type t = {
    set_id: string option;
    f_meas: float option;
    f_meas_au: float option;
    f_meas_sigma: float option;
    f_meas_sigma_au: float option;
    index_h: int option;
    index_k: int option;
    index_l: int option;
  }

  let default = {
    set_id = None;
    f_meas = None;
    f_meas_au = None;
    f_meas_sigma = None;
    f_meas_sigma_au = None;
    index_h = None;
    index_k = None;
    index_l = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "set_id" -> { b with set_id = (Some v) }
      | "F_meas" -> { b with f_meas = (PDBjDict.some_float v) }
      | "F_meas_au" -> { b with f_meas_au = (PDBjDict.some_float v) }
      | "F_meas_sigma" -> { b with f_meas_sigma = (PDBjDict.some_float v) }
      | "F_meas_sigma_au" -> { b with f_meas_sigma_au = (PDBjDict.some_float v) }
      | "index_h" -> { b with index_h = (PDBjDict.some_int v) }
      | "index_k" -> { b with index_k = (PDBjDict.some_int v) }
      | "index_l" -> { b with index_l = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("set_id",  v)) a.set_id;
      Option.map (fun v -> ("F_meas", string_of_float v)) a.f_meas;
      Option.map (fun v -> ("F_meas_au", string_of_float v)) a.f_meas_au;
      Option.map (fun v -> ("F_meas_sigma", string_of_float v)) a.f_meas_sigma;
      Option.map (fun v -> ("F_meas_sigma_au", string_of_float v)) a.f_meas_sigma_au;
      Option.map (fun v -> ("index_h", string_of_int v)) a.index_h;
      Option.map (fun v -> ("index_k", string_of_int v)) a.index_k;
      Option.map (fun v -> ("index_l", string_of_int v)) a.index_l;
    ]

end

module Publ = struct
  type t = {
    entry_id: string option;
    contact_author: string option;
    contact_author_address: string option;
    contact_author_email: string option;
    contact_author_fax: string option;
    contact_author_name: string option;
    contact_author_phone: string option;
    contact_letter: string option;
    manuscript_creation: string option;
    manuscript_processed: string option;
    manuscript_text: string option;
    requested_category: string option;
    requested_coeditor_name: string option;
    requested_journal: string option;
    section_abstract: string option;
    section_acknowledgements: string option;
    section_comment: string option;
    section_discussion: string option;
    section_experimental: string option;
    section_exptl_prep: string option;
    section_exptl_refinement: string option;
    section_exptl_solution: string option;
    section_figure_captions: string option;
    section_introduction: string option;
    section_references: string option;
    section_synopsis: string option;
    section_table_legends: string option;
    section_title: string option;
    section_title_footnote: string option;
  }

  let default = {
    entry_id = None;
    contact_author = None;
    contact_author_address = None;
    contact_author_email = None;
    contact_author_fax = None;
    contact_author_name = None;
    contact_author_phone = None;
    contact_letter = None;
    manuscript_creation = None;
    manuscript_processed = None;
    manuscript_text = None;
    requested_category = None;
    requested_coeditor_name = None;
    requested_journal = None;
    section_abstract = None;
    section_acknowledgements = None;
    section_comment = None;
    section_discussion = None;
    section_experimental = None;
    section_exptl_prep = None;
    section_exptl_refinement = None;
    section_exptl_solution = None;
    section_figure_captions = None;
    section_introduction = None;
    section_references = None;
    section_synopsis = None;
    section_table_legends = None;
    section_title = None;
    section_title_footnote = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "contact_author" -> { b with contact_author = (Some v) }
      | "contact_author_address" -> { b with contact_author_address = (Some v) }
      | "contact_author_email" -> { b with contact_author_email = (Some v) }
      | "contact_author_fax" -> { b with contact_author_fax = (Some v) }
      | "contact_author_name" -> { b with contact_author_name = (Some v) }
      | "contact_author_phone" -> { b with contact_author_phone = (Some v) }
      | "contact_letter" -> { b with contact_letter = (Some v) }
      | "manuscript_creation" -> { b with manuscript_creation = (Some v) }
      | "manuscript_processed" -> { b with manuscript_processed = (Some v) }
      | "manuscript_text" -> { b with manuscript_text = (Some v) }
      | "requested_category" -> { b with requested_category = (Some v) }
      | "requested_coeditor_name" -> { b with requested_coeditor_name = (Some v) }
      | "requested_journal" -> { b with requested_journal = (Some v) }
      | "section_abstract" -> { b with section_abstract = (Some v) }
      | "section_acknowledgements" -> { b with section_acknowledgements = (Some v) }
      | "section_comment" -> { b with section_comment = (Some v) }
      | "section_discussion" -> { b with section_discussion = (Some v) }
      | "section_experimental" -> { b with section_experimental = (Some v) }
      | "section_exptl_prep" -> { b with section_exptl_prep = (Some v) }
      | "section_exptl_refinement" -> { b with section_exptl_refinement = (Some v) }
      | "section_exptl_solution" -> { b with section_exptl_solution = (Some v) }
      | "section_figure_captions" -> { b with section_figure_captions = (Some v) }
      | "section_introduction" -> { b with section_introduction = (Some v) }
      | "section_references" -> { b with section_references = (Some v) }
      | "section_synopsis" -> { b with section_synopsis = (Some v) }
      | "section_table_legends" -> { b with section_table_legends = (Some v) }
      | "section_title" -> { b with section_title = (Some v) }
      | "section_title_footnote" -> { b with section_title_footnote = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("contact_author",  v)) a.contact_author;
      Option.map (fun v -> ("contact_author_address",  v)) a.contact_author_address;
      Option.map (fun v -> ("contact_author_email",  v)) a.contact_author_email;
      Option.map (fun v -> ("contact_author_fax",  v)) a.contact_author_fax;
      Option.map (fun v -> ("contact_author_name",  v)) a.contact_author_name;
      Option.map (fun v -> ("contact_author_phone",  v)) a.contact_author_phone;
      Option.map (fun v -> ("contact_letter",  v)) a.contact_letter;
      Option.map (fun v -> ("manuscript_creation",  v)) a.manuscript_creation;
      Option.map (fun v -> ("manuscript_processed",  v)) a.manuscript_processed;
      Option.map (fun v -> ("manuscript_text",  v)) a.manuscript_text;
      Option.map (fun v -> ("requested_category",  v)) a.requested_category;
      Option.map (fun v -> ("requested_coeditor_name",  v)) a.requested_coeditor_name;
      Option.map (fun v -> ("requested_journal",  v)) a.requested_journal;
      Option.map (fun v -> ("section_abstract",  v)) a.section_abstract;
      Option.map (fun v -> ("section_acknowledgements",  v)) a.section_acknowledgements;
      Option.map (fun v -> ("section_comment",  v)) a.section_comment;
      Option.map (fun v -> ("section_discussion",  v)) a.section_discussion;
      Option.map (fun v -> ("section_experimental",  v)) a.section_experimental;
      Option.map (fun v -> ("section_exptl_prep",  v)) a.section_exptl_prep;
      Option.map (fun v -> ("section_exptl_refinement",  v)) a.section_exptl_refinement;
      Option.map (fun v -> ("section_exptl_solution",  v)) a.section_exptl_solution;
      Option.map (fun v -> ("section_figure_captions",  v)) a.section_figure_captions;
      Option.map (fun v -> ("section_introduction",  v)) a.section_introduction;
      Option.map (fun v -> ("section_references",  v)) a.section_references;
      Option.map (fun v -> ("section_synopsis",  v)) a.section_synopsis;
      Option.map (fun v -> ("section_table_legends",  v)) a.section_table_legends;
      Option.map (fun v -> ("section_title",  v)) a.section_title;
      Option.map (fun v -> ("section_title_footnote",  v)) a.section_title_footnote;
    ]

end

module Publ_author = struct
  type t = {
    address: string option;
    email: string option;
    footnote: string option;
    name: string option;
    id_iucr: string option;
  }

  let default = {
    address = None;
    email = None;
    footnote = None;
    name = None;
    id_iucr = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "address" -> { b with address = (Some v) }
      | "email" -> { b with email = (Some v) }
      | "footnote" -> { b with footnote = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "id_iucr" -> { b with id_iucr = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("address",  v)) a.address;
      Option.map (fun v -> ("email",  v)) a.email;
      Option.map (fun v -> ("footnote",  v)) a.footnote;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("id_iucr",  v)) a.id_iucr;
    ]

end

module Publ_body = struct
  type t = {
    contents: string option;
    element: string option;
    format: string option;
    label: string option;
    title: string option;
  }

  let default = {
    contents = None;
    element = None;
    format = None;
    label = None;
    title = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "contents" -> { b with contents = (Some v) }
      | "element" -> { b with element = (Some v) }
      | "format" -> { b with format = (Some v) }
      | "label" -> { b with label = (Some v) }
      | "title" -> { b with title = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("contents",  v)) a.contents;
      Option.map (fun v -> ("element",  v)) a.element;
      Option.map (fun v -> ("format",  v)) a.format;
      Option.map (fun v -> ("label",  v)) a.label;
      Option.map (fun v -> ("title",  v)) a.title;
    ]

end

module Publ_manuscript_incl = struct
  type t = {
    entry_id: string option;
    extra_defn: string option;
    extra_info: string option;
    extra_item: string option;
  }

  let default = {
    entry_id = None;
    extra_defn = None;
    extra_info = None;
    extra_item = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "extra_defn" -> { b with extra_defn = (Some v) }
      | "extra_info" -> { b with extra_info = (Some v) }
      | "extra_item" -> { b with extra_item = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("extra_defn",  v)) a.extra_defn;
      Option.map (fun v -> ("extra_info",  v)) a.extra_info;
      Option.map (fun v -> ("extra_item",  v)) a.extra_item;
    ]

end

module Refine = struct
  type t = {
    aniso_B11: float option;
    aniso_B12: float option;
    aniso_B13: float option;
    aniso_B22: float option;
    aniso_B23: float option;
    aniso_B33: float option;
    b_iso_max: float option;
    b_iso_mean: float option;
    b_iso_min: float option;
    correlation_coeff_Fo_to_Fc: float option;
    correlation_coeff_Fo_to_Fc_free: float option;
    details: string option;
    diff_density_max: float option;
    diff_density_max_esd: float option;
    diff_density_min: float option;
    diff_density_min_esd: float option;
    diff_density_rms: float option;
    diff_density_rms_esd: float option;
    entry_id: string option;
    pdbx_refine_id: string option;
    ls_abs_structure_details: string option;
    ls_abs_structure_Flack: float option;
    ls_abs_structure_Flack_esd: float option;
    ls_abs_structure_Rogers: float option;
    ls_abs_structure_Rogers_esd: float option;
    ls_d_res_high: float option;
    ls_d_res_low: float option;
    ls_extinction_coef: float option;
    ls_extinction_coef_esd: float option;
    ls_extinction_expression: string option;
    ls_extinction_method: string option;
    ls_goodness_of_fit_all: float option;
    ls_goodness_of_fit_all_esd: float option;
    ls_goodness_of_fit_obs: float option;
    ls_goodness_of_fit_obs_esd: float option;
    ls_hydrogen_treatment: string option;
    ls_matrix_type: string option;
    ls_number_constraints: int option;
    ls_number_parameters: int option;
    ls_number_reflns_all: int option;
    ls_number_reflns_obs: int option;
    ls_number_reflns_R_free: int option;
    ls_number_reflns_R_work: int option;
    ls_number_restraints: int option;
    ls_percent_reflns_obs: float option;
    ls_percent_reflns_R_free: float option;
    ls_R_factor_all: float option;
    ls_R_factor_obs: float option;
    ls_R_factor_R_free: float option;
    ls_R_factor_R_free_error: float option;
    ls_R_factor_R_free_error_details: string option;
    ls_R_factor_R_work: float option;
    ls_R_Fsqd_factor_obs: float option;
    ls_R_I_factor_obs: float option;
    ls_redundancy_reflns_all: float option;
    ls_redundancy_reflns_obs: float option;
    ls_restrained_S_all: float option;
    ls_restrained_S_obs: float option;
    ls_shift_over_esd_max: float option;
    ls_shift_over_esd_mean: float option;
    ls_structure_factor_coef: string option;
    ls_weighting_details: string option;
    ls_weighting_scheme: string option;
    ls_wR_factor_all: float option;
    ls_wR_factor_obs: float option;
    ls_wR_factor_R_free: float option;
    ls_wR_factor_R_work: float option;
    occupancy_max: float option;
    occupancy_min: float option;
    solvent_model_details: string option;
    solvent_model_param_bsol: float option;
    solvent_model_param_ksol: float option;
    ls_R_factor_gt: float option;
    ls_goodness_of_fit_gt: float option;
    ls_goodness_of_fit_ref: float option;
    ls_shift_over_su_max: float option;
    ls_shift_over_su_max_lt: float option;
    ls_shift_over_su_mean: float option;
    ls_shift_over_su_mean_lt: float option;
    pdbx_ls_sigma_I: float option;
    pdbx_ls_sigma_F: float option;
    pdbx_ls_sigma_Fsqd: float option;
    pdbx_data_cutoff_high_absF: float option;
    pdbx_data_cutoff_high_rms_absF: float option;
    pdbx_data_cutoff_low_absF: float option;
    pdbx_isotropic_thermal_model: string option;
    pdbx_ls_cross_valid_method: string option;
    pdbx_method_to_determine_struct: string option;
    pdbx_starting_model: string option;
    pdbx_stereochemistry_target_values: string option;
    pdbx_R_Free_selection_details: string option;
    pdbx_stereochem_target_val_spec_case: string option;
    pdbx_overall_ESU_R: float option;
    pdbx_overall_ESU_R_Free: float option;
    pdbx_solvent_vdw_probe_radii: float option;
    pdbx_solvent_ion_probe_radii: float option;
    pdbx_solvent_shrinkage_radii: float option;
    pdbx_real_space_R: float option;
    pdbx_density_correlation: float option;
    pdbx_pd_number_of_powder_patterns: int option;
    pdbx_pd_number_of_points: int option;
    pdbx_pd_meas_number_of_points: int option;
    pdbx_pd_proc_ls_prof_R_factor: float option;
    pdbx_pd_proc_ls_prof_wR_factor: float option;
    pdbx_pd_Marquardt_correlation_coeff: float option;
    pdbx_pd_Fsqrd_R_factor: float option;
    pdbx_pd_ls_matrix_band_width: int option;
    pdbx_overall_phase_error: float option;
    pdbx_overall_SU_R_free_Cruickshank_DPI: float option;
    pdbx_overall_SU_R_free_Blow_DPI: float option;
    pdbx_overall_SU_R_Blow_DPI: float option;
    pdbx_TLS_residual_ADP_flag: string option;
    pdbx_diffrn_id: string option;
    overall_SU_B: float option;
    overall_SU_ML: float option;
    overall_SU_R_Cruickshank_DPI: float option;
    overall_SU_R_free: float option;
    overall_FOM_free_R_set: float option;
    overall_FOM_work_R_set: float option;
    pdbx_average_fsc_overall: float option;
    pdbx_average_fsc_work: float option;
    pdbx_average_fsc_free: float option;
    pdbx_overall_ESU_B: float option;
    pdbx_overall_ESU_ML: float option;
  }

  let default = {
    aniso_B11 = None;
    aniso_B12 = None;
    aniso_B13 = None;
    aniso_B22 = None;
    aniso_B23 = None;
    aniso_B33 = None;
    b_iso_max = None;
    b_iso_mean = None;
    b_iso_min = None;
    correlation_coeff_Fo_to_Fc = None;
    correlation_coeff_Fo_to_Fc_free = None;
    details = None;
    diff_density_max = None;
    diff_density_max_esd = None;
    diff_density_min = None;
    diff_density_min_esd = None;
    diff_density_rms = None;
    diff_density_rms_esd = None;
    entry_id = None;
    pdbx_refine_id = None;
    ls_abs_structure_details = None;
    ls_abs_structure_Flack = None;
    ls_abs_structure_Flack_esd = None;
    ls_abs_structure_Rogers = None;
    ls_abs_structure_Rogers_esd = None;
    ls_d_res_high = None;
    ls_d_res_low = None;
    ls_extinction_coef = None;
    ls_extinction_coef_esd = None;
    ls_extinction_expression = None;
    ls_extinction_method = None;
    ls_goodness_of_fit_all = None;
    ls_goodness_of_fit_all_esd = None;
    ls_goodness_of_fit_obs = None;
    ls_goodness_of_fit_obs_esd = None;
    ls_hydrogen_treatment = None;
    ls_matrix_type = None;
    ls_number_constraints = None;
    ls_number_parameters = None;
    ls_number_reflns_all = None;
    ls_number_reflns_obs = None;
    ls_number_reflns_R_free = None;
    ls_number_reflns_R_work = None;
    ls_number_restraints = None;
    ls_percent_reflns_obs = None;
    ls_percent_reflns_R_free = None;
    ls_R_factor_all = None;
    ls_R_factor_obs = None;
    ls_R_factor_R_free = None;
    ls_R_factor_R_free_error = None;
    ls_R_factor_R_free_error_details = None;
    ls_R_factor_R_work = None;
    ls_R_Fsqd_factor_obs = None;
    ls_R_I_factor_obs = None;
    ls_redundancy_reflns_all = None;
    ls_redundancy_reflns_obs = None;
    ls_restrained_S_all = None;
    ls_restrained_S_obs = None;
    ls_shift_over_esd_max = None;
    ls_shift_over_esd_mean = None;
    ls_structure_factor_coef = None;
    ls_weighting_details = None;
    ls_weighting_scheme = None;
    ls_wR_factor_all = None;
    ls_wR_factor_obs = None;
    ls_wR_factor_R_free = None;
    ls_wR_factor_R_work = None;
    occupancy_max = None;
    occupancy_min = None;
    solvent_model_details = None;
    solvent_model_param_bsol = None;
    solvent_model_param_ksol = None;
    ls_R_factor_gt = None;
    ls_goodness_of_fit_gt = None;
    ls_goodness_of_fit_ref = None;
    ls_shift_over_su_max = None;
    ls_shift_over_su_max_lt = None;
    ls_shift_over_su_mean = None;
    ls_shift_over_su_mean_lt = None;
    pdbx_ls_sigma_I = None;
    pdbx_ls_sigma_F = None;
    pdbx_ls_sigma_Fsqd = None;
    pdbx_data_cutoff_high_absF = None;
    pdbx_data_cutoff_high_rms_absF = None;
    pdbx_data_cutoff_low_absF = None;
    pdbx_isotropic_thermal_model = None;
    pdbx_ls_cross_valid_method = None;
    pdbx_method_to_determine_struct = None;
    pdbx_starting_model = None;
    pdbx_stereochemistry_target_values = None;
    pdbx_R_Free_selection_details = None;
    pdbx_stereochem_target_val_spec_case = None;
    pdbx_overall_ESU_R = None;
    pdbx_overall_ESU_R_Free = None;
    pdbx_solvent_vdw_probe_radii = None;
    pdbx_solvent_ion_probe_radii = None;
    pdbx_solvent_shrinkage_radii = None;
    pdbx_real_space_R = None;
    pdbx_density_correlation = None;
    pdbx_pd_number_of_powder_patterns = None;
    pdbx_pd_number_of_points = None;
    pdbx_pd_meas_number_of_points = None;
    pdbx_pd_proc_ls_prof_R_factor = None;
    pdbx_pd_proc_ls_prof_wR_factor = None;
    pdbx_pd_Marquardt_correlation_coeff = None;
    pdbx_pd_Fsqrd_R_factor = None;
    pdbx_pd_ls_matrix_band_width = None;
    pdbx_overall_phase_error = None;
    pdbx_overall_SU_R_free_Cruickshank_DPI = None;
    pdbx_overall_SU_R_free_Blow_DPI = None;
    pdbx_overall_SU_R_Blow_DPI = None;
    pdbx_TLS_residual_ADP_flag = None;
    pdbx_diffrn_id = None;
    overall_SU_B = None;
    overall_SU_ML = None;
    overall_SU_R_Cruickshank_DPI = None;
    overall_SU_R_free = None;
    overall_FOM_free_R_set = None;
    overall_FOM_work_R_set = None;
    pdbx_average_fsc_overall = None;
    pdbx_average_fsc_work = None;
    pdbx_average_fsc_free = None;
    pdbx_overall_ESU_B = None;
    pdbx_overall_ESU_ML = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "aniso_B[1][1]" -> { b with aniso_B11 = (PDBjDict.some_float v) }
      | "aniso_B[1][2]" -> { b with aniso_B12 = (PDBjDict.some_float v) }
      | "aniso_B[1][3]" -> { b with aniso_B13 = (PDBjDict.some_float v) }
      | "aniso_B[2][2]" -> { b with aniso_B22 = (PDBjDict.some_float v) }
      | "aniso_B[2][3]" -> { b with aniso_B23 = (PDBjDict.some_float v) }
      | "aniso_B[3][3]" -> { b with aniso_B33 = (PDBjDict.some_float v) }
      | "B_iso_max" -> { b with b_iso_max = (PDBjDict.some_float v) }
      | "B_iso_mean" -> { b with b_iso_mean = (PDBjDict.some_float v) }
      | "B_iso_min" -> { b with b_iso_min = (PDBjDict.some_float v) }
      | "correlation_coeff_Fo_to_Fc" -> { b with correlation_coeff_Fo_to_Fc = (PDBjDict.some_float v) }
      | "correlation_coeff_Fo_to_Fc_free" -> { b with correlation_coeff_Fo_to_Fc_free = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | "diff_density_max" -> { b with diff_density_max = (PDBjDict.some_float v) }
      | "diff_density_max_esd" -> { b with diff_density_max_esd = (PDBjDict.some_float v) }
      | "diff_density_min" -> { b with diff_density_min = (PDBjDict.some_float v) }
      | "diff_density_min_esd" -> { b with diff_density_min_esd = (PDBjDict.some_float v) }
      | "diff_density_rms" -> { b with diff_density_rms = (PDBjDict.some_float v) }
      | "diff_density_rms_esd" -> { b with diff_density_rms_esd = (PDBjDict.some_float v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "ls_abs_structure_details" -> { b with ls_abs_structure_details = (Some v) }
      | "ls_abs_structure_Flack" -> { b with ls_abs_structure_Flack = (PDBjDict.some_float v) }
      | "ls_abs_structure_Flack_esd" -> { b with ls_abs_structure_Flack_esd = (PDBjDict.some_float v) }
      | "ls_abs_structure_Rogers" -> { b with ls_abs_structure_Rogers = (PDBjDict.some_float v) }
      | "ls_abs_structure_Rogers_esd" -> { b with ls_abs_structure_Rogers_esd = (PDBjDict.some_float v) }
      | "ls_d_res_high" -> { b with ls_d_res_high = (PDBjDict.some_float v) }
      | "ls_d_res_low" -> { b with ls_d_res_low = (PDBjDict.some_float v) }
      | "ls_extinction_coef" -> { b with ls_extinction_coef = (PDBjDict.some_float v) }
      | "ls_extinction_coef_esd" -> { b with ls_extinction_coef_esd = (PDBjDict.some_float v) }
      | "ls_extinction_expression" -> { b with ls_extinction_expression = (Some v) }
      | "ls_extinction_method" -> { b with ls_extinction_method = (Some v) }
      | "ls_goodness_of_fit_all" -> { b with ls_goodness_of_fit_all = (PDBjDict.some_float v) }
      | "ls_goodness_of_fit_all_esd" -> { b with ls_goodness_of_fit_all_esd = (PDBjDict.some_float v) }
      | "ls_goodness_of_fit_obs" -> { b with ls_goodness_of_fit_obs = (PDBjDict.some_float v) }
      | "ls_goodness_of_fit_obs_esd" -> { b with ls_goodness_of_fit_obs_esd = (PDBjDict.some_float v) }
      | "ls_hydrogen_treatment" -> { b with ls_hydrogen_treatment = (Some v) }
      | "ls_matrix_type" -> { b with ls_matrix_type = (Some v) }
      | "ls_number_constraints" -> { b with ls_number_constraints = (PDBjDict.some_int v) }
      | "ls_number_parameters" -> { b with ls_number_parameters = (PDBjDict.some_int v) }
      | "ls_number_reflns_all" -> { b with ls_number_reflns_all = (PDBjDict.some_int v) }
      | "ls_number_reflns_obs" -> { b with ls_number_reflns_obs = (PDBjDict.some_int v) }
      | "ls_number_reflns_R_free" -> { b with ls_number_reflns_R_free = (PDBjDict.some_int v) }
      | "ls_number_reflns_R_work" -> { b with ls_number_reflns_R_work = (PDBjDict.some_int v) }
      | "ls_number_restraints" -> { b with ls_number_restraints = (PDBjDict.some_int v) }
      | "ls_percent_reflns_obs" -> { b with ls_percent_reflns_obs = (PDBjDict.some_float v) }
      | "ls_percent_reflns_R_free" -> { b with ls_percent_reflns_R_free = (PDBjDict.some_float v) }
      | "ls_R_factor_all" -> { b with ls_R_factor_all = (PDBjDict.some_float v) }
      | "ls_R_factor_obs" -> { b with ls_R_factor_obs = (PDBjDict.some_float v) }
      | "ls_R_factor_R_free" -> { b with ls_R_factor_R_free = (PDBjDict.some_float v) }
      | "ls_R_factor_R_free_error" -> { b with ls_R_factor_R_free_error = (PDBjDict.some_float v) }
      | "ls_R_factor_R_free_error_details" -> { b with ls_R_factor_R_free_error_details = (Some v) }
      | "ls_R_factor_R_work" -> { b with ls_R_factor_R_work = (PDBjDict.some_float v) }
      | "ls_R_Fsqd_factor_obs" -> { b with ls_R_Fsqd_factor_obs = (PDBjDict.some_float v) }
      | "ls_R_I_factor_obs" -> { b with ls_R_I_factor_obs = (PDBjDict.some_float v) }
      | "ls_redundancy_reflns_all" -> { b with ls_redundancy_reflns_all = (PDBjDict.some_float v) }
      | "ls_redundancy_reflns_obs" -> { b with ls_redundancy_reflns_obs = (PDBjDict.some_float v) }
      | "ls_restrained_S_all" -> { b with ls_restrained_S_all = (PDBjDict.some_float v) }
      | "ls_restrained_S_obs" -> { b with ls_restrained_S_obs = (PDBjDict.some_float v) }
      | "ls_shift_over_esd_max" -> { b with ls_shift_over_esd_max = (PDBjDict.some_float v) }
      | "ls_shift_over_esd_mean" -> { b with ls_shift_over_esd_mean = (PDBjDict.some_float v) }
      | "ls_structure_factor_coef" -> { b with ls_structure_factor_coef = (Some v) }
      | "ls_weighting_details" -> { b with ls_weighting_details = (Some v) }
      | "ls_weighting_scheme" -> { b with ls_weighting_scheme = (Some v) }
      | "ls_wR_factor_all" -> { b with ls_wR_factor_all = (PDBjDict.some_float v) }
      | "ls_wR_factor_obs" -> { b with ls_wR_factor_obs = (PDBjDict.some_float v) }
      | "ls_wR_factor_R_free" -> { b with ls_wR_factor_R_free = (PDBjDict.some_float v) }
      | "ls_wR_factor_R_work" -> { b with ls_wR_factor_R_work = (PDBjDict.some_float v) }
      | "occupancy_max" -> { b with occupancy_max = (PDBjDict.some_float v) }
      | "occupancy_min" -> { b with occupancy_min = (PDBjDict.some_float v) }
      | "solvent_model_details" -> { b with solvent_model_details = (Some v) }
      | "solvent_model_param_bsol" -> { b with solvent_model_param_bsol = (PDBjDict.some_float v) }
      | "solvent_model_param_ksol" -> { b with solvent_model_param_ksol = (PDBjDict.some_float v) }
      | "ls_R_factor_gt" -> { b with ls_R_factor_gt = (PDBjDict.some_float v) }
      | "ls_goodness_of_fit_gt" -> { b with ls_goodness_of_fit_gt = (PDBjDict.some_float v) }
      | "ls_goodness_of_fit_ref" -> { b with ls_goodness_of_fit_ref = (PDBjDict.some_float v) }
      | "ls_shift_over_su_max" -> { b with ls_shift_over_su_max = (PDBjDict.some_float v) }
      | "ls_shift_over_su_max_lt" -> { b with ls_shift_over_su_max_lt = (PDBjDict.some_float v) }
      | "ls_shift_over_su_mean" -> { b with ls_shift_over_su_mean = (PDBjDict.some_float v) }
      | "ls_shift_over_su_mean_lt" -> { b with ls_shift_over_su_mean_lt = (PDBjDict.some_float v) }
      | "pdbx_ls_sigma_I" -> { b with pdbx_ls_sigma_I = (PDBjDict.some_float v) }
      | "pdbx_ls_sigma_F" -> { b with pdbx_ls_sigma_F = (PDBjDict.some_float v) }
      | "pdbx_ls_sigma_Fsqd" -> { b with pdbx_ls_sigma_Fsqd = (PDBjDict.some_float v) }
      | "pdbx_data_cutoff_high_absF" -> { b with pdbx_data_cutoff_high_absF = (PDBjDict.some_float v) }
      | "pdbx_data_cutoff_high_rms_absF" -> { b with pdbx_data_cutoff_high_rms_absF = (PDBjDict.some_float v) }
      | "pdbx_data_cutoff_low_absF" -> { b with pdbx_data_cutoff_low_absF = (PDBjDict.some_float v) }
      | "pdbx_isotropic_thermal_model" -> { b with pdbx_isotropic_thermal_model = (Some v) }
      | "pdbx_ls_cross_valid_method" -> { b with pdbx_ls_cross_valid_method = (Some v) }
      | "pdbx_method_to_determine_struct" -> { b with pdbx_method_to_determine_struct = (Some v) }
      | "pdbx_starting_model" -> { b with pdbx_starting_model = (Some v) }
      | "pdbx_stereochemistry_target_values" -> { b with pdbx_stereochemistry_target_values = (Some v) }
      | "pdbx_R_Free_selection_details" -> { b with pdbx_R_Free_selection_details = (Some v) }
      | "pdbx_stereochem_target_val_spec_case" -> { b with pdbx_stereochem_target_val_spec_case = (Some v) }
      | "pdbx_overall_ESU_R" -> { b with pdbx_overall_ESU_R = (PDBjDict.some_float v) }
      | "pdbx_overall_ESU_R_Free" -> { b with pdbx_overall_ESU_R_Free = (PDBjDict.some_float v) }
      | "pdbx_solvent_vdw_probe_radii" -> { b with pdbx_solvent_vdw_probe_radii = (PDBjDict.some_float v) }
      | "pdbx_solvent_ion_probe_radii" -> { b with pdbx_solvent_ion_probe_radii = (PDBjDict.some_float v) }
      | "pdbx_solvent_shrinkage_radii" -> { b with pdbx_solvent_shrinkage_radii = (PDBjDict.some_float v) }
      | "pdbx_real_space_R" -> { b with pdbx_real_space_R = (PDBjDict.some_float v) }
      | "pdbx_density_correlation" -> { b with pdbx_density_correlation = (PDBjDict.some_float v) }
      | "pdbx_pd_number_of_powder_patterns" -> { b with pdbx_pd_number_of_powder_patterns = (PDBjDict.some_int v) }
      | "pdbx_pd_number_of_points" -> { b with pdbx_pd_number_of_points = (PDBjDict.some_int v) }
      | "pdbx_pd_meas_number_of_points" -> { b with pdbx_pd_meas_number_of_points = (PDBjDict.some_int v) }
      | "pdbx_pd_proc_ls_prof_R_factor" -> { b with pdbx_pd_proc_ls_prof_R_factor = (PDBjDict.some_float v) }
      | "pdbx_pd_proc_ls_prof_wR_factor" -> { b with pdbx_pd_proc_ls_prof_wR_factor = (PDBjDict.some_float v) }
      | "pdbx_pd_Marquardt_correlation_coeff" -> { b with pdbx_pd_Marquardt_correlation_coeff = (PDBjDict.some_float v) }
      | "pdbx_pd_Fsqrd_R_factor" -> { b with pdbx_pd_Fsqrd_R_factor = (PDBjDict.some_float v) }
      | "pdbx_pd_ls_matrix_band_width" -> { b with pdbx_pd_ls_matrix_band_width = (PDBjDict.some_int v) }
      | "pdbx_overall_phase_error" -> { b with pdbx_overall_phase_error = (PDBjDict.some_float v) }
      | "pdbx_overall_SU_R_free_Cruickshank_DPI" -> { b with pdbx_overall_SU_R_free_Cruickshank_DPI = (PDBjDict.some_float v) }
      | "pdbx_overall_SU_R_free_Blow_DPI" -> { b with pdbx_overall_SU_R_free_Blow_DPI = (PDBjDict.some_float v) }
      | "pdbx_overall_SU_R_Blow_DPI" -> { b with pdbx_overall_SU_R_Blow_DPI = (PDBjDict.some_float v) }
      | "pdbx_TLS_residual_ADP_flag" -> { b with pdbx_TLS_residual_ADP_flag = (Some v) }
      | "pdbx_diffrn_id" -> { b with pdbx_diffrn_id = (Some v) }
      | "overall_SU_B" -> { b with overall_SU_B = (PDBjDict.some_float v) }
      | "overall_SU_ML" -> { b with overall_SU_ML = (PDBjDict.some_float v) }
      | "overall_SU_R_Cruickshank_DPI" -> { b with overall_SU_R_Cruickshank_DPI = (PDBjDict.some_float v) }
      | "overall_SU_R_free" -> { b with overall_SU_R_free = (PDBjDict.some_float v) }
      | "overall_FOM_free_R_set" -> { b with overall_FOM_free_R_set = (PDBjDict.some_float v) }
      | "overall_FOM_work_R_set" -> { b with overall_FOM_work_R_set = (PDBjDict.some_float v) }
      | "pdbx_average_fsc_overall" -> { b with pdbx_average_fsc_overall = (PDBjDict.some_float v) }
      | "pdbx_average_fsc_work" -> { b with pdbx_average_fsc_work = (PDBjDict.some_float v) }
      | "pdbx_average_fsc_free" -> { b with pdbx_average_fsc_free = (PDBjDict.some_float v) }
      | "pdbx_overall_ESU_B" -> { b with pdbx_overall_ESU_B = (PDBjDict.some_float v) }
      | "pdbx_overall_ESU_ML" -> { b with pdbx_overall_ESU_ML = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("aniso_B[1][1]", string_of_float v)) a.aniso_B11;
      Option.map (fun v -> ("aniso_B[1][2]", string_of_float v)) a.aniso_B12;
      Option.map (fun v -> ("aniso_B[1][3]", string_of_float v)) a.aniso_B13;
      Option.map (fun v -> ("aniso_B[2][2]", string_of_float v)) a.aniso_B22;
      Option.map (fun v -> ("aniso_B[2][3]", string_of_float v)) a.aniso_B23;
      Option.map (fun v -> ("aniso_B[3][3]", string_of_float v)) a.aniso_B33;
      Option.map (fun v -> ("B_iso_max", string_of_float v)) a.b_iso_max;
      Option.map (fun v -> ("B_iso_mean", string_of_float v)) a.b_iso_mean;
      Option.map (fun v -> ("B_iso_min", string_of_float v)) a.b_iso_min;
      Option.map (fun v -> ("correlation_coeff_Fo_to_Fc", string_of_float v)) a.correlation_coeff_Fo_to_Fc;
      Option.map (fun v -> ("correlation_coeff_Fo_to_Fc_free", string_of_float v)) a.correlation_coeff_Fo_to_Fc_free;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("diff_density_max", string_of_float v)) a.diff_density_max;
      Option.map (fun v -> ("diff_density_max_esd", string_of_float v)) a.diff_density_max_esd;
      Option.map (fun v -> ("diff_density_min", string_of_float v)) a.diff_density_min;
      Option.map (fun v -> ("diff_density_min_esd", string_of_float v)) a.diff_density_min_esd;
      Option.map (fun v -> ("diff_density_rms", string_of_float v)) a.diff_density_rms;
      Option.map (fun v -> ("diff_density_rms_esd", string_of_float v)) a.diff_density_rms_esd;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("ls_abs_structure_details",  v)) a.ls_abs_structure_details;
      Option.map (fun v -> ("ls_abs_structure_Flack", string_of_float v)) a.ls_abs_structure_Flack;
      Option.map (fun v -> ("ls_abs_structure_Flack_esd", string_of_float v)) a.ls_abs_structure_Flack_esd;
      Option.map (fun v -> ("ls_abs_structure_Rogers", string_of_float v)) a.ls_abs_structure_Rogers;
      Option.map (fun v -> ("ls_abs_structure_Rogers_esd", string_of_float v)) a.ls_abs_structure_Rogers_esd;
      Option.map (fun v -> ("ls_d_res_high", string_of_float v)) a.ls_d_res_high;
      Option.map (fun v -> ("ls_d_res_low", string_of_float v)) a.ls_d_res_low;
      Option.map (fun v -> ("ls_extinction_coef", string_of_float v)) a.ls_extinction_coef;
      Option.map (fun v -> ("ls_extinction_coef_esd", string_of_float v)) a.ls_extinction_coef_esd;
      Option.map (fun v -> ("ls_extinction_expression",  v)) a.ls_extinction_expression;
      Option.map (fun v -> ("ls_extinction_method",  v)) a.ls_extinction_method;
      Option.map (fun v -> ("ls_goodness_of_fit_all", string_of_float v)) a.ls_goodness_of_fit_all;
      Option.map (fun v -> ("ls_goodness_of_fit_all_esd", string_of_float v)) a.ls_goodness_of_fit_all_esd;
      Option.map (fun v -> ("ls_goodness_of_fit_obs", string_of_float v)) a.ls_goodness_of_fit_obs;
      Option.map (fun v -> ("ls_goodness_of_fit_obs_esd", string_of_float v)) a.ls_goodness_of_fit_obs_esd;
      Option.map (fun v -> ("ls_hydrogen_treatment",  v)) a.ls_hydrogen_treatment;
      Option.map (fun v -> ("ls_matrix_type",  v)) a.ls_matrix_type;
      Option.map (fun v -> ("ls_number_constraints", string_of_int v)) a.ls_number_constraints;
      Option.map (fun v -> ("ls_number_parameters", string_of_int v)) a.ls_number_parameters;
      Option.map (fun v -> ("ls_number_reflns_all", string_of_int v)) a.ls_number_reflns_all;
      Option.map (fun v -> ("ls_number_reflns_obs", string_of_int v)) a.ls_number_reflns_obs;
      Option.map (fun v -> ("ls_number_reflns_R_free", string_of_int v)) a.ls_number_reflns_R_free;
      Option.map (fun v -> ("ls_number_reflns_R_work", string_of_int v)) a.ls_number_reflns_R_work;
      Option.map (fun v -> ("ls_number_restraints", string_of_int v)) a.ls_number_restraints;
      Option.map (fun v -> ("ls_percent_reflns_obs", string_of_float v)) a.ls_percent_reflns_obs;
      Option.map (fun v -> ("ls_percent_reflns_R_free", string_of_float v)) a.ls_percent_reflns_R_free;
      Option.map (fun v -> ("ls_R_factor_all", string_of_float v)) a.ls_R_factor_all;
      Option.map (fun v -> ("ls_R_factor_obs", string_of_float v)) a.ls_R_factor_obs;
      Option.map (fun v -> ("ls_R_factor_R_free", string_of_float v)) a.ls_R_factor_R_free;
      Option.map (fun v -> ("ls_R_factor_R_free_error", string_of_float v)) a.ls_R_factor_R_free_error;
      Option.map (fun v -> ("ls_R_factor_R_free_error_details",  v)) a.ls_R_factor_R_free_error_details;
      Option.map (fun v -> ("ls_R_factor_R_work", string_of_float v)) a.ls_R_factor_R_work;
      Option.map (fun v -> ("ls_R_Fsqd_factor_obs", string_of_float v)) a.ls_R_Fsqd_factor_obs;
      Option.map (fun v -> ("ls_R_I_factor_obs", string_of_float v)) a.ls_R_I_factor_obs;
      Option.map (fun v -> ("ls_redundancy_reflns_all", string_of_float v)) a.ls_redundancy_reflns_all;
      Option.map (fun v -> ("ls_redundancy_reflns_obs", string_of_float v)) a.ls_redundancy_reflns_obs;
      Option.map (fun v -> ("ls_restrained_S_all", string_of_float v)) a.ls_restrained_S_all;
      Option.map (fun v -> ("ls_restrained_S_obs", string_of_float v)) a.ls_restrained_S_obs;
      Option.map (fun v -> ("ls_shift_over_esd_max", string_of_float v)) a.ls_shift_over_esd_max;
      Option.map (fun v -> ("ls_shift_over_esd_mean", string_of_float v)) a.ls_shift_over_esd_mean;
      Option.map (fun v -> ("ls_structure_factor_coef",  v)) a.ls_structure_factor_coef;
      Option.map (fun v -> ("ls_weighting_details",  v)) a.ls_weighting_details;
      Option.map (fun v -> ("ls_weighting_scheme",  v)) a.ls_weighting_scheme;
      Option.map (fun v -> ("ls_wR_factor_all", string_of_float v)) a.ls_wR_factor_all;
      Option.map (fun v -> ("ls_wR_factor_obs", string_of_float v)) a.ls_wR_factor_obs;
      Option.map (fun v -> ("ls_wR_factor_R_free", string_of_float v)) a.ls_wR_factor_R_free;
      Option.map (fun v -> ("ls_wR_factor_R_work", string_of_float v)) a.ls_wR_factor_R_work;
      Option.map (fun v -> ("occupancy_max", string_of_float v)) a.occupancy_max;
      Option.map (fun v -> ("occupancy_min", string_of_float v)) a.occupancy_min;
      Option.map (fun v -> ("solvent_model_details",  v)) a.solvent_model_details;
      Option.map (fun v -> ("solvent_model_param_bsol", string_of_float v)) a.solvent_model_param_bsol;
      Option.map (fun v -> ("solvent_model_param_ksol", string_of_float v)) a.solvent_model_param_ksol;
      Option.map (fun v -> ("ls_R_factor_gt", string_of_float v)) a.ls_R_factor_gt;
      Option.map (fun v -> ("ls_goodness_of_fit_gt", string_of_float v)) a.ls_goodness_of_fit_gt;
      Option.map (fun v -> ("ls_goodness_of_fit_ref", string_of_float v)) a.ls_goodness_of_fit_ref;
      Option.map (fun v -> ("ls_shift_over_su_max", string_of_float v)) a.ls_shift_over_su_max;
      Option.map (fun v -> ("ls_shift_over_su_max_lt", string_of_float v)) a.ls_shift_over_su_max_lt;
      Option.map (fun v -> ("ls_shift_over_su_mean", string_of_float v)) a.ls_shift_over_su_mean;
      Option.map (fun v -> ("ls_shift_over_su_mean_lt", string_of_float v)) a.ls_shift_over_su_mean_lt;
      Option.map (fun v -> ("pdbx_ls_sigma_I", string_of_float v)) a.pdbx_ls_sigma_I;
      Option.map (fun v -> ("pdbx_ls_sigma_F", string_of_float v)) a.pdbx_ls_sigma_F;
      Option.map (fun v -> ("pdbx_ls_sigma_Fsqd", string_of_float v)) a.pdbx_ls_sigma_Fsqd;
      Option.map (fun v -> ("pdbx_data_cutoff_high_absF", string_of_float v)) a.pdbx_data_cutoff_high_absF;
      Option.map (fun v -> ("pdbx_data_cutoff_high_rms_absF", string_of_float v)) a.pdbx_data_cutoff_high_rms_absF;
      Option.map (fun v -> ("pdbx_data_cutoff_low_absF", string_of_float v)) a.pdbx_data_cutoff_low_absF;
      Option.map (fun v -> ("pdbx_isotropic_thermal_model",  v)) a.pdbx_isotropic_thermal_model;
      Option.map (fun v -> ("pdbx_ls_cross_valid_method",  v)) a.pdbx_ls_cross_valid_method;
      Option.map (fun v -> ("pdbx_method_to_determine_struct",  v)) a.pdbx_method_to_determine_struct;
      Option.map (fun v -> ("pdbx_starting_model",  v)) a.pdbx_starting_model;
      Option.map (fun v -> ("pdbx_stereochemistry_target_values",  v)) a.pdbx_stereochemistry_target_values;
      Option.map (fun v -> ("pdbx_R_Free_selection_details",  v)) a.pdbx_R_Free_selection_details;
      Option.map (fun v -> ("pdbx_stereochem_target_val_spec_case",  v)) a.pdbx_stereochem_target_val_spec_case;
      Option.map (fun v -> ("pdbx_overall_ESU_R", string_of_float v)) a.pdbx_overall_ESU_R;
      Option.map (fun v -> ("pdbx_overall_ESU_R_Free", string_of_float v)) a.pdbx_overall_ESU_R_Free;
      Option.map (fun v -> ("pdbx_solvent_vdw_probe_radii", string_of_float v)) a.pdbx_solvent_vdw_probe_radii;
      Option.map (fun v -> ("pdbx_solvent_ion_probe_radii", string_of_float v)) a.pdbx_solvent_ion_probe_radii;
      Option.map (fun v -> ("pdbx_solvent_shrinkage_radii", string_of_float v)) a.pdbx_solvent_shrinkage_radii;
      Option.map (fun v -> ("pdbx_real_space_R", string_of_float v)) a.pdbx_real_space_R;
      Option.map (fun v -> ("pdbx_density_correlation", string_of_float v)) a.pdbx_density_correlation;
      Option.map (fun v -> ("pdbx_pd_number_of_powder_patterns", string_of_int v)) a.pdbx_pd_number_of_powder_patterns;
      Option.map (fun v -> ("pdbx_pd_number_of_points", string_of_int v)) a.pdbx_pd_number_of_points;
      Option.map (fun v -> ("pdbx_pd_meas_number_of_points", string_of_int v)) a.pdbx_pd_meas_number_of_points;
      Option.map (fun v -> ("pdbx_pd_proc_ls_prof_R_factor", string_of_float v)) a.pdbx_pd_proc_ls_prof_R_factor;
      Option.map (fun v -> ("pdbx_pd_proc_ls_prof_wR_factor", string_of_float v)) a.pdbx_pd_proc_ls_prof_wR_factor;
      Option.map (fun v -> ("pdbx_pd_Marquardt_correlation_coeff", string_of_float v)) a.pdbx_pd_Marquardt_correlation_coeff;
      Option.map (fun v -> ("pdbx_pd_Fsqrd_R_factor", string_of_float v)) a.pdbx_pd_Fsqrd_R_factor;
      Option.map (fun v -> ("pdbx_pd_ls_matrix_band_width", string_of_int v)) a.pdbx_pd_ls_matrix_band_width;
      Option.map (fun v -> ("pdbx_overall_phase_error", string_of_float v)) a.pdbx_overall_phase_error;
      Option.map (fun v -> ("pdbx_overall_SU_R_free_Cruickshank_DPI", string_of_float v)) a.pdbx_overall_SU_R_free_Cruickshank_DPI;
      Option.map (fun v -> ("pdbx_overall_SU_R_free_Blow_DPI", string_of_float v)) a.pdbx_overall_SU_R_free_Blow_DPI;
      Option.map (fun v -> ("pdbx_overall_SU_R_Blow_DPI", string_of_float v)) a.pdbx_overall_SU_R_Blow_DPI;
      Option.map (fun v -> ("pdbx_TLS_residual_ADP_flag",  v)) a.pdbx_TLS_residual_ADP_flag;
      Option.map (fun v -> ("pdbx_diffrn_id",  v)) a.pdbx_diffrn_id;
      Option.map (fun v -> ("overall_SU_B", string_of_float v)) a.overall_SU_B;
      Option.map (fun v -> ("overall_SU_ML", string_of_float v)) a.overall_SU_ML;
      Option.map (fun v -> ("overall_SU_R_Cruickshank_DPI", string_of_float v)) a.overall_SU_R_Cruickshank_DPI;
      Option.map (fun v -> ("overall_SU_R_free", string_of_float v)) a.overall_SU_R_free;
      Option.map (fun v -> ("overall_FOM_free_R_set", string_of_float v)) a.overall_FOM_free_R_set;
      Option.map (fun v -> ("overall_FOM_work_R_set", string_of_float v)) a.overall_FOM_work_R_set;
      Option.map (fun v -> ("pdbx_average_fsc_overall", string_of_float v)) a.pdbx_average_fsc_overall;
      Option.map (fun v -> ("pdbx_average_fsc_work", string_of_float v)) a.pdbx_average_fsc_work;
      Option.map (fun v -> ("pdbx_average_fsc_free", string_of_float v)) a.pdbx_average_fsc_free;
      Option.map (fun v -> ("pdbx_overall_ESU_B", string_of_float v)) a.pdbx_overall_ESU_B;
      Option.map (fun v -> ("pdbx_overall_ESU_ML", string_of_float v)) a.pdbx_overall_ESU_ML;
    ]

end

module Refine_analyze = struct
  type t = {
    entry_id: string option;
    pdbx_refine_id: string option;
    luzzati_coordinate_error_free: float option;
    luzzati_coordinate_error_obs: float option;
    luzzati_d_res_low_free: float option;
    luzzati_d_res_low_obs: float option;
    luzzati_sigma_a_free: float option;
    luzzati_sigma_a_free_details: string option;
    luzzati_sigma_a_obs: float option;
    luzzati_sigma_a_obs_details: string option;
    number_disordered_residues: float option;
    occupancy_sum_hydrogen: float option;
    occupancy_sum_non_hydrogen: float option;
    rG_d_res_high: float option;
    rG_d_res_low: float option;
    rG_free: float option;
    rG_work: float option;
    rG_free_work_ratio: float option;
    pdbx_Luzzati_d_res_high_obs: float option;
  }

  let default = {
    entry_id = None;
    pdbx_refine_id = None;
    luzzati_coordinate_error_free = None;
    luzzati_coordinate_error_obs = None;
    luzzati_d_res_low_free = None;
    luzzati_d_res_low_obs = None;
    luzzati_sigma_a_free = None;
    luzzati_sigma_a_free_details = None;
    luzzati_sigma_a_obs = None;
    luzzati_sigma_a_obs_details = None;
    number_disordered_residues = None;
    occupancy_sum_hydrogen = None;
    occupancy_sum_non_hydrogen = None;
    rG_d_res_high = None;
    rG_d_res_low = None;
    rG_free = None;
    rG_work = None;
    rG_free_work_ratio = None;
    pdbx_Luzzati_d_res_high_obs = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "Luzzati_coordinate_error_free" -> { b with luzzati_coordinate_error_free = (PDBjDict.some_float v) }
      | "Luzzati_coordinate_error_obs" -> { b with luzzati_coordinate_error_obs = (PDBjDict.some_float v) }
      | "Luzzati_d_res_low_free" -> { b with luzzati_d_res_low_free = (PDBjDict.some_float v) }
      | "Luzzati_d_res_low_obs" -> { b with luzzati_d_res_low_obs = (PDBjDict.some_float v) }
      | "Luzzati_sigma_a_free" -> { b with luzzati_sigma_a_free = (PDBjDict.some_float v) }
      | "Luzzati_sigma_a_free_details" -> { b with luzzati_sigma_a_free_details = (Some v) }
      | "Luzzati_sigma_a_obs" -> { b with luzzati_sigma_a_obs = (PDBjDict.some_float v) }
      | "Luzzati_sigma_a_obs_details" -> { b with luzzati_sigma_a_obs_details = (Some v) }
      | "number_disordered_residues" -> { b with number_disordered_residues = (PDBjDict.some_float v) }
      | "occupancy_sum_hydrogen" -> { b with occupancy_sum_hydrogen = (PDBjDict.some_float v) }
      | "occupancy_sum_non_hydrogen" -> { b with occupancy_sum_non_hydrogen = (PDBjDict.some_float v) }
      | "RG_d_res_high" -> { b with rG_d_res_high = (PDBjDict.some_float v) }
      | "RG_d_res_low" -> { b with rG_d_res_low = (PDBjDict.some_float v) }
      | "RG_free" -> { b with rG_free = (PDBjDict.some_float v) }
      | "RG_work" -> { b with rG_work = (PDBjDict.some_float v) }
      | "RG_free_work_ratio" -> { b with rG_free_work_ratio = (PDBjDict.some_float v) }
      | "pdbx_Luzzati_d_res_high_obs" -> { b with pdbx_Luzzati_d_res_high_obs = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("Luzzati_coordinate_error_free", string_of_float v)) a.luzzati_coordinate_error_free;
      Option.map (fun v -> ("Luzzati_coordinate_error_obs", string_of_float v)) a.luzzati_coordinate_error_obs;
      Option.map (fun v -> ("Luzzati_d_res_low_free", string_of_float v)) a.luzzati_d_res_low_free;
      Option.map (fun v -> ("Luzzati_d_res_low_obs", string_of_float v)) a.luzzati_d_res_low_obs;
      Option.map (fun v -> ("Luzzati_sigma_a_free", string_of_float v)) a.luzzati_sigma_a_free;
      Option.map (fun v -> ("Luzzati_sigma_a_free_details",  v)) a.luzzati_sigma_a_free_details;
      Option.map (fun v -> ("Luzzati_sigma_a_obs", string_of_float v)) a.luzzati_sigma_a_obs;
      Option.map (fun v -> ("Luzzati_sigma_a_obs_details",  v)) a.luzzati_sigma_a_obs_details;
      Option.map (fun v -> ("number_disordered_residues", string_of_float v)) a.number_disordered_residues;
      Option.map (fun v -> ("occupancy_sum_hydrogen", string_of_float v)) a.occupancy_sum_hydrogen;
      Option.map (fun v -> ("occupancy_sum_non_hydrogen", string_of_float v)) a.occupancy_sum_non_hydrogen;
      Option.map (fun v -> ("RG_d_res_high", string_of_float v)) a.rG_d_res_high;
      Option.map (fun v -> ("RG_d_res_low", string_of_float v)) a.rG_d_res_low;
      Option.map (fun v -> ("RG_free", string_of_float v)) a.rG_free;
      Option.map (fun v -> ("RG_work", string_of_float v)) a.rG_work;
      Option.map (fun v -> ("RG_free_work_ratio", string_of_float v)) a.rG_free_work_ratio;
      Option.map (fun v -> ("pdbx_Luzzati_d_res_high_obs", string_of_float v)) a.pdbx_Luzzati_d_res_high_obs;
    ]

end

module Refine_B_iso = struct
  type t = {
    pdbx_refine_id: string option;
    class_: string option;
    details: string option;
    treatment: string option;
    value: float option;
    pdbx_residue_name: string option;
    pdbx_strand: string option;
    pdbx_residue_num: string option;
  }

  let default = {
    pdbx_refine_id = None;
    class_ = None;
    details = None;
    treatment = None;
    value = None;
    pdbx_residue_name = None;
    pdbx_strand = None;
    pdbx_residue_num = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "class" -> { b with class_ = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "treatment" -> { b with treatment = (Some v) }
      | "value" -> { b with value = (PDBjDict.some_float v) }
      | "pdbx_residue_name" -> { b with pdbx_residue_name = (Some v) }
      | "pdbx_strand" -> { b with pdbx_strand = (Some v) }
      | "pdbx_residue_num" -> { b with pdbx_residue_num = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("class",  v)) a.class_;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("treatment",  v)) a.treatment;
      Option.map (fun v -> ("value", string_of_float v)) a.value;
      Option.map (fun v -> ("pdbx_residue_name",  v)) a.pdbx_residue_name;
      Option.map (fun v -> ("pdbx_strand",  v)) a.pdbx_strand;
      Option.map (fun v -> ("pdbx_residue_num",  v)) a.pdbx_residue_num;
    ]

end

module Refine_funct_minimized = struct
  type t = {
    pdbx_refine_id: string option;
    number_terms: int option;
    residual: float option;
    type_: string option;
    weight: float option;
  }

  let default = {
    pdbx_refine_id = None;
    number_terms = None;
    residual = None;
    type_ = None;
    weight = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "number_terms" -> { b with number_terms = (PDBjDict.some_int v) }
      | "residual" -> { b with residual = (PDBjDict.some_float v) }
      | "type" -> { b with type_ = (Some v) }
      | "weight" -> { b with weight = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("number_terms", string_of_int v)) a.number_terms;
      Option.map (fun v -> ("residual", string_of_float v)) a.residual;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("weight", string_of_float v)) a.weight;
    ]

end

module Refine_hist = struct
  type t = {
    pdbx_refine_id: string option;
    cycle_id: string option;
    details: string option;
    d_res_high: float option;
    d_res_low: float option;
    number_atoms_solvent: int option;
    number_atoms_total: int option;
    number_reflns_all: int option;
    number_reflns_obs: int option;
    number_reflns_R_free: int option;
    number_reflns_R_work: int option;
    r_factor_all: float option;
    r_factor_obs: float option;
    r_factor_R_free: float option;
    r_factor_R_work: float option;
    pdbx_number_residues_total: int option;
    pdbx_B_iso_mean_ligand: float option;
    pdbx_B_iso_mean_solvent: float option;
    pdbx_number_atoms_protein: int option;
    pdbx_number_atoms_nucleic_acid: int option;
    pdbx_number_atoms_ligand: int option;
    pdbx_number_atoms_lipid: int option;
    pdbx_number_atoms_carb: int option;
    pdbx_pseudo_atom_details: string option;
    pdbx_number_atoms_solvent: int option;
    pdbx_number_atoms_total: int option;
  }

  let default = {
    pdbx_refine_id = None;
    cycle_id = None;
    details = None;
    d_res_high = None;
    d_res_low = None;
    number_atoms_solvent = None;
    number_atoms_total = None;
    number_reflns_all = None;
    number_reflns_obs = None;
    number_reflns_R_free = None;
    number_reflns_R_work = None;
    r_factor_all = None;
    r_factor_obs = None;
    r_factor_R_free = None;
    r_factor_R_work = None;
    pdbx_number_residues_total = None;
    pdbx_B_iso_mean_ligand = None;
    pdbx_B_iso_mean_solvent = None;
    pdbx_number_atoms_protein = None;
    pdbx_number_atoms_nucleic_acid = None;
    pdbx_number_atoms_ligand = None;
    pdbx_number_atoms_lipid = None;
    pdbx_number_atoms_carb = None;
    pdbx_pseudo_atom_details = None;
    pdbx_number_atoms_solvent = None;
    pdbx_number_atoms_total = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "cycle_id" -> { b with cycle_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "number_atoms_solvent" -> { b with number_atoms_solvent = (PDBjDict.some_int v) }
      | "number_atoms_total" -> { b with number_atoms_total = (PDBjDict.some_int v) }
      | "number_reflns_all" -> { b with number_reflns_all = (PDBjDict.some_int v) }
      | "number_reflns_obs" -> { b with number_reflns_obs = (PDBjDict.some_int v) }
      | "number_reflns_R_free" -> { b with number_reflns_R_free = (PDBjDict.some_int v) }
      | "number_reflns_R_work" -> { b with number_reflns_R_work = (PDBjDict.some_int v) }
      | "R_factor_all" -> { b with r_factor_all = (PDBjDict.some_float v) }
      | "R_factor_obs" -> { b with r_factor_obs = (PDBjDict.some_float v) }
      | "R_factor_R_free" -> { b with r_factor_R_free = (PDBjDict.some_float v) }
      | "R_factor_R_work" -> { b with r_factor_R_work = (PDBjDict.some_float v) }
      | "pdbx_number_residues_total" -> { b with pdbx_number_residues_total = (PDBjDict.some_int v) }
      | "pdbx_B_iso_mean_ligand" -> { b with pdbx_B_iso_mean_ligand = (PDBjDict.some_float v) }
      | "pdbx_B_iso_mean_solvent" -> { b with pdbx_B_iso_mean_solvent = (PDBjDict.some_float v) }
      | "pdbx_number_atoms_protein" -> { b with pdbx_number_atoms_protein = (PDBjDict.some_int v) }
      | "pdbx_number_atoms_nucleic_acid" -> { b with pdbx_number_atoms_nucleic_acid = (PDBjDict.some_int v) }
      | "pdbx_number_atoms_ligand" -> { b with pdbx_number_atoms_ligand = (PDBjDict.some_int v) }
      | "pdbx_number_atoms_lipid" -> { b with pdbx_number_atoms_lipid = (PDBjDict.some_int v) }
      | "pdbx_number_atoms_carb" -> { b with pdbx_number_atoms_carb = (PDBjDict.some_int v) }
      | "pdbx_pseudo_atom_details" -> { b with pdbx_pseudo_atom_details = (Some v) }
      | "pdbx_number_atoms_solvent" -> { b with pdbx_number_atoms_solvent = (PDBjDict.some_int v) }
      | "pdbx_number_atoms_total" -> { b with pdbx_number_atoms_total = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("cycle_id",  v)) a.cycle_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("number_atoms_solvent", string_of_int v)) a.number_atoms_solvent;
      Option.map (fun v -> ("number_atoms_total", string_of_int v)) a.number_atoms_total;
      Option.map (fun v -> ("number_reflns_all", string_of_int v)) a.number_reflns_all;
      Option.map (fun v -> ("number_reflns_obs", string_of_int v)) a.number_reflns_obs;
      Option.map (fun v -> ("number_reflns_R_free", string_of_int v)) a.number_reflns_R_free;
      Option.map (fun v -> ("number_reflns_R_work", string_of_int v)) a.number_reflns_R_work;
      Option.map (fun v -> ("R_factor_all", string_of_float v)) a.r_factor_all;
      Option.map (fun v -> ("R_factor_obs", string_of_float v)) a.r_factor_obs;
      Option.map (fun v -> ("R_factor_R_free", string_of_float v)) a.r_factor_R_free;
      Option.map (fun v -> ("R_factor_R_work", string_of_float v)) a.r_factor_R_work;
      Option.map (fun v -> ("pdbx_number_residues_total", string_of_int v)) a.pdbx_number_residues_total;
      Option.map (fun v -> ("pdbx_B_iso_mean_ligand", string_of_float v)) a.pdbx_B_iso_mean_ligand;
      Option.map (fun v -> ("pdbx_B_iso_mean_solvent", string_of_float v)) a.pdbx_B_iso_mean_solvent;
      Option.map (fun v -> ("pdbx_number_atoms_protein", string_of_int v)) a.pdbx_number_atoms_protein;
      Option.map (fun v -> ("pdbx_number_atoms_nucleic_acid", string_of_int v)) a.pdbx_number_atoms_nucleic_acid;
      Option.map (fun v -> ("pdbx_number_atoms_ligand", string_of_int v)) a.pdbx_number_atoms_ligand;
      Option.map (fun v -> ("pdbx_number_atoms_lipid", string_of_int v)) a.pdbx_number_atoms_lipid;
      Option.map (fun v -> ("pdbx_number_atoms_carb", string_of_int v)) a.pdbx_number_atoms_carb;
      Option.map (fun v -> ("pdbx_pseudo_atom_details",  v)) a.pdbx_pseudo_atom_details;
      Option.map (fun v -> ("pdbx_number_atoms_solvent", string_of_int v)) a.pdbx_number_atoms_solvent;
      Option.map (fun v -> ("pdbx_number_atoms_total", string_of_int v)) a.pdbx_number_atoms_total;
    ]

end

module Refine_ls_restr = struct
  type t = {
    pdbx_refine_id: string option;
    criterion: string option;
    dev_ideal: float option;
    dev_ideal_target: float option;
    number: int option;
    rejects: int option;
    type_: string option;
    weight: float option;
    pdbx_restraint_function: string option;
  }

  let default = {
    pdbx_refine_id = None;
    criterion = None;
    dev_ideal = None;
    dev_ideal_target = None;
    number = None;
    rejects = None;
    type_ = None;
    weight = None;
    pdbx_restraint_function = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "criterion" -> { b with criterion = (Some v) }
      | "dev_ideal" -> { b with dev_ideal = (PDBjDict.some_float v) }
      | "dev_ideal_target" -> { b with dev_ideal_target = (PDBjDict.some_float v) }
      | "number" -> { b with number = (PDBjDict.some_int v) }
      | "rejects" -> { b with rejects = (PDBjDict.some_int v) }
      | "type" -> { b with type_ = (Some v) }
      | "weight" -> { b with weight = (PDBjDict.some_float v) }
      | "pdbx_restraint_function" -> { b with pdbx_restraint_function = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("criterion",  v)) a.criterion;
      Option.map (fun v -> ("dev_ideal", string_of_float v)) a.dev_ideal;
      Option.map (fun v -> ("dev_ideal_target", string_of_float v)) a.dev_ideal_target;
      Option.map (fun v -> ("number", string_of_int v)) a.number;
      Option.map (fun v -> ("rejects", string_of_int v)) a.rejects;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("weight", string_of_float v)) a.weight;
      Option.map (fun v -> ("pdbx_restraint_function",  v)) a.pdbx_restraint_function;
    ]

end

module Refine_ls_restr_ncs = struct
  type t = {
    pdbx_refine_id: string option;
    dom_id: string option;
    ncs_model_details: string option;
    rms_dev_B_iso: float option;
    rms_dev_position: float option;
    weight_B_iso: float option;
    weight_position: float option;
    pdbx_ordinal: int option;
    pdbx_type: string option;
    pdbx_asym_id: string option;
    pdbx_auth_asym_id: string option;
    pdbx_number: int option;
    pdbx_rms: float option;
    pdbx_weight: float option;
    pdbx_ens_id: string option;
  }

  let default = {
    pdbx_refine_id = None;
    dom_id = None;
    ncs_model_details = None;
    rms_dev_B_iso = None;
    rms_dev_position = None;
    weight_B_iso = None;
    weight_position = None;
    pdbx_ordinal = None;
    pdbx_type = None;
    pdbx_asym_id = None;
    pdbx_auth_asym_id = None;
    pdbx_number = None;
    pdbx_rms = None;
    pdbx_weight = None;
    pdbx_ens_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "dom_id" -> { b with dom_id = (Some v) }
      | "ncs_model_details" -> { b with ncs_model_details = (Some v) }
      | "rms_dev_B_iso" -> { b with rms_dev_B_iso = (PDBjDict.some_float v) }
      | "rms_dev_position" -> { b with rms_dev_position = (PDBjDict.some_float v) }
      | "weight_B_iso" -> { b with weight_B_iso = (PDBjDict.some_float v) }
      | "weight_position" -> { b with weight_position = (PDBjDict.some_float v) }
      | "pdbx_ordinal" -> { b with pdbx_ordinal = (PDBjDict.some_int v) }
      | "pdbx_type" -> { b with pdbx_type = (Some v) }
      | "pdbx_asym_id" -> { b with pdbx_asym_id = (Some v) }
      | "pdbx_auth_asym_id" -> { b with pdbx_auth_asym_id = (Some v) }
      | "pdbx_number" -> { b with pdbx_number = (PDBjDict.some_int v) }
      | "pdbx_rms" -> { b with pdbx_rms = (PDBjDict.some_float v) }
      | "pdbx_weight" -> { b with pdbx_weight = (PDBjDict.some_float v) }
      | "pdbx_ens_id" -> { b with pdbx_ens_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("dom_id",  v)) a.dom_id;
      Option.map (fun v -> ("ncs_model_details",  v)) a.ncs_model_details;
      Option.map (fun v -> ("rms_dev_B_iso", string_of_float v)) a.rms_dev_B_iso;
      Option.map (fun v -> ("rms_dev_position", string_of_float v)) a.rms_dev_position;
      Option.map (fun v -> ("weight_B_iso", string_of_float v)) a.weight_B_iso;
      Option.map (fun v -> ("weight_position", string_of_float v)) a.weight_position;
      Option.map (fun v -> ("pdbx_ordinal", string_of_int v)) a.pdbx_ordinal;
      Option.map (fun v -> ("pdbx_type",  v)) a.pdbx_type;
      Option.map (fun v -> ("pdbx_asym_id",  v)) a.pdbx_asym_id;
      Option.map (fun v -> ("pdbx_auth_asym_id",  v)) a.pdbx_auth_asym_id;
      Option.map (fun v -> ("pdbx_number", string_of_int v)) a.pdbx_number;
      Option.map (fun v -> ("pdbx_rms", string_of_float v)) a.pdbx_rms;
      Option.map (fun v -> ("pdbx_weight", string_of_float v)) a.pdbx_weight;
      Option.map (fun v -> ("pdbx_ens_id",  v)) a.pdbx_ens_id;
    ]

end

module Refine_ls_restr_type = struct
  type t = {
    distance_cutoff_high: float option;
    distance_cutoff_low: float option;
    type_: string option;
  }

  let default = {
    distance_cutoff_high = None;
    distance_cutoff_low = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "distance_cutoff_high" -> { b with distance_cutoff_high = (PDBjDict.some_float v) }
      | "distance_cutoff_low" -> { b with distance_cutoff_low = (PDBjDict.some_float v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("distance_cutoff_high", string_of_float v)) a.distance_cutoff_high;
      Option.map (fun v -> ("distance_cutoff_low", string_of_float v)) a.distance_cutoff_low;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Refine_ls_shell = struct
  type t = {
    pdbx_refine_id: string option;
    d_res_high: float option;
    d_res_low: float option;
    number_reflns_all: int option;
    number_reflns_obs: int option;
    number_reflns_R_free: int option;
    number_reflns_R_work: int option;
    percent_reflns_obs: float option;
    percent_reflns_R_free: float option;
    r_factor_all: float option;
    r_factor_obs: float option;
    r_factor_R_free: float option;
    r_factor_R_free_error: float option;
    r_factor_R_work: float option;
    redundancy_reflns_all: float option;
    redundancy_reflns_obs: float option;
    wR_factor_all: float option;
    wR_factor_obs: float option;
    wR_factor_R_free: float option;
    wR_factor_R_work: float option;
    pdbx_total_number_of_bins_used: int option;
    pdbx_phase_error: float option;
    pdbx_fsc_work: float option;
    pdbx_fsc_free: float option;
  }

  let default = {
    pdbx_refine_id = None;
    d_res_high = None;
    d_res_low = None;
    number_reflns_all = None;
    number_reflns_obs = None;
    number_reflns_R_free = None;
    number_reflns_R_work = None;
    percent_reflns_obs = None;
    percent_reflns_R_free = None;
    r_factor_all = None;
    r_factor_obs = None;
    r_factor_R_free = None;
    r_factor_R_free_error = None;
    r_factor_R_work = None;
    redundancy_reflns_all = None;
    redundancy_reflns_obs = None;
    wR_factor_all = None;
    wR_factor_obs = None;
    wR_factor_R_free = None;
    wR_factor_R_work = None;
    pdbx_total_number_of_bins_used = None;
    pdbx_phase_error = None;
    pdbx_fsc_work = None;
    pdbx_fsc_free = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "number_reflns_all" -> { b with number_reflns_all = (PDBjDict.some_int v) }
      | "number_reflns_obs" -> { b with number_reflns_obs = (PDBjDict.some_int v) }
      | "number_reflns_R_free" -> { b with number_reflns_R_free = (PDBjDict.some_int v) }
      | "number_reflns_R_work" -> { b with number_reflns_R_work = (PDBjDict.some_int v) }
      | "percent_reflns_obs" -> { b with percent_reflns_obs = (PDBjDict.some_float v) }
      | "percent_reflns_R_free" -> { b with percent_reflns_R_free = (PDBjDict.some_float v) }
      | "R_factor_all" -> { b with r_factor_all = (PDBjDict.some_float v) }
      | "R_factor_obs" -> { b with r_factor_obs = (PDBjDict.some_float v) }
      | "R_factor_R_free" -> { b with r_factor_R_free = (PDBjDict.some_float v) }
      | "R_factor_R_free_error" -> { b with r_factor_R_free_error = (PDBjDict.some_float v) }
      | "R_factor_R_work" -> { b with r_factor_R_work = (PDBjDict.some_float v) }
      | "redundancy_reflns_all" -> { b with redundancy_reflns_all = (PDBjDict.some_float v) }
      | "redundancy_reflns_obs" -> { b with redundancy_reflns_obs = (PDBjDict.some_float v) }
      | "wR_factor_all" -> { b with wR_factor_all = (PDBjDict.some_float v) }
      | "wR_factor_obs" -> { b with wR_factor_obs = (PDBjDict.some_float v) }
      | "wR_factor_R_free" -> { b with wR_factor_R_free = (PDBjDict.some_float v) }
      | "wR_factor_R_work" -> { b with wR_factor_R_work = (PDBjDict.some_float v) }
      | "pdbx_total_number_of_bins_used" -> { b with pdbx_total_number_of_bins_used = (PDBjDict.some_int v) }
      | "pdbx_phase_error" -> { b with pdbx_phase_error = (PDBjDict.some_float v) }
      | "pdbx_fsc_work" -> { b with pdbx_fsc_work = (PDBjDict.some_float v) }
      | "pdbx_fsc_free" -> { b with pdbx_fsc_free = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("number_reflns_all", string_of_int v)) a.number_reflns_all;
      Option.map (fun v -> ("number_reflns_obs", string_of_int v)) a.number_reflns_obs;
      Option.map (fun v -> ("number_reflns_R_free", string_of_int v)) a.number_reflns_R_free;
      Option.map (fun v -> ("number_reflns_R_work", string_of_int v)) a.number_reflns_R_work;
      Option.map (fun v -> ("percent_reflns_obs", string_of_float v)) a.percent_reflns_obs;
      Option.map (fun v -> ("percent_reflns_R_free", string_of_float v)) a.percent_reflns_R_free;
      Option.map (fun v -> ("R_factor_all", string_of_float v)) a.r_factor_all;
      Option.map (fun v -> ("R_factor_obs", string_of_float v)) a.r_factor_obs;
      Option.map (fun v -> ("R_factor_R_free", string_of_float v)) a.r_factor_R_free;
      Option.map (fun v -> ("R_factor_R_free_error", string_of_float v)) a.r_factor_R_free_error;
      Option.map (fun v -> ("R_factor_R_work", string_of_float v)) a.r_factor_R_work;
      Option.map (fun v -> ("redundancy_reflns_all", string_of_float v)) a.redundancy_reflns_all;
      Option.map (fun v -> ("redundancy_reflns_obs", string_of_float v)) a.redundancy_reflns_obs;
      Option.map (fun v -> ("wR_factor_all", string_of_float v)) a.wR_factor_all;
      Option.map (fun v -> ("wR_factor_obs", string_of_float v)) a.wR_factor_obs;
      Option.map (fun v -> ("wR_factor_R_free", string_of_float v)) a.wR_factor_R_free;
      Option.map (fun v -> ("wR_factor_R_work", string_of_float v)) a.wR_factor_R_work;
      Option.map (fun v -> ("pdbx_total_number_of_bins_used", string_of_int v)) a.pdbx_total_number_of_bins_used;
      Option.map (fun v -> ("pdbx_phase_error", string_of_float v)) a.pdbx_phase_error;
      Option.map (fun v -> ("pdbx_fsc_work", string_of_float v)) a.pdbx_fsc_work;
      Option.map (fun v -> ("pdbx_fsc_free", string_of_float v)) a.pdbx_fsc_free;
    ]

end

module Refine_occupancy = struct
  type t = {
    pdbx_refine_id: string option;
    class_: string option;
    details: string option;
    treatment: string option;
    value: float option;
  }

  let default = {
    pdbx_refine_id = None;
    class_ = None;
    details = None;
    treatment = None;
    value = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "class" -> { b with class_ = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "treatment" -> { b with treatment = (Some v) }
      | "value" -> { b with value = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("class",  v)) a.class_;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("treatment",  v)) a.treatment;
      Option.map (fun v -> ("value", string_of_float v)) a.value;
    ]

end

module Refln = struct
  type t = {
    a_calc: float option;
    a_calc_au: float option;
    a_meas: float option;
    a_meas_au: float option;
    b_calc: float option;
    b_calc_au: float option;
    b_meas: float option;
    b_meas_au: float option;
    crystal_id: string option;
    f_calc: float option;
    f_calc_au: float option;
    f_meas: float option;
    f_meas_au: float option;
    f_meas_sigma: float option;
    f_meas_sigma_au: float option;
    f_squared_calc: float option;
    f_squared_meas: float option;
    f_squared_sigma: float option;
    fom: float option;
    index_h: int option;
    index_k: int option;
    index_l: int option;
    intensity_calc: float option;
    intensity_meas: float option;
    intensity_sigma: float option;
    status: string option;
    phase_calc: float option;
    phase_meas: float option;
    refinement_status: string option;
    scale_group_code: string option;
    sint_over_lambda: float option;
    symmetry_epsilon: int option;
    symmetry_multiplicity: int option;
    wavelength: float option;
    wavelength_id: string option;
    class_code: string option;
    d_spacing: float option;
    include_status: string option;
    mean_path_length_tbar: float option;
    pdbx_F_calc_part_solvent: float option;
    pdbx_phase_calc_part_solvent: float option;
    pdbx_F_calc_with_solvent: float option;
    pdbx_phase_calc_with_solvent: float option;
    pdbx_anom_difference: float option;
    pdbx_anom_difference_sigma: float option;
    pdbx_I_plus: float option;
    pdbx_I_minus: float option;
    pdbx_F_plus: float option;
    pdbx_F_minus: float option;
    pdbx_I_plus_sigma: float option;
    pdbx_I_minus_sigma: float option;
    pdbx_F_minus_sigma: float option;
    pdbx_F_plus_sigma: float option;
    pdbx_HL_A_iso: float option;
    pdbx_HL_B_iso: float option;
    pdbx_HL_C_iso: float option;
    pdbx_HL_D_iso: float option;
    pdbx_fiber_layer: int option;
    pdbx_fiber_coordinate: float option;
    pdbx_fiber_F_meas_au: float option;
    pdbx_FWT: float option;
    pdbx_PHWT: float option;
    pdbx_DELFWT: float option;
    pdbx_DELPHWT: float option;
    pdbx_diffrn_id: string option;
    pdbx_r_free_flag: int option;
    pdbx_anomalous_diff: float option;
    pdbx_anomalous_diff_sigma: float option;
    pdbx_phase_cycle: float option;
    pdbx_cos_phase_calc: float option;
    pdbx_sin_phase_calc: float option;
  }

  let default = {
    a_calc = None;
    a_calc_au = None;
    a_meas = None;
    a_meas_au = None;
    b_calc = None;
    b_calc_au = None;
    b_meas = None;
    b_meas_au = None;
    crystal_id = None;
    f_calc = None;
    f_calc_au = None;
    f_meas = None;
    f_meas_au = None;
    f_meas_sigma = None;
    f_meas_sigma_au = None;
    f_squared_calc = None;
    f_squared_meas = None;
    f_squared_sigma = None;
    fom = None;
    index_h = None;
    index_k = None;
    index_l = None;
    intensity_calc = None;
    intensity_meas = None;
    intensity_sigma = None;
    status = None;
    phase_calc = None;
    phase_meas = None;
    refinement_status = None;
    scale_group_code = None;
    sint_over_lambda = None;
    symmetry_epsilon = None;
    symmetry_multiplicity = None;
    wavelength = None;
    wavelength_id = None;
    class_code = None;
    d_spacing = None;
    include_status = None;
    mean_path_length_tbar = None;
    pdbx_F_calc_part_solvent = None;
    pdbx_phase_calc_part_solvent = None;
    pdbx_F_calc_with_solvent = None;
    pdbx_phase_calc_with_solvent = None;
    pdbx_anom_difference = None;
    pdbx_anom_difference_sigma = None;
    pdbx_I_plus = None;
    pdbx_I_minus = None;
    pdbx_F_plus = None;
    pdbx_F_minus = None;
    pdbx_I_plus_sigma = None;
    pdbx_I_minus_sigma = None;
    pdbx_F_minus_sigma = None;
    pdbx_F_plus_sigma = None;
    pdbx_HL_A_iso = None;
    pdbx_HL_B_iso = None;
    pdbx_HL_C_iso = None;
    pdbx_HL_D_iso = None;
    pdbx_fiber_layer = None;
    pdbx_fiber_coordinate = None;
    pdbx_fiber_F_meas_au = None;
    pdbx_FWT = None;
    pdbx_PHWT = None;
    pdbx_DELFWT = None;
    pdbx_DELPHWT = None;
    pdbx_diffrn_id = None;
    pdbx_r_free_flag = None;
    pdbx_anomalous_diff = None;
    pdbx_anomalous_diff_sigma = None;
    pdbx_phase_cycle = None;
    pdbx_cos_phase_calc = None;
    pdbx_sin_phase_calc = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "A_calc" -> { b with a_calc = (PDBjDict.some_float v) }
      | "A_calc_au" -> { b with a_calc_au = (PDBjDict.some_float v) }
      | "A_meas" -> { b with a_meas = (PDBjDict.some_float v) }
      | "A_meas_au" -> { b with a_meas_au = (PDBjDict.some_float v) }
      | "B_calc" -> { b with b_calc = (PDBjDict.some_float v) }
      | "B_calc_au" -> { b with b_calc_au = (PDBjDict.some_float v) }
      | "B_meas" -> { b with b_meas = (PDBjDict.some_float v) }
      | "B_meas_au" -> { b with b_meas_au = (PDBjDict.some_float v) }
      | "crystal_id" -> { b with crystal_id = (Some v) }
      | "F_calc" -> { b with f_calc = (PDBjDict.some_float v) }
      | "F_calc_au" -> { b with f_calc_au = (PDBjDict.some_float v) }
      | "F_meas" -> { b with f_meas = (PDBjDict.some_float v) }
      | "F_meas_au" -> { b with f_meas_au = (PDBjDict.some_float v) }
      | "F_meas_sigma" -> { b with f_meas_sigma = (PDBjDict.some_float v) }
      | "F_meas_sigma_au" -> { b with f_meas_sigma_au = (PDBjDict.some_float v) }
      | "F_squared_calc" -> { b with f_squared_calc = (PDBjDict.some_float v) }
      | "F_squared_meas" -> { b with f_squared_meas = (PDBjDict.some_float v) }
      | "F_squared_sigma" -> { b with f_squared_sigma = (PDBjDict.some_float v) }
      | "fom" -> { b with fom = (PDBjDict.some_float v) }
      | "index_h" -> { b with index_h = (PDBjDict.some_int v) }
      | "index_k" -> { b with index_k = (PDBjDict.some_int v) }
      | "index_l" -> { b with index_l = (PDBjDict.some_int v) }
      | "intensity_calc" -> { b with intensity_calc = (PDBjDict.some_float v) }
      | "intensity_meas" -> { b with intensity_meas = (PDBjDict.some_float v) }
      | "intensity_sigma" -> { b with intensity_sigma = (PDBjDict.some_float v) }
      | "status" -> { b with status = (Some v) }
      | "phase_calc" -> { b with phase_calc = (PDBjDict.some_float v) }
      | "phase_meas" -> { b with phase_meas = (PDBjDict.some_float v) }
      | "refinement_status" -> { b with refinement_status = (Some v) }
      | "scale_group_code" -> { b with scale_group_code = (Some v) }
      | "sint_over_lambda" -> { b with sint_over_lambda = (PDBjDict.some_float v) }
      | "symmetry_epsilon" -> { b with symmetry_epsilon = (PDBjDict.some_int v) }
      | "symmetry_multiplicity" -> { b with symmetry_multiplicity = (PDBjDict.some_int v) }
      | "wavelength" -> { b with wavelength = (PDBjDict.some_float v) }
      | "wavelength_id" -> { b with wavelength_id = (Some v) }
      | "class_code" -> { b with class_code = (Some v) }
      | "d_spacing" -> { b with d_spacing = (PDBjDict.some_float v) }
      | "include_status" -> { b with include_status = (Some v) }
      | "mean_path_length_tbar" -> { b with mean_path_length_tbar = (PDBjDict.some_float v) }
      | "pdbx_F_calc_part_solvent" -> { b with pdbx_F_calc_part_solvent = (PDBjDict.some_float v) }
      | "pdbx_phase_calc_part_solvent" -> { b with pdbx_phase_calc_part_solvent = (PDBjDict.some_float v) }
      | "pdbx_F_calc_with_solvent" -> { b with pdbx_F_calc_with_solvent = (PDBjDict.some_float v) }
      | "pdbx_phase_calc_with_solvent" -> { b with pdbx_phase_calc_with_solvent = (PDBjDict.some_float v) }
      | "pdbx_anom_difference" -> { b with pdbx_anom_difference = (PDBjDict.some_float v) }
      | "pdbx_anom_difference_sigma" -> { b with pdbx_anom_difference_sigma = (PDBjDict.some_float v) }
      | "pdbx_I_plus" -> { b with pdbx_I_plus = (PDBjDict.some_float v) }
      | "pdbx_I_minus" -> { b with pdbx_I_minus = (PDBjDict.some_float v) }
      | "pdbx_F_plus" -> { b with pdbx_F_plus = (PDBjDict.some_float v) }
      | "pdbx_F_minus" -> { b with pdbx_F_minus = (PDBjDict.some_float v) }
      | "pdbx_I_plus_sigma" -> { b with pdbx_I_plus_sigma = (PDBjDict.some_float v) }
      | "pdbx_I_minus_sigma" -> { b with pdbx_I_minus_sigma = (PDBjDict.some_float v) }
      | "pdbx_F_minus_sigma" -> { b with pdbx_F_minus_sigma = (PDBjDict.some_float v) }
      | "pdbx_F_plus_sigma" -> { b with pdbx_F_plus_sigma = (PDBjDict.some_float v) }
      | "pdbx_HL_A_iso" -> { b with pdbx_HL_A_iso = (PDBjDict.some_float v) }
      | "pdbx_HL_B_iso" -> { b with pdbx_HL_B_iso = (PDBjDict.some_float v) }
      | "pdbx_HL_C_iso" -> { b with pdbx_HL_C_iso = (PDBjDict.some_float v) }
      | "pdbx_HL_D_iso" -> { b with pdbx_HL_D_iso = (PDBjDict.some_float v) }
      | "pdbx_fiber_layer" -> { b with pdbx_fiber_layer = (PDBjDict.some_int v) }
      | "pdbx_fiber_coordinate" -> { b with pdbx_fiber_coordinate = (PDBjDict.some_float v) }
      | "pdbx_fiber_F_meas_au" -> { b with pdbx_fiber_F_meas_au = (PDBjDict.some_float v) }
      | "pdbx_FWT" -> { b with pdbx_FWT = (PDBjDict.some_float v) }
      | "pdbx_PHWT" -> { b with pdbx_PHWT = (PDBjDict.some_float v) }
      | "pdbx_DELFWT" -> { b with pdbx_DELFWT = (PDBjDict.some_float v) }
      | "pdbx_DELPHWT" -> { b with pdbx_DELPHWT = (PDBjDict.some_float v) }
      | "pdbx_diffrn_id" -> { b with pdbx_diffrn_id = (Some v) }
      | "pdbx_r_free_flag" -> { b with pdbx_r_free_flag = (PDBjDict.some_int v) }
      | "pdbx_anomalous_diff" -> { b with pdbx_anomalous_diff = (PDBjDict.some_float v) }
      | "pdbx_anomalous_diff_sigma" -> { b with pdbx_anomalous_diff_sigma = (PDBjDict.some_float v) }
      | "pdbx_phase_cycle" -> { b with pdbx_phase_cycle = (PDBjDict.some_float v) }
      | "pdbx_cos_phase_calc" -> { b with pdbx_cos_phase_calc = (PDBjDict.some_float v) }
      | "pdbx_sin_phase_calc" -> { b with pdbx_sin_phase_calc = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("A_calc", string_of_float v)) a.a_calc;
      Option.map (fun v -> ("A_calc_au", string_of_float v)) a.a_calc_au;
      Option.map (fun v -> ("A_meas", string_of_float v)) a.a_meas;
      Option.map (fun v -> ("A_meas_au", string_of_float v)) a.a_meas_au;
      Option.map (fun v -> ("B_calc", string_of_float v)) a.b_calc;
      Option.map (fun v -> ("B_calc_au", string_of_float v)) a.b_calc_au;
      Option.map (fun v -> ("B_meas", string_of_float v)) a.b_meas;
      Option.map (fun v -> ("B_meas_au", string_of_float v)) a.b_meas_au;
      Option.map (fun v -> ("crystal_id",  v)) a.crystal_id;
      Option.map (fun v -> ("F_calc", string_of_float v)) a.f_calc;
      Option.map (fun v -> ("F_calc_au", string_of_float v)) a.f_calc_au;
      Option.map (fun v -> ("F_meas", string_of_float v)) a.f_meas;
      Option.map (fun v -> ("F_meas_au", string_of_float v)) a.f_meas_au;
      Option.map (fun v -> ("F_meas_sigma", string_of_float v)) a.f_meas_sigma;
      Option.map (fun v -> ("F_meas_sigma_au", string_of_float v)) a.f_meas_sigma_au;
      Option.map (fun v -> ("F_squared_calc", string_of_float v)) a.f_squared_calc;
      Option.map (fun v -> ("F_squared_meas", string_of_float v)) a.f_squared_meas;
      Option.map (fun v -> ("F_squared_sigma", string_of_float v)) a.f_squared_sigma;
      Option.map (fun v -> ("fom", string_of_float v)) a.fom;
      Option.map (fun v -> ("index_h", string_of_int v)) a.index_h;
      Option.map (fun v -> ("index_k", string_of_int v)) a.index_k;
      Option.map (fun v -> ("index_l", string_of_int v)) a.index_l;
      Option.map (fun v -> ("intensity_calc", string_of_float v)) a.intensity_calc;
      Option.map (fun v -> ("intensity_meas", string_of_float v)) a.intensity_meas;
      Option.map (fun v -> ("intensity_sigma", string_of_float v)) a.intensity_sigma;
      Option.map (fun v -> ("status",  v)) a.status;
      Option.map (fun v -> ("phase_calc", string_of_float v)) a.phase_calc;
      Option.map (fun v -> ("phase_meas", string_of_float v)) a.phase_meas;
      Option.map (fun v -> ("refinement_status",  v)) a.refinement_status;
      Option.map (fun v -> ("scale_group_code",  v)) a.scale_group_code;
      Option.map (fun v -> ("sint_over_lambda", string_of_float v)) a.sint_over_lambda;
      Option.map (fun v -> ("symmetry_epsilon", string_of_int v)) a.symmetry_epsilon;
      Option.map (fun v -> ("symmetry_multiplicity", string_of_int v)) a.symmetry_multiplicity;
      Option.map (fun v -> ("wavelength", string_of_float v)) a.wavelength;
      Option.map (fun v -> ("wavelength_id",  v)) a.wavelength_id;
      Option.map (fun v -> ("class_code",  v)) a.class_code;
      Option.map (fun v -> ("d_spacing", string_of_float v)) a.d_spacing;
      Option.map (fun v -> ("include_status",  v)) a.include_status;
      Option.map (fun v -> ("mean_path_length_tbar", string_of_float v)) a.mean_path_length_tbar;
      Option.map (fun v -> ("pdbx_F_calc_part_solvent", string_of_float v)) a.pdbx_F_calc_part_solvent;
      Option.map (fun v -> ("pdbx_phase_calc_part_solvent", string_of_float v)) a.pdbx_phase_calc_part_solvent;
      Option.map (fun v -> ("pdbx_F_calc_with_solvent", string_of_float v)) a.pdbx_F_calc_with_solvent;
      Option.map (fun v -> ("pdbx_phase_calc_with_solvent", string_of_float v)) a.pdbx_phase_calc_with_solvent;
      Option.map (fun v -> ("pdbx_anom_difference", string_of_float v)) a.pdbx_anom_difference;
      Option.map (fun v -> ("pdbx_anom_difference_sigma", string_of_float v)) a.pdbx_anom_difference_sigma;
      Option.map (fun v -> ("pdbx_I_plus", string_of_float v)) a.pdbx_I_plus;
      Option.map (fun v -> ("pdbx_I_minus", string_of_float v)) a.pdbx_I_minus;
      Option.map (fun v -> ("pdbx_F_plus", string_of_float v)) a.pdbx_F_plus;
      Option.map (fun v -> ("pdbx_F_minus", string_of_float v)) a.pdbx_F_minus;
      Option.map (fun v -> ("pdbx_I_plus_sigma", string_of_float v)) a.pdbx_I_plus_sigma;
      Option.map (fun v -> ("pdbx_I_minus_sigma", string_of_float v)) a.pdbx_I_minus_sigma;
      Option.map (fun v -> ("pdbx_F_minus_sigma", string_of_float v)) a.pdbx_F_minus_sigma;
      Option.map (fun v -> ("pdbx_F_plus_sigma", string_of_float v)) a.pdbx_F_plus_sigma;
      Option.map (fun v -> ("pdbx_HL_A_iso", string_of_float v)) a.pdbx_HL_A_iso;
      Option.map (fun v -> ("pdbx_HL_B_iso", string_of_float v)) a.pdbx_HL_B_iso;
      Option.map (fun v -> ("pdbx_HL_C_iso", string_of_float v)) a.pdbx_HL_C_iso;
      Option.map (fun v -> ("pdbx_HL_D_iso", string_of_float v)) a.pdbx_HL_D_iso;
      Option.map (fun v -> ("pdbx_fiber_layer", string_of_int v)) a.pdbx_fiber_layer;
      Option.map (fun v -> ("pdbx_fiber_coordinate", string_of_float v)) a.pdbx_fiber_coordinate;
      Option.map (fun v -> ("pdbx_fiber_F_meas_au", string_of_float v)) a.pdbx_fiber_F_meas_au;
      Option.map (fun v -> ("pdbx_FWT", string_of_float v)) a.pdbx_FWT;
      Option.map (fun v -> ("pdbx_PHWT", string_of_float v)) a.pdbx_PHWT;
      Option.map (fun v -> ("pdbx_DELFWT", string_of_float v)) a.pdbx_DELFWT;
      Option.map (fun v -> ("pdbx_DELPHWT", string_of_float v)) a.pdbx_DELPHWT;
      Option.map (fun v -> ("pdbx_diffrn_id",  v)) a.pdbx_diffrn_id;
      Option.map (fun v -> ("pdbx_r_free_flag", string_of_int v)) a.pdbx_r_free_flag;
      Option.map (fun v -> ("pdbx_anomalous_diff", string_of_float v)) a.pdbx_anomalous_diff;
      Option.map (fun v -> ("pdbx_anomalous_diff_sigma", string_of_float v)) a.pdbx_anomalous_diff_sigma;
      Option.map (fun v -> ("pdbx_phase_cycle", string_of_float v)) a.pdbx_phase_cycle;
      Option.map (fun v -> ("pdbx_cos_phase_calc", string_of_float v)) a.pdbx_cos_phase_calc;
      Option.map (fun v -> ("pdbx_sin_phase_calc", string_of_float v)) a.pdbx_sin_phase_calc;
    ]

end

module Refln_sys_abs = struct
  type t = {
    i: float option;
    i_over_sigmaI: float option;
    index_h: int option;
    index_k: int option;
    index_l: int option;
    sigmaI: float option;
  }

  let default = {
    i = None;
    i_over_sigmaI = None;
    index_h = None;
    index_k = None;
    index_l = None;
    sigmaI = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "I" -> { b with i = (PDBjDict.some_float v) }
      | "I_over_sigmaI" -> { b with i_over_sigmaI = (PDBjDict.some_float v) }
      | "index_h" -> { b with index_h = (PDBjDict.some_int v) }
      | "index_k" -> { b with index_k = (PDBjDict.some_int v) }
      | "index_l" -> { b with index_l = (PDBjDict.some_int v) }
      | "sigmaI" -> { b with sigmaI = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("I", string_of_float v)) a.i;
      Option.map (fun v -> ("I_over_sigmaI", string_of_float v)) a.i_over_sigmaI;
      Option.map (fun v -> ("index_h", string_of_int v)) a.index_h;
      Option.map (fun v -> ("index_k", string_of_int v)) a.index_k;
      Option.map (fun v -> ("index_l", string_of_int v)) a.index_l;
      Option.map (fun v -> ("sigmaI", string_of_float v)) a.sigmaI;
    ]

end

module Reflns = struct
  type t = {
    b_iso_Wilson_estimate: float option;
    entry_id: string option;
    data_reduction_details: string option;
    data_reduction_method: string option;
    d_resolution_high: float option;
    d_resolution_low: float option;
    details: string option;
    limit_h_max: int option;
    limit_h_min: int option;
    limit_k_max: int option;
    limit_k_min: int option;
    limit_l_max: int option;
    limit_l_min: int option;
    number_all: int option;
    number_obs: int option;
    observed_criterion: string option;
    observed_criterion_F_max: float option;
    observed_criterion_F_min: float option;
    observed_criterion_I_max: float option;
    observed_criterion_I_min: float option;
    observed_criterion_sigma_F: float option;
    observed_criterion_sigma_I: float option;
    percent_possible_obs: float option;
    r_free_details: string option;
    rmerge_F_all: float option;
    rmerge_F_obs: float option;
    friedel_coverage: float option;
    number_gt: int option;
    threshold_expression: string option;
    pdbx_redundancy: float option;
    pdbx_Rmerge_I_obs: float option;
    pdbx_Rmerge_I_all: float option;
    pdbx_Rsym_value: float option;
    pdbx_netI_over_av_sigmaI: float option;
    pdbx_netI_over_sigmaI: float option;
    pdbx_res_netI_over_av_sigmaI_2: float option;
    pdbx_res_netI_over_sigmaI_2: float option;
    pdbx_chi_squared: float option;
    pdbx_scaling_rejects: int option;
    pdbx_d_res_high_opt: float option;
    pdbx_d_res_low_opt: float option;
    pdbx_d_res_opt_method: string option;
    phase_calculation_details: string option;
    pdbx_Rrim_I_all: float option;
    pdbx_Rpim_I_all: float option;
    pdbx_d_opt: float option;
    pdbx_number_measured_all: int option;
    pdbx_diffrn_id: string option;
    pdbx_ordinal: int option;
    pdbx_CC_half: float option;
    pdbx_R_split: float option;
    pdbx_redundancy_reflns_obs: float option;
    pdbx_number_anomalous: int option;
    pdbx_Rrim_I_all_anomalous: float option;
    pdbx_Rpim_I_all_anomalous: float option;
    pdbx_Rmerge_I_anomalous: float option;
  }

  let default = {
    b_iso_Wilson_estimate = None;
    entry_id = None;
    data_reduction_details = None;
    data_reduction_method = None;
    d_resolution_high = None;
    d_resolution_low = None;
    details = None;
    limit_h_max = None;
    limit_h_min = None;
    limit_k_max = None;
    limit_k_min = None;
    limit_l_max = None;
    limit_l_min = None;
    number_all = None;
    number_obs = None;
    observed_criterion = None;
    observed_criterion_F_max = None;
    observed_criterion_F_min = None;
    observed_criterion_I_max = None;
    observed_criterion_I_min = None;
    observed_criterion_sigma_F = None;
    observed_criterion_sigma_I = None;
    percent_possible_obs = None;
    r_free_details = None;
    rmerge_F_all = None;
    rmerge_F_obs = None;
    friedel_coverage = None;
    number_gt = None;
    threshold_expression = None;
    pdbx_redundancy = None;
    pdbx_Rmerge_I_obs = None;
    pdbx_Rmerge_I_all = None;
    pdbx_Rsym_value = None;
    pdbx_netI_over_av_sigmaI = None;
    pdbx_netI_over_sigmaI = None;
    pdbx_res_netI_over_av_sigmaI_2 = None;
    pdbx_res_netI_over_sigmaI_2 = None;
    pdbx_chi_squared = None;
    pdbx_scaling_rejects = None;
    pdbx_d_res_high_opt = None;
    pdbx_d_res_low_opt = None;
    pdbx_d_res_opt_method = None;
    phase_calculation_details = None;
    pdbx_Rrim_I_all = None;
    pdbx_Rpim_I_all = None;
    pdbx_d_opt = None;
    pdbx_number_measured_all = None;
    pdbx_diffrn_id = None;
    pdbx_ordinal = None;
    pdbx_CC_half = None;
    pdbx_R_split = None;
    pdbx_redundancy_reflns_obs = None;
    pdbx_number_anomalous = None;
    pdbx_Rrim_I_all_anomalous = None;
    pdbx_Rpim_I_all_anomalous = None;
    pdbx_Rmerge_I_anomalous = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "B_iso_Wilson_estimate" -> { b with b_iso_Wilson_estimate = (PDBjDict.some_float v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "data_reduction_details" -> { b with data_reduction_details = (Some v) }
      | "data_reduction_method" -> { b with data_reduction_method = (Some v) }
      | "d_resolution_high" -> { b with d_resolution_high = (PDBjDict.some_float v) }
      | "d_resolution_low" -> { b with d_resolution_low = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | "limit_h_max" -> { b with limit_h_max = (PDBjDict.some_int v) }
      | "limit_h_min" -> { b with limit_h_min = (PDBjDict.some_int v) }
      | "limit_k_max" -> { b with limit_k_max = (PDBjDict.some_int v) }
      | "limit_k_min" -> { b with limit_k_min = (PDBjDict.some_int v) }
      | "limit_l_max" -> { b with limit_l_max = (PDBjDict.some_int v) }
      | "limit_l_min" -> { b with limit_l_min = (PDBjDict.some_int v) }
      | "number_all" -> { b with number_all = (PDBjDict.some_int v) }
      | "number_obs" -> { b with number_obs = (PDBjDict.some_int v) }
      | "observed_criterion" -> { b with observed_criterion = (Some v) }
      | "observed_criterion_F_max" -> { b with observed_criterion_F_max = (PDBjDict.some_float v) }
      | "observed_criterion_F_min" -> { b with observed_criterion_F_min = (PDBjDict.some_float v) }
      | "observed_criterion_I_max" -> { b with observed_criterion_I_max = (PDBjDict.some_float v) }
      | "observed_criterion_I_min" -> { b with observed_criterion_I_min = (PDBjDict.some_float v) }
      | "observed_criterion_sigma_F" -> { b with observed_criterion_sigma_F = (PDBjDict.some_float v) }
      | "observed_criterion_sigma_I" -> { b with observed_criterion_sigma_I = (PDBjDict.some_float v) }
      | "percent_possible_obs" -> { b with percent_possible_obs = (PDBjDict.some_float v) }
      | "R_free_details" -> { b with r_free_details = (Some v) }
      | "Rmerge_F_all" -> { b with rmerge_F_all = (PDBjDict.some_float v) }
      | "Rmerge_F_obs" -> { b with rmerge_F_obs = (PDBjDict.some_float v) }
      | "Friedel_coverage" -> { b with friedel_coverage = (PDBjDict.some_float v) }
      | "number_gt" -> { b with number_gt = (PDBjDict.some_int v) }
      | "threshold_expression" -> { b with threshold_expression = (Some v) }
      | "pdbx_redundancy" -> { b with pdbx_redundancy = (PDBjDict.some_float v) }
      | "pdbx_Rmerge_I_obs" -> { b with pdbx_Rmerge_I_obs = (PDBjDict.some_float v) }
      | "pdbx_Rmerge_I_all" -> { b with pdbx_Rmerge_I_all = (PDBjDict.some_float v) }
      | "pdbx_Rsym_value" -> { b with pdbx_Rsym_value = (PDBjDict.some_float v) }
      | "pdbx_netI_over_av_sigmaI" -> { b with pdbx_netI_over_av_sigmaI = (PDBjDict.some_float v) }
      | "pdbx_netI_over_sigmaI" -> { b with pdbx_netI_over_sigmaI = (PDBjDict.some_float v) }
      | "pdbx_res_netI_over_av_sigmaI_2" -> { b with pdbx_res_netI_over_av_sigmaI_2 = (PDBjDict.some_float v) }
      | "pdbx_res_netI_over_sigmaI_2" -> { b with pdbx_res_netI_over_sigmaI_2 = (PDBjDict.some_float v) }
      | "pdbx_chi_squared" -> { b with pdbx_chi_squared = (PDBjDict.some_float v) }
      | "pdbx_scaling_rejects" -> { b with pdbx_scaling_rejects = (PDBjDict.some_int v) }
      | "pdbx_d_res_high_opt" -> { b with pdbx_d_res_high_opt = (PDBjDict.some_float v) }
      | "pdbx_d_res_low_opt" -> { b with pdbx_d_res_low_opt = (PDBjDict.some_float v) }
      | "pdbx_d_res_opt_method" -> { b with pdbx_d_res_opt_method = (Some v) }
      | "phase_calculation_details" -> { b with phase_calculation_details = (Some v) }
      | "pdbx_Rrim_I_all" -> { b with pdbx_Rrim_I_all = (PDBjDict.some_float v) }
      | "pdbx_Rpim_I_all" -> { b with pdbx_Rpim_I_all = (PDBjDict.some_float v) }
      | "pdbx_d_opt" -> { b with pdbx_d_opt = (PDBjDict.some_float v) }
      | "pdbx_number_measured_all" -> { b with pdbx_number_measured_all = (PDBjDict.some_int v) }
      | "pdbx_diffrn_id" -> { b with pdbx_diffrn_id = (Some v) }
      | "pdbx_ordinal" -> { b with pdbx_ordinal = (PDBjDict.some_int v) }
      | "pdbx_CC_half" -> { b with pdbx_CC_half = (PDBjDict.some_float v) }
      | "pdbx_R_split" -> { b with pdbx_R_split = (PDBjDict.some_float v) }
      | "pdbx_redundancy_reflns_obs" -> { b with pdbx_redundancy_reflns_obs = (PDBjDict.some_float v) }
      | "pdbx_number_anomalous" -> { b with pdbx_number_anomalous = (PDBjDict.some_int v) }
      | "pdbx_Rrim_I_all_anomalous" -> { b with pdbx_Rrim_I_all_anomalous = (PDBjDict.some_float v) }
      | "pdbx_Rpim_I_all_anomalous" -> { b with pdbx_Rpim_I_all_anomalous = (PDBjDict.some_float v) }
      | "pdbx_Rmerge_I_anomalous" -> { b with pdbx_Rmerge_I_anomalous = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("B_iso_Wilson_estimate", string_of_float v)) a.b_iso_Wilson_estimate;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("data_reduction_details",  v)) a.data_reduction_details;
      Option.map (fun v -> ("data_reduction_method",  v)) a.data_reduction_method;
      Option.map (fun v -> ("d_resolution_high", string_of_float v)) a.d_resolution_high;
      Option.map (fun v -> ("d_resolution_low", string_of_float v)) a.d_resolution_low;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("limit_h_max", string_of_int v)) a.limit_h_max;
      Option.map (fun v -> ("limit_h_min", string_of_int v)) a.limit_h_min;
      Option.map (fun v -> ("limit_k_max", string_of_int v)) a.limit_k_max;
      Option.map (fun v -> ("limit_k_min", string_of_int v)) a.limit_k_min;
      Option.map (fun v -> ("limit_l_max", string_of_int v)) a.limit_l_max;
      Option.map (fun v -> ("limit_l_min", string_of_int v)) a.limit_l_min;
      Option.map (fun v -> ("number_all", string_of_int v)) a.number_all;
      Option.map (fun v -> ("number_obs", string_of_int v)) a.number_obs;
      Option.map (fun v -> ("observed_criterion",  v)) a.observed_criterion;
      Option.map (fun v -> ("observed_criterion_F_max", string_of_float v)) a.observed_criterion_F_max;
      Option.map (fun v -> ("observed_criterion_F_min", string_of_float v)) a.observed_criterion_F_min;
      Option.map (fun v -> ("observed_criterion_I_max", string_of_float v)) a.observed_criterion_I_max;
      Option.map (fun v -> ("observed_criterion_I_min", string_of_float v)) a.observed_criterion_I_min;
      Option.map (fun v -> ("observed_criterion_sigma_F", string_of_float v)) a.observed_criterion_sigma_F;
      Option.map (fun v -> ("observed_criterion_sigma_I", string_of_float v)) a.observed_criterion_sigma_I;
      Option.map (fun v -> ("percent_possible_obs", string_of_float v)) a.percent_possible_obs;
      Option.map (fun v -> ("R_free_details",  v)) a.r_free_details;
      Option.map (fun v -> ("Rmerge_F_all", string_of_float v)) a.rmerge_F_all;
      Option.map (fun v -> ("Rmerge_F_obs", string_of_float v)) a.rmerge_F_obs;
      Option.map (fun v -> ("Friedel_coverage", string_of_float v)) a.friedel_coverage;
      Option.map (fun v -> ("number_gt", string_of_int v)) a.number_gt;
      Option.map (fun v -> ("threshold_expression",  v)) a.threshold_expression;
      Option.map (fun v -> ("pdbx_redundancy", string_of_float v)) a.pdbx_redundancy;
      Option.map (fun v -> ("pdbx_Rmerge_I_obs", string_of_float v)) a.pdbx_Rmerge_I_obs;
      Option.map (fun v -> ("pdbx_Rmerge_I_all", string_of_float v)) a.pdbx_Rmerge_I_all;
      Option.map (fun v -> ("pdbx_Rsym_value", string_of_float v)) a.pdbx_Rsym_value;
      Option.map (fun v -> ("pdbx_netI_over_av_sigmaI", string_of_float v)) a.pdbx_netI_over_av_sigmaI;
      Option.map (fun v -> ("pdbx_netI_over_sigmaI", string_of_float v)) a.pdbx_netI_over_sigmaI;
      Option.map (fun v -> ("pdbx_res_netI_over_av_sigmaI_2", string_of_float v)) a.pdbx_res_netI_over_av_sigmaI_2;
      Option.map (fun v -> ("pdbx_res_netI_over_sigmaI_2", string_of_float v)) a.pdbx_res_netI_over_sigmaI_2;
      Option.map (fun v -> ("pdbx_chi_squared", string_of_float v)) a.pdbx_chi_squared;
      Option.map (fun v -> ("pdbx_scaling_rejects", string_of_int v)) a.pdbx_scaling_rejects;
      Option.map (fun v -> ("pdbx_d_res_high_opt", string_of_float v)) a.pdbx_d_res_high_opt;
      Option.map (fun v -> ("pdbx_d_res_low_opt", string_of_float v)) a.pdbx_d_res_low_opt;
      Option.map (fun v -> ("pdbx_d_res_opt_method",  v)) a.pdbx_d_res_opt_method;
      Option.map (fun v -> ("phase_calculation_details",  v)) a.phase_calculation_details;
      Option.map (fun v -> ("pdbx_Rrim_I_all", string_of_float v)) a.pdbx_Rrim_I_all;
      Option.map (fun v -> ("pdbx_Rpim_I_all", string_of_float v)) a.pdbx_Rpim_I_all;
      Option.map (fun v -> ("pdbx_d_opt", string_of_float v)) a.pdbx_d_opt;
      Option.map (fun v -> ("pdbx_number_measured_all", string_of_int v)) a.pdbx_number_measured_all;
      Option.map (fun v -> ("pdbx_diffrn_id",  v)) a.pdbx_diffrn_id;
      Option.map (fun v -> ("pdbx_ordinal", string_of_int v)) a.pdbx_ordinal;
      Option.map (fun v -> ("pdbx_CC_half", string_of_float v)) a.pdbx_CC_half;
      Option.map (fun v -> ("pdbx_R_split", string_of_float v)) a.pdbx_R_split;
      Option.map (fun v -> ("pdbx_redundancy_reflns_obs", string_of_float v)) a.pdbx_redundancy_reflns_obs;
      Option.map (fun v -> ("pdbx_number_anomalous", string_of_int v)) a.pdbx_number_anomalous;
      Option.map (fun v -> ("pdbx_Rrim_I_all_anomalous", string_of_float v)) a.pdbx_Rrim_I_all_anomalous;
      Option.map (fun v -> ("pdbx_Rpim_I_all_anomalous", string_of_float v)) a.pdbx_Rpim_I_all_anomalous;
      Option.map (fun v -> ("pdbx_Rmerge_I_anomalous", string_of_float v)) a.pdbx_Rmerge_I_anomalous;
    ]

end

module Reflns_scale = struct
  type t = {
    group_code: string option;
    meas_F: float option;
    meas_F_squared: float option;
    meas_intensity: float option;
  }

  let default = {
    group_code = None;
    meas_F = None;
    meas_F_squared = None;
    meas_intensity = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "group_code" -> { b with group_code = (Some v) }
      | "meas_F" -> { b with meas_F = (PDBjDict.some_float v) }
      | "meas_F_squared" -> { b with meas_F_squared = (PDBjDict.some_float v) }
      | "meas_intensity" -> { b with meas_intensity = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("group_code",  v)) a.group_code;
      Option.map (fun v -> ("meas_F", string_of_float v)) a.meas_F;
      Option.map (fun v -> ("meas_F_squared", string_of_float v)) a.meas_F_squared;
      Option.map (fun v -> ("meas_intensity", string_of_float v)) a.meas_intensity;
    ]

end

module Reflns_shell = struct
  type t = {
    d_res_high: float option;
    d_res_low: float option;
    meanI_over_sigI_all: float option;
    meanI_over_sigI_obs: float option;
    number_measured_all: int option;
    number_measured_obs: int option;
    number_possible: int option;
    number_unique_all: int option;
    number_unique_obs: int option;
    percent_possible_all: float option;
    percent_possible_obs: float option;
    rmerge_F_all: float option;
    rmerge_F_obs: float option;
    rmerge_I_all: float option;
    rmerge_I_obs: float option;
    meanI_over_sigI_gt: float option;
    meanI_over_uI_all: float option;
    meanI_over_uI_gt: float option;
    number_measured_gt: int option;
    number_unique_gt: int option;
    percent_possible_gt: float option;
    rmerge_F_gt: float option;
    rmerge_I_gt: float option;
    pdbx_redundancy: float option;
    pdbx_Rsym_value: float option;
    pdbx_chi_squared: float option;
    pdbx_netI_over_sigmaI_all: float option;
    pdbx_netI_over_sigmaI_obs: float option;
    pdbx_Rrim_I_all: float option;
    pdbx_Rpim_I_all: float option;
    pdbx_rejects: int option;
    pdbx_ordinal: int option;
    pdbx_diffrn_id: string option;
    pdbx_CC_half: float option;
    pdbx_R_split: float option;
    pdbx_redundancy_reflns_obs: float option;
    pdbx_number_anomalous: int option;
    pdbx_Rrim_I_all_anomalous: float option;
    pdbx_Rpim_I_all_anomalous: float option;
    pdbx_Rmerge_I_all_anomalous: float option;
  }

  let default = {
    d_res_high = None;
    d_res_low = None;
    meanI_over_sigI_all = None;
    meanI_over_sigI_obs = None;
    number_measured_all = None;
    number_measured_obs = None;
    number_possible = None;
    number_unique_all = None;
    number_unique_obs = None;
    percent_possible_all = None;
    percent_possible_obs = None;
    rmerge_F_all = None;
    rmerge_F_obs = None;
    rmerge_I_all = None;
    rmerge_I_obs = None;
    meanI_over_sigI_gt = None;
    meanI_over_uI_all = None;
    meanI_over_uI_gt = None;
    number_measured_gt = None;
    number_unique_gt = None;
    percent_possible_gt = None;
    rmerge_F_gt = None;
    rmerge_I_gt = None;
    pdbx_redundancy = None;
    pdbx_Rsym_value = None;
    pdbx_chi_squared = None;
    pdbx_netI_over_sigmaI_all = None;
    pdbx_netI_over_sigmaI_obs = None;
    pdbx_Rrim_I_all = None;
    pdbx_Rpim_I_all = None;
    pdbx_rejects = None;
    pdbx_ordinal = None;
    pdbx_diffrn_id = None;
    pdbx_CC_half = None;
    pdbx_R_split = None;
    pdbx_redundancy_reflns_obs = None;
    pdbx_number_anomalous = None;
    pdbx_Rrim_I_all_anomalous = None;
    pdbx_Rpim_I_all_anomalous = None;
    pdbx_Rmerge_I_all_anomalous = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "meanI_over_sigI_all" -> { b with meanI_over_sigI_all = (PDBjDict.some_float v) }
      | "meanI_over_sigI_obs" -> { b with meanI_over_sigI_obs = (PDBjDict.some_float v) }
      | "number_measured_all" -> { b with number_measured_all = (PDBjDict.some_int v) }
      | "number_measured_obs" -> { b with number_measured_obs = (PDBjDict.some_int v) }
      | "number_possible" -> { b with number_possible = (PDBjDict.some_int v) }
      | "number_unique_all" -> { b with number_unique_all = (PDBjDict.some_int v) }
      | "number_unique_obs" -> { b with number_unique_obs = (PDBjDict.some_int v) }
      | "percent_possible_all" -> { b with percent_possible_all = (PDBjDict.some_float v) }
      | "percent_possible_obs" -> { b with percent_possible_obs = (PDBjDict.some_float v) }
      | "Rmerge_F_all" -> { b with rmerge_F_all = (PDBjDict.some_float v) }
      | "Rmerge_F_obs" -> { b with rmerge_F_obs = (PDBjDict.some_float v) }
      | "Rmerge_I_all" -> { b with rmerge_I_all = (PDBjDict.some_float v) }
      | "Rmerge_I_obs" -> { b with rmerge_I_obs = (PDBjDict.some_float v) }
      | "meanI_over_sigI_gt" -> { b with meanI_over_sigI_gt = (PDBjDict.some_float v) }
      | "meanI_over_uI_all" -> { b with meanI_over_uI_all = (PDBjDict.some_float v) }
      | "meanI_over_uI_gt" -> { b with meanI_over_uI_gt = (PDBjDict.some_float v) }
      | "number_measured_gt" -> { b with number_measured_gt = (PDBjDict.some_int v) }
      | "number_unique_gt" -> { b with number_unique_gt = (PDBjDict.some_int v) }
      | "percent_possible_gt" -> { b with percent_possible_gt = (PDBjDict.some_float v) }
      | "Rmerge_F_gt" -> { b with rmerge_F_gt = (PDBjDict.some_float v) }
      | "Rmerge_I_gt" -> { b with rmerge_I_gt = (PDBjDict.some_float v) }
      | "pdbx_redundancy" -> { b with pdbx_redundancy = (PDBjDict.some_float v) }
      | "pdbx_Rsym_value" -> { b with pdbx_Rsym_value = (PDBjDict.some_float v) }
      | "pdbx_chi_squared" -> { b with pdbx_chi_squared = (PDBjDict.some_float v) }
      | "pdbx_netI_over_sigmaI_all" -> { b with pdbx_netI_over_sigmaI_all = (PDBjDict.some_float v) }
      | "pdbx_netI_over_sigmaI_obs" -> { b with pdbx_netI_over_sigmaI_obs = (PDBjDict.some_float v) }
      | "pdbx_Rrim_I_all" -> { b with pdbx_Rrim_I_all = (PDBjDict.some_float v) }
      | "pdbx_Rpim_I_all" -> { b with pdbx_Rpim_I_all = (PDBjDict.some_float v) }
      | "pdbx_rejects" -> { b with pdbx_rejects = (PDBjDict.some_int v) }
      | "pdbx_ordinal" -> { b with pdbx_ordinal = (PDBjDict.some_int v) }
      | "pdbx_diffrn_id" -> { b with pdbx_diffrn_id = (Some v) }
      | "pdbx_CC_half" -> { b with pdbx_CC_half = (PDBjDict.some_float v) }
      | "pdbx_R_split" -> { b with pdbx_R_split = (PDBjDict.some_float v) }
      | "pdbx_redundancy_reflns_obs" -> { b with pdbx_redundancy_reflns_obs = (PDBjDict.some_float v) }
      | "pdbx_number_anomalous" -> { b with pdbx_number_anomalous = (PDBjDict.some_int v) }
      | "pdbx_Rrim_I_all_anomalous" -> { b with pdbx_Rrim_I_all_anomalous = (PDBjDict.some_float v) }
      | "pdbx_Rpim_I_all_anomalous" -> { b with pdbx_Rpim_I_all_anomalous = (PDBjDict.some_float v) }
      | "pdbx_Rmerge_I_all_anomalous" -> { b with pdbx_Rmerge_I_all_anomalous = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("meanI_over_sigI_all", string_of_float v)) a.meanI_over_sigI_all;
      Option.map (fun v -> ("meanI_over_sigI_obs", string_of_float v)) a.meanI_over_sigI_obs;
      Option.map (fun v -> ("number_measured_all", string_of_int v)) a.number_measured_all;
      Option.map (fun v -> ("number_measured_obs", string_of_int v)) a.number_measured_obs;
      Option.map (fun v -> ("number_possible", string_of_int v)) a.number_possible;
      Option.map (fun v -> ("number_unique_all", string_of_int v)) a.number_unique_all;
      Option.map (fun v -> ("number_unique_obs", string_of_int v)) a.number_unique_obs;
      Option.map (fun v -> ("percent_possible_all", string_of_float v)) a.percent_possible_all;
      Option.map (fun v -> ("percent_possible_obs", string_of_float v)) a.percent_possible_obs;
      Option.map (fun v -> ("Rmerge_F_all", string_of_float v)) a.rmerge_F_all;
      Option.map (fun v -> ("Rmerge_F_obs", string_of_float v)) a.rmerge_F_obs;
      Option.map (fun v -> ("Rmerge_I_all", string_of_float v)) a.rmerge_I_all;
      Option.map (fun v -> ("Rmerge_I_obs", string_of_float v)) a.rmerge_I_obs;
      Option.map (fun v -> ("meanI_over_sigI_gt", string_of_float v)) a.meanI_over_sigI_gt;
      Option.map (fun v -> ("meanI_over_uI_all", string_of_float v)) a.meanI_over_uI_all;
      Option.map (fun v -> ("meanI_over_uI_gt", string_of_float v)) a.meanI_over_uI_gt;
      Option.map (fun v -> ("number_measured_gt", string_of_int v)) a.number_measured_gt;
      Option.map (fun v -> ("number_unique_gt", string_of_int v)) a.number_unique_gt;
      Option.map (fun v -> ("percent_possible_gt", string_of_float v)) a.percent_possible_gt;
      Option.map (fun v -> ("Rmerge_F_gt", string_of_float v)) a.rmerge_F_gt;
      Option.map (fun v -> ("Rmerge_I_gt", string_of_float v)) a.rmerge_I_gt;
      Option.map (fun v -> ("pdbx_redundancy", string_of_float v)) a.pdbx_redundancy;
      Option.map (fun v -> ("pdbx_Rsym_value", string_of_float v)) a.pdbx_Rsym_value;
      Option.map (fun v -> ("pdbx_chi_squared", string_of_float v)) a.pdbx_chi_squared;
      Option.map (fun v -> ("pdbx_netI_over_sigmaI_all", string_of_float v)) a.pdbx_netI_over_sigmaI_all;
      Option.map (fun v -> ("pdbx_netI_over_sigmaI_obs", string_of_float v)) a.pdbx_netI_over_sigmaI_obs;
      Option.map (fun v -> ("pdbx_Rrim_I_all", string_of_float v)) a.pdbx_Rrim_I_all;
      Option.map (fun v -> ("pdbx_Rpim_I_all", string_of_float v)) a.pdbx_Rpim_I_all;
      Option.map (fun v -> ("pdbx_rejects", string_of_int v)) a.pdbx_rejects;
      Option.map (fun v -> ("pdbx_ordinal", string_of_int v)) a.pdbx_ordinal;
      Option.map (fun v -> ("pdbx_diffrn_id",  v)) a.pdbx_diffrn_id;
      Option.map (fun v -> ("pdbx_CC_half", string_of_float v)) a.pdbx_CC_half;
      Option.map (fun v -> ("pdbx_R_split", string_of_float v)) a.pdbx_R_split;
      Option.map (fun v -> ("pdbx_redundancy_reflns_obs", string_of_float v)) a.pdbx_redundancy_reflns_obs;
      Option.map (fun v -> ("pdbx_number_anomalous", string_of_int v)) a.pdbx_number_anomalous;
      Option.map (fun v -> ("pdbx_Rrim_I_all_anomalous", string_of_float v)) a.pdbx_Rrim_I_all_anomalous;
      Option.map (fun v -> ("pdbx_Rpim_I_all_anomalous", string_of_float v)) a.pdbx_Rpim_I_all_anomalous;
      Option.map (fun v -> ("pdbx_Rmerge_I_all_anomalous", string_of_float v)) a.pdbx_Rmerge_I_all_anomalous;
    ]

end

module Software = struct
  type t = {
    citation_id: string option;
    classification: string option;
    compiler_name: string option;
    compiler_version: string option;
    contact_author: string option;
    contact_author_email: string option;
    date: string option;
    description: string option;
    dependencies: string option;
    hardware: string option;
    language: string option;
    location: string option;
    mods: string option;
    name: string option;
    os: string option;
    os_version: string option;
    type_: string option;
    version: string option;
    pdbx_ordinal: int option;
  }

  let default = {
    citation_id = None;
    classification = None;
    compiler_name = None;
    compiler_version = None;
    contact_author = None;
    contact_author_email = None;
    date = None;
    description = None;
    dependencies = None;
    hardware = None;
    language = None;
    location = None;
    mods = None;
    name = None;
    os = None;
    os_version = None;
    type_ = None;
    version = None;
    pdbx_ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "citation_id" -> { b with citation_id = (Some v) }
      | "classification" -> { b with classification = (Some v) }
      | "compiler_name" -> { b with compiler_name = (Some v) }
      | "compiler_version" -> { b with compiler_version = (Some v) }
      | "contact_author" -> { b with contact_author = (Some v) }
      | "contact_author_email" -> { b with contact_author_email = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "description" -> { b with description = (Some v) }
      | "dependencies" -> { b with dependencies = (Some v) }
      | "hardware" -> { b with hardware = (Some v) }
      | "language" -> { b with language = (Some v) }
      | "location" -> { b with location = (Some v) }
      | "mods" -> { b with mods = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "os" -> { b with os = (Some v) }
      | "os_version" -> { b with os_version = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "version" -> { b with version = (Some v) }
      | "pdbx_ordinal" -> { b with pdbx_ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
      Option.map (fun v -> ("classification",  v)) a.classification;
      Option.map (fun v -> ("compiler_name",  v)) a.compiler_name;
      Option.map (fun v -> ("compiler_version",  v)) a.compiler_version;
      Option.map (fun v -> ("contact_author",  v)) a.contact_author;
      Option.map (fun v -> ("contact_author_email",  v)) a.contact_author_email;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("description",  v)) a.description;
      Option.map (fun v -> ("dependencies",  v)) a.dependencies;
      Option.map (fun v -> ("hardware",  v)) a.hardware;
      Option.map (fun v -> ("language",  v)) a.language;
      Option.map (fun v -> ("location",  v)) a.location;
      Option.map (fun v -> ("mods",  v)) a.mods;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("os",  v)) a.os;
      Option.map (fun v -> ("os_version",  v)) a.os_version;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("version",  v)) a.version;
      Option.map (fun v -> ("pdbx_ordinal", string_of_int v)) a.pdbx_ordinal;
    ]

end

module Struct = struct
  type t = {
    entry_id: string option;
    title: string option;
    pdbx_descriptor: string option;
    pdbx_model_details: string option;
    pdbx_formula_weight: float option;
    pdbx_formula_weight_method: string option;
    pdbx_model_type_details: string option;
    pdbx_CASP_flag: string option;
    pdbx_details: string option;
    pdbx_title_text: string option;
  }

  let default = {
    entry_id = None;
    title = None;
    pdbx_descriptor = None;
    pdbx_model_details = None;
    pdbx_formula_weight = None;
    pdbx_formula_weight_method = None;
    pdbx_model_type_details = None;
    pdbx_CASP_flag = None;
    pdbx_details = None;
    pdbx_title_text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "title" -> { b with title = (Some v) }
      | "pdbx_descriptor" -> { b with pdbx_descriptor = (Some v) }
      | "pdbx_model_details" -> { b with pdbx_model_details = (Some v) }
      | "pdbx_formula_weight" -> { b with pdbx_formula_weight = (PDBjDict.some_float v) }
      | "pdbx_formula_weight_method" -> { b with pdbx_formula_weight_method = (Some v) }
      | "pdbx_model_type_details" -> { b with pdbx_model_type_details = (Some v) }
      | "pdbx_CASP_flag" -> { b with pdbx_CASP_flag = (Some v) }
      | "pdbx_details" -> { b with pdbx_details = (Some v) }
      | "pdbx_title_text" -> { b with pdbx_title_text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("title",  v)) a.title;
      Option.map (fun v -> ("pdbx_descriptor",  v)) a.pdbx_descriptor;
      Option.map (fun v -> ("pdbx_model_details",  v)) a.pdbx_model_details;
      Option.map (fun v -> ("pdbx_formula_weight", string_of_float v)) a.pdbx_formula_weight;
      Option.map (fun v -> ("pdbx_formula_weight_method",  v)) a.pdbx_formula_weight_method;
      Option.map (fun v -> ("pdbx_model_type_details",  v)) a.pdbx_model_type_details;
      Option.map (fun v -> ("pdbx_CASP_flag",  v)) a.pdbx_CASP_flag;
      Option.map (fun v -> ("pdbx_details",  v)) a.pdbx_details;
      Option.map (fun v -> ("pdbx_title_text",  v)) a.pdbx_title_text;
    ]

end

module Struct_asym = struct
  type t = {
    details: string option;
    entity_id: string option;
    id: string option;
    pdbx_modified: string option;
    pdbx_blank_PDB_chainid_flag: string option;
    pdbx_PDB_id: string option;
    pdbx_alt_id: string option;
    pdbx_type: string option;
    pdbx_order: int option;
    pdbx_fraction_per_asym_unit: string option;
    pdbx_missing_num_begin_of_chain_not_in_seqres: int option;
    pdbx_missing_num_end_of_chain_not_in_seqres: int option;
    pdbx_missing_num_begin_of_chain_in_seqres: int option;
  }

  let default = {
    details = None;
    entity_id = None;
    id = None;
    pdbx_modified = None;
    pdbx_blank_PDB_chainid_flag = None;
    pdbx_PDB_id = None;
    pdbx_alt_id = None;
    pdbx_type = None;
    pdbx_order = None;
    pdbx_fraction_per_asym_unit = None;
    pdbx_missing_num_begin_of_chain_not_in_seqres = None;
    pdbx_missing_num_end_of_chain_not_in_seqres = None;
    pdbx_missing_num_begin_of_chain_in_seqres = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "pdbx_modified" -> { b with pdbx_modified = (Some v) }
      | "pdbx_blank_PDB_chainid_flag" -> { b with pdbx_blank_PDB_chainid_flag = (Some v) }
      | "pdbx_PDB_id" -> { b with pdbx_PDB_id = (Some v) }
      | "pdbx_alt_id" -> { b with pdbx_alt_id = (Some v) }
      | "pdbx_type" -> { b with pdbx_type = (Some v) }
      | "pdbx_order" -> { b with pdbx_order = (PDBjDict.some_int v) }
      | "pdbx_fraction_per_asym_unit" -> { b with pdbx_fraction_per_asym_unit = (Some v) }
      | "pdbx_missing_num_begin_of_chain_not_in_seqres" -> { b with pdbx_missing_num_begin_of_chain_not_in_seqres = (PDBjDict.some_int v) }
      | "pdbx_missing_num_end_of_chain_not_in_seqres" -> { b with pdbx_missing_num_end_of_chain_not_in_seqres = (PDBjDict.some_int v) }
      | "pdbx_missing_num_begin_of_chain_in_seqres" -> { b with pdbx_missing_num_begin_of_chain_in_seqres = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("pdbx_modified",  v)) a.pdbx_modified;
      Option.map (fun v -> ("pdbx_blank_PDB_chainid_flag",  v)) a.pdbx_blank_PDB_chainid_flag;
      Option.map (fun v -> ("pdbx_PDB_id",  v)) a.pdbx_PDB_id;
      Option.map (fun v -> ("pdbx_alt_id",  v)) a.pdbx_alt_id;
      Option.map (fun v -> ("pdbx_type",  v)) a.pdbx_type;
      Option.map (fun v -> ("pdbx_order", string_of_int v)) a.pdbx_order;
      Option.map (fun v -> ("pdbx_fraction_per_asym_unit",  v)) a.pdbx_fraction_per_asym_unit;
      Option.map (fun v -> ("pdbx_missing_num_begin_of_chain_not_in_seqres", string_of_int v)) a.pdbx_missing_num_begin_of_chain_not_in_seqres;
      Option.map (fun v -> ("pdbx_missing_num_end_of_chain_not_in_seqres", string_of_int v)) a.pdbx_missing_num_end_of_chain_not_in_seqres;
      Option.map (fun v -> ("pdbx_missing_num_begin_of_chain_in_seqres", string_of_int v)) a.pdbx_missing_num_begin_of_chain_in_seqres;
    ]

end

module Struct_biol = struct
  type t = {
    details: string option;
    id: string option;
    pdbx_parent_biol_id: string option;
    pdbx_formula_weight: float option;
    pdbx_formula_weight_method: string option;
    pdbx_aggregation_state: string option;
    pdbx_assembly_method: string option;
  }

  let default = {
    details = None;
    id = None;
    pdbx_parent_biol_id = None;
    pdbx_formula_weight = None;
    pdbx_formula_weight_method = None;
    pdbx_aggregation_state = None;
    pdbx_assembly_method = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "pdbx_parent_biol_id" -> { b with pdbx_parent_biol_id = (Some v) }
      | "pdbx_formula_weight" -> { b with pdbx_formula_weight = (PDBjDict.some_float v) }
      | "pdbx_formula_weight_method" -> { b with pdbx_formula_weight_method = (Some v) }
      | "pdbx_aggregation_state" -> { b with pdbx_aggregation_state = (Some v) }
      | "pdbx_assembly_method" -> { b with pdbx_assembly_method = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("pdbx_parent_biol_id",  v)) a.pdbx_parent_biol_id;
      Option.map (fun v -> ("pdbx_formula_weight", string_of_float v)) a.pdbx_formula_weight;
      Option.map (fun v -> ("pdbx_formula_weight_method",  v)) a.pdbx_formula_weight_method;
      Option.map (fun v -> ("pdbx_aggregation_state",  v)) a.pdbx_aggregation_state;
      Option.map (fun v -> ("pdbx_assembly_method",  v)) a.pdbx_assembly_method;
    ]

end

module Struct_biol_gen = struct
  type t = {
    asym_id: string option;
    biol_id: string option;
    details: string option;
    symmetry: string option;
    pdbx_full_symmetry_operation: string option;
    pdbx_PDB_order: int option;
    pdbx_new_asym_id: string option;
    pdbx_new_pdb_asym_id: string option;
    pdbx_color_red: float option;
    pdbx_color_green: float option;
    pdbx_color_blue: float option;
    pdbx_after_begin_residue_no: string option;
    pdbx_after_end_residue_no: string option;
    pdbx_before_begin_residue_no: string option;
    pdbx_before_end_residue_no: string option;
  }

  let default = {
    asym_id = None;
    biol_id = None;
    details = None;
    symmetry = None;
    pdbx_full_symmetry_operation = None;
    pdbx_PDB_order = None;
    pdbx_new_asym_id = None;
    pdbx_new_pdb_asym_id = None;
    pdbx_color_red = None;
    pdbx_color_green = None;
    pdbx_color_blue = None;
    pdbx_after_begin_residue_no = None;
    pdbx_after_end_residue_no = None;
    pdbx_before_begin_residue_no = None;
    pdbx_before_end_residue_no = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "asym_id" -> { b with asym_id = (Some v) }
      | "biol_id" -> { b with biol_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "symmetry" -> { b with symmetry = (Some v) }
      | "pdbx_full_symmetry_operation" -> { b with pdbx_full_symmetry_operation = (Some v) }
      | "pdbx_PDB_order" -> { b with pdbx_PDB_order = (PDBjDict.some_int v) }
      | "pdbx_new_asym_id" -> { b with pdbx_new_asym_id = (Some v) }
      | "pdbx_new_pdb_asym_id" -> { b with pdbx_new_pdb_asym_id = (Some v) }
      | "pdbx_color_red" -> { b with pdbx_color_red = (PDBjDict.some_float v) }
      | "pdbx_color_green" -> { b with pdbx_color_green = (PDBjDict.some_float v) }
      | "pdbx_color_blue" -> { b with pdbx_color_blue = (PDBjDict.some_float v) }
      | "pdbx_after_begin_residue_no" -> { b with pdbx_after_begin_residue_no = (Some v) }
      | "pdbx_after_end_residue_no" -> { b with pdbx_after_end_residue_no = (Some v) }
      | "pdbx_before_begin_residue_no" -> { b with pdbx_before_begin_residue_no = (Some v) }
      | "pdbx_before_end_residue_no" -> { b with pdbx_before_end_residue_no = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("biol_id",  v)) a.biol_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("symmetry",  v)) a.symmetry;
      Option.map (fun v -> ("pdbx_full_symmetry_operation",  v)) a.pdbx_full_symmetry_operation;
      Option.map (fun v -> ("pdbx_PDB_order", string_of_int v)) a.pdbx_PDB_order;
      Option.map (fun v -> ("pdbx_new_asym_id",  v)) a.pdbx_new_asym_id;
      Option.map (fun v -> ("pdbx_new_pdb_asym_id",  v)) a.pdbx_new_pdb_asym_id;
      Option.map (fun v -> ("pdbx_color_red", string_of_float v)) a.pdbx_color_red;
      Option.map (fun v -> ("pdbx_color_green", string_of_float v)) a.pdbx_color_green;
      Option.map (fun v -> ("pdbx_color_blue", string_of_float v)) a.pdbx_color_blue;
      Option.map (fun v -> ("pdbx_after_begin_residue_no",  v)) a.pdbx_after_begin_residue_no;
      Option.map (fun v -> ("pdbx_after_end_residue_no",  v)) a.pdbx_after_end_residue_no;
      Option.map (fun v -> ("pdbx_before_begin_residue_no",  v)) a.pdbx_before_begin_residue_no;
      Option.map (fun v -> ("pdbx_before_end_residue_no",  v)) a.pdbx_before_end_residue_no;
    ]

end

module Struct_biol_keywords = struct
  type t = {
    biol_id: string option;
    text: string option;
  }

  let default = {
    biol_id = None;
    text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "biol_id" -> { b with biol_id = (Some v) }
      | "text" -> { b with text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("biol_id",  v)) a.biol_id;
      Option.map (fun v -> ("text",  v)) a.text;
    ]

end

module Struct_biol_view = struct
  type t = {
    biol_id: string option;
    details: string option;
    id: string option;
    rot_matrix11: float option;
    rot_matrix12: float option;
    rot_matrix13: float option;
    rot_matrix21: float option;
    rot_matrix22: float option;
    rot_matrix23: float option;
    rot_matrix31: float option;
    rot_matrix32: float option;
    rot_matrix33: float option;
    pdbx_vector1: float option;
    pdbx_vector2: float option;
    pdbx_vector3: float option;
  }

  let default = {
    biol_id = None;
    details = None;
    id = None;
    rot_matrix11 = None;
    rot_matrix12 = None;
    rot_matrix13 = None;
    rot_matrix21 = None;
    rot_matrix22 = None;
    rot_matrix23 = None;
    rot_matrix31 = None;
    rot_matrix32 = None;
    rot_matrix33 = None;
    pdbx_vector1 = None;
    pdbx_vector2 = None;
    pdbx_vector3 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "biol_id" -> { b with biol_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "rot_matrix[1][1]" -> { b with rot_matrix11 = (PDBjDict.some_float v) }
      | "rot_matrix[1][2]" -> { b with rot_matrix12 = (PDBjDict.some_float v) }
      | "rot_matrix[1][3]" -> { b with rot_matrix13 = (PDBjDict.some_float v) }
      | "rot_matrix[2][1]" -> { b with rot_matrix21 = (PDBjDict.some_float v) }
      | "rot_matrix[2][2]" -> { b with rot_matrix22 = (PDBjDict.some_float v) }
      | "rot_matrix[2][3]" -> { b with rot_matrix23 = (PDBjDict.some_float v) }
      | "rot_matrix[3][1]" -> { b with rot_matrix31 = (PDBjDict.some_float v) }
      | "rot_matrix[3][2]" -> { b with rot_matrix32 = (PDBjDict.some_float v) }
      | "rot_matrix[3][3]" -> { b with rot_matrix33 = (PDBjDict.some_float v) }
      | "pdbx_vector[1]" -> { b with pdbx_vector1 = (PDBjDict.some_float v) }
      | "pdbx_vector[2]" -> { b with pdbx_vector2 = (PDBjDict.some_float v) }
      | "pdbx_vector[3]" -> { b with pdbx_vector3 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("biol_id",  v)) a.biol_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("rot_matrix[1][1]", string_of_float v)) a.rot_matrix11;
      Option.map (fun v -> ("rot_matrix[1][2]", string_of_float v)) a.rot_matrix12;
      Option.map (fun v -> ("rot_matrix[1][3]", string_of_float v)) a.rot_matrix13;
      Option.map (fun v -> ("rot_matrix[2][1]", string_of_float v)) a.rot_matrix21;
      Option.map (fun v -> ("rot_matrix[2][2]", string_of_float v)) a.rot_matrix22;
      Option.map (fun v -> ("rot_matrix[2][3]", string_of_float v)) a.rot_matrix23;
      Option.map (fun v -> ("rot_matrix[3][1]", string_of_float v)) a.rot_matrix31;
      Option.map (fun v -> ("rot_matrix[3][2]", string_of_float v)) a.rot_matrix32;
      Option.map (fun v -> ("rot_matrix[3][3]", string_of_float v)) a.rot_matrix33;
      Option.map (fun v -> ("pdbx_vector[1]", string_of_float v)) a.pdbx_vector1;
      Option.map (fun v -> ("pdbx_vector[2]", string_of_float v)) a.pdbx_vector2;
      Option.map (fun v -> ("pdbx_vector[3]", string_of_float v)) a.pdbx_vector3;
    ]

end

module Struct_conf = struct
  type t = {
    beg_label_asym_id: string option;
    beg_label_comp_id: string option;
    beg_label_seq_id: int option;
    beg_auth_asym_id: string option;
    beg_auth_comp_id: string option;
    beg_auth_seq_id: string option;
    conf_type_id: string option;
    details: string option;
    end_label_asym_id: string option;
    end_label_comp_id: string option;
    end_label_seq_id: int option;
    end_auth_asym_id: string option;
    end_auth_comp_id: string option;
    end_auth_seq_id: string option;
    id: string option;
    pdbx_beg_PDB_ins_code: string option;
    pdbx_end_PDB_ins_code: string option;
    pdbx_PDB_helix_class: string option;
    pdbx_PDB_helix_length: int option;
    pdbx_PDB_helix_id: string option;
  }

  let default = {
    beg_label_asym_id = None;
    beg_label_comp_id = None;
    beg_label_seq_id = None;
    beg_auth_asym_id = None;
    beg_auth_comp_id = None;
    beg_auth_seq_id = None;
    conf_type_id = None;
    details = None;
    end_label_asym_id = None;
    end_label_comp_id = None;
    end_label_seq_id = None;
    end_auth_asym_id = None;
    end_auth_comp_id = None;
    end_auth_seq_id = None;
    id = None;
    pdbx_beg_PDB_ins_code = None;
    pdbx_end_PDB_ins_code = None;
    pdbx_PDB_helix_class = None;
    pdbx_PDB_helix_length = None;
    pdbx_PDB_helix_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "beg_label_asym_id" -> { b with beg_label_asym_id = (Some v) }
      | "beg_label_comp_id" -> { b with beg_label_comp_id = (Some v) }
      | "beg_label_seq_id" -> { b with beg_label_seq_id = (PDBjDict.some_int v) }
      | "beg_auth_asym_id" -> { b with beg_auth_asym_id = (Some v) }
      | "beg_auth_comp_id" -> { b with beg_auth_comp_id = (Some v) }
      | "beg_auth_seq_id" -> { b with beg_auth_seq_id = (Some v) }
      | "conf_type_id" -> { b with conf_type_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "end_label_asym_id" -> { b with end_label_asym_id = (Some v) }
      | "end_label_comp_id" -> { b with end_label_comp_id = (Some v) }
      | "end_label_seq_id" -> { b with end_label_seq_id = (PDBjDict.some_int v) }
      | "end_auth_asym_id" -> { b with end_auth_asym_id = (Some v) }
      | "end_auth_comp_id" -> { b with end_auth_comp_id = (Some v) }
      | "end_auth_seq_id" -> { b with end_auth_seq_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "pdbx_beg_PDB_ins_code" -> { b with pdbx_beg_PDB_ins_code = (Some v) }
      | "pdbx_end_PDB_ins_code" -> { b with pdbx_end_PDB_ins_code = (Some v) }
      | "pdbx_PDB_helix_class" -> { b with pdbx_PDB_helix_class = (Some v) }
      | "pdbx_PDB_helix_length" -> { b with pdbx_PDB_helix_length = (PDBjDict.some_int v) }
      | "pdbx_PDB_helix_id" -> { b with pdbx_PDB_helix_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("beg_label_asym_id",  v)) a.beg_label_asym_id;
      Option.map (fun v -> ("beg_label_comp_id",  v)) a.beg_label_comp_id;
      Option.map (fun v -> ("beg_label_seq_id", string_of_int v)) a.beg_label_seq_id;
      Option.map (fun v -> ("beg_auth_asym_id",  v)) a.beg_auth_asym_id;
      Option.map (fun v -> ("beg_auth_comp_id",  v)) a.beg_auth_comp_id;
      Option.map (fun v -> ("beg_auth_seq_id",  v)) a.beg_auth_seq_id;
      Option.map (fun v -> ("conf_type_id",  v)) a.conf_type_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("end_label_asym_id",  v)) a.end_label_asym_id;
      Option.map (fun v -> ("end_label_comp_id",  v)) a.end_label_comp_id;
      Option.map (fun v -> ("end_label_seq_id", string_of_int v)) a.end_label_seq_id;
      Option.map (fun v -> ("end_auth_asym_id",  v)) a.end_auth_asym_id;
      Option.map (fun v -> ("end_auth_comp_id",  v)) a.end_auth_comp_id;
      Option.map (fun v -> ("end_auth_seq_id",  v)) a.end_auth_seq_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("pdbx_beg_PDB_ins_code",  v)) a.pdbx_beg_PDB_ins_code;
      Option.map (fun v -> ("pdbx_end_PDB_ins_code",  v)) a.pdbx_end_PDB_ins_code;
      Option.map (fun v -> ("pdbx_PDB_helix_class",  v)) a.pdbx_PDB_helix_class;
      Option.map (fun v -> ("pdbx_PDB_helix_length", string_of_int v)) a.pdbx_PDB_helix_length;
      Option.map (fun v -> ("pdbx_PDB_helix_id",  v)) a.pdbx_PDB_helix_id;
    ]

end

module Struct_conf_type = struct
  type t = {
    criteria: string option;
    id: string option;
    reference: string option;
  }

  let default = {
    criteria = None;
    id = None;
    reference = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "criteria" -> { b with criteria = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "reference" -> { b with reference = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("criteria",  v)) a.criteria;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("reference",  v)) a.reference;
    ]

end

module Struct_conn = struct
  type t = {
    conn_type_id: string option;
    details: string option;
    id: string option;
    ptnr1_label_alt_id: string option;
    ptnr1_label_asym_id: string option;
    ptnr1_label_atom_id: string option;
    ptnr1_label_comp_id: string option;
    ptnr1_label_seq_id: int option;
    ptnr1_auth_asym_id: string option;
    ptnr1_auth_atom_id: string option;
    ptnr1_auth_comp_id: string option;
    ptnr1_auth_seq_id: string option;
    ptnr1_role: string option;
    ptnr1_symmetry: string option;
    ptnr2_label_alt_id: string option;
    ptnr2_label_asym_id: string option;
    ptnr2_label_atom_id: string option;
    ptnr2_label_comp_id: string option;
    ptnr2_label_seq_id: int option;
    ptnr2_auth_asym_id: string option;
    ptnr2_auth_atom_id: string option;
    ptnr2_auth_comp_id: string option;
    ptnr2_auth_seq_id: string option;
    ptnr2_role: string option;
    ptnr2_symmetry: string option;
    pdbx_ptnr1_PDB_ins_code: string option;
    pdbx_ptnr1_auth_alt_id: string option;
    pdbx_ptnr1_label_alt_id: string option;
    pdbx_ptnr1_standard_comp_id: string option;
    pdbx_ptnr2_PDB_ins_code: string option;
    pdbx_ptnr2_auth_alt_id: string option;
    pdbx_ptnr2_label_alt_id: string option;
    pdbx_ptnr3_auth_alt_id: string option;
    pdbx_ptnr3_auth_asym_id: string option;
    pdbx_ptnr3_auth_atom_id: string option;
    pdbx_ptnr3_auth_comp_id: string option;
    pdbx_ptnr3_PDB_ins_code: string option;
    pdbx_ptnr3_auth_seq_id: string option;
    pdbx_ptnr3_label_alt_id: string option;
    pdbx_ptnr3_label_asym_id: string option;
    pdbx_ptnr3_label_atom_id: string option;
    pdbx_ptnr3_label_comp_id: string option;
    pdbx_ptnr3_label_seq_id: int option;
    pdbx_PDB_id: string option;
    pdbx_dist_value: float option;
    pdbx_value_order: string option;
    pdbx_leaving_atom_flag: string option;
    pdbx_ptnr1_mod_name: string option;
    pdbx_ptnr1_sugar_name: string option;
    pdbx_ptnr1_replaced_atom: string option;
    pdbx_ptnr3_auth_ins_code: string option;
  }

  let default = {
    conn_type_id = None;
    details = None;
    id = None;
    ptnr1_label_alt_id = None;
    ptnr1_label_asym_id = None;
    ptnr1_label_atom_id = None;
    ptnr1_label_comp_id = None;
    ptnr1_label_seq_id = None;
    ptnr1_auth_asym_id = None;
    ptnr1_auth_atom_id = None;
    ptnr1_auth_comp_id = None;
    ptnr1_auth_seq_id = None;
    ptnr1_role = None;
    ptnr1_symmetry = None;
    ptnr2_label_alt_id = None;
    ptnr2_label_asym_id = None;
    ptnr2_label_atom_id = None;
    ptnr2_label_comp_id = None;
    ptnr2_label_seq_id = None;
    ptnr2_auth_asym_id = None;
    ptnr2_auth_atom_id = None;
    ptnr2_auth_comp_id = None;
    ptnr2_auth_seq_id = None;
    ptnr2_role = None;
    ptnr2_symmetry = None;
    pdbx_ptnr1_PDB_ins_code = None;
    pdbx_ptnr1_auth_alt_id = None;
    pdbx_ptnr1_label_alt_id = None;
    pdbx_ptnr1_standard_comp_id = None;
    pdbx_ptnr2_PDB_ins_code = None;
    pdbx_ptnr2_auth_alt_id = None;
    pdbx_ptnr2_label_alt_id = None;
    pdbx_ptnr3_auth_alt_id = None;
    pdbx_ptnr3_auth_asym_id = None;
    pdbx_ptnr3_auth_atom_id = None;
    pdbx_ptnr3_auth_comp_id = None;
    pdbx_ptnr3_PDB_ins_code = None;
    pdbx_ptnr3_auth_seq_id = None;
    pdbx_ptnr3_label_alt_id = None;
    pdbx_ptnr3_label_asym_id = None;
    pdbx_ptnr3_label_atom_id = None;
    pdbx_ptnr3_label_comp_id = None;
    pdbx_ptnr3_label_seq_id = None;
    pdbx_PDB_id = None;
    pdbx_dist_value = None;
    pdbx_value_order = None;
    pdbx_leaving_atom_flag = None;
    pdbx_ptnr1_mod_name = None;
    pdbx_ptnr1_sugar_name = None;
    pdbx_ptnr1_replaced_atom = None;
    pdbx_ptnr3_auth_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "conn_type_id" -> { b with conn_type_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "ptnr1_label_alt_id" -> { b with ptnr1_label_alt_id = (Some v) }
      | "ptnr1_label_asym_id" -> { b with ptnr1_label_asym_id = (Some v) }
      | "ptnr1_label_atom_id" -> { b with ptnr1_label_atom_id = (Some v) }
      | "ptnr1_label_comp_id" -> { b with ptnr1_label_comp_id = (Some v) }
      | "ptnr1_label_seq_id" -> { b with ptnr1_label_seq_id = (PDBjDict.some_int v) }
      | "ptnr1_auth_asym_id" -> { b with ptnr1_auth_asym_id = (Some v) }
      | "ptnr1_auth_atom_id" -> { b with ptnr1_auth_atom_id = (Some v) }
      | "ptnr1_auth_comp_id" -> { b with ptnr1_auth_comp_id = (Some v) }
      | "ptnr1_auth_seq_id" -> { b with ptnr1_auth_seq_id = (Some v) }
      | "ptnr1_role" -> { b with ptnr1_role = (Some v) }
      | "ptnr1_symmetry" -> { b with ptnr1_symmetry = (Some v) }
      | "ptnr2_label_alt_id" -> { b with ptnr2_label_alt_id = (Some v) }
      | "ptnr2_label_asym_id" -> { b with ptnr2_label_asym_id = (Some v) }
      | "ptnr2_label_atom_id" -> { b with ptnr2_label_atom_id = (Some v) }
      | "ptnr2_label_comp_id" -> { b with ptnr2_label_comp_id = (Some v) }
      | "ptnr2_label_seq_id" -> { b with ptnr2_label_seq_id = (PDBjDict.some_int v) }
      | "ptnr2_auth_asym_id" -> { b with ptnr2_auth_asym_id = (Some v) }
      | "ptnr2_auth_atom_id" -> { b with ptnr2_auth_atom_id = (Some v) }
      | "ptnr2_auth_comp_id" -> { b with ptnr2_auth_comp_id = (Some v) }
      | "ptnr2_auth_seq_id" -> { b with ptnr2_auth_seq_id = (Some v) }
      | "ptnr2_role" -> { b with ptnr2_role = (Some v) }
      | "ptnr2_symmetry" -> { b with ptnr2_symmetry = (Some v) }
      | "pdbx_ptnr1_PDB_ins_code" -> { b with pdbx_ptnr1_PDB_ins_code = (Some v) }
      | "pdbx_ptnr1_auth_alt_id" -> { b with pdbx_ptnr1_auth_alt_id = (Some v) }
      | "pdbx_ptnr1_label_alt_id" -> { b with pdbx_ptnr1_label_alt_id = (Some v) }
      | "pdbx_ptnr1_standard_comp_id" -> { b with pdbx_ptnr1_standard_comp_id = (Some v) }
      | "pdbx_ptnr2_PDB_ins_code" -> { b with pdbx_ptnr2_PDB_ins_code = (Some v) }
      | "pdbx_ptnr2_auth_alt_id" -> { b with pdbx_ptnr2_auth_alt_id = (Some v) }
      | "pdbx_ptnr2_label_alt_id" -> { b with pdbx_ptnr2_label_alt_id = (Some v) }
      | "pdbx_ptnr3_auth_alt_id" -> { b with pdbx_ptnr3_auth_alt_id = (Some v) }
      | "pdbx_ptnr3_auth_asym_id" -> { b with pdbx_ptnr3_auth_asym_id = (Some v) }
      | "pdbx_ptnr3_auth_atom_id" -> { b with pdbx_ptnr3_auth_atom_id = (Some v) }
      | "pdbx_ptnr3_auth_comp_id" -> { b with pdbx_ptnr3_auth_comp_id = (Some v) }
      | "pdbx_ptnr3_PDB_ins_code" -> { b with pdbx_ptnr3_PDB_ins_code = (Some v) }
      | "pdbx_ptnr3_auth_seq_id" -> { b with pdbx_ptnr3_auth_seq_id = (Some v) }
      | "pdbx_ptnr3_label_alt_id" -> { b with pdbx_ptnr3_label_alt_id = (Some v) }
      | "pdbx_ptnr3_label_asym_id" -> { b with pdbx_ptnr3_label_asym_id = (Some v) }
      | "pdbx_ptnr3_label_atom_id" -> { b with pdbx_ptnr3_label_atom_id = (Some v) }
      | "pdbx_ptnr3_label_comp_id" -> { b with pdbx_ptnr3_label_comp_id = (Some v) }
      | "pdbx_ptnr3_label_seq_id" -> { b with pdbx_ptnr3_label_seq_id = (PDBjDict.some_int v) }
      | "pdbx_PDB_id" -> { b with pdbx_PDB_id = (Some v) }
      | "pdbx_dist_value" -> { b with pdbx_dist_value = (PDBjDict.some_float v) }
      | "pdbx_value_order" -> { b with pdbx_value_order = (Some v) }
      | "pdbx_leaving_atom_flag" -> { b with pdbx_leaving_atom_flag = (Some v) }
      | "pdbx_ptnr1_mod_name" -> { b with pdbx_ptnr1_mod_name = (Some v) }
      | "pdbx_ptnr1_sugar_name" -> { b with pdbx_ptnr1_sugar_name = (Some v) }
      | "pdbx_ptnr1_replaced_atom" -> { b with pdbx_ptnr1_replaced_atom = (Some v) }
      | "pdbx_ptnr3_auth_ins_code" -> { b with pdbx_ptnr3_auth_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("conn_type_id",  v)) a.conn_type_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("ptnr1_label_alt_id",  v)) a.ptnr1_label_alt_id;
      Option.map (fun v -> ("ptnr1_label_asym_id",  v)) a.ptnr1_label_asym_id;
      Option.map (fun v -> ("ptnr1_label_atom_id",  v)) a.ptnr1_label_atom_id;
      Option.map (fun v -> ("ptnr1_label_comp_id",  v)) a.ptnr1_label_comp_id;
      Option.map (fun v -> ("ptnr1_label_seq_id", string_of_int v)) a.ptnr1_label_seq_id;
      Option.map (fun v -> ("ptnr1_auth_asym_id",  v)) a.ptnr1_auth_asym_id;
      Option.map (fun v -> ("ptnr1_auth_atom_id",  v)) a.ptnr1_auth_atom_id;
      Option.map (fun v -> ("ptnr1_auth_comp_id",  v)) a.ptnr1_auth_comp_id;
      Option.map (fun v -> ("ptnr1_auth_seq_id",  v)) a.ptnr1_auth_seq_id;
      Option.map (fun v -> ("ptnr1_role",  v)) a.ptnr1_role;
      Option.map (fun v -> ("ptnr1_symmetry",  v)) a.ptnr1_symmetry;
      Option.map (fun v -> ("ptnr2_label_alt_id",  v)) a.ptnr2_label_alt_id;
      Option.map (fun v -> ("ptnr2_label_asym_id",  v)) a.ptnr2_label_asym_id;
      Option.map (fun v -> ("ptnr2_label_atom_id",  v)) a.ptnr2_label_atom_id;
      Option.map (fun v -> ("ptnr2_label_comp_id",  v)) a.ptnr2_label_comp_id;
      Option.map (fun v -> ("ptnr2_label_seq_id", string_of_int v)) a.ptnr2_label_seq_id;
      Option.map (fun v -> ("ptnr2_auth_asym_id",  v)) a.ptnr2_auth_asym_id;
      Option.map (fun v -> ("ptnr2_auth_atom_id",  v)) a.ptnr2_auth_atom_id;
      Option.map (fun v -> ("ptnr2_auth_comp_id",  v)) a.ptnr2_auth_comp_id;
      Option.map (fun v -> ("ptnr2_auth_seq_id",  v)) a.ptnr2_auth_seq_id;
      Option.map (fun v -> ("ptnr2_role",  v)) a.ptnr2_role;
      Option.map (fun v -> ("ptnr2_symmetry",  v)) a.ptnr2_symmetry;
      Option.map (fun v -> ("pdbx_ptnr1_PDB_ins_code",  v)) a.pdbx_ptnr1_PDB_ins_code;
      Option.map (fun v -> ("pdbx_ptnr1_auth_alt_id",  v)) a.pdbx_ptnr1_auth_alt_id;
      Option.map (fun v -> ("pdbx_ptnr1_label_alt_id",  v)) a.pdbx_ptnr1_label_alt_id;
      Option.map (fun v -> ("pdbx_ptnr1_standard_comp_id",  v)) a.pdbx_ptnr1_standard_comp_id;
      Option.map (fun v -> ("pdbx_ptnr2_PDB_ins_code",  v)) a.pdbx_ptnr2_PDB_ins_code;
      Option.map (fun v -> ("pdbx_ptnr2_auth_alt_id",  v)) a.pdbx_ptnr2_auth_alt_id;
      Option.map (fun v -> ("pdbx_ptnr2_label_alt_id",  v)) a.pdbx_ptnr2_label_alt_id;
      Option.map (fun v -> ("pdbx_ptnr3_auth_alt_id",  v)) a.pdbx_ptnr3_auth_alt_id;
      Option.map (fun v -> ("pdbx_ptnr3_auth_asym_id",  v)) a.pdbx_ptnr3_auth_asym_id;
      Option.map (fun v -> ("pdbx_ptnr3_auth_atom_id",  v)) a.pdbx_ptnr3_auth_atom_id;
      Option.map (fun v -> ("pdbx_ptnr3_auth_comp_id",  v)) a.pdbx_ptnr3_auth_comp_id;
      Option.map (fun v -> ("pdbx_ptnr3_PDB_ins_code",  v)) a.pdbx_ptnr3_PDB_ins_code;
      Option.map (fun v -> ("pdbx_ptnr3_auth_seq_id",  v)) a.pdbx_ptnr3_auth_seq_id;
      Option.map (fun v -> ("pdbx_ptnr3_label_alt_id",  v)) a.pdbx_ptnr3_label_alt_id;
      Option.map (fun v -> ("pdbx_ptnr3_label_asym_id",  v)) a.pdbx_ptnr3_label_asym_id;
      Option.map (fun v -> ("pdbx_ptnr3_label_atom_id",  v)) a.pdbx_ptnr3_label_atom_id;
      Option.map (fun v -> ("pdbx_ptnr3_label_comp_id",  v)) a.pdbx_ptnr3_label_comp_id;
      Option.map (fun v -> ("pdbx_ptnr3_label_seq_id", string_of_int v)) a.pdbx_ptnr3_label_seq_id;
      Option.map (fun v -> ("pdbx_PDB_id",  v)) a.pdbx_PDB_id;
      Option.map (fun v -> ("pdbx_dist_value", string_of_float v)) a.pdbx_dist_value;
      Option.map (fun v -> ("pdbx_value_order",  v)) a.pdbx_value_order;
      Option.map (fun v -> ("pdbx_leaving_atom_flag",  v)) a.pdbx_leaving_atom_flag;
      Option.map (fun v -> ("pdbx_ptnr1_mod_name",  v)) a.pdbx_ptnr1_mod_name;
      Option.map (fun v -> ("pdbx_ptnr1_sugar_name",  v)) a.pdbx_ptnr1_sugar_name;
      Option.map (fun v -> ("pdbx_ptnr1_replaced_atom",  v)) a.pdbx_ptnr1_replaced_atom;
      Option.map (fun v -> ("pdbx_ptnr3_auth_ins_code",  v)) a.pdbx_ptnr3_auth_ins_code;
    ]

end

module Struct_conn_type = struct
  type t = {
    criteria: string option;
    id: string option;
    reference: string option;
  }

  let default = {
    criteria = None;
    id = None;
    reference = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "criteria" -> { b with criteria = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "reference" -> { b with reference = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("criteria",  v)) a.criteria;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("reference",  v)) a.reference;
    ]

end

module Struct_keywords = struct
  type t = {
    entry_id: string option;
    text: string option;
    pdbx_keywords: string option;
    pdbx_details: string option;
  }

  let default = {
    entry_id = None;
    text = None;
    pdbx_keywords = None;
    pdbx_details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "text" -> { b with text = (Some v) }
      | "pdbx_keywords" -> { b with pdbx_keywords = (Some v) }
      | "pdbx_details" -> { b with pdbx_details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("text",  v)) a.text;
      Option.map (fun v -> ("pdbx_keywords",  v)) a.pdbx_keywords;
      Option.map (fun v -> ("pdbx_details",  v)) a.pdbx_details;
    ]

end

module Struct_mon_details = struct
  type t = {
    entry_id: string option;
    prot_cis: float option;
    rSCC: string option;
    rSR: string option;
  }

  let default = {
    entry_id = None;
    prot_cis = None;
    rSCC = None;
    rSR = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "prot_cis" -> { b with prot_cis = (PDBjDict.some_float v) }
      | "RSCC" -> { b with rSCC = (Some v) }
      | "RSR" -> { b with rSR = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("prot_cis", string_of_float v)) a.prot_cis;
      Option.map (fun v -> ("RSCC",  v)) a.rSCC;
      Option.map (fun v -> ("RSR",  v)) a.rSR;
    ]

end

module Struct_mon_nucl = struct
  type t = {
    alpha: float option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    beta: float option;
    chi1: float option;
    chi2: float option;
    delta: float option;
    details: float option;
    epsilon: float option;
    gamma: float option;
    label_alt_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    mean_B_all: float option;
    mean_B_base: float option;
    mean_B_phos: float option;
    mean_B_sugar: float option;
    nu0: float option;
    nu1: float option;
    nu2: float option;
    nu3: float option;
    nu4: float option;
    p: float option;
    rSCC_all: float option;
    rSCC_base: float option;
    rSCC_phos: float option;
    rSCC_sugar: float option;
    rSR_all: float option;
    rSR_base: float option;
    rSR_phos: float option;
    rSR_sugar: float option;
    tau0: float option;
    tau1: float option;
    tau2: float option;
    tau3: float option;
    tau4: float option;
    taum: float option;
    zeta: float option;
  }

  let default = {
    alpha = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    beta = None;
    chi1 = None;
    chi2 = None;
    delta = None;
    details = None;
    epsilon = None;
    gamma = None;
    label_alt_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    mean_B_all = None;
    mean_B_base = None;
    mean_B_phos = None;
    mean_B_sugar = None;
    nu0 = None;
    nu1 = None;
    nu2 = None;
    nu3 = None;
    nu4 = None;
    p = None;
    rSCC_all = None;
    rSCC_base = None;
    rSCC_phos = None;
    rSCC_sugar = None;
    rSR_all = None;
    rSR_base = None;
    rSR_phos = None;
    rSR_sugar = None;
    tau0 = None;
    tau1 = None;
    tau2 = None;
    tau3 = None;
    tau4 = None;
    taum = None;
    zeta = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "alpha" -> { b with alpha = (PDBjDict.some_float v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "beta" -> { b with beta = (PDBjDict.some_float v) }
      | "chi1" -> { b with chi1 = (PDBjDict.some_float v) }
      | "chi2" -> { b with chi2 = (PDBjDict.some_float v) }
      | "delta" -> { b with delta = (PDBjDict.some_float v) }
      | "details" -> { b with details = (PDBjDict.some_float v) }
      | "epsilon" -> { b with epsilon = (PDBjDict.some_float v) }
      | "gamma" -> { b with gamma = (PDBjDict.some_float v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "mean_B_all" -> { b with mean_B_all = (PDBjDict.some_float v) }
      | "mean_B_base" -> { b with mean_B_base = (PDBjDict.some_float v) }
      | "mean_B_phos" -> { b with mean_B_phos = (PDBjDict.some_float v) }
      | "mean_B_sugar" -> { b with mean_B_sugar = (PDBjDict.some_float v) }
      | "nu0" -> { b with nu0 = (PDBjDict.some_float v) }
      | "nu1" -> { b with nu1 = (PDBjDict.some_float v) }
      | "nu2" -> { b with nu2 = (PDBjDict.some_float v) }
      | "nu3" -> { b with nu3 = (PDBjDict.some_float v) }
      | "nu4" -> { b with nu4 = (PDBjDict.some_float v) }
      | "P" -> { b with p = (PDBjDict.some_float v) }
      | "RSCC_all" -> { b with rSCC_all = (PDBjDict.some_float v) }
      | "RSCC_base" -> { b with rSCC_base = (PDBjDict.some_float v) }
      | "RSCC_phos" -> { b with rSCC_phos = (PDBjDict.some_float v) }
      | "RSCC_sugar" -> { b with rSCC_sugar = (PDBjDict.some_float v) }
      | "RSR_all" -> { b with rSR_all = (PDBjDict.some_float v) }
      | "RSR_base" -> { b with rSR_base = (PDBjDict.some_float v) }
      | "RSR_phos" -> { b with rSR_phos = (PDBjDict.some_float v) }
      | "RSR_sugar" -> { b with rSR_sugar = (PDBjDict.some_float v) }
      | "tau0" -> { b with tau0 = (PDBjDict.some_float v) }
      | "tau1" -> { b with tau1 = (PDBjDict.some_float v) }
      | "tau2" -> { b with tau2 = (PDBjDict.some_float v) }
      | "tau3" -> { b with tau3 = (PDBjDict.some_float v) }
      | "tau4" -> { b with tau4 = (PDBjDict.some_float v) }
      | "taum" -> { b with taum = (PDBjDict.some_float v) }
      | "zeta" -> { b with zeta = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("alpha", string_of_float v)) a.alpha;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("beta", string_of_float v)) a.beta;
      Option.map (fun v -> ("chi1", string_of_float v)) a.chi1;
      Option.map (fun v -> ("chi2", string_of_float v)) a.chi2;
      Option.map (fun v -> ("delta", string_of_float v)) a.delta;
      Option.map (fun v -> ("details", string_of_float v)) a.details;
      Option.map (fun v -> ("epsilon", string_of_float v)) a.epsilon;
      Option.map (fun v -> ("gamma", string_of_float v)) a.gamma;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("mean_B_all", string_of_float v)) a.mean_B_all;
      Option.map (fun v -> ("mean_B_base", string_of_float v)) a.mean_B_base;
      Option.map (fun v -> ("mean_B_phos", string_of_float v)) a.mean_B_phos;
      Option.map (fun v -> ("mean_B_sugar", string_of_float v)) a.mean_B_sugar;
      Option.map (fun v -> ("nu0", string_of_float v)) a.nu0;
      Option.map (fun v -> ("nu1", string_of_float v)) a.nu1;
      Option.map (fun v -> ("nu2", string_of_float v)) a.nu2;
      Option.map (fun v -> ("nu3", string_of_float v)) a.nu3;
      Option.map (fun v -> ("nu4", string_of_float v)) a.nu4;
      Option.map (fun v -> ("P", string_of_float v)) a.p;
      Option.map (fun v -> ("RSCC_all", string_of_float v)) a.rSCC_all;
      Option.map (fun v -> ("RSCC_base", string_of_float v)) a.rSCC_base;
      Option.map (fun v -> ("RSCC_phos", string_of_float v)) a.rSCC_phos;
      Option.map (fun v -> ("RSCC_sugar", string_of_float v)) a.rSCC_sugar;
      Option.map (fun v -> ("RSR_all", string_of_float v)) a.rSR_all;
      Option.map (fun v -> ("RSR_base", string_of_float v)) a.rSR_base;
      Option.map (fun v -> ("RSR_phos", string_of_float v)) a.rSR_phos;
      Option.map (fun v -> ("RSR_sugar", string_of_float v)) a.rSR_sugar;
      Option.map (fun v -> ("tau0", string_of_float v)) a.tau0;
      Option.map (fun v -> ("tau1", string_of_float v)) a.tau1;
      Option.map (fun v -> ("tau2", string_of_float v)) a.tau2;
      Option.map (fun v -> ("tau3", string_of_float v)) a.tau3;
      Option.map (fun v -> ("tau4", string_of_float v)) a.tau4;
      Option.map (fun v -> ("taum", string_of_float v)) a.taum;
      Option.map (fun v -> ("zeta", string_of_float v)) a.zeta;
    ]

end

module Struct_mon_prot = struct
  type t = {
    chi1: float option;
    chi2: float option;
    chi3: float option;
    chi4: float option;
    chi5: float option;
    details: float option;
    label_alt_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    rSCC_all: float option;
    rSCC_main: float option;
    rSCC_side: float option;
    rSR_all: float option;
    rSR_main: float option;
    rSR_side: float option;
    mean_B_all: float option;
    mean_B_main: float option;
    mean_B_side: float option;
    omega: float option;
    phi: float option;
    psi: float option;
  }

  let default = {
    chi1 = None;
    chi2 = None;
    chi3 = None;
    chi4 = None;
    chi5 = None;
    details = None;
    label_alt_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    rSCC_all = None;
    rSCC_main = None;
    rSCC_side = None;
    rSR_all = None;
    rSR_main = None;
    rSR_side = None;
    mean_B_all = None;
    mean_B_main = None;
    mean_B_side = None;
    omega = None;
    phi = None;
    psi = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "chi1" -> { b with chi1 = (PDBjDict.some_float v) }
      | "chi2" -> { b with chi2 = (PDBjDict.some_float v) }
      | "chi3" -> { b with chi3 = (PDBjDict.some_float v) }
      | "chi4" -> { b with chi4 = (PDBjDict.some_float v) }
      | "chi5" -> { b with chi5 = (PDBjDict.some_float v) }
      | "details" -> { b with details = (PDBjDict.some_float v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "RSCC_all" -> { b with rSCC_all = (PDBjDict.some_float v) }
      | "RSCC_main" -> { b with rSCC_main = (PDBjDict.some_float v) }
      | "RSCC_side" -> { b with rSCC_side = (PDBjDict.some_float v) }
      | "RSR_all" -> { b with rSR_all = (PDBjDict.some_float v) }
      | "RSR_main" -> { b with rSR_main = (PDBjDict.some_float v) }
      | "RSR_side" -> { b with rSR_side = (PDBjDict.some_float v) }
      | "mean_B_all" -> { b with mean_B_all = (PDBjDict.some_float v) }
      | "mean_B_main" -> { b with mean_B_main = (PDBjDict.some_float v) }
      | "mean_B_side" -> { b with mean_B_side = (PDBjDict.some_float v) }
      | "omega" -> { b with omega = (PDBjDict.some_float v) }
      | "phi" -> { b with phi = (PDBjDict.some_float v) }
      | "psi" -> { b with psi = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("chi1", string_of_float v)) a.chi1;
      Option.map (fun v -> ("chi2", string_of_float v)) a.chi2;
      Option.map (fun v -> ("chi3", string_of_float v)) a.chi3;
      Option.map (fun v -> ("chi4", string_of_float v)) a.chi4;
      Option.map (fun v -> ("chi5", string_of_float v)) a.chi5;
      Option.map (fun v -> ("details", string_of_float v)) a.details;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("RSCC_all", string_of_float v)) a.rSCC_all;
      Option.map (fun v -> ("RSCC_main", string_of_float v)) a.rSCC_main;
      Option.map (fun v -> ("RSCC_side", string_of_float v)) a.rSCC_side;
      Option.map (fun v -> ("RSR_all", string_of_float v)) a.rSR_all;
      Option.map (fun v -> ("RSR_main", string_of_float v)) a.rSR_main;
      Option.map (fun v -> ("RSR_side", string_of_float v)) a.rSR_side;
      Option.map (fun v -> ("mean_B_all", string_of_float v)) a.mean_B_all;
      Option.map (fun v -> ("mean_B_main", string_of_float v)) a.mean_B_main;
      Option.map (fun v -> ("mean_B_side", string_of_float v)) a.mean_B_side;
      Option.map (fun v -> ("omega", string_of_float v)) a.omega;
      Option.map (fun v -> ("phi", string_of_float v)) a.phi;
      Option.map (fun v -> ("psi", string_of_float v)) a.psi;
    ]

end

module Struct_mon_prot_cis = struct
  type t = {
    label_alt_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pdbx_auth_asym_id_2: string option;
    pdbx_auth_comp_id_2: string option;
    pdbx_auth_seq_id_2: string option;
    pdbx_label_asym_id_2: string option;
    pdbx_label_comp_id_2: string option;
    pdbx_label_seq_id_2: int option;
    pdbx_PDB_ins_code: string option;
    pdbx_PDB_ins_code_2: string option;
    pdbx_PDB_model_num: int option;
    pdbx_omega_angle: string option;
    pdbx_id: string option;
    pdbx_auth_ins_code: string option;
    pdbx_auth_ins_code_2: string option;
  }

  let default = {
    label_alt_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pdbx_auth_asym_id_2 = None;
    pdbx_auth_comp_id_2 = None;
    pdbx_auth_seq_id_2 = None;
    pdbx_label_asym_id_2 = None;
    pdbx_label_comp_id_2 = None;
    pdbx_label_seq_id_2 = None;
    pdbx_PDB_ins_code = None;
    pdbx_PDB_ins_code_2 = None;
    pdbx_PDB_model_num = None;
    pdbx_omega_angle = None;
    pdbx_id = None;
    pdbx_auth_ins_code = None;
    pdbx_auth_ins_code_2 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "pdbx_auth_asym_id_2" -> { b with pdbx_auth_asym_id_2 = (Some v) }
      | "pdbx_auth_comp_id_2" -> { b with pdbx_auth_comp_id_2 = (Some v) }
      | "pdbx_auth_seq_id_2" -> { b with pdbx_auth_seq_id_2 = (Some v) }
      | "pdbx_label_asym_id_2" -> { b with pdbx_label_asym_id_2 = (Some v) }
      | "pdbx_label_comp_id_2" -> { b with pdbx_label_comp_id_2 = (Some v) }
      | "pdbx_label_seq_id_2" -> { b with pdbx_label_seq_id_2 = (PDBjDict.some_int v) }
      | "pdbx_PDB_ins_code" -> { b with pdbx_PDB_ins_code = (Some v) }
      | "pdbx_PDB_ins_code_2" -> { b with pdbx_PDB_ins_code_2 = (Some v) }
      | "pdbx_PDB_model_num" -> { b with pdbx_PDB_model_num = (PDBjDict.some_int v) }
      | "pdbx_omega_angle" -> { b with pdbx_omega_angle = (Some v) }
      | "pdbx_id" -> { b with pdbx_id = (Some v) }
      | "pdbx_auth_ins_code" -> { b with pdbx_auth_ins_code = (Some v) }
      | "pdbx_auth_ins_code_2" -> { b with pdbx_auth_ins_code_2 = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("pdbx_auth_asym_id_2",  v)) a.pdbx_auth_asym_id_2;
      Option.map (fun v -> ("pdbx_auth_comp_id_2",  v)) a.pdbx_auth_comp_id_2;
      Option.map (fun v -> ("pdbx_auth_seq_id_2",  v)) a.pdbx_auth_seq_id_2;
      Option.map (fun v -> ("pdbx_label_asym_id_2",  v)) a.pdbx_label_asym_id_2;
      Option.map (fun v -> ("pdbx_label_comp_id_2",  v)) a.pdbx_label_comp_id_2;
      Option.map (fun v -> ("pdbx_label_seq_id_2", string_of_int v)) a.pdbx_label_seq_id_2;
      Option.map (fun v -> ("pdbx_PDB_ins_code",  v)) a.pdbx_PDB_ins_code;
      Option.map (fun v -> ("pdbx_PDB_ins_code_2",  v)) a.pdbx_PDB_ins_code_2;
      Option.map (fun v -> ("pdbx_PDB_model_num", string_of_int v)) a.pdbx_PDB_model_num;
      Option.map (fun v -> ("pdbx_omega_angle",  v)) a.pdbx_omega_angle;
      Option.map (fun v -> ("pdbx_id",  v)) a.pdbx_id;
      Option.map (fun v -> ("pdbx_auth_ins_code",  v)) a.pdbx_auth_ins_code;
      Option.map (fun v -> ("pdbx_auth_ins_code_2",  v)) a.pdbx_auth_ins_code_2;
    ]

end

module Struct_ncs_dom = struct
  type t = {
    details: string option;
    id: string option;
    pdbx_ens_id: string option;
  }

  let default = {
    details = None;
    id = None;
    pdbx_ens_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "pdbx_ens_id" -> { b with pdbx_ens_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("pdbx_ens_id",  v)) a.pdbx_ens_id;
    ]

end

module Struct_ncs_dom_lim = struct
  type t = {
    beg_label_alt_id: string option;
    beg_label_asym_id: string option;
    beg_label_comp_id: string option;
    beg_label_seq_id: int option;
    beg_auth_asym_id: string option;
    beg_auth_comp_id: string option;
    beg_auth_seq_id: string option;
    dom_id: string option;
    end_label_alt_id: string option;
    end_label_asym_id: string option;
    end_label_comp_id: string option;
    end_label_seq_id: int option;
    end_auth_asym_id: string option;
    end_auth_comp_id: string option;
    end_auth_seq_id: string option;
    selection_details: string option;
    pdbx_component_id: int option;
    pdbx_refine_code: float option;
    pdbx_ens_id: string option;
  }

  let default = {
    beg_label_alt_id = None;
    beg_label_asym_id = None;
    beg_label_comp_id = None;
    beg_label_seq_id = None;
    beg_auth_asym_id = None;
    beg_auth_comp_id = None;
    beg_auth_seq_id = None;
    dom_id = None;
    end_label_alt_id = None;
    end_label_asym_id = None;
    end_label_comp_id = None;
    end_label_seq_id = None;
    end_auth_asym_id = None;
    end_auth_comp_id = None;
    end_auth_seq_id = None;
    selection_details = None;
    pdbx_component_id = None;
    pdbx_refine_code = None;
    pdbx_ens_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "beg_label_alt_id" -> { b with beg_label_alt_id = (Some v) }
      | "beg_label_asym_id" -> { b with beg_label_asym_id = (Some v) }
      | "beg_label_comp_id" -> { b with beg_label_comp_id = (Some v) }
      | "beg_label_seq_id" -> { b with beg_label_seq_id = (PDBjDict.some_int v) }
      | "beg_auth_asym_id" -> { b with beg_auth_asym_id = (Some v) }
      | "beg_auth_comp_id" -> { b with beg_auth_comp_id = (Some v) }
      | "beg_auth_seq_id" -> { b with beg_auth_seq_id = (Some v) }
      | "dom_id" -> { b with dom_id = (Some v) }
      | "end_label_alt_id" -> { b with end_label_alt_id = (Some v) }
      | "end_label_asym_id" -> { b with end_label_asym_id = (Some v) }
      | "end_label_comp_id" -> { b with end_label_comp_id = (Some v) }
      | "end_label_seq_id" -> { b with end_label_seq_id = (PDBjDict.some_int v) }
      | "end_auth_asym_id" -> { b with end_auth_asym_id = (Some v) }
      | "end_auth_comp_id" -> { b with end_auth_comp_id = (Some v) }
      | "end_auth_seq_id" -> { b with end_auth_seq_id = (Some v) }
      | "selection_details" -> { b with selection_details = (Some v) }
      | "pdbx_component_id" -> { b with pdbx_component_id = (PDBjDict.some_int v) }
      | "pdbx_refine_code" -> { b with pdbx_refine_code = (PDBjDict.some_float v) }
      | "pdbx_ens_id" -> { b with pdbx_ens_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("beg_label_alt_id",  v)) a.beg_label_alt_id;
      Option.map (fun v -> ("beg_label_asym_id",  v)) a.beg_label_asym_id;
      Option.map (fun v -> ("beg_label_comp_id",  v)) a.beg_label_comp_id;
      Option.map (fun v -> ("beg_label_seq_id", string_of_int v)) a.beg_label_seq_id;
      Option.map (fun v -> ("beg_auth_asym_id",  v)) a.beg_auth_asym_id;
      Option.map (fun v -> ("beg_auth_comp_id",  v)) a.beg_auth_comp_id;
      Option.map (fun v -> ("beg_auth_seq_id",  v)) a.beg_auth_seq_id;
      Option.map (fun v -> ("dom_id",  v)) a.dom_id;
      Option.map (fun v -> ("end_label_alt_id",  v)) a.end_label_alt_id;
      Option.map (fun v -> ("end_label_asym_id",  v)) a.end_label_asym_id;
      Option.map (fun v -> ("end_label_comp_id",  v)) a.end_label_comp_id;
      Option.map (fun v -> ("end_label_seq_id", string_of_int v)) a.end_label_seq_id;
      Option.map (fun v -> ("end_auth_asym_id",  v)) a.end_auth_asym_id;
      Option.map (fun v -> ("end_auth_comp_id",  v)) a.end_auth_comp_id;
      Option.map (fun v -> ("end_auth_seq_id",  v)) a.end_auth_seq_id;
      Option.map (fun v -> ("selection_details",  v)) a.selection_details;
      Option.map (fun v -> ("pdbx_component_id", string_of_int v)) a.pdbx_component_id;
      Option.map (fun v -> ("pdbx_refine_code", string_of_float v)) a.pdbx_refine_code;
      Option.map (fun v -> ("pdbx_ens_id",  v)) a.pdbx_ens_id;
    ]

end

module Struct_ncs_ens = struct
  type t = {
    details: string option;
    id: string option;
    point_group: string option;
  }

  let default = {
    details = None;
    id = None;
    point_group = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "point_group" -> { b with point_group = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("point_group",  v)) a.point_group;
    ]

end

module Struct_ncs_ens_gen = struct
  type t = {
    dom_id_1: string option;
    dom_id_2: string option;
    ens_id: string option;
    oper_id: string option;
  }

  let default = {
    dom_id_1 = None;
    dom_id_2 = None;
    ens_id = None;
    oper_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "dom_id_1" -> { b with dom_id_1 = (Some v) }
      | "dom_id_2" -> { b with dom_id_2 = (Some v) }
      | "ens_id" -> { b with ens_id = (Some v) }
      | "oper_id" -> { b with oper_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("dom_id_1",  v)) a.dom_id_1;
      Option.map (fun v -> ("dom_id_2",  v)) a.dom_id_2;
      Option.map (fun v -> ("ens_id",  v)) a.ens_id;
      Option.map (fun v -> ("oper_id",  v)) a.oper_id;
    ]

end

module Struct_ncs_oper = struct
  type t = {
    code: string option;
    details: string option;
    id: string option;
    matrix11: float option;
    matrix12: float option;
    matrix13: float option;
    matrix21: float option;
    matrix22: float option;
    matrix23: float option;
    matrix31: float option;
    matrix32: float option;
    matrix33: float option;
    vector1: float option;
    vector2: float option;
    vector3: float option;
  }

  let default = {
    code = None;
    details = None;
    id = None;
    matrix11 = None;
    matrix12 = None;
    matrix13 = None;
    matrix21 = None;
    matrix22 = None;
    matrix23 = None;
    matrix31 = None;
    matrix32 = None;
    matrix33 = None;
    vector1 = None;
    vector2 = None;
    vector3 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "code" -> { b with code = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "matrix[1][1]" -> { b with matrix11 = (PDBjDict.some_float v) }
      | "matrix[1][2]" -> { b with matrix12 = (PDBjDict.some_float v) }
      | "matrix[1][3]" -> { b with matrix13 = (PDBjDict.some_float v) }
      | "matrix[2][1]" -> { b with matrix21 = (PDBjDict.some_float v) }
      | "matrix[2][2]" -> { b with matrix22 = (PDBjDict.some_float v) }
      | "matrix[2][3]" -> { b with matrix23 = (PDBjDict.some_float v) }
      | "matrix[3][1]" -> { b with matrix31 = (PDBjDict.some_float v) }
      | "matrix[3][2]" -> { b with matrix32 = (PDBjDict.some_float v) }
      | "matrix[3][3]" -> { b with matrix33 = (PDBjDict.some_float v) }
      | "vector[1]" -> { b with vector1 = (PDBjDict.some_float v) }
      | "vector[2]" -> { b with vector2 = (PDBjDict.some_float v) }
      | "vector[3]" -> { b with vector3 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("code",  v)) a.code;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("matrix[1][1]", string_of_float v)) a.matrix11;
      Option.map (fun v -> ("matrix[1][2]", string_of_float v)) a.matrix12;
      Option.map (fun v -> ("matrix[1][3]", string_of_float v)) a.matrix13;
      Option.map (fun v -> ("matrix[2][1]", string_of_float v)) a.matrix21;
      Option.map (fun v -> ("matrix[2][2]", string_of_float v)) a.matrix22;
      Option.map (fun v -> ("matrix[2][3]", string_of_float v)) a.matrix23;
      Option.map (fun v -> ("matrix[3][1]", string_of_float v)) a.matrix31;
      Option.map (fun v -> ("matrix[3][2]", string_of_float v)) a.matrix32;
      Option.map (fun v -> ("matrix[3][3]", string_of_float v)) a.matrix33;
      Option.map (fun v -> ("vector[1]", string_of_float v)) a.vector1;
      Option.map (fun v -> ("vector[2]", string_of_float v)) a.vector2;
      Option.map (fun v -> ("vector[3]", string_of_float v)) a.vector3;
    ]

end

module Struct_ref = struct
  type t = {
    biol_id: string option;
    db_code: string option;
    db_name: string option;
    details: string option;
    entity_id: string option;
    id: string option;
    seq_align: string option;
    seq_dif: string option;
    pdbx_db_accession: string option;
    pdbx_db_isoform: string option;
    pdbx_seq_one_letter_code: string option;
    pdbx_align_begin: string option;
    pdbx_align_end: string option;
  }

  let default = {
    biol_id = None;
    db_code = None;
    db_name = None;
    details = None;
    entity_id = None;
    id = None;
    seq_align = None;
    seq_dif = None;
    pdbx_db_accession = None;
    pdbx_db_isoform = None;
    pdbx_seq_one_letter_code = None;
    pdbx_align_begin = None;
    pdbx_align_end = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "biol_id" -> { b with biol_id = (Some v) }
      | "db_code" -> { b with db_code = (Some v) }
      | "db_name" -> { b with db_name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "seq_align" -> { b with seq_align = (Some v) }
      | "seq_dif" -> { b with seq_dif = (Some v) }
      | "pdbx_db_accession" -> { b with pdbx_db_accession = (Some v) }
      | "pdbx_db_isoform" -> { b with pdbx_db_isoform = (Some v) }
      | "pdbx_seq_one_letter_code" -> { b with pdbx_seq_one_letter_code = (Some v) }
      | "pdbx_align_begin" -> { b with pdbx_align_begin = (Some v) }
      | "pdbx_align_end" -> { b with pdbx_align_end = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("biol_id",  v)) a.biol_id;
      Option.map (fun v -> ("db_code",  v)) a.db_code;
      Option.map (fun v -> ("db_name",  v)) a.db_name;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("seq_align",  v)) a.seq_align;
      Option.map (fun v -> ("seq_dif",  v)) a.seq_dif;
      Option.map (fun v -> ("pdbx_db_accession",  v)) a.pdbx_db_accession;
      Option.map (fun v -> ("pdbx_db_isoform",  v)) a.pdbx_db_isoform;
      Option.map (fun v -> ("pdbx_seq_one_letter_code",  v)) a.pdbx_seq_one_letter_code;
      Option.map (fun v -> ("pdbx_align_begin",  v)) a.pdbx_align_begin;
      Option.map (fun v -> ("pdbx_align_end",  v)) a.pdbx_align_end;
    ]

end

module Struct_ref_seq = struct
  type t = {
    align_id: string option;
    db_align_beg: int option;
    db_align_end: int option;
    details: string option;
    ref_id: string option;
    seq_align_beg: int option;
    seq_align_end: int option;
    pdbx_strand_id: string option;
    pdbx_db_accession: string option;
    pdbx_db_align_beg_ins_code: string option;
    pdbx_db_align_end_ins_code: string option;
    pdbx_PDB_id_code: string option;
    pdbx_auth_seq_align_beg: string option;
    pdbx_auth_seq_align_end: string option;
    pdbx_seq_align_beg_ins_code: string option;
    pdbx_seq_align_end_ins_code: string option;
  }

  let default = {
    align_id = None;
    db_align_beg = None;
    db_align_end = None;
    details = None;
    ref_id = None;
    seq_align_beg = None;
    seq_align_end = None;
    pdbx_strand_id = None;
    pdbx_db_accession = None;
    pdbx_db_align_beg_ins_code = None;
    pdbx_db_align_end_ins_code = None;
    pdbx_PDB_id_code = None;
    pdbx_auth_seq_align_beg = None;
    pdbx_auth_seq_align_end = None;
    pdbx_seq_align_beg_ins_code = None;
    pdbx_seq_align_end_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "align_id" -> { b with align_id = (Some v) }
      | "db_align_beg" -> { b with db_align_beg = (PDBjDict.some_int v) }
      | "db_align_end" -> { b with db_align_end = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "ref_id" -> { b with ref_id = (Some v) }
      | "seq_align_beg" -> { b with seq_align_beg = (PDBjDict.some_int v) }
      | "seq_align_end" -> { b with seq_align_end = (PDBjDict.some_int v) }
      | "pdbx_strand_id" -> { b with pdbx_strand_id = (Some v) }
      | "pdbx_db_accession" -> { b with pdbx_db_accession = (Some v) }
      | "pdbx_db_align_beg_ins_code" -> { b with pdbx_db_align_beg_ins_code = (Some v) }
      | "pdbx_db_align_end_ins_code" -> { b with pdbx_db_align_end_ins_code = (Some v) }
      | "pdbx_PDB_id_code" -> { b with pdbx_PDB_id_code = (Some v) }
      | "pdbx_auth_seq_align_beg" -> { b with pdbx_auth_seq_align_beg = (Some v) }
      | "pdbx_auth_seq_align_end" -> { b with pdbx_auth_seq_align_end = (Some v) }
      | "pdbx_seq_align_beg_ins_code" -> { b with pdbx_seq_align_beg_ins_code = (Some v) }
      | "pdbx_seq_align_end_ins_code" -> { b with pdbx_seq_align_end_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("align_id",  v)) a.align_id;
      Option.map (fun v -> ("db_align_beg", string_of_int v)) a.db_align_beg;
      Option.map (fun v -> ("db_align_end", string_of_int v)) a.db_align_end;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("ref_id",  v)) a.ref_id;
      Option.map (fun v -> ("seq_align_beg", string_of_int v)) a.seq_align_beg;
      Option.map (fun v -> ("seq_align_end", string_of_int v)) a.seq_align_end;
      Option.map (fun v -> ("pdbx_strand_id",  v)) a.pdbx_strand_id;
      Option.map (fun v -> ("pdbx_db_accession",  v)) a.pdbx_db_accession;
      Option.map (fun v -> ("pdbx_db_align_beg_ins_code",  v)) a.pdbx_db_align_beg_ins_code;
      Option.map (fun v -> ("pdbx_db_align_end_ins_code",  v)) a.pdbx_db_align_end_ins_code;
      Option.map (fun v -> ("pdbx_PDB_id_code",  v)) a.pdbx_PDB_id_code;
      Option.map (fun v -> ("pdbx_auth_seq_align_beg",  v)) a.pdbx_auth_seq_align_beg;
      Option.map (fun v -> ("pdbx_auth_seq_align_end",  v)) a.pdbx_auth_seq_align_end;
      Option.map (fun v -> ("pdbx_seq_align_beg_ins_code",  v)) a.pdbx_seq_align_beg_ins_code;
      Option.map (fun v -> ("pdbx_seq_align_end_ins_code",  v)) a.pdbx_seq_align_end_ins_code;
    ]

end

module Struct_ref_seq_dif = struct
  type t = {
    align_id: string option;
    db_mon_id: string option;
    details: string option;
    mon_id: string option;
    seq_num: int option;
    pdbx_pdb_id_code: string option;
    pdbx_pdb_strand_id: string option;
    pdbx_pdb_ins_code: string option;
    pdbx_auth_seq_num: string option;
    pdbx_seq_db_name: string option;
    pdbx_seq_db_accession_code: string option;
    pdbx_seq_db_seq_num: string option;
    pdbx_ordinal: int option;
  }

  let default = {
    align_id = None;
    db_mon_id = None;
    details = None;
    mon_id = None;
    seq_num = None;
    pdbx_pdb_id_code = None;
    pdbx_pdb_strand_id = None;
    pdbx_pdb_ins_code = None;
    pdbx_auth_seq_num = None;
    pdbx_seq_db_name = None;
    pdbx_seq_db_accession_code = None;
    pdbx_seq_db_seq_num = None;
    pdbx_ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "align_id" -> { b with align_id = (Some v) }
      | "db_mon_id" -> { b with db_mon_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "mon_id" -> { b with mon_id = (Some v) }
      | "seq_num" -> { b with seq_num = (PDBjDict.some_int v) }
      | "pdbx_pdb_id_code" -> { b with pdbx_pdb_id_code = (Some v) }
      | "pdbx_pdb_strand_id" -> { b with pdbx_pdb_strand_id = (Some v) }
      | "pdbx_pdb_ins_code" -> { b with pdbx_pdb_ins_code = (Some v) }
      | "pdbx_auth_seq_num" -> { b with pdbx_auth_seq_num = (Some v) }
      | "pdbx_seq_db_name" -> { b with pdbx_seq_db_name = (Some v) }
      | "pdbx_seq_db_accession_code" -> { b with pdbx_seq_db_accession_code = (Some v) }
      | "pdbx_seq_db_seq_num" -> { b with pdbx_seq_db_seq_num = (Some v) }
      | "pdbx_ordinal" -> { b with pdbx_ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("align_id",  v)) a.align_id;
      Option.map (fun v -> ("db_mon_id",  v)) a.db_mon_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("mon_id",  v)) a.mon_id;
      Option.map (fun v -> ("seq_num", string_of_int v)) a.seq_num;
      Option.map (fun v -> ("pdbx_pdb_id_code",  v)) a.pdbx_pdb_id_code;
      Option.map (fun v -> ("pdbx_pdb_strand_id",  v)) a.pdbx_pdb_strand_id;
      Option.map (fun v -> ("pdbx_pdb_ins_code",  v)) a.pdbx_pdb_ins_code;
      Option.map (fun v -> ("pdbx_auth_seq_num",  v)) a.pdbx_auth_seq_num;
      Option.map (fun v -> ("pdbx_seq_db_name",  v)) a.pdbx_seq_db_name;
      Option.map (fun v -> ("pdbx_seq_db_accession_code",  v)) a.pdbx_seq_db_accession_code;
      Option.map (fun v -> ("pdbx_seq_db_seq_num",  v)) a.pdbx_seq_db_seq_num;
      Option.map (fun v -> ("pdbx_ordinal", string_of_int v)) a.pdbx_ordinal;
    ]

end

module Struct_sheet = struct
  type t = {
    details: string option;
    id: string option;
    number_strands: int option;
    type_: string option;
  }

  let default = {
    details = None;
    id = None;
    number_strands = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "number_strands" -> { b with number_strands = (PDBjDict.some_int v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("number_strands", string_of_int v)) a.number_strands;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Struct_sheet_hbond = struct
  type t = {
    range_1_beg_label_atom_id: string option;
    range_1_beg_label_seq_id: int option;
    range_1_end_label_atom_id: string option;
    range_1_end_label_seq_id: int option;
    range_2_beg_label_atom_id: string option;
    range_2_beg_label_seq_id: int option;
    range_2_end_label_atom_id: string option;
    range_2_end_label_seq_id: int option;
    range_1_beg_auth_atom_id: string option;
    range_1_beg_auth_seq_id: string option;
    range_1_end_auth_atom_id: string option;
    range_1_end_auth_seq_id: string option;
    range_2_beg_auth_atom_id: string option;
    range_2_beg_auth_seq_id: string option;
    range_2_end_auth_atom_id: string option;
    range_2_end_auth_seq_id: string option;
    range_id_1: string option;
    range_id_2: string option;
    sheet_id: string option;
    pdbx_range_1_beg_auth_comp_id: string option;
    pdbx_range_1_beg_auth_asym_id: string option;
    pdbx_range_1_end_auth_comp_id: string option;
    pdbx_range_1_end_auth_asym_id: string option;
    pdbx_range_1_beg_label_comp_id: string option;
    pdbx_range_1_beg_label_asym_id: string option;
    pdbx_range_1_beg_PDB_ins_code: string option;
    pdbx_range_1_end_label_comp_id: string option;
    pdbx_range_1_end_label_asym_id: string option;
    pdbx_range_1_end_PDB_ins_code: string option;
    pdbx_range_2_beg_label_comp_id: string option;
    pdbx_range_2_beg_label_asym_id: string option;
    pdbx_range_2_beg_PDB_ins_code: string option;
    pdbx_range_2_end_label_comp_id: string option;
    pdbx_range_2_end_label_asym_id: string option;
    pdbx_range_2_end_label_ins_code: string option;
  }

  let default = {
    range_1_beg_label_atom_id = None;
    range_1_beg_label_seq_id = None;
    range_1_end_label_atom_id = None;
    range_1_end_label_seq_id = None;
    range_2_beg_label_atom_id = None;
    range_2_beg_label_seq_id = None;
    range_2_end_label_atom_id = None;
    range_2_end_label_seq_id = None;
    range_1_beg_auth_atom_id = None;
    range_1_beg_auth_seq_id = None;
    range_1_end_auth_atom_id = None;
    range_1_end_auth_seq_id = None;
    range_2_beg_auth_atom_id = None;
    range_2_beg_auth_seq_id = None;
    range_2_end_auth_atom_id = None;
    range_2_end_auth_seq_id = None;
    range_id_1 = None;
    range_id_2 = None;
    sheet_id = None;
    pdbx_range_1_beg_auth_comp_id = None;
    pdbx_range_1_beg_auth_asym_id = None;
    pdbx_range_1_end_auth_comp_id = None;
    pdbx_range_1_end_auth_asym_id = None;
    pdbx_range_1_beg_label_comp_id = None;
    pdbx_range_1_beg_label_asym_id = None;
    pdbx_range_1_beg_PDB_ins_code = None;
    pdbx_range_1_end_label_comp_id = None;
    pdbx_range_1_end_label_asym_id = None;
    pdbx_range_1_end_PDB_ins_code = None;
    pdbx_range_2_beg_label_comp_id = None;
    pdbx_range_2_beg_label_asym_id = None;
    pdbx_range_2_beg_PDB_ins_code = None;
    pdbx_range_2_end_label_comp_id = None;
    pdbx_range_2_end_label_asym_id = None;
    pdbx_range_2_end_label_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "range_1_beg_label_atom_id" -> { b with range_1_beg_label_atom_id = (Some v) }
      | "range_1_beg_label_seq_id" -> { b with range_1_beg_label_seq_id = (PDBjDict.some_int v) }
      | "range_1_end_label_atom_id" -> { b with range_1_end_label_atom_id = (Some v) }
      | "range_1_end_label_seq_id" -> { b with range_1_end_label_seq_id = (PDBjDict.some_int v) }
      | "range_2_beg_label_atom_id" -> { b with range_2_beg_label_atom_id = (Some v) }
      | "range_2_beg_label_seq_id" -> { b with range_2_beg_label_seq_id = (PDBjDict.some_int v) }
      | "range_2_end_label_atom_id" -> { b with range_2_end_label_atom_id = (Some v) }
      | "range_2_end_label_seq_id" -> { b with range_2_end_label_seq_id = (PDBjDict.some_int v) }
      | "range_1_beg_auth_atom_id" -> { b with range_1_beg_auth_atom_id = (Some v) }
      | "range_1_beg_auth_seq_id" -> { b with range_1_beg_auth_seq_id = (Some v) }
      | "range_1_end_auth_atom_id" -> { b with range_1_end_auth_atom_id = (Some v) }
      | "range_1_end_auth_seq_id" -> { b with range_1_end_auth_seq_id = (Some v) }
      | "range_2_beg_auth_atom_id" -> { b with range_2_beg_auth_atom_id = (Some v) }
      | "range_2_beg_auth_seq_id" -> { b with range_2_beg_auth_seq_id = (Some v) }
      | "range_2_end_auth_atom_id" -> { b with range_2_end_auth_atom_id = (Some v) }
      | "range_2_end_auth_seq_id" -> { b with range_2_end_auth_seq_id = (Some v) }
      | "range_id_1" -> { b with range_id_1 = (Some v) }
      | "range_id_2" -> { b with range_id_2 = (Some v) }
      | "sheet_id" -> { b with sheet_id = (Some v) }
      | "pdbx_range_1_beg_auth_comp_id" -> { b with pdbx_range_1_beg_auth_comp_id = (Some v) }
      | "pdbx_range_1_beg_auth_asym_id" -> { b with pdbx_range_1_beg_auth_asym_id = (Some v) }
      | "pdbx_range_1_end_auth_comp_id" -> { b with pdbx_range_1_end_auth_comp_id = (Some v) }
      | "pdbx_range_1_end_auth_asym_id" -> { b with pdbx_range_1_end_auth_asym_id = (Some v) }
      | "pdbx_range_1_beg_label_comp_id" -> { b with pdbx_range_1_beg_label_comp_id = (Some v) }
      | "pdbx_range_1_beg_label_asym_id" -> { b with pdbx_range_1_beg_label_asym_id = (Some v) }
      | "pdbx_range_1_beg_PDB_ins_code" -> { b with pdbx_range_1_beg_PDB_ins_code = (Some v) }
      | "pdbx_range_1_end_label_comp_id" -> { b with pdbx_range_1_end_label_comp_id = (Some v) }
      | "pdbx_range_1_end_label_asym_id" -> { b with pdbx_range_1_end_label_asym_id = (Some v) }
      | "pdbx_range_1_end_PDB_ins_code" -> { b with pdbx_range_1_end_PDB_ins_code = (Some v) }
      | "pdbx_range_2_beg_label_comp_id" -> { b with pdbx_range_2_beg_label_comp_id = (Some v) }
      | "pdbx_range_2_beg_label_asym_id" -> { b with pdbx_range_2_beg_label_asym_id = (Some v) }
      | "pdbx_range_2_beg_PDB_ins_code" -> { b with pdbx_range_2_beg_PDB_ins_code = (Some v) }
      | "pdbx_range_2_end_label_comp_id" -> { b with pdbx_range_2_end_label_comp_id = (Some v) }
      | "pdbx_range_2_end_label_asym_id" -> { b with pdbx_range_2_end_label_asym_id = (Some v) }
      | "pdbx_range_2_end_label_ins_code" -> { b with pdbx_range_2_end_label_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("range_1_beg_label_atom_id",  v)) a.range_1_beg_label_atom_id;
      Option.map (fun v -> ("range_1_beg_label_seq_id", string_of_int v)) a.range_1_beg_label_seq_id;
      Option.map (fun v -> ("range_1_end_label_atom_id",  v)) a.range_1_end_label_atom_id;
      Option.map (fun v -> ("range_1_end_label_seq_id", string_of_int v)) a.range_1_end_label_seq_id;
      Option.map (fun v -> ("range_2_beg_label_atom_id",  v)) a.range_2_beg_label_atom_id;
      Option.map (fun v -> ("range_2_beg_label_seq_id", string_of_int v)) a.range_2_beg_label_seq_id;
      Option.map (fun v -> ("range_2_end_label_atom_id",  v)) a.range_2_end_label_atom_id;
      Option.map (fun v -> ("range_2_end_label_seq_id", string_of_int v)) a.range_2_end_label_seq_id;
      Option.map (fun v -> ("range_1_beg_auth_atom_id",  v)) a.range_1_beg_auth_atom_id;
      Option.map (fun v -> ("range_1_beg_auth_seq_id",  v)) a.range_1_beg_auth_seq_id;
      Option.map (fun v -> ("range_1_end_auth_atom_id",  v)) a.range_1_end_auth_atom_id;
      Option.map (fun v -> ("range_1_end_auth_seq_id",  v)) a.range_1_end_auth_seq_id;
      Option.map (fun v -> ("range_2_beg_auth_atom_id",  v)) a.range_2_beg_auth_atom_id;
      Option.map (fun v -> ("range_2_beg_auth_seq_id",  v)) a.range_2_beg_auth_seq_id;
      Option.map (fun v -> ("range_2_end_auth_atom_id",  v)) a.range_2_end_auth_atom_id;
      Option.map (fun v -> ("range_2_end_auth_seq_id",  v)) a.range_2_end_auth_seq_id;
      Option.map (fun v -> ("range_id_1",  v)) a.range_id_1;
      Option.map (fun v -> ("range_id_2",  v)) a.range_id_2;
      Option.map (fun v -> ("sheet_id",  v)) a.sheet_id;
      Option.map (fun v -> ("pdbx_range_1_beg_auth_comp_id",  v)) a.pdbx_range_1_beg_auth_comp_id;
      Option.map (fun v -> ("pdbx_range_1_beg_auth_asym_id",  v)) a.pdbx_range_1_beg_auth_asym_id;
      Option.map (fun v -> ("pdbx_range_1_end_auth_comp_id",  v)) a.pdbx_range_1_end_auth_comp_id;
      Option.map (fun v -> ("pdbx_range_1_end_auth_asym_id",  v)) a.pdbx_range_1_end_auth_asym_id;
      Option.map (fun v -> ("pdbx_range_1_beg_label_comp_id",  v)) a.pdbx_range_1_beg_label_comp_id;
      Option.map (fun v -> ("pdbx_range_1_beg_label_asym_id",  v)) a.pdbx_range_1_beg_label_asym_id;
      Option.map (fun v -> ("pdbx_range_1_beg_PDB_ins_code",  v)) a.pdbx_range_1_beg_PDB_ins_code;
      Option.map (fun v -> ("pdbx_range_1_end_label_comp_id",  v)) a.pdbx_range_1_end_label_comp_id;
      Option.map (fun v -> ("pdbx_range_1_end_label_asym_id",  v)) a.pdbx_range_1_end_label_asym_id;
      Option.map (fun v -> ("pdbx_range_1_end_PDB_ins_code",  v)) a.pdbx_range_1_end_PDB_ins_code;
      Option.map (fun v -> ("pdbx_range_2_beg_label_comp_id",  v)) a.pdbx_range_2_beg_label_comp_id;
      Option.map (fun v -> ("pdbx_range_2_beg_label_asym_id",  v)) a.pdbx_range_2_beg_label_asym_id;
      Option.map (fun v -> ("pdbx_range_2_beg_PDB_ins_code",  v)) a.pdbx_range_2_beg_PDB_ins_code;
      Option.map (fun v -> ("pdbx_range_2_end_label_comp_id",  v)) a.pdbx_range_2_end_label_comp_id;
      Option.map (fun v -> ("pdbx_range_2_end_label_asym_id",  v)) a.pdbx_range_2_end_label_asym_id;
      Option.map (fun v -> ("pdbx_range_2_end_label_ins_code",  v)) a.pdbx_range_2_end_label_ins_code;
    ]

end

module Struct_sheet_order = struct
  type t = {
    offset: int option;
    range_id_1: string option;
    range_id_2: string option;
    sense: string option;
    sheet_id: string option;
  }

  let default = {
    offset = None;
    range_id_1 = None;
    range_id_2 = None;
    sense = None;
    sheet_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "offset" -> { b with offset = (PDBjDict.some_int v) }
      | "range_id_1" -> { b with range_id_1 = (Some v) }
      | "range_id_2" -> { b with range_id_2 = (Some v) }
      | "sense" -> { b with sense = (Some v) }
      | "sheet_id" -> { b with sheet_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("offset", string_of_int v)) a.offset;
      Option.map (fun v -> ("range_id_1",  v)) a.range_id_1;
      Option.map (fun v -> ("range_id_2",  v)) a.range_id_2;
      Option.map (fun v -> ("sense",  v)) a.sense;
      Option.map (fun v -> ("sheet_id",  v)) a.sheet_id;
    ]

end

module Struct_sheet_range = struct
  type t = {
    beg_label_asym_id: string option;
    beg_label_comp_id: string option;
    beg_label_seq_id: int option;
    end_label_asym_id: string option;
    end_label_comp_id: string option;
    end_label_seq_id: int option;
    beg_auth_asym_id: string option;
    beg_auth_comp_id: string option;
    beg_auth_seq_id: string option;
    end_auth_asym_id: string option;
    end_auth_comp_id: string option;
    end_auth_seq_id: string option;
    id: string option;
    sheet_id: string option;
    symmetry: string option;
    pdbx_beg_PDB_ins_code: string option;
    pdbx_end_PDB_ins_code: string option;
  }

  let default = {
    beg_label_asym_id = None;
    beg_label_comp_id = None;
    beg_label_seq_id = None;
    end_label_asym_id = None;
    end_label_comp_id = None;
    end_label_seq_id = None;
    beg_auth_asym_id = None;
    beg_auth_comp_id = None;
    beg_auth_seq_id = None;
    end_auth_asym_id = None;
    end_auth_comp_id = None;
    end_auth_seq_id = None;
    id = None;
    sheet_id = None;
    symmetry = None;
    pdbx_beg_PDB_ins_code = None;
    pdbx_end_PDB_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "beg_label_asym_id" -> { b with beg_label_asym_id = (Some v) }
      | "beg_label_comp_id" -> { b with beg_label_comp_id = (Some v) }
      | "beg_label_seq_id" -> { b with beg_label_seq_id = (PDBjDict.some_int v) }
      | "end_label_asym_id" -> { b with end_label_asym_id = (Some v) }
      | "end_label_comp_id" -> { b with end_label_comp_id = (Some v) }
      | "end_label_seq_id" -> { b with end_label_seq_id = (PDBjDict.some_int v) }
      | "beg_auth_asym_id" -> { b with beg_auth_asym_id = (Some v) }
      | "beg_auth_comp_id" -> { b with beg_auth_comp_id = (Some v) }
      | "beg_auth_seq_id" -> { b with beg_auth_seq_id = (Some v) }
      | "end_auth_asym_id" -> { b with end_auth_asym_id = (Some v) }
      | "end_auth_comp_id" -> { b with end_auth_comp_id = (Some v) }
      | "end_auth_seq_id" -> { b with end_auth_seq_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "sheet_id" -> { b with sheet_id = (Some v) }
      | "symmetry" -> { b with symmetry = (Some v) }
      | "pdbx_beg_PDB_ins_code" -> { b with pdbx_beg_PDB_ins_code = (Some v) }
      | "pdbx_end_PDB_ins_code" -> { b with pdbx_end_PDB_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("beg_label_asym_id",  v)) a.beg_label_asym_id;
      Option.map (fun v -> ("beg_label_comp_id",  v)) a.beg_label_comp_id;
      Option.map (fun v -> ("beg_label_seq_id", string_of_int v)) a.beg_label_seq_id;
      Option.map (fun v -> ("end_label_asym_id",  v)) a.end_label_asym_id;
      Option.map (fun v -> ("end_label_comp_id",  v)) a.end_label_comp_id;
      Option.map (fun v -> ("end_label_seq_id", string_of_int v)) a.end_label_seq_id;
      Option.map (fun v -> ("beg_auth_asym_id",  v)) a.beg_auth_asym_id;
      Option.map (fun v -> ("beg_auth_comp_id",  v)) a.beg_auth_comp_id;
      Option.map (fun v -> ("beg_auth_seq_id",  v)) a.beg_auth_seq_id;
      Option.map (fun v -> ("end_auth_asym_id",  v)) a.end_auth_asym_id;
      Option.map (fun v -> ("end_auth_comp_id",  v)) a.end_auth_comp_id;
      Option.map (fun v -> ("end_auth_seq_id",  v)) a.end_auth_seq_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("sheet_id",  v)) a.sheet_id;
      Option.map (fun v -> ("symmetry",  v)) a.symmetry;
      Option.map (fun v -> ("pdbx_beg_PDB_ins_code",  v)) a.pdbx_beg_PDB_ins_code;
      Option.map (fun v -> ("pdbx_end_PDB_ins_code",  v)) a.pdbx_end_PDB_ins_code;
    ]

end

module Struct_sheet_topology = struct
  type t = {
    offset: int option;
    range_id_1: string option;
    range_id_2: string option;
    sense: string option;
    sheet_id: string option;
  }

  let default = {
    offset = None;
    range_id_1 = None;
    range_id_2 = None;
    sense = None;
    sheet_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "offset" -> { b with offset = (PDBjDict.some_int v) }
      | "range_id_1" -> { b with range_id_1 = (Some v) }
      | "range_id_2" -> { b with range_id_2 = (Some v) }
      | "sense" -> { b with sense = (Some v) }
      | "sheet_id" -> { b with sheet_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("offset", string_of_int v)) a.offset;
      Option.map (fun v -> ("range_id_1",  v)) a.range_id_1;
      Option.map (fun v -> ("range_id_2",  v)) a.range_id_2;
      Option.map (fun v -> ("sense",  v)) a.sense;
      Option.map (fun v -> ("sheet_id",  v)) a.sheet_id;
    ]

end

module Struct_site = struct
  type t = {
    details: string option;
    id: string option;
    pdbx_num_residues: int option;
    pdbx_evidence_code: string option;
    pdbx_auth_asym_id: string option;
    pdbx_auth_comp_id: string option;
    pdbx_auth_seq_id: string option;
    pdbx_auth_ins_code: string option;
  }

  let default = {
    details = None;
    id = None;
    pdbx_num_residues = None;
    pdbx_evidence_code = None;
    pdbx_auth_asym_id = None;
    pdbx_auth_comp_id = None;
    pdbx_auth_seq_id = None;
    pdbx_auth_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "pdbx_num_residues" -> { b with pdbx_num_residues = (PDBjDict.some_int v) }
      | "pdbx_evidence_code" -> { b with pdbx_evidence_code = (Some v) }
      | "pdbx_auth_asym_id" -> { b with pdbx_auth_asym_id = (Some v) }
      | "pdbx_auth_comp_id" -> { b with pdbx_auth_comp_id = (Some v) }
      | "pdbx_auth_seq_id" -> { b with pdbx_auth_seq_id = (Some v) }
      | "pdbx_auth_ins_code" -> { b with pdbx_auth_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("pdbx_num_residues", string_of_int v)) a.pdbx_num_residues;
      Option.map (fun v -> ("pdbx_evidence_code",  v)) a.pdbx_evidence_code;
      Option.map (fun v -> ("pdbx_auth_asym_id",  v)) a.pdbx_auth_asym_id;
      Option.map (fun v -> ("pdbx_auth_comp_id",  v)) a.pdbx_auth_comp_id;
      Option.map (fun v -> ("pdbx_auth_seq_id",  v)) a.pdbx_auth_seq_id;
      Option.map (fun v -> ("pdbx_auth_ins_code",  v)) a.pdbx_auth_ins_code;
    ]

end

module Struct_site_gen = struct
  type t = {
    details: string option;
    id: string option;
    label_alt_id: string option;
    label_asym_id: string option;
    label_atom_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    auth_asym_id: string option;
    auth_atom_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    site_id: string option;
    symmetry: string option;
    pdbx_auth_ins_code: string option;
    pdbx_num_res: int option;
  }

  let default = {
    details = None;
    id = None;
    label_alt_id = None;
    label_asym_id = None;
    label_atom_id = None;
    label_comp_id = None;
    label_seq_id = None;
    auth_asym_id = None;
    auth_atom_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    site_id = None;
    symmetry = None;
    pdbx_auth_ins_code = None;
    pdbx_num_res = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_atom_id" -> { b with label_atom_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_atom_id" -> { b with auth_atom_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "site_id" -> { b with site_id = (Some v) }
      | "symmetry" -> { b with symmetry = (Some v) }
      | "pdbx_auth_ins_code" -> { b with pdbx_auth_ins_code = (Some v) }
      | "pdbx_num_res" -> { b with pdbx_num_res = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_atom_id",  v)) a.label_atom_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_atom_id",  v)) a.auth_atom_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("site_id",  v)) a.site_id;
      Option.map (fun v -> ("symmetry",  v)) a.symmetry;
      Option.map (fun v -> ("pdbx_auth_ins_code",  v)) a.pdbx_auth_ins_code;
      Option.map (fun v -> ("pdbx_num_res", string_of_int v)) a.pdbx_num_res;
    ]

end

module Struct_site_keywords = struct
  type t = {
    site_id: string option;
    text: string option;
  }

  let default = {
    site_id = None;
    text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "site_id" -> { b with site_id = (Some v) }
      | "text" -> { b with text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("site_id",  v)) a.site_id;
      Option.map (fun v -> ("text",  v)) a.text;
    ]

end

module Struct_site_view = struct
  type t = {
    details: string option;
    id: string option;
    rot_matrix11: float option;
    rot_matrix12: float option;
    rot_matrix13: float option;
    rot_matrix21: float option;
    rot_matrix22: float option;
    rot_matrix23: float option;
    rot_matrix31: float option;
    rot_matrix32: float option;
    rot_matrix33: float option;
    site_id: string option;
  }

  let default = {
    details = None;
    id = None;
    rot_matrix11 = None;
    rot_matrix12 = None;
    rot_matrix13 = None;
    rot_matrix21 = None;
    rot_matrix22 = None;
    rot_matrix23 = None;
    rot_matrix31 = None;
    rot_matrix32 = None;
    rot_matrix33 = None;
    site_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "rot_matrix[1][1]" -> { b with rot_matrix11 = (PDBjDict.some_float v) }
      | "rot_matrix[1][2]" -> { b with rot_matrix12 = (PDBjDict.some_float v) }
      | "rot_matrix[1][3]" -> { b with rot_matrix13 = (PDBjDict.some_float v) }
      | "rot_matrix[2][1]" -> { b with rot_matrix21 = (PDBjDict.some_float v) }
      | "rot_matrix[2][2]" -> { b with rot_matrix22 = (PDBjDict.some_float v) }
      | "rot_matrix[2][3]" -> { b with rot_matrix23 = (PDBjDict.some_float v) }
      | "rot_matrix[3][1]" -> { b with rot_matrix31 = (PDBjDict.some_float v) }
      | "rot_matrix[3][2]" -> { b with rot_matrix32 = (PDBjDict.some_float v) }
      | "rot_matrix[3][3]" -> { b with rot_matrix33 = (PDBjDict.some_float v) }
      | "site_id" -> { b with site_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("rot_matrix[1][1]", string_of_float v)) a.rot_matrix11;
      Option.map (fun v -> ("rot_matrix[1][2]", string_of_float v)) a.rot_matrix12;
      Option.map (fun v -> ("rot_matrix[1][3]", string_of_float v)) a.rot_matrix13;
      Option.map (fun v -> ("rot_matrix[2][1]", string_of_float v)) a.rot_matrix21;
      Option.map (fun v -> ("rot_matrix[2][2]", string_of_float v)) a.rot_matrix22;
      Option.map (fun v -> ("rot_matrix[2][3]", string_of_float v)) a.rot_matrix23;
      Option.map (fun v -> ("rot_matrix[3][1]", string_of_float v)) a.rot_matrix31;
      Option.map (fun v -> ("rot_matrix[3][2]", string_of_float v)) a.rot_matrix32;
      Option.map (fun v -> ("rot_matrix[3][3]", string_of_float v)) a.rot_matrix33;
      Option.map (fun v -> ("site_id",  v)) a.site_id;
    ]

end

module Symmetry = struct
  type t = {
    entry_id: string option;
    cell_setting: string option;
    int_Tables_number: int option;
    space_group_name_Hall: string option;
    space_group_name_H_M: string option;
    pdbx_full_space_group_name_H_M: string option;
  }

  let default = {
    entry_id = None;
    cell_setting = None;
    int_Tables_number = None;
    space_group_name_Hall = None;
    space_group_name_H_M = None;
    pdbx_full_space_group_name_H_M = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "cell_setting" -> { b with cell_setting = (Some v) }
      | "Int_Tables_number" -> { b with int_Tables_number = (PDBjDict.some_int v) }
      | "space_group_name_Hall" -> { b with space_group_name_Hall = (Some v) }
      | "space_group_name_H-M" -> { b with space_group_name_H_M = (Some v) }
      | "pdbx_full_space_group_name_H-M" -> { b with pdbx_full_space_group_name_H_M = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("cell_setting",  v)) a.cell_setting;
      Option.map (fun v -> ("Int_Tables_number", string_of_int v)) a.int_Tables_number;
      Option.map (fun v -> ("space_group_name_Hall",  v)) a.space_group_name_Hall;
      Option.map (fun v -> ("space_group_name_H-M",  v)) a.space_group_name_H_M;
      Option.map (fun v -> ("pdbx_full_space_group_name_H-M",  v)) a.pdbx_full_space_group_name_H_M;
    ]

end

module Symmetry_equiv = struct
  type t = {
    id: string option;
    pos_as_xyz: string option;
  }

  let default = {
    id = None;
    pos_as_xyz = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "pos_as_xyz" -> { b with pos_as_xyz = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("pos_as_xyz",  v)) a.pos_as_xyz;
    ]

end

module Audit_link = struct
  type t = {
    block_code: string option;
    block_description: string option;
  }

  let default = {
    block_code = None;
    block_description = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "block_code" -> { b with block_code = (Some v) }
      | "block_description" -> { b with block_description = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("block_code",  v)) a.block_code;
      Option.map (fun v -> ("block_description",  v)) a.block_description;
    ]

end

module Diffrn_reflns_class = struct
  type t = {
    av_R_eq: float option;
    av_sgI_over_I: float option;
    av_uI_over_I: float option;
    code: string option;
    description: string option;
    d_res_high: float option;
    d_res_low: float option;
    number: int option;
  }

  let default = {
    av_R_eq = None;
    av_sgI_over_I = None;
    av_uI_over_I = None;
    code = None;
    description = None;
    d_res_high = None;
    d_res_low = None;
    number = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "av_R_eq" -> { b with av_R_eq = (PDBjDict.some_float v) }
      | "av_sgI/I" -> { b with av_sgI_over_I = (PDBjDict.some_float v) }
      | "av_uI/I" -> { b with av_uI_over_I = (PDBjDict.some_float v) }
      | "code" -> { b with code = (Some v) }
      | "description" -> { b with description = (Some v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "number" -> { b with number = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("av_R_eq", string_of_float v)) a.av_R_eq;
      Option.map (fun v -> ("av_sgI/I", string_of_float v)) a.av_sgI_over_I;
      Option.map (fun v -> ("av_uI/I", string_of_float v)) a.av_uI_over_I;
      Option.map (fun v -> ("code",  v)) a.code;
      Option.map (fun v -> ("description",  v)) a.description;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("number", string_of_int v)) a.number;
    ]

end

module Refine_ls_class = struct
  type t = {
    code: string option;
    d_res_high: float option;
    d_res_low: float option;
    r_factor_gt: float option;
    r_factor_all: float option;
    r_Fsqd_factor: float option;
    r_I_factor: float option;
    wR_factor_all: float option;
  }

  let default = {
    code = None;
    d_res_high = None;
    d_res_low = None;
    r_factor_gt = None;
    r_factor_all = None;
    r_Fsqd_factor = None;
    r_I_factor = None;
    wR_factor_all = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "code" -> { b with code = (Some v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "R_factor_gt" -> { b with r_factor_gt = (PDBjDict.some_float v) }
      | "R_factor_all" -> { b with r_factor_all = (PDBjDict.some_float v) }
      | "R_Fsqd_factor" -> { b with r_Fsqd_factor = (PDBjDict.some_float v) }
      | "R_I_factor" -> { b with r_I_factor = (PDBjDict.some_float v) }
      | "wR_factor_all" -> { b with wR_factor_all = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("code",  v)) a.code;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("R_factor_gt", string_of_float v)) a.r_factor_gt;
      Option.map (fun v -> ("R_factor_all", string_of_float v)) a.r_factor_all;
      Option.map (fun v -> ("R_Fsqd_factor", string_of_float v)) a.r_Fsqd_factor;
      Option.map (fun v -> ("R_I_factor", string_of_float v)) a.r_I_factor;
      Option.map (fun v -> ("wR_factor_all", string_of_float v)) a.wR_factor_all;
    ]

end

module Reflns_class = struct
  type t = {
    code: string option;
    description: string option;
    d_res_high: float option;
    d_res_low: float option;
    number_gt: int option;
    number_total: int option;
    r_factor_all: float option;
    r_factor_gt: float option;
    r_Fsqd_factor: float option;
    r_I_factor: float option;
    wR_factor_all: float option;
  }

  let default = {
    code = None;
    description = None;
    d_res_high = None;
    d_res_low = None;
    number_gt = None;
    number_total = None;
    r_factor_all = None;
    r_factor_gt = None;
    r_Fsqd_factor = None;
    r_I_factor = None;
    wR_factor_all = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "code" -> { b with code = (Some v) }
      | "description" -> { b with description = (Some v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "number_gt" -> { b with number_gt = (PDBjDict.some_int v) }
      | "number_total" -> { b with number_total = (PDBjDict.some_int v) }
      | "R_factor_all" -> { b with r_factor_all = (PDBjDict.some_float v) }
      | "R_factor_gt" -> { b with r_factor_gt = (PDBjDict.some_float v) }
      | "R_Fsqd_factor" -> { b with r_Fsqd_factor = (PDBjDict.some_float v) }
      | "R_I_factor" -> { b with r_I_factor = (PDBjDict.some_float v) }
      | "wR_factor_all" -> { b with wR_factor_all = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("code",  v)) a.code;
      Option.map (fun v -> ("description",  v)) a.description;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("number_gt", string_of_int v)) a.number_gt;
      Option.map (fun v -> ("number_total", string_of_int v)) a.number_total;
      Option.map (fun v -> ("R_factor_all", string_of_float v)) a.r_factor_all;
      Option.map (fun v -> ("R_factor_gt", string_of_float v)) a.r_factor_gt;
      Option.map (fun v -> ("R_Fsqd_factor", string_of_float v)) a.r_Fsqd_factor;
      Option.map (fun v -> ("R_I_factor", string_of_float v)) a.r_I_factor;
      Option.map (fun v -> ("wR_factor_all", string_of_float v)) a.wR_factor_all;
    ]

end

module Space_group = struct
  type t = {
    crystal_system: string option;
    id: string option;
    iT_number: int option;
    name_Hall: string option;
    name_H_M_alt: string option;
  }

  let default = {
    crystal_system = None;
    id = None;
    iT_number = None;
    name_Hall = None;
    name_H_M_alt = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "crystal_system" -> { b with crystal_system = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "IT_number" -> { b with iT_number = (PDBjDict.some_int v) }
      | "name_Hall" -> { b with name_Hall = (Some v) }
      | "name_H-M_alt" -> { b with name_H_M_alt = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("crystal_system",  v)) a.crystal_system;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("IT_number", string_of_int v)) a.iT_number;
      Option.map (fun v -> ("name_Hall",  v)) a.name_Hall;
      Option.map (fun v -> ("name_H-M_alt",  v)) a.name_H_M_alt;
    ]

end

module Space_group_symop = struct
  type t = {
    id: string option;
    operation_xyz: string option;
    sg_id: string option;
  }

  let default = {
    id = None;
    operation_xyz = None;
    sg_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "operation_xyz" -> { b with operation_xyz = (Some v) }
      | "sg_id" -> { b with sg_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("operation_xyz",  v)) a.operation_xyz;
      Option.map (fun v -> ("sg_id",  v)) a.sg_id;
    ]

end

module Valence_param = struct
  type t = {
    atom_1: string option;
    atom_1_valence: int option;
    atom_2: string option;
    atom_2_valence: int option;
    b: float option;
    details: string option;
    id: string option;
    ref_id: string option;
    ro: float option;
  }

  let default = {
    atom_1 = None;
    atom_1_valence = None;
    atom_2 = None;
    atom_2_valence = None;
    b = None;
    details = None;
    id = None;
    ref_id = None;
    ro = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_1" -> { b with atom_1 = (Some v) }
      | "atom_1_valence" -> { b with atom_1_valence = (PDBjDict.some_int v) }
      | "atom_2" -> { b with atom_2 = (Some v) }
      | "atom_2_valence" -> { b with atom_2_valence = (PDBjDict.some_int v) }
      | "B" -> { b with b = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "ref_id" -> { b with ref_id = (Some v) }
      | "Ro" -> { b with ro = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_1",  v)) a.atom_1;
      Option.map (fun v -> ("atom_1_valence", string_of_int v)) a.atom_1_valence;
      Option.map (fun v -> ("atom_2",  v)) a.atom_2;
      Option.map (fun v -> ("atom_2_valence", string_of_int v)) a.atom_2_valence;
      Option.map (fun v -> ("B", string_of_float v)) a.b;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("ref_id",  v)) a.ref_id;
      Option.map (fun v -> ("Ro", string_of_float v)) a.ro;
    ]

end

module Valence_ref = struct
  type t = {
    id: string option;
    reference: string option;
  }

  let default = {
    id = None;
    reference = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "reference" -> { b with reference = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("reference",  v)) a.reference;
    ]

end

module Pdbx_audit = struct
  type t = {
    entry_id: string option;
    current_version: string option;
  }

  let default = {
    entry_id = None;
    current_version = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "current_version" -> { b with current_version = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("current_version",  v)) a.current_version;
    ]

end

module Pdbx_version = struct
  type t = {
    entry_id: string option;
    revision_date: string option;
    major_version: int option;
    minor_version: string option;
    details: string option;
    revision_type: string option;
  }

  let default = {
    entry_id = None;
    revision_date = None;
    major_version = None;
    minor_version = None;
    details = None;
    revision_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "revision_date" -> { b with revision_date = (Some v) }
      | "major_version" -> { b with major_version = (PDBjDict.some_int v) }
      | "minor_version" -> { b with minor_version = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "revision_type" -> { b with revision_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("revision_date",  v)) a.revision_date;
      Option.map (fun v -> ("major_version", string_of_int v)) a.major_version;
      Option.map (fun v -> ("minor_version",  v)) a.minor_version;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("revision_type",  v)) a.revision_type;
    ]

end

module Pdbx_audit_author = struct
  type t = {
    address: string option;
    name: string option;
    ordinal: int option;
  }

  let default = {
    address = None;
    name = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "address" -> { b with address = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("address",  v)) a.address;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Pdbx_database_message = struct
  type t = {
    entry_id: string option;
    message_id: string option;
    date: string option;
    content_type: string option;
    message_type: string option;
    sender: string option;
    sender_address_fax: string option;
    sender_address_phone: string option;
    sender_address_email: string option;
    sender_address_mail: string option;
    receiver: string option;
    receiver_address_fax: string option;
    receiver_address_phone: string option;
    receiver_address_email: string option;
    receiver_address_mail: string option;
    message: string option;
  }

  let default = {
    entry_id = None;
    message_id = None;
    date = None;
    content_type = None;
    message_type = None;
    sender = None;
    sender_address_fax = None;
    sender_address_phone = None;
    sender_address_email = None;
    sender_address_mail = None;
    receiver = None;
    receiver_address_fax = None;
    receiver_address_phone = None;
    receiver_address_email = None;
    receiver_address_mail = None;
    message = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "message_id" -> { b with message_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "content_type" -> { b with content_type = (Some v) }
      | "message_type" -> { b with message_type = (Some v) }
      | "sender" -> { b with sender = (Some v) }
      | "sender_address_fax" -> { b with sender_address_fax = (Some v) }
      | "sender_address_phone" -> { b with sender_address_phone = (Some v) }
      | "sender_address_email" -> { b with sender_address_email = (Some v) }
      | "sender_address_mail" -> { b with sender_address_mail = (Some v) }
      | "receiver" -> { b with receiver = (Some v) }
      | "receiver_address_fax" -> { b with receiver_address_fax = (Some v) }
      | "receiver_address_phone" -> { b with receiver_address_phone = (Some v) }
      | "receiver_address_email" -> { b with receiver_address_email = (Some v) }
      | "receiver_address_mail" -> { b with receiver_address_mail = (Some v) }
      | "message" -> { b with message = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("message_id",  v)) a.message_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("content_type",  v)) a.content_type;
      Option.map (fun v -> ("message_type",  v)) a.message_type;
      Option.map (fun v -> ("sender",  v)) a.sender;
      Option.map (fun v -> ("sender_address_fax",  v)) a.sender_address_fax;
      Option.map (fun v -> ("sender_address_phone",  v)) a.sender_address_phone;
      Option.map (fun v -> ("sender_address_email",  v)) a.sender_address_email;
      Option.map (fun v -> ("sender_address_mail",  v)) a.sender_address_mail;
      Option.map (fun v -> ("receiver",  v)) a.receiver;
      Option.map (fun v -> ("receiver_address_fax",  v)) a.receiver_address_fax;
      Option.map (fun v -> ("receiver_address_phone",  v)) a.receiver_address_phone;
      Option.map (fun v -> ("receiver_address_email",  v)) a.receiver_address_email;
      Option.map (fun v -> ("receiver_address_mail",  v)) a.receiver_address_mail;
      Option.map (fun v -> ("message",  v)) a.message;
    ]

end

module Pdbx_database_PDB_obs_spr = struct
  type t = {
    id: string option;
    date: string option;
    pdb_id: string option;
    replace_pdb_id: string option;
    details: string option;
  }

  let default = {
    id = None;
    date = None;
    pdb_id = None;
    replace_pdb_id = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "pdb_id" -> { b with pdb_id = (Some v) }
      | "replace_pdb_id" -> { b with replace_pdb_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("pdb_id",  v)) a.pdb_id;
      Option.map (fun v -> ("replace_pdb_id",  v)) a.replace_pdb_id;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_database_proc = struct
  type t = {
    entry_id: string option;
    cycle_id: string option;
    date_begin_cycle: string option;
    date_end_cycle: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    cycle_id = None;
    date_begin_cycle = None;
    date_end_cycle = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "cycle_id" -> { b with cycle_id = (Some v) }
      | "date_begin_cycle" -> { b with date_begin_cycle = (Some v) }
      | "date_end_cycle" -> { b with date_end_cycle = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("cycle_id",  v)) a.cycle_id;
      Option.map (fun v -> ("date_begin_cycle",  v)) a.date_begin_cycle;
      Option.map (fun v -> ("date_end_cycle",  v)) a.date_end_cycle;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_database_remark = struct
  type t = {
    id: int option;
    text: string option;
  }

  let default = {
    id = None;
    text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "text" -> { b with text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("text",  v)) a.text;
    ]

end

module Pdbx_database_status = struct
  type t = {
    status_code: string option;
    author_release_status_code: string option;
    status_code_sf: string option;
    status_code_mr: string option;
    dep_release_code_coordinates: string option;
    dep_release_code_sequence: string option;
    dep_release_code_struct_fact: string option;
    dep_release_code_nmr_constraints: string option;
    entry_id: string option;
    recvd_deposit_form: string option;
    date_deposition_form: string option;
    date_begin_deposition: string option;
    date_begin_processing: string option;
    date_end_processing: string option;
    date_begin_release_preparation: string option;
    date_author_release_request: string option;
    recvd_coordinates: string option;
    date_coordinates: string option;
    recvd_struct_fact: string option;
    date_struct_fact: string option;
    recvd_nmr_constraints: string option;
    date_nmr_constraints: string option;
    recvd_internal_approval: string option;
    recvd_manuscript: string option;
    date_manuscript: string option;
    name_depositor: string option;
    recvd_author_approval: string option;
    author_approval_type: string option;
    date_author_approval: string option;
    recvd_initial_deposition_date: string option;
    date_submitted: string option;
    rcsb_annotator: string option;
    date_of_sf_release: string option;
    date_of_mr_release: string option;
    date_of_PDB_release: string option;
    date_hold_coordinates: string option;
    date_hold_struct_fact: string option;
    date_hold_nmr_constraints: string option;
    hold_for_publication: string option;
    sG_entry: string option;
    pdb_date_of_author_approval: string option;
    deposit_site: string option;
    process_site: string option;
    dep_release_code_chemical_shifts: string option;
    recvd_chemical_shifts: string option;
    date_chemical_shifts: string option;
    date_hold_chemical_shifts: string option;
    status_code_cs: string option;
    date_of_cs_release: string option;
    methods_development_category: string option;
    pdb_format_compatible: string option;
    auth_req_rel_date: string option;
    ndb_tid: string option;
    status_coordinates_in_NDB: string option;
    date_revised: string option;
    replaced_entry_id: string option;
    revision_id: string option;
    revision_description: string option;
    pdbx_annotator: string option;
    date_of_NDB_release: string option;
    date_released_to_PDB: string option;
    skip_PDB_REMARK_500: string option;
    skip_PDB_REMARK: string option;
    title_suppression: string option;
  }

  let default = {
    status_code = None;
    author_release_status_code = None;
    status_code_sf = None;
    status_code_mr = None;
    dep_release_code_coordinates = None;
    dep_release_code_sequence = None;
    dep_release_code_struct_fact = None;
    dep_release_code_nmr_constraints = None;
    entry_id = None;
    recvd_deposit_form = None;
    date_deposition_form = None;
    date_begin_deposition = None;
    date_begin_processing = None;
    date_end_processing = None;
    date_begin_release_preparation = None;
    date_author_release_request = None;
    recvd_coordinates = None;
    date_coordinates = None;
    recvd_struct_fact = None;
    date_struct_fact = None;
    recvd_nmr_constraints = None;
    date_nmr_constraints = None;
    recvd_internal_approval = None;
    recvd_manuscript = None;
    date_manuscript = None;
    name_depositor = None;
    recvd_author_approval = None;
    author_approval_type = None;
    date_author_approval = None;
    recvd_initial_deposition_date = None;
    date_submitted = None;
    rcsb_annotator = None;
    date_of_sf_release = None;
    date_of_mr_release = None;
    date_of_PDB_release = None;
    date_hold_coordinates = None;
    date_hold_struct_fact = None;
    date_hold_nmr_constraints = None;
    hold_for_publication = None;
    sG_entry = None;
    pdb_date_of_author_approval = None;
    deposit_site = None;
    process_site = None;
    dep_release_code_chemical_shifts = None;
    recvd_chemical_shifts = None;
    date_chemical_shifts = None;
    date_hold_chemical_shifts = None;
    status_code_cs = None;
    date_of_cs_release = None;
    methods_development_category = None;
    pdb_format_compatible = None;
    auth_req_rel_date = None;
    ndb_tid = None;
    status_coordinates_in_NDB = None;
    date_revised = None;
    replaced_entry_id = None;
    revision_id = None;
    revision_description = None;
    pdbx_annotator = None;
    date_of_NDB_release = None;
    date_released_to_PDB = None;
    skip_PDB_REMARK_500 = None;
    skip_PDB_REMARK = None;
    title_suppression = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "status_code" -> { b with status_code = (Some v) }
      | "author_release_status_code" -> { b with author_release_status_code = (Some v) }
      | "status_code_sf" -> { b with status_code_sf = (Some v) }
      | "status_code_mr" -> { b with status_code_mr = (Some v) }
      | "dep_release_code_coordinates" -> { b with dep_release_code_coordinates = (Some v) }
      | "dep_release_code_sequence" -> { b with dep_release_code_sequence = (Some v) }
      | "dep_release_code_struct_fact" -> { b with dep_release_code_struct_fact = (Some v) }
      | "dep_release_code_nmr_constraints" -> { b with dep_release_code_nmr_constraints = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "recvd_deposit_form" -> { b with recvd_deposit_form = (Some v) }
      | "date_deposition_form" -> { b with date_deposition_form = (Some v) }
      | "date_begin_deposition" -> { b with date_begin_deposition = (Some v) }
      | "date_begin_processing" -> { b with date_begin_processing = (Some v) }
      | "date_end_processing" -> { b with date_end_processing = (Some v) }
      | "date_begin_release_preparation" -> { b with date_begin_release_preparation = (Some v) }
      | "date_author_release_request" -> { b with date_author_release_request = (Some v) }
      | "recvd_coordinates" -> { b with recvd_coordinates = (Some v) }
      | "date_coordinates" -> { b with date_coordinates = (Some v) }
      | "recvd_struct_fact" -> { b with recvd_struct_fact = (Some v) }
      | "date_struct_fact" -> { b with date_struct_fact = (Some v) }
      | "recvd_nmr_constraints" -> { b with recvd_nmr_constraints = (Some v) }
      | "date_nmr_constraints" -> { b with date_nmr_constraints = (Some v) }
      | "recvd_internal_approval" -> { b with recvd_internal_approval = (Some v) }
      | "recvd_manuscript" -> { b with recvd_manuscript = (Some v) }
      | "date_manuscript" -> { b with date_manuscript = (Some v) }
      | "name_depositor" -> { b with name_depositor = (Some v) }
      | "recvd_author_approval" -> { b with recvd_author_approval = (Some v) }
      | "author_approval_type" -> { b with author_approval_type = (Some v) }
      | "date_author_approval" -> { b with date_author_approval = (Some v) }
      | "recvd_initial_deposition_date" -> { b with recvd_initial_deposition_date = (Some v) }
      | "date_submitted" -> { b with date_submitted = (Some v) }
      | "rcsb_annotator" -> { b with rcsb_annotator = (Some v) }
      | "date_of_sf_release" -> { b with date_of_sf_release = (Some v) }
      | "date_of_mr_release" -> { b with date_of_mr_release = (Some v) }
      | "date_of_PDB_release" -> { b with date_of_PDB_release = (Some v) }
      | "date_hold_coordinates" -> { b with date_hold_coordinates = (Some v) }
      | "date_hold_struct_fact" -> { b with date_hold_struct_fact = (Some v) }
      | "date_hold_nmr_constraints" -> { b with date_hold_nmr_constraints = (Some v) }
      | "hold_for_publication" -> { b with hold_for_publication = (Some v) }
      | "SG_entry" -> { b with sG_entry = (Some v) }
      | "pdb_date_of_author_approval" -> { b with pdb_date_of_author_approval = (Some v) }
      | "deposit_site" -> { b with deposit_site = (Some v) }
      | "process_site" -> { b with process_site = (Some v) }
      | "dep_release_code_chemical_shifts" -> { b with dep_release_code_chemical_shifts = (Some v) }
      | "recvd_chemical_shifts" -> { b with recvd_chemical_shifts = (Some v) }
      | "date_chemical_shifts" -> { b with date_chemical_shifts = (Some v) }
      | "date_hold_chemical_shifts" -> { b with date_hold_chemical_shifts = (Some v) }
      | "status_code_cs" -> { b with status_code_cs = (Some v) }
      | "date_of_cs_release" -> { b with date_of_cs_release = (Some v) }
      | "methods_development_category" -> { b with methods_development_category = (Some v) }
      | "pdb_format_compatible" -> { b with pdb_format_compatible = (Some v) }
      | "auth_req_rel_date" -> { b with auth_req_rel_date = (Some v) }
      | "ndb_tid" -> { b with ndb_tid = (Some v) }
      | "status_coordinates_in_NDB" -> { b with status_coordinates_in_NDB = (Some v) }
      | "date_revised" -> { b with date_revised = (Some v) }
      | "replaced_entry_id" -> { b with replaced_entry_id = (Some v) }
      | "revision_id" -> { b with revision_id = (Some v) }
      | "revision_description" -> { b with revision_description = (Some v) }
      | "pdbx_annotator" -> { b with pdbx_annotator = (Some v) }
      | "date_of_NDB_release" -> { b with date_of_NDB_release = (Some v) }
      | "date_released_to_PDB" -> { b with date_released_to_PDB = (Some v) }
      | "skip_PDB_REMARK_500" -> { b with skip_PDB_REMARK_500 = (Some v) }
      | "skip_PDB_REMARK" -> { b with skip_PDB_REMARK = (Some v) }
      | "title_suppression" -> { b with title_suppression = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("status_code",  v)) a.status_code;
      Option.map (fun v -> ("author_release_status_code",  v)) a.author_release_status_code;
      Option.map (fun v -> ("status_code_sf",  v)) a.status_code_sf;
      Option.map (fun v -> ("status_code_mr",  v)) a.status_code_mr;
      Option.map (fun v -> ("dep_release_code_coordinates",  v)) a.dep_release_code_coordinates;
      Option.map (fun v -> ("dep_release_code_sequence",  v)) a.dep_release_code_sequence;
      Option.map (fun v -> ("dep_release_code_struct_fact",  v)) a.dep_release_code_struct_fact;
      Option.map (fun v -> ("dep_release_code_nmr_constraints",  v)) a.dep_release_code_nmr_constraints;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("recvd_deposit_form",  v)) a.recvd_deposit_form;
      Option.map (fun v -> ("date_deposition_form",  v)) a.date_deposition_form;
      Option.map (fun v -> ("date_begin_deposition",  v)) a.date_begin_deposition;
      Option.map (fun v -> ("date_begin_processing",  v)) a.date_begin_processing;
      Option.map (fun v -> ("date_end_processing",  v)) a.date_end_processing;
      Option.map (fun v -> ("date_begin_release_preparation",  v)) a.date_begin_release_preparation;
      Option.map (fun v -> ("date_author_release_request",  v)) a.date_author_release_request;
      Option.map (fun v -> ("recvd_coordinates",  v)) a.recvd_coordinates;
      Option.map (fun v -> ("date_coordinates",  v)) a.date_coordinates;
      Option.map (fun v -> ("recvd_struct_fact",  v)) a.recvd_struct_fact;
      Option.map (fun v -> ("date_struct_fact",  v)) a.date_struct_fact;
      Option.map (fun v -> ("recvd_nmr_constraints",  v)) a.recvd_nmr_constraints;
      Option.map (fun v -> ("date_nmr_constraints",  v)) a.date_nmr_constraints;
      Option.map (fun v -> ("recvd_internal_approval",  v)) a.recvd_internal_approval;
      Option.map (fun v -> ("recvd_manuscript",  v)) a.recvd_manuscript;
      Option.map (fun v -> ("date_manuscript",  v)) a.date_manuscript;
      Option.map (fun v -> ("name_depositor",  v)) a.name_depositor;
      Option.map (fun v -> ("recvd_author_approval",  v)) a.recvd_author_approval;
      Option.map (fun v -> ("author_approval_type",  v)) a.author_approval_type;
      Option.map (fun v -> ("date_author_approval",  v)) a.date_author_approval;
      Option.map (fun v -> ("recvd_initial_deposition_date",  v)) a.recvd_initial_deposition_date;
      Option.map (fun v -> ("date_submitted",  v)) a.date_submitted;
      Option.map (fun v -> ("rcsb_annotator",  v)) a.rcsb_annotator;
      Option.map (fun v -> ("date_of_sf_release",  v)) a.date_of_sf_release;
      Option.map (fun v -> ("date_of_mr_release",  v)) a.date_of_mr_release;
      Option.map (fun v -> ("date_of_PDB_release",  v)) a.date_of_PDB_release;
      Option.map (fun v -> ("date_hold_coordinates",  v)) a.date_hold_coordinates;
      Option.map (fun v -> ("date_hold_struct_fact",  v)) a.date_hold_struct_fact;
      Option.map (fun v -> ("date_hold_nmr_constraints",  v)) a.date_hold_nmr_constraints;
      Option.map (fun v -> ("hold_for_publication",  v)) a.hold_for_publication;
      Option.map (fun v -> ("SG_entry",  v)) a.sG_entry;
      Option.map (fun v -> ("pdb_date_of_author_approval",  v)) a.pdb_date_of_author_approval;
      Option.map (fun v -> ("deposit_site",  v)) a.deposit_site;
      Option.map (fun v -> ("process_site",  v)) a.process_site;
      Option.map (fun v -> ("dep_release_code_chemical_shifts",  v)) a.dep_release_code_chemical_shifts;
      Option.map (fun v -> ("recvd_chemical_shifts",  v)) a.recvd_chemical_shifts;
      Option.map (fun v -> ("date_chemical_shifts",  v)) a.date_chemical_shifts;
      Option.map (fun v -> ("date_hold_chemical_shifts",  v)) a.date_hold_chemical_shifts;
      Option.map (fun v -> ("status_code_cs",  v)) a.status_code_cs;
      Option.map (fun v -> ("date_of_cs_release",  v)) a.date_of_cs_release;
      Option.map (fun v -> ("methods_development_category",  v)) a.methods_development_category;
      Option.map (fun v -> ("pdb_format_compatible",  v)) a.pdb_format_compatible;
      Option.map (fun v -> ("auth_req_rel_date",  v)) a.auth_req_rel_date;
      Option.map (fun v -> ("ndb_tid",  v)) a.ndb_tid;
      Option.map (fun v -> ("status_coordinates_in_NDB",  v)) a.status_coordinates_in_NDB;
      Option.map (fun v -> ("date_revised",  v)) a.date_revised;
      Option.map (fun v -> ("replaced_entry_id",  v)) a.replaced_entry_id;
      Option.map (fun v -> ("revision_id",  v)) a.revision_id;
      Option.map (fun v -> ("revision_description",  v)) a.revision_description;
      Option.map (fun v -> ("pdbx_annotator",  v)) a.pdbx_annotator;
      Option.map (fun v -> ("date_of_NDB_release",  v)) a.date_of_NDB_release;
      Option.map (fun v -> ("date_released_to_PDB",  v)) a.date_released_to_PDB;
      Option.map (fun v -> ("skip_PDB_REMARK_500",  v)) a.skip_PDB_REMARK_500;
      Option.map (fun v -> ("skip_PDB_REMARK",  v)) a.skip_PDB_REMARK;
      Option.map (fun v -> ("title_suppression",  v)) a.title_suppression;
    ]

end

module Pdbx_entity_name = struct
  type t = {
    entity_id: string option;
    name: string option;
    name_type: string option;
  }

  let default = {
    entity_id = None;
    name = None;
    name_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "name_type" -> { b with name_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("name_type",  v)) a.name_type;
    ]

end

module Pdbx_prerelease_seq = struct
  type t = {
    entity_id: string option;
    seq_one_letter_code: string option;
  }

  let default = {
    entity_id = None;
    seq_one_letter_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "seq_one_letter_code" -> { b with seq_one_letter_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("seq_one_letter_code",  v)) a.seq_one_letter_code;
    ]

end

module Pdbx_poly_seq_scheme = struct
  type t = {
    asym_id: string option;
    entity_id: string option;
    seq_id: int option;
    hetero: string option;
    mon_id: string option;
    pdb_strand_id: string option;
    ndb_seq_num: int option;
    pdb_seq_num: string option;
    auth_seq_num: string option;
    pdb_mon_id: string option;
    auth_mon_id: string option;
    pdb_ins_code: string option;
  }

  let default = {
    asym_id = None;
    entity_id = None;
    seq_id = None;
    hetero = None;
    mon_id = None;
    pdb_strand_id = None;
    ndb_seq_num = None;
    pdb_seq_num = None;
    auth_seq_num = None;
    pdb_mon_id = None;
    auth_mon_id = None;
    pdb_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "asym_id" -> { b with asym_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "seq_id" -> { b with seq_id = (PDBjDict.some_int v) }
      | "hetero" -> { b with hetero = (Some v) }
      | "mon_id" -> { b with mon_id = (Some v) }
      | "pdb_strand_id" -> { b with pdb_strand_id = (Some v) }
      | "ndb_seq_num" -> { b with ndb_seq_num = (PDBjDict.some_int v) }
      | "pdb_seq_num" -> { b with pdb_seq_num = (Some v) }
      | "auth_seq_num" -> { b with auth_seq_num = (Some v) }
      | "pdb_mon_id" -> { b with pdb_mon_id = (Some v) }
      | "auth_mon_id" -> { b with auth_mon_id = (Some v) }
      | "pdb_ins_code" -> { b with pdb_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("seq_id", string_of_int v)) a.seq_id;
      Option.map (fun v -> ("hetero",  v)) a.hetero;
      Option.map (fun v -> ("mon_id",  v)) a.mon_id;
      Option.map (fun v -> ("pdb_strand_id",  v)) a.pdb_strand_id;
      Option.map (fun v -> ("ndb_seq_num", string_of_int v)) a.ndb_seq_num;
      Option.map (fun v -> ("pdb_seq_num",  v)) a.pdb_seq_num;
      Option.map (fun v -> ("auth_seq_num",  v)) a.auth_seq_num;
      Option.map (fun v -> ("pdb_mon_id",  v)) a.pdb_mon_id;
      Option.map (fun v -> ("auth_mon_id",  v)) a.auth_mon_id;
      Option.map (fun v -> ("pdb_ins_code",  v)) a.pdb_ins_code;
    ]

end

module Pdbx_nonpoly_scheme = struct
  type t = {
    asym_id: string option;
    entity_id: string option;
    mon_id: string option;
    pdb_strand_id: string option;
    ndb_seq_num: string option;
    pdb_seq_num: string option;
    auth_seq_num: string option;
    pdb_mon_id: string option;
    auth_mon_id: string option;
    pdb_ins_code: string option;
  }

  let default = {
    asym_id = None;
    entity_id = None;
    mon_id = None;
    pdb_strand_id = None;
    ndb_seq_num = None;
    pdb_seq_num = None;
    auth_seq_num = None;
    pdb_mon_id = None;
    auth_mon_id = None;
    pdb_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "asym_id" -> { b with asym_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "mon_id" -> { b with mon_id = (Some v) }
      | "pdb_strand_id" -> { b with pdb_strand_id = (Some v) }
      | "ndb_seq_num" -> { b with ndb_seq_num = (Some v) }
      | "pdb_seq_num" -> { b with pdb_seq_num = (Some v) }
      | "auth_seq_num" -> { b with auth_seq_num = (Some v) }
      | "pdb_mon_id" -> { b with pdb_mon_id = (Some v) }
      | "auth_mon_id" -> { b with auth_mon_id = (Some v) }
      | "pdb_ins_code" -> { b with pdb_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("mon_id",  v)) a.mon_id;
      Option.map (fun v -> ("pdb_strand_id",  v)) a.pdb_strand_id;
      Option.map (fun v -> ("ndb_seq_num",  v)) a.ndb_seq_num;
      Option.map (fun v -> ("pdb_seq_num",  v)) a.pdb_seq_num;
      Option.map (fun v -> ("auth_seq_num",  v)) a.auth_seq_num;
      Option.map (fun v -> ("pdb_mon_id",  v)) a.pdb_mon_id;
      Option.map (fun v -> ("auth_mon_id",  v)) a.auth_mon_id;
      Option.map (fun v -> ("pdb_ins_code",  v)) a.pdb_ins_code;
    ]

end

module Pdbx_refine = struct
  type t = {
    entry_id: string option;
    pdbx_refine_id: string option;
    r_factor_all_no_cutoff: float option;
    r_factor_obs_no_cutoff: float option;
    free_R_factor_4sig_cutoff: float option;
    free_R_factor_no_cutoff: float option;
    free_R_error_no_cutoff: float option;
    free_R_val_test_set_size_perc_no_cutoff: float option;
    free_R_val_test_set_ct_no_cutoff: float option;
    number_reflns_obs_no_cutoff: float option;
    r_factor_all_4sig_cutoff: float option;
    r_factor_obs_4sig_cutoff: float option;
    free_R_val_4sig_cutoff: float option;
    free_R_val_test_set_size_perc_4sig_cutoff: float option;
    free_R_val_test_set_ct_4sig_cutoff: float option;
    number_reflns_obs_4sig_cutoff: float option;
    free_R_val_no_cutoff: float option;
  }

  let default = {
    entry_id = None;
    pdbx_refine_id = None;
    r_factor_all_no_cutoff = None;
    r_factor_obs_no_cutoff = None;
    free_R_factor_4sig_cutoff = None;
    free_R_factor_no_cutoff = None;
    free_R_error_no_cutoff = None;
    free_R_val_test_set_size_perc_no_cutoff = None;
    free_R_val_test_set_ct_no_cutoff = None;
    number_reflns_obs_no_cutoff = None;
    r_factor_all_4sig_cutoff = None;
    r_factor_obs_4sig_cutoff = None;
    free_R_val_4sig_cutoff = None;
    free_R_val_test_set_size_perc_4sig_cutoff = None;
    free_R_val_test_set_ct_4sig_cutoff = None;
    number_reflns_obs_4sig_cutoff = None;
    free_R_val_no_cutoff = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "R_factor_all_no_cutoff" -> { b with r_factor_all_no_cutoff = (PDBjDict.some_float v) }
      | "R_factor_obs_no_cutoff" -> { b with r_factor_obs_no_cutoff = (PDBjDict.some_float v) }
      | "free_R_factor_4sig_cutoff" -> { b with free_R_factor_4sig_cutoff = (PDBjDict.some_float v) }
      | "free_R_factor_no_cutoff" -> { b with free_R_factor_no_cutoff = (PDBjDict.some_float v) }
      | "free_R_error_no_cutoff" -> { b with free_R_error_no_cutoff = (PDBjDict.some_float v) }
      | "free_R_val_test_set_size_perc_no_cutoff" -> { b with free_R_val_test_set_size_perc_no_cutoff = (PDBjDict.some_float v) }
      | "free_R_val_test_set_ct_no_cutoff" -> { b with free_R_val_test_set_ct_no_cutoff = (PDBjDict.some_float v) }
      | "number_reflns_obs_no_cutoff" -> { b with number_reflns_obs_no_cutoff = (PDBjDict.some_float v) }
      | "R_factor_all_4sig_cutoff" -> { b with r_factor_all_4sig_cutoff = (PDBjDict.some_float v) }
      | "R_factor_obs_4sig_cutoff" -> { b with r_factor_obs_4sig_cutoff = (PDBjDict.some_float v) }
      | "free_R_val_4sig_cutoff" -> { b with free_R_val_4sig_cutoff = (PDBjDict.some_float v) }
      | "free_R_val_test_set_size_perc_4sig_cutoff" -> { b with free_R_val_test_set_size_perc_4sig_cutoff = (PDBjDict.some_float v) }
      | "free_R_val_test_set_ct_4sig_cutoff" -> { b with free_R_val_test_set_ct_4sig_cutoff = (PDBjDict.some_float v) }
      | "number_reflns_obs_4sig_cutoff" -> { b with number_reflns_obs_4sig_cutoff = (PDBjDict.some_float v) }
      | "free_R_val_no_cutoff" -> { b with free_R_val_no_cutoff = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("R_factor_all_no_cutoff", string_of_float v)) a.r_factor_all_no_cutoff;
      Option.map (fun v -> ("R_factor_obs_no_cutoff", string_of_float v)) a.r_factor_obs_no_cutoff;
      Option.map (fun v -> ("free_R_factor_4sig_cutoff", string_of_float v)) a.free_R_factor_4sig_cutoff;
      Option.map (fun v -> ("free_R_factor_no_cutoff", string_of_float v)) a.free_R_factor_no_cutoff;
      Option.map (fun v -> ("free_R_error_no_cutoff", string_of_float v)) a.free_R_error_no_cutoff;
      Option.map (fun v -> ("free_R_val_test_set_size_perc_no_cutoff", string_of_float v)) a.free_R_val_test_set_size_perc_no_cutoff;
      Option.map (fun v -> ("free_R_val_test_set_ct_no_cutoff", string_of_float v)) a.free_R_val_test_set_ct_no_cutoff;
      Option.map (fun v -> ("number_reflns_obs_no_cutoff", string_of_float v)) a.number_reflns_obs_no_cutoff;
      Option.map (fun v -> ("R_factor_all_4sig_cutoff", string_of_float v)) a.r_factor_all_4sig_cutoff;
      Option.map (fun v -> ("R_factor_obs_4sig_cutoff", string_of_float v)) a.r_factor_obs_4sig_cutoff;
      Option.map (fun v -> ("free_R_val_4sig_cutoff", string_of_float v)) a.free_R_val_4sig_cutoff;
      Option.map (fun v -> ("free_R_val_test_set_size_perc_4sig_cutoff", string_of_float v)) a.free_R_val_test_set_size_perc_4sig_cutoff;
      Option.map (fun v -> ("free_R_val_test_set_ct_4sig_cutoff", string_of_float v)) a.free_R_val_test_set_ct_4sig_cutoff;
      Option.map (fun v -> ("number_reflns_obs_4sig_cutoff", string_of_float v)) a.number_reflns_obs_4sig_cutoff;
      Option.map (fun v -> ("free_R_val_no_cutoff", string_of_float v)) a.free_R_val_no_cutoff;
    ]

end

module Pdbx_struct_sheet_hbond = struct
  type t = {
    range_id_1: string option;
    range_id_2: string option;
    sheet_id: string option;
    range_1_label_atom_id: string option;
    range_1_label_seq_id: int option;
    range_1_label_comp_id: string option;
    range_1_label_asym_id: string option;
    range_1_auth_atom_id: string option;
    range_1_auth_seq_id: string option;
    range_1_auth_comp_id: string option;
    range_1_auth_asym_id: string option;
    range_1_PDB_ins_code: string option;
    range_2_label_atom_id: string option;
    range_2_label_seq_id: int option;
    range_2_label_comp_id: string option;
    range_2_label_asym_id: string option;
    range_2_auth_atom_id: string option;
    range_2_auth_seq_id: string option;
    range_2_auth_comp_id: string option;
    range_2_auth_asym_id: string option;
    range_2_PDB_ins_code: string option;
  }

  let default = {
    range_id_1 = None;
    range_id_2 = None;
    sheet_id = None;
    range_1_label_atom_id = None;
    range_1_label_seq_id = None;
    range_1_label_comp_id = None;
    range_1_label_asym_id = None;
    range_1_auth_atom_id = None;
    range_1_auth_seq_id = None;
    range_1_auth_comp_id = None;
    range_1_auth_asym_id = None;
    range_1_PDB_ins_code = None;
    range_2_label_atom_id = None;
    range_2_label_seq_id = None;
    range_2_label_comp_id = None;
    range_2_label_asym_id = None;
    range_2_auth_atom_id = None;
    range_2_auth_seq_id = None;
    range_2_auth_comp_id = None;
    range_2_auth_asym_id = None;
    range_2_PDB_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "range_id_1" -> { b with range_id_1 = (Some v) }
      | "range_id_2" -> { b with range_id_2 = (Some v) }
      | "sheet_id" -> { b with sheet_id = (Some v) }
      | "range_1_label_atom_id" -> { b with range_1_label_atom_id = (Some v) }
      | "range_1_label_seq_id" -> { b with range_1_label_seq_id = (PDBjDict.some_int v) }
      | "range_1_label_comp_id" -> { b with range_1_label_comp_id = (Some v) }
      | "range_1_label_asym_id" -> { b with range_1_label_asym_id = (Some v) }
      | "range_1_auth_atom_id" -> { b with range_1_auth_atom_id = (Some v) }
      | "range_1_auth_seq_id" -> { b with range_1_auth_seq_id = (Some v) }
      | "range_1_auth_comp_id" -> { b with range_1_auth_comp_id = (Some v) }
      | "range_1_auth_asym_id" -> { b with range_1_auth_asym_id = (Some v) }
      | "range_1_PDB_ins_code" -> { b with range_1_PDB_ins_code = (Some v) }
      | "range_2_label_atom_id" -> { b with range_2_label_atom_id = (Some v) }
      | "range_2_label_seq_id" -> { b with range_2_label_seq_id = (PDBjDict.some_int v) }
      | "range_2_label_comp_id" -> { b with range_2_label_comp_id = (Some v) }
      | "range_2_label_asym_id" -> { b with range_2_label_asym_id = (Some v) }
      | "range_2_auth_atom_id" -> { b with range_2_auth_atom_id = (Some v) }
      | "range_2_auth_seq_id" -> { b with range_2_auth_seq_id = (Some v) }
      | "range_2_auth_comp_id" -> { b with range_2_auth_comp_id = (Some v) }
      | "range_2_auth_asym_id" -> { b with range_2_auth_asym_id = (Some v) }
      | "range_2_PDB_ins_code" -> { b with range_2_PDB_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("range_id_1",  v)) a.range_id_1;
      Option.map (fun v -> ("range_id_2",  v)) a.range_id_2;
      Option.map (fun v -> ("sheet_id",  v)) a.sheet_id;
      Option.map (fun v -> ("range_1_label_atom_id",  v)) a.range_1_label_atom_id;
      Option.map (fun v -> ("range_1_label_seq_id", string_of_int v)) a.range_1_label_seq_id;
      Option.map (fun v -> ("range_1_label_comp_id",  v)) a.range_1_label_comp_id;
      Option.map (fun v -> ("range_1_label_asym_id",  v)) a.range_1_label_asym_id;
      Option.map (fun v -> ("range_1_auth_atom_id",  v)) a.range_1_auth_atom_id;
      Option.map (fun v -> ("range_1_auth_seq_id",  v)) a.range_1_auth_seq_id;
      Option.map (fun v -> ("range_1_auth_comp_id",  v)) a.range_1_auth_comp_id;
      Option.map (fun v -> ("range_1_auth_asym_id",  v)) a.range_1_auth_asym_id;
      Option.map (fun v -> ("range_1_PDB_ins_code",  v)) a.range_1_PDB_ins_code;
      Option.map (fun v -> ("range_2_label_atom_id",  v)) a.range_2_label_atom_id;
      Option.map (fun v -> ("range_2_label_seq_id", string_of_int v)) a.range_2_label_seq_id;
      Option.map (fun v -> ("range_2_label_comp_id",  v)) a.range_2_label_comp_id;
      Option.map (fun v -> ("range_2_label_asym_id",  v)) a.range_2_label_asym_id;
      Option.map (fun v -> ("range_2_auth_atom_id",  v)) a.range_2_auth_atom_id;
      Option.map (fun v -> ("range_2_auth_seq_id",  v)) a.range_2_auth_seq_id;
      Option.map (fun v -> ("range_2_auth_comp_id",  v)) a.range_2_auth_comp_id;
      Option.map (fun v -> ("range_2_auth_asym_id",  v)) a.range_2_auth_asym_id;
      Option.map (fun v -> ("range_2_PDB_ins_code",  v)) a.range_2_PDB_ins_code;
    ]

end

module Pdbx_xplor_file = struct
  type t = {
    serial_no: string option;
    pdbx_refine_id: string option;
    param_file: string option;
    topol_file: string option;
  }

  let default = {
    serial_no = None;
    pdbx_refine_id = None;
    param_file = None;
    topol_file = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "serial_no" -> { b with serial_no = (Some v) }
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "param_file" -> { b with param_file = (Some v) }
      | "topol_file" -> { b with topol_file = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("serial_no",  v)) a.serial_no;
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("param_file",  v)) a.param_file;
      Option.map (fun v -> ("topol_file",  v)) a.topol_file;
    ]

end

module Pdbx_refine_aux_file = struct
  type t = {
    serial_no: string option;
    pdbx_refine_id: string option;
    file_name: string option;
    file_type: string option;
  }

  let default = {
    serial_no = None;
    pdbx_refine_id = None;
    file_name = None;
    file_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "serial_no" -> { b with serial_no = (Some v) }
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "file_name" -> { b with file_name = (Some v) }
      | "file_type" -> { b with file_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("serial_no",  v)) a.serial_no;
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("file_name",  v)) a.file_name;
      Option.map (fun v -> ("file_type",  v)) a.file_type;
    ]

end

module Pdbx_database_related = struct
  type t = {
    db_name: string option;
    details: string option;
    db_id: string option;
    content_type: string option;
  }

  let default = {
    db_name = None;
    details = None;
    db_id = None;
    content_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "db_name" -> { b with db_name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "db_id" -> { b with db_id = (Some v) }
      | "content_type" -> { b with content_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("db_name",  v)) a.db_name;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("db_id",  v)) a.db_id;
      Option.map (fun v -> ("content_type",  v)) a.content_type;
    ]

end

module Pdbx_entity_assembly = struct
  type t = {
    id: string option;
    entity_id: string option;
    biol_id: string option;
    num_copies: int option;
  }

  let default = {
    id = None;
    entity_id = None;
    biol_id = None;
    num_copies = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "biol_id" -> { b with biol_id = (Some v) }
      | "num_copies" -> { b with num_copies = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("biol_id",  v)) a.biol_id;
      Option.map (fun v -> ("num_copies", string_of_int v)) a.num_copies;
    ]

end

module Pdbx_exptl_crystal_grow_comp = struct
  type t = {
    crystal_id: string option;
    comp_id: string option;
    comp_name: string option;
    sol_id: string option;
    conc: float option;
    conc_range: string option;
    conc_units: string option;
  }

  let default = {
    crystal_id = None;
    comp_id = None;
    comp_name = None;
    sol_id = None;
    conc = None;
    conc_range = None;
    conc_units = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "crystal_id" -> { b with crystal_id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "comp_name" -> { b with comp_name = (Some v) }
      | "sol_id" -> { b with sol_id = (Some v) }
      | "conc" -> { b with conc = (PDBjDict.some_float v) }
      | "conc_range" -> { b with conc_range = (Some v) }
      | "conc_units" -> { b with conc_units = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("crystal_id",  v)) a.crystal_id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("comp_name",  v)) a.comp_name;
      Option.map (fun v -> ("sol_id",  v)) a.sol_id;
      Option.map (fun v -> ("conc", string_of_float v)) a.conc;
      Option.map (fun v -> ("conc_range",  v)) a.conc_range;
      Option.map (fun v -> ("conc_units",  v)) a.conc_units;
    ]

end

module Pdbx_exptl_crystal_grow_sol = struct
  type t = {
    crystal_id: string option;
    sol_id: string option;
    volume: float option;
    volume_units: string option;
    pH: float option;
  }

  let default = {
    crystal_id = None;
    sol_id = None;
    volume = None;
    volume_units = None;
    pH = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "crystal_id" -> { b with crystal_id = (Some v) }
      | "sol_id" -> { b with sol_id = (Some v) }
      | "volume" -> { b with volume = (PDBjDict.some_float v) }
      | "volume_units" -> { b with volume_units = (Some v) }
      | "pH" -> { b with pH = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("crystal_id",  v)) a.crystal_id;
      Option.map (fun v -> ("sol_id",  v)) a.sol_id;
      Option.map (fun v -> ("volume", string_of_float v)) a.volume;
      Option.map (fun v -> ("volume_units",  v)) a.volume_units;
      Option.map (fun v -> ("pH", string_of_float v)) a.pH;
    ]

end

module Pdbx_exptl_crystal_cryo_treatment = struct
  type t = {
    crystal_id: string option;
    final_solution_details: string option;
    soaking_details: string option;
    cooling_details: string option;
    annealing_details: string option;
  }

  let default = {
    crystal_id = None;
    final_solution_details = None;
    soaking_details = None;
    cooling_details = None;
    annealing_details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "crystal_id" -> { b with crystal_id = (Some v) }
      | "final_solution_details" -> { b with final_solution_details = (Some v) }
      | "soaking_details" -> { b with soaking_details = (Some v) }
      | "cooling_details" -> { b with cooling_details = (Some v) }
      | "annealing_details" -> { b with annealing_details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("crystal_id",  v)) a.crystal_id;
      Option.map (fun v -> ("final_solution_details",  v)) a.final_solution_details;
      Option.map (fun v -> ("soaking_details",  v)) a.soaking_details;
      Option.map (fun v -> ("cooling_details",  v)) a.cooling_details;
      Option.map (fun v -> ("annealing_details",  v)) a.annealing_details;
    ]

end

module Pdbx_refine_tls = struct
  type t = {
    id: string option;
    pdbx_refine_id: string option;
    details: string option;
    method_: string option;
    origin_x: float option;
    origin_y: float option;
    origin_z: float option;
    t11: float option;
    t11_esd: float option;
    t12: float option;
    t12_esd: float option;
    t13: float option;
    t13_esd: float option;
    t22: float option;
    t22_esd: float option;
    t23: float option;
    t23_esd: float option;
    t33: float option;
    t33_esd: float option;
    l11: float option;
    l11_esd: float option;
    l12: float option;
    l12_esd: float option;
    l13: float option;
    l13_esd: float option;
    l22: float option;
    l22_esd: float option;
    l23: float option;
    l23_esd: float option;
    l33: float option;
    l33_esd: float option;
    s11: float option;
    s11_esd: float option;
    s12: float option;
    s12_esd: float option;
    s13: float option;
    s13_esd: float option;
    s21: float option;
    s21_esd: float option;
    s22: float option;
    s22_esd: float option;
    s23: float option;
    s23_esd: float option;
    s31: float option;
    s31_esd: float option;
    s32: float option;
    s32_esd: float option;
    s33: float option;
    s33_esd: float option;
  }

  let default = {
    id = None;
    pdbx_refine_id = None;
    details = None;
    method_ = None;
    origin_x = None;
    origin_y = None;
    origin_z = None;
    t11 = None;
    t11_esd = None;
    t12 = None;
    t12_esd = None;
    t13 = None;
    t13_esd = None;
    t22 = None;
    t22_esd = None;
    t23 = None;
    t23_esd = None;
    t33 = None;
    t33_esd = None;
    l11 = None;
    l11_esd = None;
    l12 = None;
    l12_esd = None;
    l13 = None;
    l13_esd = None;
    l22 = None;
    l22_esd = None;
    l23 = None;
    l23_esd = None;
    l33 = None;
    l33_esd = None;
    s11 = None;
    s11_esd = None;
    s12 = None;
    s12_esd = None;
    s13 = None;
    s13_esd = None;
    s21 = None;
    s21_esd = None;
    s22 = None;
    s22_esd = None;
    s23 = None;
    s23_esd = None;
    s31 = None;
    s31_esd = None;
    s32 = None;
    s32_esd = None;
    s33 = None;
    s33_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "origin_x" -> { b with origin_x = (PDBjDict.some_float v) }
      | "origin_y" -> { b with origin_y = (PDBjDict.some_float v) }
      | "origin_z" -> { b with origin_z = (PDBjDict.some_float v) }
      | "T[1][1]" -> { b with t11 = (PDBjDict.some_float v) }
      | "T[1][1]_esd" -> { b with t11_esd = (PDBjDict.some_float v) }
      | "T[1][2]" -> { b with t12 = (PDBjDict.some_float v) }
      | "T[1][2]_esd" -> { b with t12_esd = (PDBjDict.some_float v) }
      | "T[1][3]" -> { b with t13 = (PDBjDict.some_float v) }
      | "T[1][3]_esd" -> { b with t13_esd = (PDBjDict.some_float v) }
      | "T[2][2]" -> { b with t22 = (PDBjDict.some_float v) }
      | "T[2][2]_esd" -> { b with t22_esd = (PDBjDict.some_float v) }
      | "T[2][3]" -> { b with t23 = (PDBjDict.some_float v) }
      | "T[2][3]_esd" -> { b with t23_esd = (PDBjDict.some_float v) }
      | "T[3][3]" -> { b with t33 = (PDBjDict.some_float v) }
      | "T[3][3]_esd" -> { b with t33_esd = (PDBjDict.some_float v) }
      | "L[1][1]" -> { b with l11 = (PDBjDict.some_float v) }
      | "L[1][1]_esd" -> { b with l11_esd = (PDBjDict.some_float v) }
      | "L[1][2]" -> { b with l12 = (PDBjDict.some_float v) }
      | "L[1][2]_esd" -> { b with l12_esd = (PDBjDict.some_float v) }
      | "L[1][3]" -> { b with l13 = (PDBjDict.some_float v) }
      | "L[1][3]_esd" -> { b with l13_esd = (PDBjDict.some_float v) }
      | "L[2][2]" -> { b with l22 = (PDBjDict.some_float v) }
      | "L[2][2]_esd" -> { b with l22_esd = (PDBjDict.some_float v) }
      | "L[2][3]" -> { b with l23 = (PDBjDict.some_float v) }
      | "L[2][3]_esd" -> { b with l23_esd = (PDBjDict.some_float v) }
      | "L[3][3]" -> { b with l33 = (PDBjDict.some_float v) }
      | "L[3][3]_esd" -> { b with l33_esd = (PDBjDict.some_float v) }
      | "S[1][1]" -> { b with s11 = (PDBjDict.some_float v) }
      | "S[1][1]_esd" -> { b with s11_esd = (PDBjDict.some_float v) }
      | "S[1][2]" -> { b with s12 = (PDBjDict.some_float v) }
      | "S[1][2]_esd" -> { b with s12_esd = (PDBjDict.some_float v) }
      | "S[1][3]" -> { b with s13 = (PDBjDict.some_float v) }
      | "S[1][3]_esd" -> { b with s13_esd = (PDBjDict.some_float v) }
      | "S[2][1]" -> { b with s21 = (PDBjDict.some_float v) }
      | "S[2][1]_esd" -> { b with s21_esd = (PDBjDict.some_float v) }
      | "S[2][2]" -> { b with s22 = (PDBjDict.some_float v) }
      | "S[2][2]_esd" -> { b with s22_esd = (PDBjDict.some_float v) }
      | "S[2][3]" -> { b with s23 = (PDBjDict.some_float v) }
      | "S[2][3]_esd" -> { b with s23_esd = (PDBjDict.some_float v) }
      | "S[3][1]" -> { b with s31 = (PDBjDict.some_float v) }
      | "S[3][1]_esd" -> { b with s31_esd = (PDBjDict.some_float v) }
      | "S[3][2]" -> { b with s32 = (PDBjDict.some_float v) }
      | "S[3][2]_esd" -> { b with s32_esd = (PDBjDict.some_float v) }
      | "S[3][3]" -> { b with s33 = (PDBjDict.some_float v) }
      | "S[3][3]_esd" -> { b with s33_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("origin_x", string_of_float v)) a.origin_x;
      Option.map (fun v -> ("origin_y", string_of_float v)) a.origin_y;
      Option.map (fun v -> ("origin_z", string_of_float v)) a.origin_z;
      Option.map (fun v -> ("T[1][1]", string_of_float v)) a.t11;
      Option.map (fun v -> ("T[1][1]_esd", string_of_float v)) a.t11_esd;
      Option.map (fun v -> ("T[1][2]", string_of_float v)) a.t12;
      Option.map (fun v -> ("T[1][2]_esd", string_of_float v)) a.t12_esd;
      Option.map (fun v -> ("T[1][3]", string_of_float v)) a.t13;
      Option.map (fun v -> ("T[1][3]_esd", string_of_float v)) a.t13_esd;
      Option.map (fun v -> ("T[2][2]", string_of_float v)) a.t22;
      Option.map (fun v -> ("T[2][2]_esd", string_of_float v)) a.t22_esd;
      Option.map (fun v -> ("T[2][3]", string_of_float v)) a.t23;
      Option.map (fun v -> ("T[2][3]_esd", string_of_float v)) a.t23_esd;
      Option.map (fun v -> ("T[3][3]", string_of_float v)) a.t33;
      Option.map (fun v -> ("T[3][3]_esd", string_of_float v)) a.t33_esd;
      Option.map (fun v -> ("L[1][1]", string_of_float v)) a.l11;
      Option.map (fun v -> ("L[1][1]_esd", string_of_float v)) a.l11_esd;
      Option.map (fun v -> ("L[1][2]", string_of_float v)) a.l12;
      Option.map (fun v -> ("L[1][2]_esd", string_of_float v)) a.l12_esd;
      Option.map (fun v -> ("L[1][3]", string_of_float v)) a.l13;
      Option.map (fun v -> ("L[1][3]_esd", string_of_float v)) a.l13_esd;
      Option.map (fun v -> ("L[2][2]", string_of_float v)) a.l22;
      Option.map (fun v -> ("L[2][2]_esd", string_of_float v)) a.l22_esd;
      Option.map (fun v -> ("L[2][3]", string_of_float v)) a.l23;
      Option.map (fun v -> ("L[2][3]_esd", string_of_float v)) a.l23_esd;
      Option.map (fun v -> ("L[3][3]", string_of_float v)) a.l33;
      Option.map (fun v -> ("L[3][3]_esd", string_of_float v)) a.l33_esd;
      Option.map (fun v -> ("S[1][1]", string_of_float v)) a.s11;
      Option.map (fun v -> ("S[1][1]_esd", string_of_float v)) a.s11_esd;
      Option.map (fun v -> ("S[1][2]", string_of_float v)) a.s12;
      Option.map (fun v -> ("S[1][2]_esd", string_of_float v)) a.s12_esd;
      Option.map (fun v -> ("S[1][3]", string_of_float v)) a.s13;
      Option.map (fun v -> ("S[1][3]_esd", string_of_float v)) a.s13_esd;
      Option.map (fun v -> ("S[2][1]", string_of_float v)) a.s21;
      Option.map (fun v -> ("S[2][1]_esd", string_of_float v)) a.s21_esd;
      Option.map (fun v -> ("S[2][2]", string_of_float v)) a.s22;
      Option.map (fun v -> ("S[2][2]_esd", string_of_float v)) a.s22_esd;
      Option.map (fun v -> ("S[2][3]", string_of_float v)) a.s23;
      Option.map (fun v -> ("S[2][3]_esd", string_of_float v)) a.s23_esd;
      Option.map (fun v -> ("S[3][1]", string_of_float v)) a.s31;
      Option.map (fun v -> ("S[3][1]_esd", string_of_float v)) a.s31_esd;
      Option.map (fun v -> ("S[3][2]", string_of_float v)) a.s32;
      Option.map (fun v -> ("S[3][2]_esd", string_of_float v)) a.s32_esd;
      Option.map (fun v -> ("S[3][3]", string_of_float v)) a.s33;
      Option.map (fun v -> ("S[3][3]_esd", string_of_float v)) a.s33_esd;
    ]

end

module Pdbx_refine_tls_group = struct
  type t = {
    id: string option;
    pdbx_refine_id: string option;
    refine_tls_id: string option;
    beg_label_asym_id: string option;
    beg_label_seq_id: int option;
    beg_auth_asym_id: string option;
    beg_auth_seq_id: string option;
    end_label_asym_id: string option;
    end_label_seq_id: int option;
    end_auth_asym_id: string option;
    end_auth_seq_id: string option;
    selection: string option;
    selection_details: string option;
  }

  let default = {
    id = None;
    pdbx_refine_id = None;
    refine_tls_id = None;
    beg_label_asym_id = None;
    beg_label_seq_id = None;
    beg_auth_asym_id = None;
    beg_auth_seq_id = None;
    end_label_asym_id = None;
    end_label_seq_id = None;
    end_auth_asym_id = None;
    end_auth_seq_id = None;
    selection = None;
    selection_details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "pdbx_refine_id" -> { b with pdbx_refine_id = (Some v) }
      | "refine_tls_id" -> { b with refine_tls_id = (Some v) }
      | "beg_label_asym_id" -> { b with beg_label_asym_id = (Some v) }
      | "beg_label_seq_id" -> { b with beg_label_seq_id = (PDBjDict.some_int v) }
      | "beg_auth_asym_id" -> { b with beg_auth_asym_id = (Some v) }
      | "beg_auth_seq_id" -> { b with beg_auth_seq_id = (Some v) }
      | "end_label_asym_id" -> { b with end_label_asym_id = (Some v) }
      | "end_label_seq_id" -> { b with end_label_seq_id = (PDBjDict.some_int v) }
      | "end_auth_asym_id" -> { b with end_auth_asym_id = (Some v) }
      | "end_auth_seq_id" -> { b with end_auth_seq_id = (Some v) }
      | "selection" -> { b with selection = (Some v) }
      | "selection_details" -> { b with selection_details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("pdbx_refine_id",  v)) a.pdbx_refine_id;
      Option.map (fun v -> ("refine_tls_id",  v)) a.refine_tls_id;
      Option.map (fun v -> ("beg_label_asym_id",  v)) a.beg_label_asym_id;
      Option.map (fun v -> ("beg_label_seq_id", string_of_int v)) a.beg_label_seq_id;
      Option.map (fun v -> ("beg_auth_asym_id",  v)) a.beg_auth_asym_id;
      Option.map (fun v -> ("beg_auth_seq_id",  v)) a.beg_auth_seq_id;
      Option.map (fun v -> ("end_label_asym_id",  v)) a.end_label_asym_id;
      Option.map (fun v -> ("end_label_seq_id", string_of_int v)) a.end_label_seq_id;
      Option.map (fun v -> ("end_auth_asym_id",  v)) a.end_auth_asym_id;
      Option.map (fun v -> ("end_auth_seq_id",  v)) a.end_auth_seq_id;
      Option.map (fun v -> ("selection",  v)) a.selection;
      Option.map (fun v -> ("selection_details",  v)) a.selection_details;
    ]

end

module Pdbx_contact_author = struct
  type t = {
    id: int option;
    address_1: string option;
    address_2: string option;
    address_3: string option;
    legacy_address: string option;
    city: string option;
    state_province: string option;
    postal_code: string option;
    email: string option;
    fax: string option;
    name_first: string option;
    name_last: string option;
    name_mi: string option;
    name_salutation: string option;
    country: string option;
    continent: string option;
    phone: string option;
    role: string option;
    organization_type: string option;
    identifier_ORCID: string option;
  }

  let default = {
    id = None;
    address_1 = None;
    address_2 = None;
    address_3 = None;
    legacy_address = None;
    city = None;
    state_province = None;
    postal_code = None;
    email = None;
    fax = None;
    name_first = None;
    name_last = None;
    name_mi = None;
    name_salutation = None;
    country = None;
    continent = None;
    phone = None;
    role = None;
    organization_type = None;
    identifier_ORCID = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "address_1" -> { b with address_1 = (Some v) }
      | "address_2" -> { b with address_2 = (Some v) }
      | "address_3" -> { b with address_3 = (Some v) }
      | "legacy_address" -> { b with legacy_address = (Some v) }
      | "city" -> { b with city = (Some v) }
      | "state_province" -> { b with state_province = (Some v) }
      | "postal_code" -> { b with postal_code = (Some v) }
      | "email" -> { b with email = (Some v) }
      | "fax" -> { b with fax = (Some v) }
      | "name_first" -> { b with name_first = (Some v) }
      | "name_last" -> { b with name_last = (Some v) }
      | "name_mi" -> { b with name_mi = (Some v) }
      | "name_salutation" -> { b with name_salutation = (Some v) }
      | "country" -> { b with country = (Some v) }
      | "continent" -> { b with continent = (Some v) }
      | "phone" -> { b with phone = (Some v) }
      | "role" -> { b with role = (Some v) }
      | "organization_type" -> { b with organization_type = (Some v) }
      | "identifier_ORCID" -> { b with identifier_ORCID = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("address_1",  v)) a.address_1;
      Option.map (fun v -> ("address_2",  v)) a.address_2;
      Option.map (fun v -> ("address_3",  v)) a.address_3;
      Option.map (fun v -> ("legacy_address",  v)) a.legacy_address;
      Option.map (fun v -> ("city",  v)) a.city;
      Option.map (fun v -> ("state_province",  v)) a.state_province;
      Option.map (fun v -> ("postal_code",  v)) a.postal_code;
      Option.map (fun v -> ("email",  v)) a.email;
      Option.map (fun v -> ("fax",  v)) a.fax;
      Option.map (fun v -> ("name_first",  v)) a.name_first;
      Option.map (fun v -> ("name_last",  v)) a.name_last;
      Option.map (fun v -> ("name_mi",  v)) a.name_mi;
      Option.map (fun v -> ("name_salutation",  v)) a.name_salutation;
      Option.map (fun v -> ("country",  v)) a.country;
      Option.map (fun v -> ("continent",  v)) a.continent;
      Option.map (fun v -> ("phone",  v)) a.phone;
      Option.map (fun v -> ("role",  v)) a.role;
      Option.map (fun v -> ("organization_type",  v)) a.organization_type;
      Option.map (fun v -> ("identifier_ORCID",  v)) a.identifier_ORCID;
    ]

end

module Pdbx_SG_project = struct
  type t = {
    id: int option;
    project_name: string option;
    full_name_of_center: string option;
    initial_of_center: string option;
  }

  let default = {
    id = None;
    project_name = None;
    full_name_of_center = None;
    initial_of_center = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "project_name" -> { b with project_name = (Some v) }
      | "full_name_of_center" -> { b with full_name_of_center = (Some v) }
      | "initial_of_center" -> { b with initial_of_center = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("project_name",  v)) a.project_name;
      Option.map (fun v -> ("full_name_of_center",  v)) a.full_name_of_center;
      Option.map (fun v -> ("initial_of_center",  v)) a.initial_of_center;
    ]

end

module Pdbx_atom_site_aniso_tls = struct
  type t = {
    id: string option;
    type_symbol: string option;
    tls_group_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    auth_atom_id: string option;
    auth_asym_id: string option;
    pDB_ins_code: string option;
    label_alt_id: string option;
    label_asym_id: string option;
    label_atom_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    u_tls11: float option;
    u_tls22: float option;
    u_tls33: float option;
    u_tls12: float option;
    u_tls13: float option;
    u_tls23: float option;
  }

  let default = {
    id = None;
    type_symbol = None;
    tls_group_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    auth_atom_id = None;
    auth_asym_id = None;
    pDB_ins_code = None;
    label_alt_id = None;
    label_asym_id = None;
    label_atom_id = None;
    label_comp_id = None;
    label_seq_id = None;
    u_tls11 = None;
    u_tls22 = None;
    u_tls33 = None;
    u_tls12 = None;
    u_tls13 = None;
    u_tls23 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "type_symbol" -> { b with type_symbol = (Some v) }
      | "tls_group_id" -> { b with tls_group_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "auth_atom_id" -> { b with auth_atom_id = (Some v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_atom_id" -> { b with label_atom_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "U_tls[1][1]" -> { b with u_tls11 = (PDBjDict.some_float v) }
      | "U_tls[2][2]" -> { b with u_tls22 = (PDBjDict.some_float v) }
      | "U_tls[3][3]" -> { b with u_tls33 = (PDBjDict.some_float v) }
      | "U_tls[1][2]" -> { b with u_tls12 = (PDBjDict.some_float v) }
      | "U_tls[1][3]" -> { b with u_tls13 = (PDBjDict.some_float v) }
      | "U_tls[2][3]" -> { b with u_tls23 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("type_symbol",  v)) a.type_symbol;
      Option.map (fun v -> ("tls_group_id",  v)) a.tls_group_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("auth_atom_id",  v)) a.auth_atom_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_atom_id",  v)) a.label_atom_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("U_tls[1][1]", string_of_float v)) a.u_tls11;
      Option.map (fun v -> ("U_tls[2][2]", string_of_float v)) a.u_tls22;
      Option.map (fun v -> ("U_tls[3][3]", string_of_float v)) a.u_tls33;
      Option.map (fun v -> ("U_tls[1][2]", string_of_float v)) a.u_tls12;
      Option.map (fun v -> ("U_tls[1][3]", string_of_float v)) a.u_tls13;
      Option.map (fun v -> ("U_tls[2][3]", string_of_float v)) a.u_tls23;
    ]

end

module Pdbx_nmr_details = struct
  type t = {
    entry_id: string option;
    text: string option;
  }

  let default = {
    entry_id = None;
    text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "text" -> { b with text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("text",  v)) a.text;
    ]

end

module Pdbx_nmr_sample_details = struct
  type t = {
    solution_id: string option;
    contents: string option;
    solvent_system: string option;
    label: string option;
    type_: string option;
    details: string option;
  }

  let default = {
    solution_id = None;
    contents = None;
    solvent_system = None;
    label = None;
    type_ = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "solution_id" -> { b with solution_id = (Some v) }
      | "contents" -> { b with contents = (Some v) }
      | "solvent_system" -> { b with solvent_system = (Some v) }
      | "label" -> { b with label = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("solution_id",  v)) a.solution_id;
      Option.map (fun v -> ("contents",  v)) a.contents;
      Option.map (fun v -> ("solvent_system",  v)) a.solvent_system;
      Option.map (fun v -> ("label",  v)) a.label;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_nmr_exptl_sample = struct
  type t = {
    solution_id: string option;
    component: string option;
    concentration: float option;
    concentration_range: string option;
    concentration_units: string option;
    isotopic_labeling: string option;
    concentration_err: float option;
  }

  let default = {
    solution_id = None;
    component = None;
    concentration = None;
    concentration_range = None;
    concentration_units = None;
    isotopic_labeling = None;
    concentration_err = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "solution_id" -> { b with solution_id = (Some v) }
      | "component" -> { b with component = (Some v) }
      | "concentration" -> { b with concentration = (PDBjDict.some_float v) }
      | "concentration_range" -> { b with concentration_range = (Some v) }
      | "concentration_units" -> { b with concentration_units = (Some v) }
      | "isotopic_labeling" -> { b with isotopic_labeling = (Some v) }
      | "concentration_err" -> { b with concentration_err = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("solution_id",  v)) a.solution_id;
      Option.map (fun v -> ("component",  v)) a.component;
      Option.map (fun v -> ("concentration", string_of_float v)) a.concentration;
      Option.map (fun v -> ("concentration_range",  v)) a.concentration_range;
      Option.map (fun v -> ("concentration_units",  v)) a.concentration_units;
      Option.map (fun v -> ("isotopic_labeling",  v)) a.isotopic_labeling;
      Option.map (fun v -> ("concentration_err", string_of_float v)) a.concentration_err;
    ]

end

module Pdbx_nmr_exptl_sample_conditions = struct
  type t = {
    conditions_id: string option;
    temperature: string option;
    pressure_units: string option;
    pressure: string option;
    pH: string option;
    ionic_strength: string option;
    details: string option;
    ionic_strength_err: float option;
    ionic_strength_units: string option;
    label: string option;
    pH_err: float option;
    pH_units: string option;
    pressure_err: float option;
    temperature_err: float option;
    temperature_units: string option;
  }

  let default = {
    conditions_id = None;
    temperature = None;
    pressure_units = None;
    pressure = None;
    pH = None;
    ionic_strength = None;
    details = None;
    ionic_strength_err = None;
    ionic_strength_units = None;
    label = None;
    pH_err = None;
    pH_units = None;
    pressure_err = None;
    temperature_err = None;
    temperature_units = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "conditions_id" -> { b with conditions_id = (Some v) }
      | "temperature" -> { b with temperature = (Some v) }
      | "pressure_units" -> { b with pressure_units = (Some v) }
      | "pressure" -> { b with pressure = (Some v) }
      | "pH" -> { b with pH = (Some v) }
      | "ionic_strength" -> { b with ionic_strength = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "ionic_strength_err" -> { b with ionic_strength_err = (PDBjDict.some_float v) }
      | "ionic_strength_units" -> { b with ionic_strength_units = (Some v) }
      | "label" -> { b with label = (Some v) }
      | "pH_err" -> { b with pH_err = (PDBjDict.some_float v) }
      | "pH_units" -> { b with pH_units = (Some v) }
      | "pressure_err" -> { b with pressure_err = (PDBjDict.some_float v) }
      | "temperature_err" -> { b with temperature_err = (PDBjDict.some_float v) }
      | "temperature_units" -> { b with temperature_units = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("conditions_id",  v)) a.conditions_id;
      Option.map (fun v -> ("temperature",  v)) a.temperature;
      Option.map (fun v -> ("pressure_units",  v)) a.pressure_units;
      Option.map (fun v -> ("pressure",  v)) a.pressure;
      Option.map (fun v -> ("pH",  v)) a.pH;
      Option.map (fun v -> ("ionic_strength",  v)) a.ionic_strength;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("ionic_strength_err", string_of_float v)) a.ionic_strength_err;
      Option.map (fun v -> ("ionic_strength_units",  v)) a.ionic_strength_units;
      Option.map (fun v -> ("label",  v)) a.label;
      Option.map (fun v -> ("pH_err", string_of_float v)) a.pH_err;
      Option.map (fun v -> ("pH_units",  v)) a.pH_units;
      Option.map (fun v -> ("pressure_err", string_of_float v)) a.pressure_err;
      Option.map (fun v -> ("temperature_err", string_of_float v)) a.temperature_err;
      Option.map (fun v -> ("temperature_units",  v)) a.temperature_units;
    ]

end

module Pdbx_nmr_spectrometer = struct
  type t = {
    spectrometer_id: string option;
    model: string option;
    type_: string option;
    manufacturer: string option;
    field_strength: float option;
    details: string option;
    name: string option;
  }

  let default = {
    spectrometer_id = None;
    model = None;
    type_ = None;
    manufacturer = None;
    field_strength = None;
    details = None;
    name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "spectrometer_id" -> { b with spectrometer_id = (Some v) }
      | "model" -> { b with model = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "manufacturer" -> { b with manufacturer = (Some v) }
      | "field_strength" -> { b with field_strength = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | "name" -> { b with name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("spectrometer_id",  v)) a.spectrometer_id;
      Option.map (fun v -> ("model",  v)) a.model;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("manufacturer",  v)) a.manufacturer;
      Option.map (fun v -> ("field_strength", string_of_float v)) a.field_strength;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("name",  v)) a.name;
    ]

end

module Pdbx_nmr_exptl = struct
  type t = {
    experiment_id: string option;
    conditions_id: string option;
    solution_id: string option;
    type_: string option;
    spectrometer_id: int option;
    sample_state: string option;
  }

  let default = {
    experiment_id = None;
    conditions_id = None;
    solution_id = None;
    type_ = None;
    spectrometer_id = None;
    sample_state = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "experiment_id" -> { b with experiment_id = (Some v) }
      | "conditions_id" -> { b with conditions_id = (Some v) }
      | "solution_id" -> { b with solution_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "spectrometer_id" -> { b with spectrometer_id = (PDBjDict.some_int v) }
      | "sample_state" -> { b with sample_state = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("experiment_id",  v)) a.experiment_id;
      Option.map (fun v -> ("conditions_id",  v)) a.conditions_id;
      Option.map (fun v -> ("solution_id",  v)) a.solution_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("spectrometer_id", string_of_int v)) a.spectrometer_id;
      Option.map (fun v -> ("sample_state",  v)) a.sample_state;
    ]

end

module Pdbx_nmr_software = struct
  type t = {
    ordinal: int option;
    classification: string option;
    name: string option;
    version: string option;
    authors: string option;
    details: string option;
  }

  let default = {
    ordinal = None;
    classification = None;
    name = None;
    version = None;
    authors = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "classification" -> { b with classification = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "version" -> { b with version = (Some v) }
      | "authors" -> { b with authors = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("classification",  v)) a.classification;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("version",  v)) a.version;
      Option.map (fun v -> ("authors",  v)) a.authors;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_nmr_constraints = struct
  type t = {
    entry_id: string option;
    nOE_constraints_total: int option;
    nOE_intraresidue_total_count: int option;
    nOE_interentity_total_count: int option;
    nOE_sequential_total_count: int option;
    nOE_medium_range_total_count: int option;
    nOE_long_range_total_count: int option;
    protein_phi_angle_constraints_total_count: int option;
    protein_psi_angle_constraints_total_count: int option;
    protein_chi_angle_constraints_total_count: int option;
    protein_other_angle_constraints_total_count: int option;
    nOE_interproton_distance_evaluation: string option;
    nOE_pseudoatom_corrections: string option;
    nOE_motional_averaging_correction: string option;
    hydrogen_bond_constraints_total_count: int option;
    disulfide_bond_constraints_total_count: int option;
    nA_alpha_angle_constraints_total_count: int option;
    nA_beta_angle_constraints_total_count: int option;
    nA_gamma_angle_constraints_total_count: int option;
    nA_delta_angle_constraints_total_count: int option;
    nA_epsilon_angle_constraints_total_count: int option;
    nA_chi_angle_constraints_total_count: int option;
    nA_other_angle_constraints_total_count: int option;
    nA_sugar_pucker_constraints_total_count: int option;
  }

  let default = {
    entry_id = None;
    nOE_constraints_total = None;
    nOE_intraresidue_total_count = None;
    nOE_interentity_total_count = None;
    nOE_sequential_total_count = None;
    nOE_medium_range_total_count = None;
    nOE_long_range_total_count = None;
    protein_phi_angle_constraints_total_count = None;
    protein_psi_angle_constraints_total_count = None;
    protein_chi_angle_constraints_total_count = None;
    protein_other_angle_constraints_total_count = None;
    nOE_interproton_distance_evaluation = None;
    nOE_pseudoatom_corrections = None;
    nOE_motional_averaging_correction = None;
    hydrogen_bond_constraints_total_count = None;
    disulfide_bond_constraints_total_count = None;
    nA_alpha_angle_constraints_total_count = None;
    nA_beta_angle_constraints_total_count = None;
    nA_gamma_angle_constraints_total_count = None;
    nA_delta_angle_constraints_total_count = None;
    nA_epsilon_angle_constraints_total_count = None;
    nA_chi_angle_constraints_total_count = None;
    nA_other_angle_constraints_total_count = None;
    nA_sugar_pucker_constraints_total_count = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "NOE_constraints_total" -> { b with nOE_constraints_total = (PDBjDict.some_int v) }
      | "NOE_intraresidue_total_count" -> { b with nOE_intraresidue_total_count = (PDBjDict.some_int v) }
      | "NOE_interentity_total_count" -> { b with nOE_interentity_total_count = (PDBjDict.some_int v) }
      | "NOE_sequential_total_count" -> { b with nOE_sequential_total_count = (PDBjDict.some_int v) }
      | "NOE_medium_range_total_count" -> { b with nOE_medium_range_total_count = (PDBjDict.some_int v) }
      | "NOE_long_range_total_count" -> { b with nOE_long_range_total_count = (PDBjDict.some_int v) }
      | "protein_phi_angle_constraints_total_count" -> { b with protein_phi_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "protein_psi_angle_constraints_total_count" -> { b with protein_psi_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "protein_chi_angle_constraints_total_count" -> { b with protein_chi_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "protein_other_angle_constraints_total_count" -> { b with protein_other_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "NOE_interproton_distance_evaluation" -> { b with nOE_interproton_distance_evaluation = (Some v) }
      | "NOE_pseudoatom_corrections" -> { b with nOE_pseudoatom_corrections = (Some v) }
      | "NOE_motional_averaging_correction" -> { b with nOE_motional_averaging_correction = (Some v) }
      | "hydrogen_bond_constraints_total_count" -> { b with hydrogen_bond_constraints_total_count = (PDBjDict.some_int v) }
      | "disulfide_bond_constraints_total_count" -> { b with disulfide_bond_constraints_total_count = (PDBjDict.some_int v) }
      | "NA_alpha-angle_constraints_total_count" -> { b with nA_alpha_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "NA_beta-angle_constraints_total_count" -> { b with nA_beta_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "NA_gamma-angle_constraints_total_count" -> { b with nA_gamma_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "NA_delta-angle_constraints_total_count" -> { b with nA_delta_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "NA_epsilon-angle_constraints_total_count" -> { b with nA_epsilon_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "NA_chi-angle_constraints_total_count" -> { b with nA_chi_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "NA_other-angle_constraints_total_count" -> { b with nA_other_angle_constraints_total_count = (PDBjDict.some_int v) }
      | "NA_sugar_pucker_constraints_total_count" -> { b with nA_sugar_pucker_constraints_total_count = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("NOE_constraints_total", string_of_int v)) a.nOE_constraints_total;
      Option.map (fun v -> ("NOE_intraresidue_total_count", string_of_int v)) a.nOE_intraresidue_total_count;
      Option.map (fun v -> ("NOE_interentity_total_count", string_of_int v)) a.nOE_interentity_total_count;
      Option.map (fun v -> ("NOE_sequential_total_count", string_of_int v)) a.nOE_sequential_total_count;
      Option.map (fun v -> ("NOE_medium_range_total_count", string_of_int v)) a.nOE_medium_range_total_count;
      Option.map (fun v -> ("NOE_long_range_total_count", string_of_int v)) a.nOE_long_range_total_count;
      Option.map (fun v -> ("protein_phi_angle_constraints_total_count", string_of_int v)) a.protein_phi_angle_constraints_total_count;
      Option.map (fun v -> ("protein_psi_angle_constraints_total_count", string_of_int v)) a.protein_psi_angle_constraints_total_count;
      Option.map (fun v -> ("protein_chi_angle_constraints_total_count", string_of_int v)) a.protein_chi_angle_constraints_total_count;
      Option.map (fun v -> ("protein_other_angle_constraints_total_count", string_of_int v)) a.protein_other_angle_constraints_total_count;
      Option.map (fun v -> ("NOE_interproton_distance_evaluation",  v)) a.nOE_interproton_distance_evaluation;
      Option.map (fun v -> ("NOE_pseudoatom_corrections",  v)) a.nOE_pseudoatom_corrections;
      Option.map (fun v -> ("NOE_motional_averaging_correction",  v)) a.nOE_motional_averaging_correction;
      Option.map (fun v -> ("hydrogen_bond_constraints_total_count", string_of_int v)) a.hydrogen_bond_constraints_total_count;
      Option.map (fun v -> ("disulfide_bond_constraints_total_count", string_of_int v)) a.disulfide_bond_constraints_total_count;
      Option.map (fun v -> ("NA_alpha-angle_constraints_total_count", string_of_int v)) a.nA_alpha_angle_constraints_total_count;
      Option.map (fun v -> ("NA_beta-angle_constraints_total_count", string_of_int v)) a.nA_beta_angle_constraints_total_count;
      Option.map (fun v -> ("NA_gamma-angle_constraints_total_count", string_of_int v)) a.nA_gamma_angle_constraints_total_count;
      Option.map (fun v -> ("NA_delta-angle_constraints_total_count", string_of_int v)) a.nA_delta_angle_constraints_total_count;
      Option.map (fun v -> ("NA_epsilon-angle_constraints_total_count", string_of_int v)) a.nA_epsilon_angle_constraints_total_count;
      Option.map (fun v -> ("NA_chi-angle_constraints_total_count", string_of_int v)) a.nA_chi_angle_constraints_total_count;
      Option.map (fun v -> ("NA_other-angle_constraints_total_count", string_of_int v)) a.nA_other_angle_constraints_total_count;
      Option.map (fun v -> ("NA_sugar_pucker_constraints_total_count", string_of_int v)) a.nA_sugar_pucker_constraints_total_count;
    ]

end

module Pdbx_nmr_ensemble = struct
  type t = {
    entry_id: string option;
    conformers_calculated_total_number: int option;
    conformers_submitted_total_number: int option;
    conformer_selection_criteria: string option;
    representative_conformer: int option;
    average_constraints_per_residue: int option;
    average_constraint_violations_per_residue: int option;
    maximum_distance_constraint_violation: float option;
    average_distance_constraint_violation: float option;
    maximum_upper_distance_constraint_violation: float option;
    maximum_lower_distance_constraint_violation: float option;
    distance_constraint_violation_method: string option;
    maximum_torsion_angle_constraint_violation: float option;
    average_torsion_angle_constraint_violation: float option;
    torsion_angle_constraint_violation_method: string option;
  }

  let default = {
    entry_id = None;
    conformers_calculated_total_number = None;
    conformers_submitted_total_number = None;
    conformer_selection_criteria = None;
    representative_conformer = None;
    average_constraints_per_residue = None;
    average_constraint_violations_per_residue = None;
    maximum_distance_constraint_violation = None;
    average_distance_constraint_violation = None;
    maximum_upper_distance_constraint_violation = None;
    maximum_lower_distance_constraint_violation = None;
    distance_constraint_violation_method = None;
    maximum_torsion_angle_constraint_violation = None;
    average_torsion_angle_constraint_violation = None;
    torsion_angle_constraint_violation_method = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "conformers_calculated_total_number" -> { b with conformers_calculated_total_number = (PDBjDict.some_int v) }
      | "conformers_submitted_total_number" -> { b with conformers_submitted_total_number = (PDBjDict.some_int v) }
      | "conformer_selection_criteria" -> { b with conformer_selection_criteria = (Some v) }
      | "representative_conformer" -> { b with representative_conformer = (PDBjDict.some_int v) }
      | "average_constraints_per_residue" -> { b with average_constraints_per_residue = (PDBjDict.some_int v) }
      | "average_constraint_violations_per_residue" -> { b with average_constraint_violations_per_residue = (PDBjDict.some_int v) }
      | "maximum_distance_constraint_violation" -> { b with maximum_distance_constraint_violation = (PDBjDict.some_float v) }
      | "average_distance_constraint_violation" -> { b with average_distance_constraint_violation = (PDBjDict.some_float v) }
      | "maximum_upper_distance_constraint_violation" -> { b with maximum_upper_distance_constraint_violation = (PDBjDict.some_float v) }
      | "maximum_lower_distance_constraint_violation" -> { b with maximum_lower_distance_constraint_violation = (PDBjDict.some_float v) }
      | "distance_constraint_violation_method" -> { b with distance_constraint_violation_method = (Some v) }
      | "maximum_torsion_angle_constraint_violation" -> { b with maximum_torsion_angle_constraint_violation = (PDBjDict.some_float v) }
      | "average_torsion_angle_constraint_violation" -> { b with average_torsion_angle_constraint_violation = (PDBjDict.some_float v) }
      | "torsion_angle_constraint_violation_method" -> { b with torsion_angle_constraint_violation_method = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("conformers_calculated_total_number", string_of_int v)) a.conformers_calculated_total_number;
      Option.map (fun v -> ("conformers_submitted_total_number", string_of_int v)) a.conformers_submitted_total_number;
      Option.map (fun v -> ("conformer_selection_criteria",  v)) a.conformer_selection_criteria;
      Option.map (fun v -> ("representative_conformer", string_of_int v)) a.representative_conformer;
      Option.map (fun v -> ("average_constraints_per_residue", string_of_int v)) a.average_constraints_per_residue;
      Option.map (fun v -> ("average_constraint_violations_per_residue", string_of_int v)) a.average_constraint_violations_per_residue;
      Option.map (fun v -> ("maximum_distance_constraint_violation", string_of_float v)) a.maximum_distance_constraint_violation;
      Option.map (fun v -> ("average_distance_constraint_violation", string_of_float v)) a.average_distance_constraint_violation;
      Option.map (fun v -> ("maximum_upper_distance_constraint_violation", string_of_float v)) a.maximum_upper_distance_constraint_violation;
      Option.map (fun v -> ("maximum_lower_distance_constraint_violation", string_of_float v)) a.maximum_lower_distance_constraint_violation;
      Option.map (fun v -> ("distance_constraint_violation_method",  v)) a.distance_constraint_violation_method;
      Option.map (fun v -> ("maximum_torsion_angle_constraint_violation", string_of_float v)) a.maximum_torsion_angle_constraint_violation;
      Option.map (fun v -> ("average_torsion_angle_constraint_violation", string_of_float v)) a.average_torsion_angle_constraint_violation;
      Option.map (fun v -> ("torsion_angle_constraint_violation_method",  v)) a.torsion_angle_constraint_violation_method;
    ]

end

module Pdbx_nmr_ensemble_rms = struct
  type t = {
    entry_id: string option;
    residue_range_begin: int option;
    chain_range_begin: string option;
    residue_range_end: int option;
    chain_range_end: string option;
    atom_type: string option;
    distance_rms_dev: float option;
    distance_rms_dev_error: float option;
    covalent_bond_rms_dev: float option;
    covalent_bond_rms_dev_error: float option;
    bond_angle_rms_dev: float option;
    bond_angle_rms_dev_error: float option;
    improper_torsion_angle_rms_dev: float option;
    improper_torsion_angle_rms_dev_error: float option;
    peptide_planarity_rms_dev: float option;
    peptide_planarity_rms_dev_error: float option;
    dihedral_angles_rms_dev: float option;
    dihedral_angles_rms_dev_error: float option;
    coord_average_rmsd_method: string option;
  }

  let default = {
    entry_id = None;
    residue_range_begin = None;
    chain_range_begin = None;
    residue_range_end = None;
    chain_range_end = None;
    atom_type = None;
    distance_rms_dev = None;
    distance_rms_dev_error = None;
    covalent_bond_rms_dev = None;
    covalent_bond_rms_dev_error = None;
    bond_angle_rms_dev = None;
    bond_angle_rms_dev_error = None;
    improper_torsion_angle_rms_dev = None;
    improper_torsion_angle_rms_dev_error = None;
    peptide_planarity_rms_dev = None;
    peptide_planarity_rms_dev_error = None;
    dihedral_angles_rms_dev = None;
    dihedral_angles_rms_dev_error = None;
    coord_average_rmsd_method = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "residue_range_begin" -> { b with residue_range_begin = (PDBjDict.some_int v) }
      | "chain_range_begin" -> { b with chain_range_begin = (Some v) }
      | "residue_range_end" -> { b with residue_range_end = (PDBjDict.some_int v) }
      | "chain_range_end" -> { b with chain_range_end = (Some v) }
      | "atom_type" -> { b with atom_type = (Some v) }
      | "distance_rms_dev" -> { b with distance_rms_dev = (PDBjDict.some_float v) }
      | "distance_rms_dev_error" -> { b with distance_rms_dev_error = (PDBjDict.some_float v) }
      | "covalent_bond_rms_dev" -> { b with covalent_bond_rms_dev = (PDBjDict.some_float v) }
      | "covalent_bond_rms_dev_error" -> { b with covalent_bond_rms_dev_error = (PDBjDict.some_float v) }
      | "bond_angle_rms_dev" -> { b with bond_angle_rms_dev = (PDBjDict.some_float v) }
      | "bond_angle_rms_dev_error" -> { b with bond_angle_rms_dev_error = (PDBjDict.some_float v) }
      | "improper_torsion_angle_rms_dev" -> { b with improper_torsion_angle_rms_dev = (PDBjDict.some_float v) }
      | "improper_torsion_angle_rms_dev_error" -> { b with improper_torsion_angle_rms_dev_error = (PDBjDict.some_float v) }
      | "peptide_planarity_rms_dev" -> { b with peptide_planarity_rms_dev = (PDBjDict.some_float v) }
      | "peptide_planarity_rms_dev_error" -> { b with peptide_planarity_rms_dev_error = (PDBjDict.some_float v) }
      | "dihedral_angles_rms_dev" -> { b with dihedral_angles_rms_dev = (PDBjDict.some_float v) }
      | "dihedral_angles_rms_dev_error" -> { b with dihedral_angles_rms_dev_error = (PDBjDict.some_float v) }
      | "coord_average_rmsd_method" -> { b with coord_average_rmsd_method = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("residue_range_begin", string_of_int v)) a.residue_range_begin;
      Option.map (fun v -> ("chain_range_begin",  v)) a.chain_range_begin;
      Option.map (fun v -> ("residue_range_end", string_of_int v)) a.residue_range_end;
      Option.map (fun v -> ("chain_range_end",  v)) a.chain_range_end;
      Option.map (fun v -> ("atom_type",  v)) a.atom_type;
      Option.map (fun v -> ("distance_rms_dev", string_of_float v)) a.distance_rms_dev;
      Option.map (fun v -> ("distance_rms_dev_error", string_of_float v)) a.distance_rms_dev_error;
      Option.map (fun v -> ("covalent_bond_rms_dev", string_of_float v)) a.covalent_bond_rms_dev;
      Option.map (fun v -> ("covalent_bond_rms_dev_error", string_of_float v)) a.covalent_bond_rms_dev_error;
      Option.map (fun v -> ("bond_angle_rms_dev", string_of_float v)) a.bond_angle_rms_dev;
      Option.map (fun v -> ("bond_angle_rms_dev_error", string_of_float v)) a.bond_angle_rms_dev_error;
      Option.map (fun v -> ("improper_torsion_angle_rms_dev", string_of_float v)) a.improper_torsion_angle_rms_dev;
      Option.map (fun v -> ("improper_torsion_angle_rms_dev_error", string_of_float v)) a.improper_torsion_angle_rms_dev_error;
      Option.map (fun v -> ("peptide_planarity_rms_dev", string_of_float v)) a.peptide_planarity_rms_dev;
      Option.map (fun v -> ("peptide_planarity_rms_dev_error", string_of_float v)) a.peptide_planarity_rms_dev_error;
      Option.map (fun v -> ("dihedral_angles_rms_dev", string_of_float v)) a.dihedral_angles_rms_dev;
      Option.map (fun v -> ("dihedral_angles_rms_dev_error", string_of_float v)) a.dihedral_angles_rms_dev_error;
      Option.map (fun v -> ("coord_average_rmsd_method",  v)) a.coord_average_rmsd_method;
    ]

end

module Pdbx_nmr_representative = struct
  type t = {
    entry_id: string option;
    conformer_id: string option;
    selection_criteria: string option;
  }

  let default = {
    entry_id = None;
    conformer_id = None;
    selection_criteria = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "conformer_id" -> { b with conformer_id = (Some v) }
      | "selection_criteria" -> { b with selection_criteria = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("conformer_id",  v)) a.conformer_id;
      Option.map (fun v -> ("selection_criteria",  v)) a.selection_criteria;
    ]

end

module Pdbx_nmr_refine = struct
  type t = {
    entry_id: string option;
    method_: string option;
    details: string option;
    software_ordinal: int option;
  }

  let default = {
    entry_id = None;
    method_ = None;
    details = None;
    software_ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "software_ordinal" -> { b with software_ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("software_ordinal", string_of_int v)) a.software_ordinal;
    ]

end

module Pdbx_nmr_force_constants = struct
  type t = {
    entry_id: string option;
    exptl_distance_term: float option;
    exptl_distance_term_units: string option;
    exptl_torsion_angles_term: float option;
    exptl_torsion_angles_term_units: string option;
    exptl_J_coupling_term: float option;
    exptl_J_coupling_term_units: string option;
    exptl_13C_shift_term: float option;
    exptl_13C_shift_term_units: string option;
    exptl_1H_shift_term: float option;
    exptl_1H_shift_term_units: string option;
    exptl_dipolar_coupling_term: float option;
    exptl_dipolar_coupling_term_units: string option;
    exptl_D_isotope_shift_term: float option;
    exptl_D_isotope_shift_term_units: string option;
    covalent_geom_bond_term: float option;
    covalent_geom_bond_term_units: string option;
    covalent_geom_angles_term: float option;
    covalent_geom_angles_term_units: string option;
    covalent_geom_impropers_term: float option;
    covalent_geom_impropers_term_units: string option;
    non_bonded_inter_van_der_Waals_term_type: string option;
    non_bonded_inter_van_der_Waals_term: float option;
    non_bonded_inter_van_der_Waals_term_units: string option;
    non_bonded_inter_conf_db_potential_term: float option;
    non_bonded_inter_radius_of_gyration_term: float option;
    non_bonded_inter_radius_of_gyration_term_units: string option;
  }

  let default = {
    entry_id = None;
    exptl_distance_term = None;
    exptl_distance_term_units = None;
    exptl_torsion_angles_term = None;
    exptl_torsion_angles_term_units = None;
    exptl_J_coupling_term = None;
    exptl_J_coupling_term_units = None;
    exptl_13C_shift_term = None;
    exptl_13C_shift_term_units = None;
    exptl_1H_shift_term = None;
    exptl_1H_shift_term_units = None;
    exptl_dipolar_coupling_term = None;
    exptl_dipolar_coupling_term_units = None;
    exptl_D_isotope_shift_term = None;
    exptl_D_isotope_shift_term_units = None;
    covalent_geom_bond_term = None;
    covalent_geom_bond_term_units = None;
    covalent_geom_angles_term = None;
    covalent_geom_angles_term_units = None;
    covalent_geom_impropers_term = None;
    covalent_geom_impropers_term_units = None;
    non_bonded_inter_van_der_Waals_term_type = None;
    non_bonded_inter_van_der_Waals_term = None;
    non_bonded_inter_van_der_Waals_term_units = None;
    non_bonded_inter_conf_db_potential_term = None;
    non_bonded_inter_radius_of_gyration_term = None;
    non_bonded_inter_radius_of_gyration_term_units = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "exptl_distance_term" -> { b with exptl_distance_term = (PDBjDict.some_float v) }
      | "exptl_distance_term_units" -> { b with exptl_distance_term_units = (Some v) }
      | "exptl_torsion_angles_term" -> { b with exptl_torsion_angles_term = (PDBjDict.some_float v) }
      | "exptl_torsion_angles_term_units" -> { b with exptl_torsion_angles_term_units = (Some v) }
      | "exptl_J_coupling_term" -> { b with exptl_J_coupling_term = (PDBjDict.some_float v) }
      | "exptl_J_coupling_term_units" -> { b with exptl_J_coupling_term_units = (Some v) }
      | "exptl_13C_shift_term" -> { b with exptl_13C_shift_term = (PDBjDict.some_float v) }
      | "exptl_13C_shift_term_units" -> { b with exptl_13C_shift_term_units = (Some v) }
      | "exptl_1H_shift_term" -> { b with exptl_1H_shift_term = (PDBjDict.some_float v) }
      | "exptl_1H_shift_term_units" -> { b with exptl_1H_shift_term_units = (Some v) }
      | "exptl_dipolar_coupling_term" -> { b with exptl_dipolar_coupling_term = (PDBjDict.some_float v) }
      | "exptl_dipolar_coupling_term_units" -> { b with exptl_dipolar_coupling_term_units = (Some v) }
      | "exptl_D_isotope_shift_term" -> { b with exptl_D_isotope_shift_term = (PDBjDict.some_float v) }
      | "exptl_D_isotope_shift_term_units" -> { b with exptl_D_isotope_shift_term_units = (Some v) }
      | "covalent_geom_bond_term" -> { b with covalent_geom_bond_term = (PDBjDict.some_float v) }
      | "covalent_geom_bond_term_units" -> { b with covalent_geom_bond_term_units = (Some v) }
      | "covalent_geom_angles_term" -> { b with covalent_geom_angles_term = (PDBjDict.some_float v) }
      | "covalent_geom_angles_term_units" -> { b with covalent_geom_angles_term_units = (Some v) }
      | "covalent_geom_impropers_term" -> { b with covalent_geom_impropers_term = (PDBjDict.some_float v) }
      | "covalent_geom_impropers_term_units" -> { b with covalent_geom_impropers_term_units = (Some v) }
      | "non-bonded_inter_van_der_Waals_term_type" -> { b with non_bonded_inter_van_der_Waals_term_type = (Some v) }
      | "non-bonded_inter_van_der_Waals_term" -> { b with non_bonded_inter_van_der_Waals_term = (PDBjDict.some_float v) }
      | "non-bonded_inter_van_der_Waals_term_units" -> { b with non_bonded_inter_van_der_Waals_term_units = (Some v) }
      | "non-bonded_inter_conf_db_potential_term" -> { b with non_bonded_inter_conf_db_potential_term = (PDBjDict.some_float v) }
      | "non-bonded_inter_radius_of_gyration_term" -> { b with non_bonded_inter_radius_of_gyration_term = (PDBjDict.some_float v) }
      | "non-bonded_inter_radius_of_gyration_term_units" -> { b with non_bonded_inter_radius_of_gyration_term_units = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("exptl_distance_term", string_of_float v)) a.exptl_distance_term;
      Option.map (fun v -> ("exptl_distance_term_units",  v)) a.exptl_distance_term_units;
      Option.map (fun v -> ("exptl_torsion_angles_term", string_of_float v)) a.exptl_torsion_angles_term;
      Option.map (fun v -> ("exptl_torsion_angles_term_units",  v)) a.exptl_torsion_angles_term_units;
      Option.map (fun v -> ("exptl_J_coupling_term", string_of_float v)) a.exptl_J_coupling_term;
      Option.map (fun v -> ("exptl_J_coupling_term_units",  v)) a.exptl_J_coupling_term_units;
      Option.map (fun v -> ("exptl_13C_shift_term", string_of_float v)) a.exptl_13C_shift_term;
      Option.map (fun v -> ("exptl_13C_shift_term_units",  v)) a.exptl_13C_shift_term_units;
      Option.map (fun v -> ("exptl_1H_shift_term", string_of_float v)) a.exptl_1H_shift_term;
      Option.map (fun v -> ("exptl_1H_shift_term_units",  v)) a.exptl_1H_shift_term_units;
      Option.map (fun v -> ("exptl_dipolar_coupling_term", string_of_float v)) a.exptl_dipolar_coupling_term;
      Option.map (fun v -> ("exptl_dipolar_coupling_term_units",  v)) a.exptl_dipolar_coupling_term_units;
      Option.map (fun v -> ("exptl_D_isotope_shift_term", string_of_float v)) a.exptl_D_isotope_shift_term;
      Option.map (fun v -> ("exptl_D_isotope_shift_term_units",  v)) a.exptl_D_isotope_shift_term_units;
      Option.map (fun v -> ("covalent_geom_bond_term", string_of_float v)) a.covalent_geom_bond_term;
      Option.map (fun v -> ("covalent_geom_bond_term_units",  v)) a.covalent_geom_bond_term_units;
      Option.map (fun v -> ("covalent_geom_angles_term", string_of_float v)) a.covalent_geom_angles_term;
      Option.map (fun v -> ("covalent_geom_angles_term_units",  v)) a.covalent_geom_angles_term_units;
      Option.map (fun v -> ("covalent_geom_impropers_term", string_of_float v)) a.covalent_geom_impropers_term;
      Option.map (fun v -> ("covalent_geom_impropers_term_units",  v)) a.covalent_geom_impropers_term_units;
      Option.map (fun v -> ("non-bonded_inter_van_der_Waals_term_type",  v)) a.non_bonded_inter_van_der_Waals_term_type;
      Option.map (fun v -> ("non-bonded_inter_van_der_Waals_term", string_of_float v)) a.non_bonded_inter_van_der_Waals_term;
      Option.map (fun v -> ("non-bonded_inter_van_der_Waals_term_units",  v)) a.non_bonded_inter_van_der_Waals_term_units;
      Option.map (fun v -> ("non-bonded_inter_conf_db_potential_term", string_of_float v)) a.non_bonded_inter_conf_db_potential_term;
      Option.map (fun v -> ("non-bonded_inter_radius_of_gyration_term", string_of_float v)) a.non_bonded_inter_radius_of_gyration_term;
      Option.map (fun v -> ("non-bonded_inter_radius_of_gyration_term_units",  v)) a.non_bonded_inter_radius_of_gyration_term_units;
    ]

end

module Ndb_struct_conf_na = struct
  type t = {
    entry_id: string option;
    feature: string option;
    feature_count: int option;
  }

  let default = {
    entry_id = None;
    feature = None;
    feature_count = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "feature" -> { b with feature = (Some v) }
      | "feature_count" -> { b with feature_count = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("feature",  v)) a.feature;
      Option.map (fun v -> ("feature_count", string_of_int v)) a.feature_count;
    ]

end

module Ndb_struct_feature_na = struct
  type t = {
    entry_id: string option;
    feature: string option;
    feature_count: int option;
  }

  let default = {
    entry_id = None;
    feature = None;
    feature_count = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "feature" -> { b with feature = (Some v) }
      | "feature_count" -> { b with feature_count = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("feature",  v)) a.feature;
      Option.map (fun v -> ("feature_count", string_of_int v)) a.feature_count;
    ]

end

module Ndb_struct_na_base_pair = struct
  type t = {
    model_number: int option;
    pair_number: int option;
    pair_name: string option;
    i_label_asym_id: string option;
    i_label_comp_id: string option;
    i_label_seq_id: int option;
    i_symmetry: string option;
    j_label_asym_id: string option;
    j_label_comp_id: string option;
    j_label_seq_id: int option;
    j_symmetry: string option;
    i_auth_asym_id: string option;
    i_auth_seq_id: string option;
    i_PDB_ins_code: string option;
    j_auth_asym_id: string option;
    j_auth_seq_id: string option;
    j_PDB_ins_code: string option;
    shear: float option;
    stretch: float option;
    stagger: float option;
    buckle: float option;
    propeller: float option;
    opening: float option;
    hbond_type_12: int option;
    hbond_type_28: int option;
  }

  let default = {
    model_number = None;
    pair_number = None;
    pair_name = None;
    i_label_asym_id = None;
    i_label_comp_id = None;
    i_label_seq_id = None;
    i_symmetry = None;
    j_label_asym_id = None;
    j_label_comp_id = None;
    j_label_seq_id = None;
    j_symmetry = None;
    i_auth_asym_id = None;
    i_auth_seq_id = None;
    i_PDB_ins_code = None;
    j_auth_asym_id = None;
    j_auth_seq_id = None;
    j_PDB_ins_code = None;
    shear = None;
    stretch = None;
    stagger = None;
    buckle = None;
    propeller = None;
    opening = None;
    hbond_type_12 = None;
    hbond_type_28 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "model_number" -> { b with model_number = (PDBjDict.some_int v) }
      | "pair_number" -> { b with pair_number = (PDBjDict.some_int v) }
      | "pair_name" -> { b with pair_name = (Some v) }
      | "i_label_asym_id" -> { b with i_label_asym_id = (Some v) }
      | "i_label_comp_id" -> { b with i_label_comp_id = (Some v) }
      | "i_label_seq_id" -> { b with i_label_seq_id = (PDBjDict.some_int v) }
      | "i_symmetry" -> { b with i_symmetry = (Some v) }
      | "j_label_asym_id" -> { b with j_label_asym_id = (Some v) }
      | "j_label_comp_id" -> { b with j_label_comp_id = (Some v) }
      | "j_label_seq_id" -> { b with j_label_seq_id = (PDBjDict.some_int v) }
      | "j_symmetry" -> { b with j_symmetry = (Some v) }
      | "i_auth_asym_id" -> { b with i_auth_asym_id = (Some v) }
      | "i_auth_seq_id" -> { b with i_auth_seq_id = (Some v) }
      | "i_PDB_ins_code" -> { b with i_PDB_ins_code = (Some v) }
      | "j_auth_asym_id" -> { b with j_auth_asym_id = (Some v) }
      | "j_auth_seq_id" -> { b with j_auth_seq_id = (Some v) }
      | "j_PDB_ins_code" -> { b with j_PDB_ins_code = (Some v) }
      | "shear" -> { b with shear = (PDBjDict.some_float v) }
      | "stretch" -> { b with stretch = (PDBjDict.some_float v) }
      | "stagger" -> { b with stagger = (PDBjDict.some_float v) }
      | "buckle" -> { b with buckle = (PDBjDict.some_float v) }
      | "propeller" -> { b with propeller = (PDBjDict.some_float v) }
      | "opening" -> { b with opening = (PDBjDict.some_float v) }
      | "hbond_type_12" -> { b with hbond_type_12 = (PDBjDict.some_int v) }
      | "hbond_type_28" -> { b with hbond_type_28 = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("model_number", string_of_int v)) a.model_number;
      Option.map (fun v -> ("pair_number", string_of_int v)) a.pair_number;
      Option.map (fun v -> ("pair_name",  v)) a.pair_name;
      Option.map (fun v -> ("i_label_asym_id",  v)) a.i_label_asym_id;
      Option.map (fun v -> ("i_label_comp_id",  v)) a.i_label_comp_id;
      Option.map (fun v -> ("i_label_seq_id", string_of_int v)) a.i_label_seq_id;
      Option.map (fun v -> ("i_symmetry",  v)) a.i_symmetry;
      Option.map (fun v -> ("j_label_asym_id",  v)) a.j_label_asym_id;
      Option.map (fun v -> ("j_label_comp_id",  v)) a.j_label_comp_id;
      Option.map (fun v -> ("j_label_seq_id", string_of_int v)) a.j_label_seq_id;
      Option.map (fun v -> ("j_symmetry",  v)) a.j_symmetry;
      Option.map (fun v -> ("i_auth_asym_id",  v)) a.i_auth_asym_id;
      Option.map (fun v -> ("i_auth_seq_id",  v)) a.i_auth_seq_id;
      Option.map (fun v -> ("i_PDB_ins_code",  v)) a.i_PDB_ins_code;
      Option.map (fun v -> ("j_auth_asym_id",  v)) a.j_auth_asym_id;
      Option.map (fun v -> ("j_auth_seq_id",  v)) a.j_auth_seq_id;
      Option.map (fun v -> ("j_PDB_ins_code",  v)) a.j_PDB_ins_code;
      Option.map (fun v -> ("shear", string_of_float v)) a.shear;
      Option.map (fun v -> ("stretch", string_of_float v)) a.stretch;
      Option.map (fun v -> ("stagger", string_of_float v)) a.stagger;
      Option.map (fun v -> ("buckle", string_of_float v)) a.buckle;
      Option.map (fun v -> ("propeller", string_of_float v)) a.propeller;
      Option.map (fun v -> ("opening", string_of_float v)) a.opening;
      Option.map (fun v -> ("hbond_type_12", string_of_int v)) a.hbond_type_12;
      Option.map (fun v -> ("hbond_type_28", string_of_int v)) a.hbond_type_28;
    ]

end

module Ndb_struct_na_base_pair_step = struct
  type t = {
    model_number: int option;
    step_number: int option;
    step_name: string option;
    i_label_asym_id_1: string option;
    i_label_comp_id_1: string option;
    i_label_seq_id_1: int option;
    i_symmetry_1: string option;
    j_label_asym_id_1: string option;
    j_label_comp_id_1: string option;
    j_label_seq_id_1: int option;
    j_symmetry_1: string option;
    i_label_asym_id_2: string option;
    i_label_comp_id_2: string option;
    i_label_seq_id_2: int option;
    i_symmetry_2: string option;
    j_label_asym_id_2: string option;
    j_label_comp_id_2: string option;
    j_label_seq_id_2: int option;
    j_symmetry_2: string option;
    i_auth_asym_id_1: string option;
    i_auth_seq_id_1: string option;
    i_PDB_ins_code_1: string option;
    j_auth_asym_id_1: string option;
    j_auth_seq_id_1: string option;
    j_PDB_ins_code_1: string option;
    i_auth_asym_id_2: string option;
    i_auth_seq_id_2: string option;
    i_PDB_ins_code_2: string option;
    j_auth_asym_id_2: string option;
    j_auth_seq_id_2: string option;
    j_PDB_ins_code_2: string option;
    shift: float option;
    slide: float option;
    rise: float option;
    tilt: float option;
    roll: float option;
    twist: float option;
    x_displacement: float option;
    y_displacement: float option;
    helical_rise: float option;
    inclination: float option;
    tip: float option;
    helical_twist: float option;
  }

  let default = {
    model_number = None;
    step_number = None;
    step_name = None;
    i_label_asym_id_1 = None;
    i_label_comp_id_1 = None;
    i_label_seq_id_1 = None;
    i_symmetry_1 = None;
    j_label_asym_id_1 = None;
    j_label_comp_id_1 = None;
    j_label_seq_id_1 = None;
    j_symmetry_1 = None;
    i_label_asym_id_2 = None;
    i_label_comp_id_2 = None;
    i_label_seq_id_2 = None;
    i_symmetry_2 = None;
    j_label_asym_id_2 = None;
    j_label_comp_id_2 = None;
    j_label_seq_id_2 = None;
    j_symmetry_2 = None;
    i_auth_asym_id_1 = None;
    i_auth_seq_id_1 = None;
    i_PDB_ins_code_1 = None;
    j_auth_asym_id_1 = None;
    j_auth_seq_id_1 = None;
    j_PDB_ins_code_1 = None;
    i_auth_asym_id_2 = None;
    i_auth_seq_id_2 = None;
    i_PDB_ins_code_2 = None;
    j_auth_asym_id_2 = None;
    j_auth_seq_id_2 = None;
    j_PDB_ins_code_2 = None;
    shift = None;
    slide = None;
    rise = None;
    tilt = None;
    roll = None;
    twist = None;
    x_displacement = None;
    y_displacement = None;
    helical_rise = None;
    inclination = None;
    tip = None;
    helical_twist = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "model_number" -> { b with model_number = (PDBjDict.some_int v) }
      | "step_number" -> { b with step_number = (PDBjDict.some_int v) }
      | "step_name" -> { b with step_name = (Some v) }
      | "i_label_asym_id_1" -> { b with i_label_asym_id_1 = (Some v) }
      | "i_label_comp_id_1" -> { b with i_label_comp_id_1 = (Some v) }
      | "i_label_seq_id_1" -> { b with i_label_seq_id_1 = (PDBjDict.some_int v) }
      | "i_symmetry_1" -> { b with i_symmetry_1 = (Some v) }
      | "j_label_asym_id_1" -> { b with j_label_asym_id_1 = (Some v) }
      | "j_label_comp_id_1" -> { b with j_label_comp_id_1 = (Some v) }
      | "j_label_seq_id_1" -> { b with j_label_seq_id_1 = (PDBjDict.some_int v) }
      | "j_symmetry_1" -> { b with j_symmetry_1 = (Some v) }
      | "i_label_asym_id_2" -> { b with i_label_asym_id_2 = (Some v) }
      | "i_label_comp_id_2" -> { b with i_label_comp_id_2 = (Some v) }
      | "i_label_seq_id_2" -> { b with i_label_seq_id_2 = (PDBjDict.some_int v) }
      | "i_symmetry_2" -> { b with i_symmetry_2 = (Some v) }
      | "j_label_asym_id_2" -> { b with j_label_asym_id_2 = (Some v) }
      | "j_label_comp_id_2" -> { b with j_label_comp_id_2 = (Some v) }
      | "j_label_seq_id_2" -> { b with j_label_seq_id_2 = (PDBjDict.some_int v) }
      | "j_symmetry_2" -> { b with j_symmetry_2 = (Some v) }
      | "i_auth_asym_id_1" -> { b with i_auth_asym_id_1 = (Some v) }
      | "i_auth_seq_id_1" -> { b with i_auth_seq_id_1 = (Some v) }
      | "i_PDB_ins_code_1" -> { b with i_PDB_ins_code_1 = (Some v) }
      | "j_auth_asym_id_1" -> { b with j_auth_asym_id_1 = (Some v) }
      | "j_auth_seq_id_1" -> { b with j_auth_seq_id_1 = (Some v) }
      | "j_PDB_ins_code_1" -> { b with j_PDB_ins_code_1 = (Some v) }
      | "i_auth_asym_id_2" -> { b with i_auth_asym_id_2 = (Some v) }
      | "i_auth_seq_id_2" -> { b with i_auth_seq_id_2 = (Some v) }
      | "i_PDB_ins_code_2" -> { b with i_PDB_ins_code_2 = (Some v) }
      | "j_auth_asym_id_2" -> { b with j_auth_asym_id_2 = (Some v) }
      | "j_auth_seq_id_2" -> { b with j_auth_seq_id_2 = (Some v) }
      | "j_PDB_ins_code_2" -> { b with j_PDB_ins_code_2 = (Some v) }
      | "shift" -> { b with shift = (PDBjDict.some_float v) }
      | "slide" -> { b with slide = (PDBjDict.some_float v) }
      | "rise" -> { b with rise = (PDBjDict.some_float v) }
      | "tilt" -> { b with tilt = (PDBjDict.some_float v) }
      | "roll" -> { b with roll = (PDBjDict.some_float v) }
      | "twist" -> { b with twist = (PDBjDict.some_float v) }
      | "x_displacement" -> { b with x_displacement = (PDBjDict.some_float v) }
      | "y_displacement" -> { b with y_displacement = (PDBjDict.some_float v) }
      | "helical_rise" -> { b with helical_rise = (PDBjDict.some_float v) }
      | "inclination" -> { b with inclination = (PDBjDict.some_float v) }
      | "tip" -> { b with tip = (PDBjDict.some_float v) }
      | "helical_twist" -> { b with helical_twist = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("model_number", string_of_int v)) a.model_number;
      Option.map (fun v -> ("step_number", string_of_int v)) a.step_number;
      Option.map (fun v -> ("step_name",  v)) a.step_name;
      Option.map (fun v -> ("i_label_asym_id_1",  v)) a.i_label_asym_id_1;
      Option.map (fun v -> ("i_label_comp_id_1",  v)) a.i_label_comp_id_1;
      Option.map (fun v -> ("i_label_seq_id_1", string_of_int v)) a.i_label_seq_id_1;
      Option.map (fun v -> ("i_symmetry_1",  v)) a.i_symmetry_1;
      Option.map (fun v -> ("j_label_asym_id_1",  v)) a.j_label_asym_id_1;
      Option.map (fun v -> ("j_label_comp_id_1",  v)) a.j_label_comp_id_1;
      Option.map (fun v -> ("j_label_seq_id_1", string_of_int v)) a.j_label_seq_id_1;
      Option.map (fun v -> ("j_symmetry_1",  v)) a.j_symmetry_1;
      Option.map (fun v -> ("i_label_asym_id_2",  v)) a.i_label_asym_id_2;
      Option.map (fun v -> ("i_label_comp_id_2",  v)) a.i_label_comp_id_2;
      Option.map (fun v -> ("i_label_seq_id_2", string_of_int v)) a.i_label_seq_id_2;
      Option.map (fun v -> ("i_symmetry_2",  v)) a.i_symmetry_2;
      Option.map (fun v -> ("j_label_asym_id_2",  v)) a.j_label_asym_id_2;
      Option.map (fun v -> ("j_label_comp_id_2",  v)) a.j_label_comp_id_2;
      Option.map (fun v -> ("j_label_seq_id_2", string_of_int v)) a.j_label_seq_id_2;
      Option.map (fun v -> ("j_symmetry_2",  v)) a.j_symmetry_2;
      Option.map (fun v -> ("i_auth_asym_id_1",  v)) a.i_auth_asym_id_1;
      Option.map (fun v -> ("i_auth_seq_id_1",  v)) a.i_auth_seq_id_1;
      Option.map (fun v -> ("i_PDB_ins_code_1",  v)) a.i_PDB_ins_code_1;
      Option.map (fun v -> ("j_auth_asym_id_1",  v)) a.j_auth_asym_id_1;
      Option.map (fun v -> ("j_auth_seq_id_1",  v)) a.j_auth_seq_id_1;
      Option.map (fun v -> ("j_PDB_ins_code_1",  v)) a.j_PDB_ins_code_1;
      Option.map (fun v -> ("i_auth_asym_id_2",  v)) a.i_auth_asym_id_2;
      Option.map (fun v -> ("i_auth_seq_id_2",  v)) a.i_auth_seq_id_2;
      Option.map (fun v -> ("i_PDB_ins_code_2",  v)) a.i_PDB_ins_code_2;
      Option.map (fun v -> ("j_auth_asym_id_2",  v)) a.j_auth_asym_id_2;
      Option.map (fun v -> ("j_auth_seq_id_2",  v)) a.j_auth_seq_id_2;
      Option.map (fun v -> ("j_PDB_ins_code_2",  v)) a.j_PDB_ins_code_2;
      Option.map (fun v -> ("shift", string_of_float v)) a.shift;
      Option.map (fun v -> ("slide", string_of_float v)) a.slide;
      Option.map (fun v -> ("rise", string_of_float v)) a.rise;
      Option.map (fun v -> ("tilt", string_of_float v)) a.tilt;
      Option.map (fun v -> ("roll", string_of_float v)) a.roll;
      Option.map (fun v -> ("twist", string_of_float v)) a.twist;
      Option.map (fun v -> ("x_displacement", string_of_float v)) a.x_displacement;
      Option.map (fun v -> ("y_displacement", string_of_float v)) a.y_displacement;
      Option.map (fun v -> ("helical_rise", string_of_float v)) a.helical_rise;
      Option.map (fun v -> ("inclination", string_of_float v)) a.inclination;
      Option.map (fun v -> ("tip", string_of_float v)) a.tip;
      Option.map (fun v -> ("helical_twist", string_of_float v)) a.helical_twist;
    ]

end

module Ndb_original_ndb_coordinates = struct
  type t = {
    coord_section: string option;
  }

  let default = {
    coord_section = None;
  }

  let of_mmCIF items =
    match items with
    | [] -> default
    | (_,v)::_ -> { coord_section = (Some v) }

  let to_mmCIF a =
    match a.coord_section with
    | None -> []
    | Some v -> [ ("coord_section",( v)) ]

end

module Pdbx_entity_nonpoly = struct
  type t = {
    entity_id: string option;
    comp_id: string option;
    name: string option;
  }

  let default = {
    entity_id = None;
    comp_id = None;
    name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("name",  v)) a.name;
    ]

end

module Pdbx_phasing_dm = struct
  type t = {
    entry_id: string option;
    method_: string option;
    mask_type: string option;
    fom_acentric: float option;
    fom_centric: float option;
    fom: float option;
    reflns_acentric: int option;
    reflns_centric: int option;
    reflns: int option;
    delta_phi_initial: float option;
    delta_phi_final: float option;
  }

  let default = {
    entry_id = None;
    method_ = None;
    mask_type = None;
    fom_acentric = None;
    fom_centric = None;
    fom = None;
    reflns_acentric = None;
    reflns_centric = None;
    reflns = None;
    delta_phi_initial = None;
    delta_phi_final = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "mask_type" -> { b with mask_type = (Some v) }
      | "fom_acentric" -> { b with fom_acentric = (PDBjDict.some_float v) }
      | "fom_centric" -> { b with fom_centric = (PDBjDict.some_float v) }
      | "fom" -> { b with fom = (PDBjDict.some_float v) }
      | "reflns_acentric" -> { b with reflns_acentric = (PDBjDict.some_int v) }
      | "reflns_centric" -> { b with reflns_centric = (PDBjDict.some_int v) }
      | "reflns" -> { b with reflns = (PDBjDict.some_int v) }
      | "delta_phi_initial" -> { b with delta_phi_initial = (PDBjDict.some_float v) }
      | "delta_phi_final" -> { b with delta_phi_final = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("mask_type",  v)) a.mask_type;
      Option.map (fun v -> ("fom_acentric", string_of_float v)) a.fom_acentric;
      Option.map (fun v -> ("fom_centric", string_of_float v)) a.fom_centric;
      Option.map (fun v -> ("fom", string_of_float v)) a.fom;
      Option.map (fun v -> ("reflns_acentric", string_of_int v)) a.reflns_acentric;
      Option.map (fun v -> ("reflns_centric", string_of_int v)) a.reflns_centric;
      Option.map (fun v -> ("reflns", string_of_int v)) a.reflns;
      Option.map (fun v -> ("delta_phi_initial", string_of_float v)) a.delta_phi_initial;
      Option.map (fun v -> ("delta_phi_final", string_of_float v)) a.delta_phi_final;
    ]

end

module Pdbx_phasing_dm_shell = struct
  type t = {
    d_res_high: float option;
    d_res_low: float option;
    fom_acentric: float option;
    fom_centric: float option;
    fom: float option;
    reflns_acentric: int option;
    reflns_centric: int option;
    reflns: int option;
    delta_phi_initial: float option;
    delta_phi_final: float option;
  }

  let default = {
    d_res_high = None;
    d_res_low = None;
    fom_acentric = None;
    fom_centric = None;
    fom = None;
    reflns_acentric = None;
    reflns_centric = None;
    reflns = None;
    delta_phi_initial = None;
    delta_phi_final = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "fom_acentric" -> { b with fom_acentric = (PDBjDict.some_float v) }
      | "fom_centric" -> { b with fom_centric = (PDBjDict.some_float v) }
      | "fom" -> { b with fom = (PDBjDict.some_float v) }
      | "reflns_acentric" -> { b with reflns_acentric = (PDBjDict.some_int v) }
      | "reflns_centric" -> { b with reflns_centric = (PDBjDict.some_int v) }
      | "reflns" -> { b with reflns = (PDBjDict.some_int v) }
      | "delta_phi_initial" -> { b with delta_phi_initial = (PDBjDict.some_float v) }
      | "delta_phi_final" -> { b with delta_phi_final = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("fom_acentric", string_of_float v)) a.fom_acentric;
      Option.map (fun v -> ("fom_centric", string_of_float v)) a.fom_centric;
      Option.map (fun v -> ("fom", string_of_float v)) a.fom;
      Option.map (fun v -> ("reflns_acentric", string_of_int v)) a.reflns_acentric;
      Option.map (fun v -> ("reflns_centric", string_of_int v)) a.reflns_centric;
      Option.map (fun v -> ("reflns", string_of_int v)) a.reflns;
      Option.map (fun v -> ("delta_phi_initial", string_of_float v)) a.delta_phi_initial;
      Option.map (fun v -> ("delta_phi_final", string_of_float v)) a.delta_phi_final;
    ]

end

module Pdbx_phasing_MAD_shell = struct
  type t = {
    d_res_low: float option;
    d_res_high: float option;
    reflns_acentric: float option;
    reflns_centric: int option;
    reflns: int option;
    fom_acentric: float option;
    fom_centric: float option;
    fom: float option;
    r_cullis_centric: float option;
    r_cullis_acentric: float option;
    r_cullis: float option;
    r_kraut_centric: float option;
    r_kraut_acentric: float option;
    r_kraut: float option;
    loc_centric: float option;
    loc_acentric: float option;
    loc: float option;
    power_centric: float option;
    power_acentric: float option;
    power: float option;
  }

  let default = {
    d_res_low = None;
    d_res_high = None;
    reflns_acentric = None;
    reflns_centric = None;
    reflns = None;
    fom_acentric = None;
    fom_centric = None;
    fom = None;
    r_cullis_centric = None;
    r_cullis_acentric = None;
    r_cullis = None;
    r_kraut_centric = None;
    r_kraut_acentric = None;
    r_kraut = None;
    loc_centric = None;
    loc_acentric = None;
    loc = None;
    power_centric = None;
    power_acentric = None;
    power = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "reflns_acentric" -> { b with reflns_acentric = (PDBjDict.some_float v) }
      | "reflns_centric" -> { b with reflns_centric = (PDBjDict.some_int v) }
      | "reflns" -> { b with reflns = (PDBjDict.some_int v) }
      | "fom_acentric" -> { b with fom_acentric = (PDBjDict.some_float v) }
      | "fom_centric" -> { b with fom_centric = (PDBjDict.some_float v) }
      | "fom" -> { b with fom = (PDBjDict.some_float v) }
      | "R_cullis_centric" -> { b with r_cullis_centric = (PDBjDict.some_float v) }
      | "R_cullis_acentric" -> { b with r_cullis_acentric = (PDBjDict.some_float v) }
      | "R_cullis" -> { b with r_cullis = (PDBjDict.some_float v) }
      | "R_kraut_centric" -> { b with r_kraut_centric = (PDBjDict.some_float v) }
      | "R_kraut_acentric" -> { b with r_kraut_acentric = (PDBjDict.some_float v) }
      | "R_kraut" -> { b with r_kraut = (PDBjDict.some_float v) }
      | "loc_centric" -> { b with loc_centric = (PDBjDict.some_float v) }
      | "loc_acentric" -> { b with loc_acentric = (PDBjDict.some_float v) }
      | "loc" -> { b with loc = (PDBjDict.some_float v) }
      | "power_centric" -> { b with power_centric = (PDBjDict.some_float v) }
      | "power_acentric" -> { b with power_acentric = (PDBjDict.some_float v) }
      | "power" -> { b with power = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("reflns_acentric", string_of_float v)) a.reflns_acentric;
      Option.map (fun v -> ("reflns_centric", string_of_int v)) a.reflns_centric;
      Option.map (fun v -> ("reflns", string_of_int v)) a.reflns;
      Option.map (fun v -> ("fom_acentric", string_of_float v)) a.fom_acentric;
      Option.map (fun v -> ("fom_centric", string_of_float v)) a.fom_centric;
      Option.map (fun v -> ("fom", string_of_float v)) a.fom;
      Option.map (fun v -> ("R_cullis_centric", string_of_float v)) a.r_cullis_centric;
      Option.map (fun v -> ("R_cullis_acentric", string_of_float v)) a.r_cullis_acentric;
      Option.map (fun v -> ("R_cullis", string_of_float v)) a.r_cullis;
      Option.map (fun v -> ("R_kraut_centric", string_of_float v)) a.r_kraut_centric;
      Option.map (fun v -> ("R_kraut_acentric", string_of_float v)) a.r_kraut_acentric;
      Option.map (fun v -> ("R_kraut", string_of_float v)) a.r_kraut;
      Option.map (fun v -> ("loc_centric", string_of_float v)) a.loc_centric;
      Option.map (fun v -> ("loc_acentric", string_of_float v)) a.loc_acentric;
      Option.map (fun v -> ("loc", string_of_float v)) a.loc;
      Option.map (fun v -> ("power_centric", string_of_float v)) a.power_centric;
      Option.map (fun v -> ("power_acentric", string_of_float v)) a.power_acentric;
      Option.map (fun v -> ("power", string_of_float v)) a.power;
    ]

end

module Pdbx_phasing_MAD_set = struct
  type t = {
    id: string option;
    d_res_low: float option;
    d_res_high: float option;
    number_of_sites: int option;
    reflns_acentric: int option;
    reflns_centric: int option;
    reflns: int option;
    fom_acentric: float option;
    fom_centric: float option;
    fom: float option;
    r_cullis_centric: float option;
    r_cullis_acentric: float option;
    r_cullis: float option;
    r_kraut_centric: float option;
    r_kraut_acentric: float option;
    r_kraut: float option;
    loc_centric: float option;
    loc_acentric: float option;
    loc: float option;
    power_centric: float option;
    power_acentric: float option;
    power: float option;
  }

  let default = {
    id = None;
    d_res_low = None;
    d_res_high = None;
    number_of_sites = None;
    reflns_acentric = None;
    reflns_centric = None;
    reflns = None;
    fom_acentric = None;
    fom_centric = None;
    fom = None;
    r_cullis_centric = None;
    r_cullis_acentric = None;
    r_cullis = None;
    r_kraut_centric = None;
    r_kraut_acentric = None;
    r_kraut = None;
    loc_centric = None;
    loc_acentric = None;
    loc = None;
    power_centric = None;
    power_acentric = None;
    power = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "number_of_sites" -> { b with number_of_sites = (PDBjDict.some_int v) }
      | "reflns_acentric" -> { b with reflns_acentric = (PDBjDict.some_int v) }
      | "reflns_centric" -> { b with reflns_centric = (PDBjDict.some_int v) }
      | "reflns" -> { b with reflns = (PDBjDict.some_int v) }
      | "fom_acentric" -> { b with fom_acentric = (PDBjDict.some_float v) }
      | "fom_centric" -> { b with fom_centric = (PDBjDict.some_float v) }
      | "fom" -> { b with fom = (PDBjDict.some_float v) }
      | "R_cullis_centric" -> { b with r_cullis_centric = (PDBjDict.some_float v) }
      | "R_cullis_acentric" -> { b with r_cullis_acentric = (PDBjDict.some_float v) }
      | "R_cullis" -> { b with r_cullis = (PDBjDict.some_float v) }
      | "R_kraut_centric" -> { b with r_kraut_centric = (PDBjDict.some_float v) }
      | "R_kraut_acentric" -> { b with r_kraut_acentric = (PDBjDict.some_float v) }
      | "R_kraut" -> { b with r_kraut = (PDBjDict.some_float v) }
      | "loc_centric" -> { b with loc_centric = (PDBjDict.some_float v) }
      | "loc_acentric" -> { b with loc_acentric = (PDBjDict.some_float v) }
      | "loc" -> { b with loc = (PDBjDict.some_float v) }
      | "power_centric" -> { b with power_centric = (PDBjDict.some_float v) }
      | "power_acentric" -> { b with power_acentric = (PDBjDict.some_float v) }
      | "power" -> { b with power = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("number_of_sites", string_of_int v)) a.number_of_sites;
      Option.map (fun v -> ("reflns_acentric", string_of_int v)) a.reflns_acentric;
      Option.map (fun v -> ("reflns_centric", string_of_int v)) a.reflns_centric;
      Option.map (fun v -> ("reflns", string_of_int v)) a.reflns;
      Option.map (fun v -> ("fom_acentric", string_of_float v)) a.fom_acentric;
      Option.map (fun v -> ("fom_centric", string_of_float v)) a.fom_centric;
      Option.map (fun v -> ("fom", string_of_float v)) a.fom;
      Option.map (fun v -> ("R_cullis_centric", string_of_float v)) a.r_cullis_centric;
      Option.map (fun v -> ("R_cullis_acentric", string_of_float v)) a.r_cullis_acentric;
      Option.map (fun v -> ("R_cullis", string_of_float v)) a.r_cullis;
      Option.map (fun v -> ("R_kraut_centric", string_of_float v)) a.r_kraut_centric;
      Option.map (fun v -> ("R_kraut_acentric", string_of_float v)) a.r_kraut_acentric;
      Option.map (fun v -> ("R_kraut", string_of_float v)) a.r_kraut;
      Option.map (fun v -> ("loc_centric", string_of_float v)) a.loc_centric;
      Option.map (fun v -> ("loc_acentric", string_of_float v)) a.loc_acentric;
      Option.map (fun v -> ("loc", string_of_float v)) a.loc;
      Option.map (fun v -> ("power_centric", string_of_float v)) a.power_centric;
      Option.map (fun v -> ("power_acentric", string_of_float v)) a.power_acentric;
      Option.map (fun v -> ("power", string_of_float v)) a.power;
    ]

end

module Pdbx_phasing_MAD_set_shell = struct
  type t = {
    id: string option;
    d_res_low: float option;
    d_res_high: float option;
    reflns_acentric: int option;
    reflns_centric: int option;
    reflns: int option;
    fom_acentric: float option;
    fom_centric: float option;
    fom: float option;
    r_cullis_centric: float option;
    r_cullis_acentric: float option;
    r_cullis: float option;
    r_kraut_centric: float option;
    r_kraut_acentric: float option;
    r_kraut: float option;
    loc_centric: float option;
    loc_acentric: float option;
    loc: float option;
    power_centric: float option;
    power_acentric: float option;
    power: float option;
  }

  let default = {
    id = None;
    d_res_low = None;
    d_res_high = None;
    reflns_acentric = None;
    reflns_centric = None;
    reflns = None;
    fom_acentric = None;
    fom_centric = None;
    fom = None;
    r_cullis_centric = None;
    r_cullis_acentric = None;
    r_cullis = None;
    r_kraut_centric = None;
    r_kraut_acentric = None;
    r_kraut = None;
    loc_centric = None;
    loc_acentric = None;
    loc = None;
    power_centric = None;
    power_acentric = None;
    power = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "reflns_acentric" -> { b with reflns_acentric = (PDBjDict.some_int v) }
      | "reflns_centric" -> { b with reflns_centric = (PDBjDict.some_int v) }
      | "reflns" -> { b with reflns = (PDBjDict.some_int v) }
      | "fom_acentric" -> { b with fom_acentric = (PDBjDict.some_float v) }
      | "fom_centric" -> { b with fom_centric = (PDBjDict.some_float v) }
      | "fom" -> { b with fom = (PDBjDict.some_float v) }
      | "R_cullis_centric" -> { b with r_cullis_centric = (PDBjDict.some_float v) }
      | "R_cullis_acentric" -> { b with r_cullis_acentric = (PDBjDict.some_float v) }
      | "R_cullis" -> { b with r_cullis = (PDBjDict.some_float v) }
      | "R_kraut_centric" -> { b with r_kraut_centric = (PDBjDict.some_float v) }
      | "R_kraut_acentric" -> { b with r_kraut_acentric = (PDBjDict.some_float v) }
      | "R_kraut" -> { b with r_kraut = (PDBjDict.some_float v) }
      | "loc_centric" -> { b with loc_centric = (PDBjDict.some_float v) }
      | "loc_acentric" -> { b with loc_acentric = (PDBjDict.some_float v) }
      | "loc" -> { b with loc = (PDBjDict.some_float v) }
      | "power_centric" -> { b with power_centric = (PDBjDict.some_float v) }
      | "power_acentric" -> { b with power_acentric = (PDBjDict.some_float v) }
      | "power" -> { b with power = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("reflns_acentric", string_of_int v)) a.reflns_acentric;
      Option.map (fun v -> ("reflns_centric", string_of_int v)) a.reflns_centric;
      Option.map (fun v -> ("reflns", string_of_int v)) a.reflns;
      Option.map (fun v -> ("fom_acentric", string_of_float v)) a.fom_acentric;
      Option.map (fun v -> ("fom_centric", string_of_float v)) a.fom_centric;
      Option.map (fun v -> ("fom", string_of_float v)) a.fom;
      Option.map (fun v -> ("R_cullis_centric", string_of_float v)) a.r_cullis_centric;
      Option.map (fun v -> ("R_cullis_acentric", string_of_float v)) a.r_cullis_acentric;
      Option.map (fun v -> ("R_cullis", string_of_float v)) a.r_cullis;
      Option.map (fun v -> ("R_kraut_centric", string_of_float v)) a.r_kraut_centric;
      Option.map (fun v -> ("R_kraut_acentric", string_of_float v)) a.r_kraut_acentric;
      Option.map (fun v -> ("R_kraut", string_of_float v)) a.r_kraut;
      Option.map (fun v -> ("loc_centric", string_of_float v)) a.loc_centric;
      Option.map (fun v -> ("loc_acentric", string_of_float v)) a.loc_acentric;
      Option.map (fun v -> ("loc", string_of_float v)) a.loc;
      Option.map (fun v -> ("power_centric", string_of_float v)) a.power_centric;
      Option.map (fun v -> ("power_acentric", string_of_float v)) a.power_acentric;
      Option.map (fun v -> ("power", string_of_float v)) a.power;
    ]

end

module Pdbx_phasing_MAD_set_site = struct
  type t = {
    id: string option;
    atom_type_symbol: string option;
    cartn_x: float option;
    cartn_y: float option;
    cartn_z: float option;
    cartn_x_esd: float option;
    cartn_y_esd: float option;
    cartn_z_esd: float option;
    fract_x: float option;
    fract_y: float option;
    fract_z: float option;
    fract_x_esd: float option;
    fract_y_esd: float option;
    fract_z_esd: float option;
    b_iso: float option;
    b_iso_esd: float option;
    occupancy: float option;
    occupancy_esd: float option;
    set_id: string option;
    occupancy_iso: float option;
  }

  let default = {
    id = None;
    atom_type_symbol = None;
    cartn_x = None;
    cartn_y = None;
    cartn_z = None;
    cartn_x_esd = None;
    cartn_y_esd = None;
    cartn_z_esd = None;
    fract_x = None;
    fract_y = None;
    fract_z = None;
    fract_x_esd = None;
    fract_y_esd = None;
    fract_z_esd = None;
    b_iso = None;
    b_iso_esd = None;
    occupancy = None;
    occupancy_esd = None;
    set_id = None;
    occupancy_iso = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "atom_type_symbol" -> { b with atom_type_symbol = (Some v) }
      | "Cartn_x" -> { b with cartn_x = (PDBjDict.some_float v) }
      | "Cartn_y" -> { b with cartn_y = (PDBjDict.some_float v) }
      | "Cartn_z" -> { b with cartn_z = (PDBjDict.some_float v) }
      | "Cartn_x_esd" -> { b with cartn_x_esd = (PDBjDict.some_float v) }
      | "Cartn_y_esd" -> { b with cartn_y_esd = (PDBjDict.some_float v) }
      | "Cartn_z_esd" -> { b with cartn_z_esd = (PDBjDict.some_float v) }
      | "fract_x" -> { b with fract_x = (PDBjDict.some_float v) }
      | "fract_y" -> { b with fract_y = (PDBjDict.some_float v) }
      | "fract_z" -> { b with fract_z = (PDBjDict.some_float v) }
      | "fract_x_esd" -> { b with fract_x_esd = (PDBjDict.some_float v) }
      | "fract_y_esd" -> { b with fract_y_esd = (PDBjDict.some_float v) }
      | "fract_z_esd" -> { b with fract_z_esd = (PDBjDict.some_float v) }
      | "b_iso" -> { b with b_iso = (PDBjDict.some_float v) }
      | "b_iso_esd" -> { b with b_iso_esd = (PDBjDict.some_float v) }
      | "occupancy" -> { b with occupancy = (PDBjDict.some_float v) }
      | "occupancy_esd" -> { b with occupancy_esd = (PDBjDict.some_float v) }
      | "set_id" -> { b with set_id = (Some v) }
      | "occupancy_iso" -> { b with occupancy_iso = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("atom_type_symbol",  v)) a.atom_type_symbol;
      Option.map (fun v -> ("Cartn_x", string_of_float v)) a.cartn_x;
      Option.map (fun v -> ("Cartn_y", string_of_float v)) a.cartn_y;
      Option.map (fun v -> ("Cartn_z", string_of_float v)) a.cartn_z;
      Option.map (fun v -> ("Cartn_x_esd", string_of_float v)) a.cartn_x_esd;
      Option.map (fun v -> ("Cartn_y_esd", string_of_float v)) a.cartn_y_esd;
      Option.map (fun v -> ("Cartn_z_esd", string_of_float v)) a.cartn_z_esd;
      Option.map (fun v -> ("fract_x", string_of_float v)) a.fract_x;
      Option.map (fun v -> ("fract_y", string_of_float v)) a.fract_y;
      Option.map (fun v -> ("fract_z", string_of_float v)) a.fract_z;
      Option.map (fun v -> ("fract_x_esd", string_of_float v)) a.fract_x_esd;
      Option.map (fun v -> ("fract_y_esd", string_of_float v)) a.fract_y_esd;
      Option.map (fun v -> ("fract_z_esd", string_of_float v)) a.fract_z_esd;
      Option.map (fun v -> ("b_iso", string_of_float v)) a.b_iso;
      Option.map (fun v -> ("b_iso_esd", string_of_float v)) a.b_iso_esd;
      Option.map (fun v -> ("occupancy", string_of_float v)) a.occupancy;
      Option.map (fun v -> ("occupancy_esd", string_of_float v)) a.occupancy_esd;
      Option.map (fun v -> ("set_id",  v)) a.set_id;
      Option.map (fun v -> ("occupancy_iso", string_of_float v)) a.occupancy_iso;
    ]

end

module Pdbx_phasing_MR = struct
  type t = {
    entry_id: string option;
    method_rotation: string option;
    d_res_high_rotation: float option;
    d_res_low_rotation: float option;
    sigma_F_rotation: float option;
    sigma_I_rotation: float option;
    reflns_percent_rotation: float option;
    method_translation: string option;
    d_res_high_translation: float option;
    d_res_low_translation: float option;
    sigma_F_translation: float option;
    sigma_I_translation: float option;
    reflns_percent_translation: float option;
    correlation_coeff_Io_to_Ic: float option;
    correlation_coeff_Fo_to_Fc: float option;
    r_factor: float option;
    r_rigid_body: float option;
    packing: float option;
    model_details: string option;
    native_set_id: string option;
    d_res_high_fit: float option;
    d_res_low_fit: float option;
    zscore_rotation: float option;
    lL_gain_rotation: float option;
    zscore_translation: float option;
    lL_gain_translation: float option;
  }

  let default = {
    entry_id = None;
    method_rotation = None;
    d_res_high_rotation = None;
    d_res_low_rotation = None;
    sigma_F_rotation = None;
    sigma_I_rotation = None;
    reflns_percent_rotation = None;
    method_translation = None;
    d_res_high_translation = None;
    d_res_low_translation = None;
    sigma_F_translation = None;
    sigma_I_translation = None;
    reflns_percent_translation = None;
    correlation_coeff_Io_to_Ic = None;
    correlation_coeff_Fo_to_Fc = None;
    r_factor = None;
    r_rigid_body = None;
    packing = None;
    model_details = None;
    native_set_id = None;
    d_res_high_fit = None;
    d_res_low_fit = None;
    zscore_rotation = None;
    lL_gain_rotation = None;
    zscore_translation = None;
    lL_gain_translation = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "method_rotation" -> { b with method_rotation = (Some v) }
      | "d_res_high_rotation" -> { b with d_res_high_rotation = (PDBjDict.some_float v) }
      | "d_res_low_rotation" -> { b with d_res_low_rotation = (PDBjDict.some_float v) }
      | "sigma_F_rotation" -> { b with sigma_F_rotation = (PDBjDict.some_float v) }
      | "sigma_I_rotation" -> { b with sigma_I_rotation = (PDBjDict.some_float v) }
      | "reflns_percent_rotation" -> { b with reflns_percent_rotation = (PDBjDict.some_float v) }
      | "method_translation" -> { b with method_translation = (Some v) }
      | "d_res_high_translation" -> { b with d_res_high_translation = (PDBjDict.some_float v) }
      | "d_res_low_translation" -> { b with d_res_low_translation = (PDBjDict.some_float v) }
      | "sigma_F_translation" -> { b with sigma_F_translation = (PDBjDict.some_float v) }
      | "sigma_I_translation" -> { b with sigma_I_translation = (PDBjDict.some_float v) }
      | "reflns_percent_translation" -> { b with reflns_percent_translation = (PDBjDict.some_float v) }
      | "correlation_coeff_Io_to_Ic" -> { b with correlation_coeff_Io_to_Ic = (PDBjDict.some_float v) }
      | "correlation_coeff_Fo_to_Fc" -> { b with correlation_coeff_Fo_to_Fc = (PDBjDict.some_float v) }
      | "R_factor" -> { b with r_factor = (PDBjDict.some_float v) }
      | "R_rigid_body" -> { b with r_rigid_body = (PDBjDict.some_float v) }
      | "packing" -> { b with packing = (PDBjDict.some_float v) }
      | "model_details" -> { b with model_details = (Some v) }
      | "native_set_id" -> { b with native_set_id = (Some v) }
      | "d_res_high_fit" -> { b with d_res_high_fit = (PDBjDict.some_float v) }
      | "d_res_low_fit" -> { b with d_res_low_fit = (PDBjDict.some_float v) }
      | "zscore_rotation" -> { b with zscore_rotation = (PDBjDict.some_float v) }
      | "LL_gain_rotation" -> { b with lL_gain_rotation = (PDBjDict.some_float v) }
      | "zscore_translation" -> { b with zscore_translation = (PDBjDict.some_float v) }
      | "LL_gain_translation" -> { b with lL_gain_translation = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("method_rotation",  v)) a.method_rotation;
      Option.map (fun v -> ("d_res_high_rotation", string_of_float v)) a.d_res_high_rotation;
      Option.map (fun v -> ("d_res_low_rotation", string_of_float v)) a.d_res_low_rotation;
      Option.map (fun v -> ("sigma_F_rotation", string_of_float v)) a.sigma_F_rotation;
      Option.map (fun v -> ("sigma_I_rotation", string_of_float v)) a.sigma_I_rotation;
      Option.map (fun v -> ("reflns_percent_rotation", string_of_float v)) a.reflns_percent_rotation;
      Option.map (fun v -> ("method_translation",  v)) a.method_translation;
      Option.map (fun v -> ("d_res_high_translation", string_of_float v)) a.d_res_high_translation;
      Option.map (fun v -> ("d_res_low_translation", string_of_float v)) a.d_res_low_translation;
      Option.map (fun v -> ("sigma_F_translation", string_of_float v)) a.sigma_F_translation;
      Option.map (fun v -> ("sigma_I_translation", string_of_float v)) a.sigma_I_translation;
      Option.map (fun v -> ("reflns_percent_translation", string_of_float v)) a.reflns_percent_translation;
      Option.map (fun v -> ("correlation_coeff_Io_to_Ic", string_of_float v)) a.correlation_coeff_Io_to_Ic;
      Option.map (fun v -> ("correlation_coeff_Fo_to_Fc", string_of_float v)) a.correlation_coeff_Fo_to_Fc;
      Option.map (fun v -> ("R_factor", string_of_float v)) a.r_factor;
      Option.map (fun v -> ("R_rigid_body", string_of_float v)) a.r_rigid_body;
      Option.map (fun v -> ("packing", string_of_float v)) a.packing;
      Option.map (fun v -> ("model_details",  v)) a.model_details;
      Option.map (fun v -> ("native_set_id",  v)) a.native_set_id;
      Option.map (fun v -> ("d_res_high_fit", string_of_float v)) a.d_res_high_fit;
      Option.map (fun v -> ("d_res_low_fit", string_of_float v)) a.d_res_low_fit;
      Option.map (fun v -> ("zscore_rotation", string_of_float v)) a.zscore_rotation;
      Option.map (fun v -> ("LL_gain_rotation", string_of_float v)) a.lL_gain_rotation;
      Option.map (fun v -> ("zscore_translation", string_of_float v)) a.zscore_translation;
      Option.map (fun v -> ("LL_gain_translation", string_of_float v)) a.lL_gain_translation;
    ]

end

module Pdbx_refine_component = struct
  type t = {
    label_alt_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    b_iso: float option;
    b_iso_main_chain: float option;
    b_iso_side_chain: float option;
    shift: float option;
    shift_side_chain: float option;
    shift_main_chain: float option;
    correlation: float option;
    correlation_side_chain: float option;
    correlation_main_chain: float option;
    real_space_R: float option;
    real_space_R_side_chain: float option;
    real_space_R_main_chain: float option;
    connect: float option;
    density_index: float option;
    density_index_main_chain: float option;
    density_index_side_chain: float option;
    density_ratio: float option;
    density_ratio_main_chain: float option;
    density_ratio_side_chain: float option;
  }

  let default = {
    label_alt_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    b_iso = None;
    b_iso_main_chain = None;
    b_iso_side_chain = None;
    shift = None;
    shift_side_chain = None;
    shift_main_chain = None;
    correlation = None;
    correlation_side_chain = None;
    correlation_main_chain = None;
    real_space_R = None;
    real_space_R_side_chain = None;
    real_space_R_main_chain = None;
    connect = None;
    density_index = None;
    density_index_main_chain = None;
    density_index_side_chain = None;
    density_ratio = None;
    density_ratio_main_chain = None;
    density_ratio_side_chain = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "B_iso" -> { b with b_iso = (PDBjDict.some_float v) }
      | "B_iso_main_chain" -> { b with b_iso_main_chain = (PDBjDict.some_float v) }
      | "B_iso_side_chain" -> { b with b_iso_side_chain = (PDBjDict.some_float v) }
      | "shift" -> { b with shift = (PDBjDict.some_float v) }
      | "shift_side_chain" -> { b with shift_side_chain = (PDBjDict.some_float v) }
      | "shift_main_chain" -> { b with shift_main_chain = (PDBjDict.some_float v) }
      | "correlation" -> { b with correlation = (PDBjDict.some_float v) }
      | "correlation_side_chain" -> { b with correlation_side_chain = (PDBjDict.some_float v) }
      | "correlation_main_chain" -> { b with correlation_main_chain = (PDBjDict.some_float v) }
      | "real_space_R" -> { b with real_space_R = (PDBjDict.some_float v) }
      | "real_space_R_side_chain" -> { b with real_space_R_side_chain = (PDBjDict.some_float v) }
      | "real_space_R_main_chain" -> { b with real_space_R_main_chain = (PDBjDict.some_float v) }
      | "connect" -> { b with connect = (PDBjDict.some_float v) }
      | "density_index" -> { b with density_index = (PDBjDict.some_float v) }
      | "density_index_main_chain" -> { b with density_index_main_chain = (PDBjDict.some_float v) }
      | "density_index_side_chain" -> { b with density_index_side_chain = (PDBjDict.some_float v) }
      | "density_ratio" -> { b with density_ratio = (PDBjDict.some_float v) }
      | "density_ratio_main_chain" -> { b with density_ratio_main_chain = (PDBjDict.some_float v) }
      | "density_ratio_side_chain" -> { b with density_ratio_side_chain = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("B_iso", string_of_float v)) a.b_iso;
      Option.map (fun v -> ("B_iso_main_chain", string_of_float v)) a.b_iso_main_chain;
      Option.map (fun v -> ("B_iso_side_chain", string_of_float v)) a.b_iso_side_chain;
      Option.map (fun v -> ("shift", string_of_float v)) a.shift;
      Option.map (fun v -> ("shift_side_chain", string_of_float v)) a.shift_side_chain;
      Option.map (fun v -> ("shift_main_chain", string_of_float v)) a.shift_main_chain;
      Option.map (fun v -> ("correlation", string_of_float v)) a.correlation;
      Option.map (fun v -> ("correlation_side_chain", string_of_float v)) a.correlation_side_chain;
      Option.map (fun v -> ("correlation_main_chain", string_of_float v)) a.correlation_main_chain;
      Option.map (fun v -> ("real_space_R", string_of_float v)) a.real_space_R;
      Option.map (fun v -> ("real_space_R_side_chain", string_of_float v)) a.real_space_R_side_chain;
      Option.map (fun v -> ("real_space_R_main_chain", string_of_float v)) a.real_space_R_main_chain;
      Option.map (fun v -> ("connect", string_of_float v)) a.connect;
      Option.map (fun v -> ("density_index", string_of_float v)) a.density_index;
      Option.map (fun v -> ("density_index_main_chain", string_of_float v)) a.density_index_main_chain;
      Option.map (fun v -> ("density_index_side_chain", string_of_float v)) a.density_index_side_chain;
      Option.map (fun v -> ("density_ratio", string_of_float v)) a.density_ratio;
      Option.map (fun v -> ("density_ratio_main_chain", string_of_float v)) a.density_ratio_main_chain;
      Option.map (fun v -> ("density_ratio_side_chain", string_of_float v)) a.density_ratio_side_chain;
    ]

end

module Pdbx_entity_prod_protocol = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    protocol: string option;
    protocol_type: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    protocol = None;
    protocol_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "protocol" -> { b with protocol = (Some v) }
      | "protocol_type" -> { b with protocol_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("protocol",  v)) a.protocol;
      Option.map (fun v -> ("protocol_type",  v)) a.protocol_type;
    ]

end

module Pdbx_entity_src_gen_prod_other = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    next_step_id: int option;
    end_construct_id: string option;
    robot_id: string option;
    date: string option;
    process_name: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    next_step_id = None;
    end_construct_id = None;
    robot_id = None;
    date = None;
    process_name = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "next_step_id" -> { b with next_step_id = (PDBjDict.some_int v) }
      | "end_construct_id" -> { b with end_construct_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "process_name" -> { b with process_name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("next_step_id", string_of_int v)) a.next_step_id;
      Option.map (fun v -> ("end_construct_id",  v)) a.end_construct_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("process_name",  v)) a.process_name;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_entity_src_gen_prod_other_parameter = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    parameter: string option;
    value: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    parameter = None;
    value = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "parameter" -> { b with parameter = (Some v) }
      | "value" -> { b with value = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("parameter",  v)) a.parameter;
      Option.map (fun v -> ("value",  v)) a.value;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_entity_src_gen_prod_pcr = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    next_step_id: int option;
    end_construct_id: string option;
    robot_id: string option;
    date: string option;
    forward_primer_id: string option;
    reverse_primer_id: string option;
    reaction_details: string option;
    purification_details: string option;
    summary: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    next_step_id = None;
    end_construct_id = None;
    robot_id = None;
    date = None;
    forward_primer_id = None;
    reverse_primer_id = None;
    reaction_details = None;
    purification_details = None;
    summary = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "next_step_id" -> { b with next_step_id = (PDBjDict.some_int v) }
      | "end_construct_id" -> { b with end_construct_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "forward_primer_id" -> { b with forward_primer_id = (Some v) }
      | "reverse_primer_id" -> { b with reverse_primer_id = (Some v) }
      | "reaction_details" -> { b with reaction_details = (Some v) }
      | "purification_details" -> { b with purification_details = (Some v) }
      | "summary" -> { b with summary = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("next_step_id", string_of_int v)) a.next_step_id;
      Option.map (fun v -> ("end_construct_id",  v)) a.end_construct_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("forward_primer_id",  v)) a.forward_primer_id;
      Option.map (fun v -> ("reverse_primer_id",  v)) a.reverse_primer_id;
      Option.map (fun v -> ("reaction_details",  v)) a.reaction_details;
      Option.map (fun v -> ("purification_details",  v)) a.purification_details;
      Option.map (fun v -> ("summary",  v)) a.summary;
    ]

end

module Pdbx_entity_src_gen_prod_digest = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    next_step_id: int option;
    end_construct_id: string option;
    robot_id: string option;
    date: string option;
    restriction_enzyme_1: string option;
    restriction_enzyme_2: string option;
    purification_details: string option;
    summary: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    next_step_id = None;
    end_construct_id = None;
    robot_id = None;
    date = None;
    restriction_enzyme_1 = None;
    restriction_enzyme_2 = None;
    purification_details = None;
    summary = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "next_step_id" -> { b with next_step_id = (PDBjDict.some_int v) }
      | "end_construct_id" -> { b with end_construct_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "restriction_enzyme_1" -> { b with restriction_enzyme_1 = (Some v) }
      | "restriction_enzyme_2" -> { b with restriction_enzyme_2 = (Some v) }
      | "purification_details" -> { b with purification_details = (Some v) }
      | "summary" -> { b with summary = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("next_step_id", string_of_int v)) a.next_step_id;
      Option.map (fun v -> ("end_construct_id",  v)) a.end_construct_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("restriction_enzyme_1",  v)) a.restriction_enzyme_1;
      Option.map (fun v -> ("restriction_enzyme_2",  v)) a.restriction_enzyme_2;
      Option.map (fun v -> ("purification_details",  v)) a.purification_details;
      Option.map (fun v -> ("summary",  v)) a.summary;
    ]

end

module Pdbx_entity_src_gen_clone = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    next_step_id: int option;
    end_construct_id: string option;
    robot_id: string option;
    date: string option;
    gene_insert_method: string option;
    vector_name: string option;
    vector_details: string option;
    transformation_method: string option;
    marker: string option;
    verification_method: string option;
    purification_details: string option;
    summary: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    next_step_id = None;
    end_construct_id = None;
    robot_id = None;
    date = None;
    gene_insert_method = None;
    vector_name = None;
    vector_details = None;
    transformation_method = None;
    marker = None;
    verification_method = None;
    purification_details = None;
    summary = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "next_step_id" -> { b with next_step_id = (PDBjDict.some_int v) }
      | "end_construct_id" -> { b with end_construct_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "gene_insert_method" -> { b with gene_insert_method = (Some v) }
      | "vector_name" -> { b with vector_name = (Some v) }
      | "vector_details" -> { b with vector_details = (Some v) }
      | "transformation_method" -> { b with transformation_method = (Some v) }
      | "marker" -> { b with marker = (Some v) }
      | "verification_method" -> { b with verification_method = (Some v) }
      | "purification_details" -> { b with purification_details = (Some v) }
      | "summary" -> { b with summary = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("next_step_id", string_of_int v)) a.next_step_id;
      Option.map (fun v -> ("end_construct_id",  v)) a.end_construct_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("gene_insert_method",  v)) a.gene_insert_method;
      Option.map (fun v -> ("vector_name",  v)) a.vector_name;
      Option.map (fun v -> ("vector_details",  v)) a.vector_details;
      Option.map (fun v -> ("transformation_method",  v)) a.transformation_method;
      Option.map (fun v -> ("marker",  v)) a.marker;
      Option.map (fun v -> ("verification_method",  v)) a.verification_method;
      Option.map (fun v -> ("purification_details",  v)) a.purification_details;
      Option.map (fun v -> ("summary",  v)) a.summary;
    ]

end

module Pdbx_entity_src_gen_clone_ligation = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    cleavage_enzymes: string option;
    ligation_enzymes: string option;
    temperature: float option;
    time: int option;
    details: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    cleavage_enzymes = None;
    ligation_enzymes = None;
    temperature = None;
    time = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "cleavage_enzymes" -> { b with cleavage_enzymes = (Some v) }
      | "ligation_enzymes" -> { b with ligation_enzymes = (Some v) }
      | "temperature" -> { b with temperature = (PDBjDict.some_float v) }
      | "time" -> { b with time = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("cleavage_enzymes",  v)) a.cleavage_enzymes;
      Option.map (fun v -> ("ligation_enzymes",  v)) a.ligation_enzymes;
      Option.map (fun v -> ("temperature", string_of_float v)) a.temperature;
      Option.map (fun v -> ("time", string_of_int v)) a.time;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_entity_src_gen_clone_recombination = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    system: string option;
    recombination_enzymes: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    system = None;
    recombination_enzymes = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "system" -> { b with system = (Some v) }
      | "recombination_enzymes" -> { b with recombination_enzymes = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("system",  v)) a.system;
      Option.map (fun v -> ("recombination_enzymes",  v)) a.recombination_enzymes;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_entity_src_gen_express = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    next_step_id: int option;
    end_construct_id: string option;
    robot_id: string option;
    date: string option;
    promoter_type: string option;
    plasmid_id: string option;
    vector_type: string option;
    n_terminal_seq_tag: string option;
    c_terminal_seq_tag: string option;
    host_org_scientific_name: string option;
    host_org_common_name: string option;
    host_org_variant: string option;
    host_org_strain: string option;
    host_org_tissue: string option;
    host_org_culture_collection: string option;
    host_org_cell_line: string option;
    host_org_tax_id: string option;
    host_org_details: string option;
    culture_base_media: string option;
    culture_additives: string option;
    culture_volume: float option;
    culture_time: float option;
    culture_temperature: float option;
    inducer: string option;
    inducer_concentration: float option;
    induction_details: string option;
    multiplicity_of_infection: float option;
    induction_timepoint: float option;
    induction_temperature: float option;
    harvesting_details: string option;
    storage_details: string option;
    summary: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    next_step_id = None;
    end_construct_id = None;
    robot_id = None;
    date = None;
    promoter_type = None;
    plasmid_id = None;
    vector_type = None;
    n_terminal_seq_tag = None;
    c_terminal_seq_tag = None;
    host_org_scientific_name = None;
    host_org_common_name = None;
    host_org_variant = None;
    host_org_strain = None;
    host_org_tissue = None;
    host_org_culture_collection = None;
    host_org_cell_line = None;
    host_org_tax_id = None;
    host_org_details = None;
    culture_base_media = None;
    culture_additives = None;
    culture_volume = None;
    culture_time = None;
    culture_temperature = None;
    inducer = None;
    inducer_concentration = None;
    induction_details = None;
    multiplicity_of_infection = None;
    induction_timepoint = None;
    induction_temperature = None;
    harvesting_details = None;
    storage_details = None;
    summary = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "next_step_id" -> { b with next_step_id = (PDBjDict.some_int v) }
      | "end_construct_id" -> { b with end_construct_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "promoter_type" -> { b with promoter_type = (Some v) }
      | "plasmid_id" -> { b with plasmid_id = (Some v) }
      | "vector_type" -> { b with vector_type = (Some v) }
      | "N_terminal_seq_tag" -> { b with n_terminal_seq_tag = (Some v) }
      | "C_terminal_seq_tag" -> { b with c_terminal_seq_tag = (Some v) }
      | "host_org_scientific_name" -> { b with host_org_scientific_name = (Some v) }
      | "host_org_common_name" -> { b with host_org_common_name = (Some v) }
      | "host_org_variant" -> { b with host_org_variant = (Some v) }
      | "host_org_strain" -> { b with host_org_strain = (Some v) }
      | "host_org_tissue" -> { b with host_org_tissue = (Some v) }
      | "host_org_culture_collection" -> { b with host_org_culture_collection = (Some v) }
      | "host_org_cell_line" -> { b with host_org_cell_line = (Some v) }
      | "host_org_tax_id" -> { b with host_org_tax_id = (Some v) }
      | "host_org_details" -> { b with host_org_details = (Some v) }
      | "culture_base_media" -> { b with culture_base_media = (Some v) }
      | "culture_additives" -> { b with culture_additives = (Some v) }
      | "culture_volume" -> { b with culture_volume = (PDBjDict.some_float v) }
      | "culture_time" -> { b with culture_time = (PDBjDict.some_float v) }
      | "culture_temperature" -> { b with culture_temperature = (PDBjDict.some_float v) }
      | "inducer" -> { b with inducer = (Some v) }
      | "inducer_concentration" -> { b with inducer_concentration = (PDBjDict.some_float v) }
      | "induction_details" -> { b with induction_details = (Some v) }
      | "multiplicity_of_infection" -> { b with multiplicity_of_infection = (PDBjDict.some_float v) }
      | "induction_timepoint" -> { b with induction_timepoint = (PDBjDict.some_float v) }
      | "induction_temperature" -> { b with induction_temperature = (PDBjDict.some_float v) }
      | "harvesting_details" -> { b with harvesting_details = (Some v) }
      | "storage_details" -> { b with storage_details = (Some v) }
      | "summary" -> { b with summary = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("next_step_id", string_of_int v)) a.next_step_id;
      Option.map (fun v -> ("end_construct_id",  v)) a.end_construct_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("promoter_type",  v)) a.promoter_type;
      Option.map (fun v -> ("plasmid_id",  v)) a.plasmid_id;
      Option.map (fun v -> ("vector_type",  v)) a.vector_type;
      Option.map (fun v -> ("N_terminal_seq_tag",  v)) a.n_terminal_seq_tag;
      Option.map (fun v -> ("C_terminal_seq_tag",  v)) a.c_terminal_seq_tag;
      Option.map (fun v -> ("host_org_scientific_name",  v)) a.host_org_scientific_name;
      Option.map (fun v -> ("host_org_common_name",  v)) a.host_org_common_name;
      Option.map (fun v -> ("host_org_variant",  v)) a.host_org_variant;
      Option.map (fun v -> ("host_org_strain",  v)) a.host_org_strain;
      Option.map (fun v -> ("host_org_tissue",  v)) a.host_org_tissue;
      Option.map (fun v -> ("host_org_culture_collection",  v)) a.host_org_culture_collection;
      Option.map (fun v -> ("host_org_cell_line",  v)) a.host_org_cell_line;
      Option.map (fun v -> ("host_org_tax_id",  v)) a.host_org_tax_id;
      Option.map (fun v -> ("host_org_details",  v)) a.host_org_details;
      Option.map (fun v -> ("culture_base_media",  v)) a.culture_base_media;
      Option.map (fun v -> ("culture_additives",  v)) a.culture_additives;
      Option.map (fun v -> ("culture_volume", string_of_float v)) a.culture_volume;
      Option.map (fun v -> ("culture_time", string_of_float v)) a.culture_time;
      Option.map (fun v -> ("culture_temperature", string_of_float v)) a.culture_temperature;
      Option.map (fun v -> ("inducer",  v)) a.inducer;
      Option.map (fun v -> ("inducer_concentration", string_of_float v)) a.inducer_concentration;
      Option.map (fun v -> ("induction_details",  v)) a.induction_details;
      Option.map (fun v -> ("multiplicity_of_infection", string_of_float v)) a.multiplicity_of_infection;
      Option.map (fun v -> ("induction_timepoint", string_of_float v)) a.induction_timepoint;
      Option.map (fun v -> ("induction_temperature", string_of_float v)) a.induction_temperature;
      Option.map (fun v -> ("harvesting_details",  v)) a.harvesting_details;
      Option.map (fun v -> ("storage_details",  v)) a.storage_details;
      Option.map (fun v -> ("summary",  v)) a.summary;
    ]

end

module Pdbx_entity_src_gen_express_timepoint = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    serial: int option;
    oD: int option;
    time: int option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    serial = None;
    oD = None;
    time = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "serial" -> { b with serial = (PDBjDict.some_int v) }
      | "OD" -> { b with oD = (PDBjDict.some_int v) }
      | "time" -> { b with time = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("serial", string_of_int v)) a.serial;
      Option.map (fun v -> ("OD", string_of_int v)) a.oD;
      Option.map (fun v -> ("time", string_of_int v)) a.time;
    ]

end

module Pdbx_entity_src_gen_lysis = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    next_step_id: int option;
    end_construct_id: string option;
    robot_id: string option;
    date: string option;
    method_: string option;
    buffer_id: string option;
    buffer_volume: float option;
    temperature: float option;
    time: float option;
    details: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    next_step_id = None;
    end_construct_id = None;
    robot_id = None;
    date = None;
    method_ = None;
    buffer_id = None;
    buffer_volume = None;
    temperature = None;
    time = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "next_step_id" -> { b with next_step_id = (PDBjDict.some_int v) }
      | "end_construct_id" -> { b with end_construct_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "buffer_id" -> { b with buffer_id = (Some v) }
      | "buffer_volume" -> { b with buffer_volume = (PDBjDict.some_float v) }
      | "temperature" -> { b with temperature = (PDBjDict.some_float v) }
      | "time" -> { b with time = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("next_step_id", string_of_int v)) a.next_step_id;
      Option.map (fun v -> ("end_construct_id",  v)) a.end_construct_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("buffer_id",  v)) a.buffer_id;
      Option.map (fun v -> ("buffer_volume", string_of_float v)) a.buffer_volume;
      Option.map (fun v -> ("temperature", string_of_float v)) a.temperature;
      Option.map (fun v -> ("time", string_of_float v)) a.time;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_entity_src_gen_refold = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    next_step_id: int option;
    end_construct_id: string option;
    robot_id: string option;
    date: string option;
    denature_buffer_id: string option;
    refold_buffer_id: string option;
    temperature: float option;
    time: float option;
    storage_buffer_id: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    next_step_id = None;
    end_construct_id = None;
    robot_id = None;
    date = None;
    denature_buffer_id = None;
    refold_buffer_id = None;
    temperature = None;
    time = None;
    storage_buffer_id = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "next_step_id" -> { b with next_step_id = (PDBjDict.some_int v) }
      | "end_construct_id" -> { b with end_construct_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "denature_buffer_id" -> { b with denature_buffer_id = (Some v) }
      | "refold_buffer_id" -> { b with refold_buffer_id = (Some v) }
      | "temperature" -> { b with temperature = (PDBjDict.some_float v) }
      | "time" -> { b with time = (PDBjDict.some_float v) }
      | "storage_buffer_id" -> { b with storage_buffer_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("next_step_id", string_of_int v)) a.next_step_id;
      Option.map (fun v -> ("end_construct_id",  v)) a.end_construct_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("denature_buffer_id",  v)) a.denature_buffer_id;
      Option.map (fun v -> ("refold_buffer_id",  v)) a.refold_buffer_id;
      Option.map (fun v -> ("temperature", string_of_float v)) a.temperature;
      Option.map (fun v -> ("time", string_of_float v)) a.time;
      Option.map (fun v -> ("storage_buffer_id",  v)) a.storage_buffer_id;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_entity_src_gen_proteolysis = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    next_step_id: int option;
    end_construct_id: string option;
    robot_id: string option;
    date: string option;
    details: string option;
    protease: string option;
    protein_protease_ratio: float option;
    cleavage_buffer_id: string option;
    cleavage_temperature: float option;
    cleavage_time: float option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    next_step_id = None;
    end_construct_id = None;
    robot_id = None;
    date = None;
    details = None;
    protease = None;
    protein_protease_ratio = None;
    cleavage_buffer_id = None;
    cleavage_temperature = None;
    cleavage_time = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "next_step_id" -> { b with next_step_id = (PDBjDict.some_int v) }
      | "end_construct_id" -> { b with end_construct_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "protease" -> { b with protease = (Some v) }
      | "protein_protease_ratio" -> { b with protein_protease_ratio = (PDBjDict.some_float v) }
      | "cleavage_buffer_id" -> { b with cleavage_buffer_id = (Some v) }
      | "cleavage_temperature" -> { b with cleavage_temperature = (PDBjDict.some_float v) }
      | "cleavage_time" -> { b with cleavage_time = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("next_step_id", string_of_int v)) a.next_step_id;
      Option.map (fun v -> ("end_construct_id",  v)) a.end_construct_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("protease",  v)) a.protease;
      Option.map (fun v -> ("protein_protease_ratio", string_of_float v)) a.protein_protease_ratio;
      Option.map (fun v -> ("cleavage_buffer_id",  v)) a.cleavage_buffer_id;
      Option.map (fun v -> ("cleavage_temperature", string_of_float v)) a.cleavage_temperature;
      Option.map (fun v -> ("cleavage_time", string_of_float v)) a.cleavage_time;
    ]

end

module Pdbx_entity_src_gen_chrom = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    next_step_id: int option;
    end_construct_id: string option;
    robot_id: string option;
    date: string option;
    column_type: string option;
    column_volume: float option;
    column_temperature: float option;
    equilibration_buffer_id: string option;
    flow_rate: float option;
    elution_buffer_id: string option;
    elution_protocol: string option;
    sample_prep_details: string option;
    sample_volume: float option;
    sample_concentration: float option;
    sample_conc_method: string option;
    volume_pooled_fractions: float option;
    yield_pooled_fractions: float option;
    yield_method: string option;
    post_treatment: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    next_step_id = None;
    end_construct_id = None;
    robot_id = None;
    date = None;
    column_type = None;
    column_volume = None;
    column_temperature = None;
    equilibration_buffer_id = None;
    flow_rate = None;
    elution_buffer_id = None;
    elution_protocol = None;
    sample_prep_details = None;
    sample_volume = None;
    sample_concentration = None;
    sample_conc_method = None;
    volume_pooled_fractions = None;
    yield_pooled_fractions = None;
    yield_method = None;
    post_treatment = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "next_step_id" -> { b with next_step_id = (PDBjDict.some_int v) }
      | "end_construct_id" -> { b with end_construct_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "column_type" -> { b with column_type = (Some v) }
      | "column_volume" -> { b with column_volume = (PDBjDict.some_float v) }
      | "column_temperature" -> { b with column_temperature = (PDBjDict.some_float v) }
      | "equilibration_buffer_id" -> { b with equilibration_buffer_id = (Some v) }
      | "flow_rate" -> { b with flow_rate = (PDBjDict.some_float v) }
      | "elution_buffer_id" -> { b with elution_buffer_id = (Some v) }
      | "elution_protocol" -> { b with elution_protocol = (Some v) }
      | "sample_prep_details" -> { b with sample_prep_details = (Some v) }
      | "sample_volume" -> { b with sample_volume = (PDBjDict.some_float v) }
      | "sample_concentration" -> { b with sample_concentration = (PDBjDict.some_float v) }
      | "sample_conc_method" -> { b with sample_conc_method = (Some v) }
      | "volume_pooled_fractions" -> { b with volume_pooled_fractions = (PDBjDict.some_float v) }
      | "yield_pooled_fractions" -> { b with yield_pooled_fractions = (PDBjDict.some_float v) }
      | "yield_method" -> { b with yield_method = (Some v) }
      | "post_treatment" -> { b with post_treatment = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("next_step_id", string_of_int v)) a.next_step_id;
      Option.map (fun v -> ("end_construct_id",  v)) a.end_construct_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("column_type",  v)) a.column_type;
      Option.map (fun v -> ("column_volume", string_of_float v)) a.column_volume;
      Option.map (fun v -> ("column_temperature", string_of_float v)) a.column_temperature;
      Option.map (fun v -> ("equilibration_buffer_id",  v)) a.equilibration_buffer_id;
      Option.map (fun v -> ("flow_rate", string_of_float v)) a.flow_rate;
      Option.map (fun v -> ("elution_buffer_id",  v)) a.elution_buffer_id;
      Option.map (fun v -> ("elution_protocol",  v)) a.elution_protocol;
      Option.map (fun v -> ("sample_prep_details",  v)) a.sample_prep_details;
      Option.map (fun v -> ("sample_volume", string_of_float v)) a.sample_volume;
      Option.map (fun v -> ("sample_concentration", string_of_float v)) a.sample_concentration;
      Option.map (fun v -> ("sample_conc_method",  v)) a.sample_conc_method;
      Option.map (fun v -> ("volume_pooled_fractions", string_of_float v)) a.volume_pooled_fractions;
      Option.map (fun v -> ("yield_pooled_fractions", string_of_float v)) a.yield_pooled_fractions;
      Option.map (fun v -> ("yield_method",  v)) a.yield_method;
      Option.map (fun v -> ("post_treatment",  v)) a.post_treatment;
    ]

end

module Pdbx_entity_src_gen_fract = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    next_step_id: int option;
    end_construct_id: string option;
    robot_id: string option;
    date: string option;
    method_: string option;
    temperature: float option;
    details: string option;
    protein_location: string option;
    protein_volume: float option;
    protein_yield: float option;
    protein_yield_method: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    next_step_id = None;
    end_construct_id = None;
    robot_id = None;
    date = None;
    method_ = None;
    temperature = None;
    details = None;
    protein_location = None;
    protein_volume = None;
    protein_yield = None;
    protein_yield_method = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "next_step_id" -> { b with next_step_id = (PDBjDict.some_int v) }
      | "end_construct_id" -> { b with end_construct_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "temperature" -> { b with temperature = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | "protein_location" -> { b with protein_location = (Some v) }
      | "protein_volume" -> { b with protein_volume = (PDBjDict.some_float v) }
      | "protein_yield" -> { b with protein_yield = (PDBjDict.some_float v) }
      | "protein_yield_method" -> { b with protein_yield_method = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("next_step_id", string_of_int v)) a.next_step_id;
      Option.map (fun v -> ("end_construct_id",  v)) a.end_construct_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("temperature", string_of_float v)) a.temperature;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("protein_location",  v)) a.protein_location;
      Option.map (fun v -> ("protein_volume", string_of_float v)) a.protein_volume;
      Option.map (fun v -> ("protein_yield", string_of_float v)) a.protein_yield;
      Option.map (fun v -> ("protein_yield_method",  v)) a.protein_yield_method;
    ]

end

module Pdbx_entity_src_gen_pure = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    product_id: string option;
    date: string option;
    conc_device_id: string option;
    conc_details: string option;
    conc_assay_method: string option;
    protein_concentration: float option;
    protein_yield: float option;
    protein_purity: float option;
    protein_oligomeric_state: int option;
    storage_buffer_id: string option;
    storage_temperature: float option;
    summary: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    product_id = None;
    date = None;
    conc_device_id = None;
    conc_details = None;
    conc_assay_method = None;
    protein_concentration = None;
    protein_yield = None;
    protein_purity = None;
    protein_oligomeric_state = None;
    storage_buffer_id = None;
    storage_temperature = None;
    summary = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "product_id" -> { b with product_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "conc_device_id" -> { b with conc_device_id = (Some v) }
      | "conc_details" -> { b with conc_details = (Some v) }
      | "conc_assay_method" -> { b with conc_assay_method = (Some v) }
      | "protein_concentration" -> { b with protein_concentration = (PDBjDict.some_float v) }
      | "protein_yield" -> { b with protein_yield = (PDBjDict.some_float v) }
      | "protein_purity" -> { b with protein_purity = (PDBjDict.some_float v) }
      | "protein_oligomeric_state" -> { b with protein_oligomeric_state = (PDBjDict.some_int v) }
      | "storage_buffer_id" -> { b with storage_buffer_id = (Some v) }
      | "storage_temperature" -> { b with storage_temperature = (PDBjDict.some_float v) }
      | "summary" -> { b with summary = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("product_id",  v)) a.product_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("conc_device_id",  v)) a.conc_device_id;
      Option.map (fun v -> ("conc_details",  v)) a.conc_details;
      Option.map (fun v -> ("conc_assay_method",  v)) a.conc_assay_method;
      Option.map (fun v -> ("protein_concentration", string_of_float v)) a.protein_concentration;
      Option.map (fun v -> ("protein_yield", string_of_float v)) a.protein_yield;
      Option.map (fun v -> ("protein_purity", string_of_float v)) a.protein_purity;
      Option.map (fun v -> ("protein_oligomeric_state", string_of_int v)) a.protein_oligomeric_state;
      Option.map (fun v -> ("storage_buffer_id",  v)) a.storage_buffer_id;
      Option.map (fun v -> ("storage_temperature", string_of_float v)) a.storage_temperature;
      Option.map (fun v -> ("summary",  v)) a.summary;
    ]

end

module Pdbx_entity_src_gen_character = struct
  type t = {
    entry_id: string option;
    entity_id: string option;
    step_id: int option;
    robot_id: string option;
    date: string option;
    method_: string option;
    result: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    entity_id = None;
    step_id = None;
    robot_id = None;
    date = None;
    method_ = None;
    result = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "step_id" -> { b with step_id = (PDBjDict.some_int v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "result" -> { b with result = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("step_id", string_of_int v)) a.step_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("result",  v)) a.result;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_construct = struct
  type t = {
    entry_id: string option;
    id: string option;
    name: string option;
    organisation: string option;
    entity_id: string option;
    robot_id: string option;
    date: string option;
    details: string option;
    class_: string option;
    type_: string option;
    seq: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    name = None;
    organisation = None;
    entity_id = None;
    robot_id = None;
    date = None;
    details = None;
    class_ = None;
    type_ = None;
    seq = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "organisation" -> { b with organisation = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "robot_id" -> { b with robot_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "class" -> { b with class_ = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "seq" -> { b with seq = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("organisation",  v)) a.organisation;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("robot_id",  v)) a.robot_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("class",  v)) a.class_;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("seq",  v)) a.seq;
    ]

end

module Pdbx_construct_feature = struct
  type t = {
    id: string option;
    construct_id: string option;
    entry_id: string option;
    start_seq: int option;
    end_seq: int option;
    type_: string option;
    details: string option;
  }

  let default = {
    id = None;
    construct_id = None;
    entry_id = None;
    start_seq = None;
    end_seq = None;
    type_ = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "construct_id" -> { b with construct_id = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "start_seq" -> { b with start_seq = (PDBjDict.some_int v) }
      | "end_seq" -> { b with end_seq = (PDBjDict.some_int v) }
      | "type" -> { b with type_ = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("construct_id",  v)) a.construct_id;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("start_seq", string_of_int v)) a.start_seq;
      Option.map (fun v -> ("end_seq", string_of_int v)) a.end_seq;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_robot_system = struct
  type t = {
    id: string option;
    model: string option;
    type_: string option;
    manufacturer: string option;
  }

  let default = {
    id = None;
    model = None;
    type_ = None;
    manufacturer = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "model" -> { b with model = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "manufacturer" -> { b with manufacturer = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("model",  v)) a.model;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("manufacturer",  v)) a.manufacturer;
    ]

end

module Pdbx_buffer = struct
  type t = {
    id: string option;
    name: string option;
    details: string option;
  }

  let default = {
    id = None;
    name = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_buffer_components = struct
  type t = {
    id: string option;
    buffer_id: string option;
    name: string option;
    volume: string option;
    conc: string option;
    details: string option;
    conc_units: string option;
    isotopic_labeling: string option;
  }

  let default = {
    id = None;
    buffer_id = None;
    name = None;
    volume = None;
    conc = None;
    details = None;
    conc_units = None;
    isotopic_labeling = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "buffer_id" -> { b with buffer_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "volume" -> { b with volume = (Some v) }
      | "conc" -> { b with conc = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "conc_units" -> { b with conc_units = (Some v) }
      | "isotopic_labeling" -> { b with isotopic_labeling = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("buffer_id",  v)) a.buffer_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("volume",  v)) a.volume;
      Option.map (fun v -> ("conc",  v)) a.conc;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("conc_units",  v)) a.conc_units;
      Option.map (fun v -> ("isotopic_labeling",  v)) a.isotopic_labeling;
    ]

end

module Pdbx_domain = struct
  type t = {
    details: string option;
    id: string option;
  }

  let default = {
    details = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Pdbx_domain_range = struct
  type t = {
    beg_label_alt_id: string option;
    beg_label_asym_id: string option;
    beg_label_comp_id: string option;
    beg_label_seq_id: int option;
    beg_auth_asym_id: string option;
    beg_auth_comp_id: string option;
    beg_auth_seq_id: string option;
    domain_id: string option;
    end_label_alt_id: string option;
    end_label_asym_id: string option;
    end_label_comp_id: string option;
    end_label_seq_id: int option;
    end_auth_asym_id: string option;
    end_auth_comp_id: string option;
    end_auth_seq_id: string option;
  }

  let default = {
    beg_label_alt_id = None;
    beg_label_asym_id = None;
    beg_label_comp_id = None;
    beg_label_seq_id = None;
    beg_auth_asym_id = None;
    beg_auth_comp_id = None;
    beg_auth_seq_id = None;
    domain_id = None;
    end_label_alt_id = None;
    end_label_asym_id = None;
    end_label_comp_id = None;
    end_label_seq_id = None;
    end_auth_asym_id = None;
    end_auth_comp_id = None;
    end_auth_seq_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "beg_label_alt_id" -> { b with beg_label_alt_id = (Some v) }
      | "beg_label_asym_id" -> { b with beg_label_asym_id = (Some v) }
      | "beg_label_comp_id" -> { b with beg_label_comp_id = (Some v) }
      | "beg_label_seq_id" -> { b with beg_label_seq_id = (PDBjDict.some_int v) }
      | "beg_auth_asym_id" -> { b with beg_auth_asym_id = (Some v) }
      | "beg_auth_comp_id" -> { b with beg_auth_comp_id = (Some v) }
      | "beg_auth_seq_id" -> { b with beg_auth_seq_id = (Some v) }
      | "domain_id" -> { b with domain_id = (Some v) }
      | "end_label_alt_id" -> { b with end_label_alt_id = (Some v) }
      | "end_label_asym_id" -> { b with end_label_asym_id = (Some v) }
      | "end_label_comp_id" -> { b with end_label_comp_id = (Some v) }
      | "end_label_seq_id" -> { b with end_label_seq_id = (PDBjDict.some_int v) }
      | "end_auth_asym_id" -> { b with end_auth_asym_id = (Some v) }
      | "end_auth_comp_id" -> { b with end_auth_comp_id = (Some v) }
      | "end_auth_seq_id" -> { b with end_auth_seq_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("beg_label_alt_id",  v)) a.beg_label_alt_id;
      Option.map (fun v -> ("beg_label_asym_id",  v)) a.beg_label_asym_id;
      Option.map (fun v -> ("beg_label_comp_id",  v)) a.beg_label_comp_id;
      Option.map (fun v -> ("beg_label_seq_id", string_of_int v)) a.beg_label_seq_id;
      Option.map (fun v -> ("beg_auth_asym_id",  v)) a.beg_auth_asym_id;
      Option.map (fun v -> ("beg_auth_comp_id",  v)) a.beg_auth_comp_id;
      Option.map (fun v -> ("beg_auth_seq_id",  v)) a.beg_auth_seq_id;
      Option.map (fun v -> ("domain_id",  v)) a.domain_id;
      Option.map (fun v -> ("end_label_alt_id",  v)) a.end_label_alt_id;
      Option.map (fun v -> ("end_label_asym_id",  v)) a.end_label_asym_id;
      Option.map (fun v -> ("end_label_comp_id",  v)) a.end_label_comp_id;
      Option.map (fun v -> ("end_label_seq_id", string_of_int v)) a.end_label_seq_id;
      Option.map (fun v -> ("end_auth_asym_id",  v)) a.end_auth_asym_id;
      Option.map (fun v -> ("end_auth_comp_id",  v)) a.end_auth_comp_id;
      Option.map (fun v -> ("end_auth_seq_id",  v)) a.end_auth_seq_id;
    ]

end

module Pdbx_sequence_range = struct
  type t = {
    beg_label_alt_id: string option;
    beg_label_asym_id: string option;
    beg_label_comp_id: string option;
    beg_label_seq_id: int option;
    beg_auth_asym_id: string option;
    beg_auth_comp_id: string option;
    beg_auth_seq_id: string option;
    seq_range_id: string option;
    end_label_alt_id: string option;
    end_label_asym_id: string option;
    end_label_comp_id: string option;
    end_label_seq_id: int option;
    end_auth_asym_id: string option;
    end_auth_comp_id: string option;
    end_auth_seq_id: string option;
  }

  let default = {
    beg_label_alt_id = None;
    beg_label_asym_id = None;
    beg_label_comp_id = None;
    beg_label_seq_id = None;
    beg_auth_asym_id = None;
    beg_auth_comp_id = None;
    beg_auth_seq_id = None;
    seq_range_id = None;
    end_label_alt_id = None;
    end_label_asym_id = None;
    end_label_comp_id = None;
    end_label_seq_id = None;
    end_auth_asym_id = None;
    end_auth_comp_id = None;
    end_auth_seq_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "beg_label_alt_id" -> { b with beg_label_alt_id = (Some v) }
      | "beg_label_asym_id" -> { b with beg_label_asym_id = (Some v) }
      | "beg_label_comp_id" -> { b with beg_label_comp_id = (Some v) }
      | "beg_label_seq_id" -> { b with beg_label_seq_id = (PDBjDict.some_int v) }
      | "beg_auth_asym_id" -> { b with beg_auth_asym_id = (Some v) }
      | "beg_auth_comp_id" -> { b with beg_auth_comp_id = (Some v) }
      | "beg_auth_seq_id" -> { b with beg_auth_seq_id = (Some v) }
      | "seq_range_id" -> { b with seq_range_id = (Some v) }
      | "end_label_alt_id" -> { b with end_label_alt_id = (Some v) }
      | "end_label_asym_id" -> { b with end_label_asym_id = (Some v) }
      | "end_label_comp_id" -> { b with end_label_comp_id = (Some v) }
      | "end_label_seq_id" -> { b with end_label_seq_id = (PDBjDict.some_int v) }
      | "end_auth_asym_id" -> { b with end_auth_asym_id = (Some v) }
      | "end_auth_comp_id" -> { b with end_auth_comp_id = (Some v) }
      | "end_auth_seq_id" -> { b with end_auth_seq_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("beg_label_alt_id",  v)) a.beg_label_alt_id;
      Option.map (fun v -> ("beg_label_asym_id",  v)) a.beg_label_asym_id;
      Option.map (fun v -> ("beg_label_comp_id",  v)) a.beg_label_comp_id;
      Option.map (fun v -> ("beg_label_seq_id", string_of_int v)) a.beg_label_seq_id;
      Option.map (fun v -> ("beg_auth_asym_id",  v)) a.beg_auth_asym_id;
      Option.map (fun v -> ("beg_auth_comp_id",  v)) a.beg_auth_comp_id;
      Option.map (fun v -> ("beg_auth_seq_id",  v)) a.beg_auth_seq_id;
      Option.map (fun v -> ("seq_range_id",  v)) a.seq_range_id;
      Option.map (fun v -> ("end_label_alt_id",  v)) a.end_label_alt_id;
      Option.map (fun v -> ("end_label_asym_id",  v)) a.end_label_asym_id;
      Option.map (fun v -> ("end_label_comp_id",  v)) a.end_label_comp_id;
      Option.map (fun v -> ("end_label_seq_id", string_of_int v)) a.end_label_seq_id;
      Option.map (fun v -> ("end_auth_asym_id",  v)) a.end_auth_asym_id;
      Option.map (fun v -> ("end_auth_comp_id",  v)) a.end_auth_comp_id;
      Option.map (fun v -> ("end_auth_seq_id",  v)) a.end_auth_seq_id;
    ]

end

module Pdbx_feature_entry = struct
  type t = {
    id: string option;
    feature_name: string option;
    feature_type: string option;
    feature: string option;
    feature_identifier: string option;
    feature_assigned_by: string option;
    feature_citation_id: string option;
    feature_software_id: string option;
  }

  let default = {
    id = None;
    feature_name = None;
    feature_type = None;
    feature = None;
    feature_identifier = None;
    feature_assigned_by = None;
    feature_citation_id = None;
    feature_software_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "feature_name" -> { b with feature_name = (Some v) }
      | "feature_type" -> { b with feature_type = (Some v) }
      | "feature" -> { b with feature = (Some v) }
      | "feature_identifier" -> { b with feature_identifier = (Some v) }
      | "feature_assigned_by" -> { b with feature_assigned_by = (Some v) }
      | "feature_citation_id" -> { b with feature_citation_id = (Some v) }
      | "feature_software_id" -> { b with feature_software_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("feature_name",  v)) a.feature_name;
      Option.map (fun v -> ("feature_type",  v)) a.feature_type;
      Option.map (fun v -> ("feature",  v)) a.feature;
      Option.map (fun v -> ("feature_identifier",  v)) a.feature_identifier;
      Option.map (fun v -> ("feature_assigned_by",  v)) a.feature_assigned_by;
      Option.map (fun v -> ("feature_citation_id",  v)) a.feature_citation_id;
      Option.map (fun v -> ("feature_software_id",  v)) a.feature_software_id;
    ]

end

module Pdbx_feature_domain = struct
  type t = {
    id: string option;
    domain_id: string option;
    feature_name: string option;
    feature_type: string option;
    feature: string option;
    feature_identifier: string option;
    feature_assigned_by: string option;
    feature_citation_id: string option;
    feature_software_id: string option;
  }

  let default = {
    id = None;
    domain_id = None;
    feature_name = None;
    feature_type = None;
    feature = None;
    feature_identifier = None;
    feature_assigned_by = None;
    feature_citation_id = None;
    feature_software_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "domain_id" -> { b with domain_id = (Some v) }
      | "feature_name" -> { b with feature_name = (Some v) }
      | "feature_type" -> { b with feature_type = (Some v) }
      | "feature" -> { b with feature = (Some v) }
      | "feature_identifier" -> { b with feature_identifier = (Some v) }
      | "feature_assigned_by" -> { b with feature_assigned_by = (Some v) }
      | "feature_citation_id" -> { b with feature_citation_id = (Some v) }
      | "feature_software_id" -> { b with feature_software_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("domain_id",  v)) a.domain_id;
      Option.map (fun v -> ("feature_name",  v)) a.feature_name;
      Option.map (fun v -> ("feature_type",  v)) a.feature_type;
      Option.map (fun v -> ("feature",  v)) a.feature;
      Option.map (fun v -> ("feature_identifier",  v)) a.feature_identifier;
      Option.map (fun v -> ("feature_assigned_by",  v)) a.feature_assigned_by;
      Option.map (fun v -> ("feature_citation_id",  v)) a.feature_citation_id;
      Option.map (fun v -> ("feature_software_id",  v)) a.feature_software_id;
    ]

end

module Pdbx_feature_sequence_range = struct
  type t = {
    id: string option;
    seq_range_id: string option;
    feature_name: string option;
    feature_type: string option;
    feature: string option;
    feature_identifier: string option;
    feature_assigned_by: string option;
    feature_citation_id: string option;
    feature_software_id: string option;
  }

  let default = {
    id = None;
    seq_range_id = None;
    feature_name = None;
    feature_type = None;
    feature = None;
    feature_identifier = None;
    feature_assigned_by = None;
    feature_citation_id = None;
    feature_software_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "seq_range_id" -> { b with seq_range_id = (Some v) }
      | "feature_name" -> { b with feature_name = (Some v) }
      | "feature_type" -> { b with feature_type = (Some v) }
      | "feature" -> { b with feature = (Some v) }
      | "feature_identifier" -> { b with feature_identifier = (Some v) }
      | "feature_assigned_by" -> { b with feature_assigned_by = (Some v) }
      | "feature_citation_id" -> { b with feature_citation_id = (Some v) }
      | "feature_software_id" -> { b with feature_software_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("seq_range_id",  v)) a.seq_range_id;
      Option.map (fun v -> ("feature_name",  v)) a.feature_name;
      Option.map (fun v -> ("feature_type",  v)) a.feature_type;
      Option.map (fun v -> ("feature",  v)) a.feature;
      Option.map (fun v -> ("feature_identifier",  v)) a.feature_identifier;
      Option.map (fun v -> ("feature_assigned_by",  v)) a.feature_assigned_by;
      Option.map (fun v -> ("feature_citation_id",  v)) a.feature_citation_id;
      Option.map (fun v -> ("feature_software_id",  v)) a.feature_software_id;
    ]

end

module Pdbx_feature_assembly = struct
  type t = {
    id: string option;
    assembly_id: string option;
    feature_name: string option;
    feature_type: string option;
    feature: string option;
    feature_identifier: string option;
    feature_assigned_by: string option;
    feature_citation_id: string option;
    feature_software_id: string option;
  }

  let default = {
    id = None;
    assembly_id = None;
    feature_name = None;
    feature_type = None;
    feature = None;
    feature_identifier = None;
    feature_assigned_by = None;
    feature_citation_id = None;
    feature_software_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "assembly_id" -> { b with assembly_id = (Some v) }
      | "feature_name" -> { b with feature_name = (Some v) }
      | "feature_type" -> { b with feature_type = (Some v) }
      | "feature" -> { b with feature = (Some v) }
      | "feature_identifier" -> { b with feature_identifier = (Some v) }
      | "feature_assigned_by" -> { b with feature_assigned_by = (Some v) }
      | "feature_citation_id" -> { b with feature_citation_id = (Some v) }
      | "feature_software_id" -> { b with feature_software_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("assembly_id",  v)) a.assembly_id;
      Option.map (fun v -> ("feature_name",  v)) a.feature_name;
      Option.map (fun v -> ("feature_type",  v)) a.feature_type;
      Option.map (fun v -> ("feature",  v)) a.feature;
      Option.map (fun v -> ("feature_identifier",  v)) a.feature_identifier;
      Option.map (fun v -> ("feature_assigned_by",  v)) a.feature_assigned_by;
      Option.map (fun v -> ("feature_citation_id",  v)) a.feature_citation_id;
      Option.map (fun v -> ("feature_software_id",  v)) a.feature_software_id;
    ]

end

module Pdbx_feature_monomer = struct
  type t = {
    id: string option;
    feature_name: string option;
    feature_type: string option;
    feature: string option;
    feature_identifier: string option;
    feature_assigned_by: string option;
    feature_citation_id: string option;
    feature_software_id: string option;
    label_alt_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
  }

  let default = {
    id = None;
    feature_name = None;
    feature_type = None;
    feature = None;
    feature_identifier = None;
    feature_assigned_by = None;
    feature_citation_id = None;
    feature_software_id = None;
    label_alt_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "feature_name" -> { b with feature_name = (Some v) }
      | "feature_type" -> { b with feature_type = (Some v) }
      | "feature" -> { b with feature = (Some v) }
      | "feature_identifier" -> { b with feature_identifier = (Some v) }
      | "feature_assigned_by" -> { b with feature_assigned_by = (Some v) }
      | "feature_citation_id" -> { b with feature_citation_id = (Some v) }
      | "feature_software_id" -> { b with feature_software_id = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("feature_name",  v)) a.feature_name;
      Option.map (fun v -> ("feature_type",  v)) a.feature_type;
      Option.map (fun v -> ("feature",  v)) a.feature;
      Option.map (fun v -> ("feature_identifier",  v)) a.feature_identifier;
      Option.map (fun v -> ("feature_assigned_by",  v)) a.feature_assigned_by;
      Option.map (fun v -> ("feature_citation_id",  v)) a.feature_citation_id;
      Option.map (fun v -> ("feature_software_id",  v)) a.feature_software_id;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
    ]

end

module Pdbx_exptl_pd = struct
  type t = {
    entry_id: string option;
    spec_preparation_pH: float option;
    spec_preparation_pH_range: string option;
    spec_preparation: string option;
  }

  let default = {
    entry_id = None;
    spec_preparation_pH = None;
    spec_preparation_pH_range = None;
    spec_preparation = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "spec_preparation_pH" -> { b with spec_preparation_pH = (PDBjDict.some_float v) }
      | "spec_preparation_pH_range" -> { b with spec_preparation_pH_range = (Some v) }
      | "spec_preparation" -> { b with spec_preparation = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("spec_preparation_pH", string_of_float v)) a.spec_preparation_pH;
      Option.map (fun v -> ("spec_preparation_pH_range",  v)) a.spec_preparation_pH_range;
      Option.map (fun v -> ("spec_preparation",  v)) a.spec_preparation;
    ]

end

module Pdbx_reflns_twin = struct
  type t = {
    diffrn_id: string option;
    crystal_id: string option;
    domain_id: string option;
    type_: string option;
    operator: string option;
    fraction: float option;
    mean_I2_over_mean_I_square: float option;
    mean_F_square_over_mean_F2: float option;
  }

  let default = {
    diffrn_id = None;
    crystal_id = None;
    domain_id = None;
    type_ = None;
    operator = None;
    fraction = None;
    mean_I2_over_mean_I_square = None;
    mean_F_square_over_mean_F2 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "crystal_id" -> { b with crystal_id = (Some v) }
      | "domain_id" -> { b with domain_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "operator" -> { b with operator = (Some v) }
      | "fraction" -> { b with fraction = (PDBjDict.some_float v) }
      | "mean_I2_over_mean_I_square" -> { b with mean_I2_over_mean_I_square = (PDBjDict.some_float v) }
      | "mean_F_square_over_mean_F2" -> { b with mean_F_square_over_mean_F2 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("crystal_id",  v)) a.crystal_id;
      Option.map (fun v -> ("domain_id",  v)) a.domain_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("operator",  v)) a.operator;
      Option.map (fun v -> ("fraction", string_of_float v)) a.fraction;
      Option.map (fun v -> ("mean_I2_over_mean_I_square", string_of_float v)) a.mean_I2_over_mean_I_square;
      Option.map (fun v -> ("mean_F_square_over_mean_F2", string_of_float v)) a.mean_F_square_over_mean_F2;
    ]

end

module Pdbx_struct_info = struct
  type t = {
    type_: string option;
    value: string option;
    details: string option;
  }

  let default = {
    type_ = None;
    value = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "type" -> { b with type_ = (Some v) }
      | "value" -> { b with value = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("value",  v)) a.value;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_re_refinement = struct
  type t = {
    entry_id: string option;
    citation_id: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    citation_id = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "citation_id" -> { b with citation_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_struct_assembly_prop = struct
  type t = {
    biol_id: string option;
    type_: string option;
    value: string option;
    details: string option;
  }

  let default = {
    biol_id = None;
    type_ = None;
    value = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "biol_id" -> { b with biol_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "value" -> { b with value = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("biol_id",  v)) a.biol_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("value",  v)) a.value;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_struct_ref_seq_feature = struct
  type t = {
    feature_id: int option;
    align_id: string option;
    type_: string option;
    details: string option;
    pdb_strand_id: string option;
    asym_id: string option;
    beg_auth_seq_id: string option;
    end_auth_seq_id: string option;
    beg_seq_num: string option;
    end_seq_num: string option;
    beg_auth_mon_id: string option;
    end_auth_mon_id: string option;
    beg_pdb_ins_code: string option;
    end_pdb_ins_code: string option;
  }

  let default = {
    feature_id = None;
    align_id = None;
    type_ = None;
    details = None;
    pdb_strand_id = None;
    asym_id = None;
    beg_auth_seq_id = None;
    end_auth_seq_id = None;
    beg_seq_num = None;
    end_seq_num = None;
    beg_auth_mon_id = None;
    end_auth_mon_id = None;
    beg_pdb_ins_code = None;
    end_pdb_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "feature_id" -> { b with feature_id = (PDBjDict.some_int v) }
      | "align_id" -> { b with align_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "pdb_strand_id" -> { b with pdb_strand_id = (Some v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | "beg_auth_seq_id" -> { b with beg_auth_seq_id = (Some v) }
      | "end_auth_seq_id" -> { b with end_auth_seq_id = (Some v) }
      | "beg_seq_num" -> { b with beg_seq_num = (Some v) }
      | "end_seq_num" -> { b with end_seq_num = (Some v) }
      | "beg_auth_mon_id" -> { b with beg_auth_mon_id = (Some v) }
      | "end_auth_mon_id" -> { b with end_auth_mon_id = (Some v) }
      | "beg_pdb_ins_code" -> { b with beg_pdb_ins_code = (Some v) }
      | "end_pdb_ins_code" -> { b with end_pdb_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("feature_id", string_of_int v)) a.feature_id;
      Option.map (fun v -> ("align_id",  v)) a.align_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("pdb_strand_id",  v)) a.pdb_strand_id;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("beg_auth_seq_id",  v)) a.beg_auth_seq_id;
      Option.map (fun v -> ("end_auth_seq_id",  v)) a.end_auth_seq_id;
      Option.map (fun v -> ("beg_seq_num",  v)) a.beg_seq_num;
      Option.map (fun v -> ("end_seq_num",  v)) a.end_seq_num;
      Option.map (fun v -> ("beg_auth_mon_id",  v)) a.beg_auth_mon_id;
      Option.map (fun v -> ("end_auth_mon_id",  v)) a.end_auth_mon_id;
      Option.map (fun v -> ("beg_pdb_ins_code",  v)) a.beg_pdb_ins_code;
      Option.map (fun v -> ("end_pdb_ins_code",  v)) a.end_pdb_ins_code;
    ]

end

module Pdbx_struct_ref_seq_feature_prop = struct
  type t = {
    feature_id: int option;
    property_id: int option;
    type_: string option;
    value: string option;
    details: string option;
    beg_db_mon_id: string option;
    end_db_mon_id: string option;
    beg_db_seq_id: int option;
    end_db_seq_id: int option;
  }

  let default = {
    feature_id = None;
    property_id = None;
    type_ = None;
    value = None;
    details = None;
    beg_db_mon_id = None;
    end_db_mon_id = None;
    beg_db_seq_id = None;
    end_db_seq_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "feature_id" -> { b with feature_id = (PDBjDict.some_int v) }
      | "property_id" -> { b with property_id = (PDBjDict.some_int v) }
      | "type" -> { b with type_ = (Some v) }
      | "value" -> { b with value = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "beg_db_mon_id" -> { b with beg_db_mon_id = (Some v) }
      | "end_db_mon_id" -> { b with end_db_mon_id = (Some v) }
      | "beg_db_seq_id" -> { b with beg_db_seq_id = (PDBjDict.some_int v) }
      | "end_db_seq_id" -> { b with end_db_seq_id = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("feature_id", string_of_int v)) a.feature_id;
      Option.map (fun v -> ("property_id", string_of_int v)) a.property_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("value",  v)) a.value;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("beg_db_mon_id",  v)) a.beg_db_mon_id;
      Option.map (fun v -> ("end_db_mon_id",  v)) a.end_db_mon_id;
      Option.map (fun v -> ("beg_db_seq_id", string_of_int v)) a.beg_db_seq_id;
      Option.map (fun v -> ("end_db_seq_id", string_of_int v)) a.end_db_seq_id;
    ]

end

module Pdbx_struct_chem_comp_diagnostics = struct
  type t = {
    details: string option;
    type_: string option;
    pdb_strand_id: string option;
    asym_id: string option;
    auth_seq_id: string option;
    seq_num: int option;
    auth_comp_id: string option;
    pdb_ins_code: string option;
    ordinal: int option;
  }

  let default = {
    details = None;
    type_ = None;
    pdb_strand_id = None;
    asym_id = None;
    auth_seq_id = None;
    seq_num = None;
    auth_comp_id = None;
    pdb_ins_code = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "pdb_strand_id" -> { b with pdb_strand_id = (Some v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "seq_num" -> { b with seq_num = (PDBjDict.some_int v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "pdb_ins_code" -> { b with pdb_ins_code = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("pdb_strand_id",  v)) a.pdb_strand_id;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("seq_num", string_of_int v)) a.seq_num;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("pdb_ins_code",  v)) a.pdb_ins_code;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Pdbx_chem_comp_feature = struct
  type t = {
    comp_id: string option;
    type_: string option;
    support: string option;
    value: string option;
    source: string option;
  }

  let default = {
    comp_id = None;
    type_ = None;
    support = None;
    value = None;
    source = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "comp_id" -> { b with comp_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "support" -> { b with support = (Some v) }
      | "value" -> { b with value = (Some v) }
      | "source" -> { b with source = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("support",  v)) a.support;
      Option.map (fun v -> ("value",  v)) a.value;
      Option.map (fun v -> ("source",  v)) a.source;
    ]

end

module Pdbx_coordinate_model = struct
  type t = {
    asym_id: string option;
    type_: string option;
  }

  let default = {
    asym_id = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "asym_id" -> { b with asym_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_struct_chem_comp_feature = struct
  type t = {
    details: string option;
    type_: string option;
    pdb_strand_id: string option;
    asym_id: string option;
    auth_seq_id: string option;
    seq_num: int option;
    auth_comp_id: string option;
    pdb_ins_code: string option;
    ordinal: int option;
  }

  let default = {
    details = None;
    type_ = None;
    pdb_strand_id = None;
    asym_id = None;
    auth_seq_id = None;
    seq_num = None;
    auth_comp_id = None;
    pdb_ins_code = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "pdb_strand_id" -> { b with pdb_strand_id = (Some v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "seq_num" -> { b with seq_num = (PDBjDict.some_int v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "pdb_ins_code" -> { b with pdb_ins_code = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("pdb_strand_id",  v)) a.pdb_strand_id;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("seq_num", string_of_int v)) a.seq_num;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("pdb_ins_code",  v)) a.pdb_ins_code;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Pdbx_diffrn_reflns_shell = struct
  type t = {
    diffrn_id: string option;
    d_res_low: float option;
    d_res_high: float option;
    percent_possible_obs: float option;
    rmerge_I_obs: float option;
    rsym_value: float option;
    chi_squared: float option;
    redundancy: float option;
    rejects: int option;
    number_obs: int option;
  }

  let default = {
    diffrn_id = None;
    d_res_low = None;
    d_res_high = None;
    percent_possible_obs = None;
    rmerge_I_obs = None;
    rsym_value = None;
    chi_squared = None;
    redundancy = None;
    rejects = None;
    number_obs = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "diffrn_id" -> { b with diffrn_id = (Some v) }
      | "d_res_low" -> { b with d_res_low = (PDBjDict.some_float v) }
      | "d_res_high" -> { b with d_res_high = (PDBjDict.some_float v) }
      | "percent_possible_obs" -> { b with percent_possible_obs = (PDBjDict.some_float v) }
      | "Rmerge_I_obs" -> { b with rmerge_I_obs = (PDBjDict.some_float v) }
      | "Rsym_value" -> { b with rsym_value = (PDBjDict.some_float v) }
      | "chi_squared" -> { b with chi_squared = (PDBjDict.some_float v) }
      | "redundancy" -> { b with redundancy = (PDBjDict.some_float v) }
      | "rejects" -> { b with rejects = (PDBjDict.some_int v) }
      | "number_obs" -> { b with number_obs = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("diffrn_id",  v)) a.diffrn_id;
      Option.map (fun v -> ("d_res_low", string_of_float v)) a.d_res_low;
      Option.map (fun v -> ("d_res_high", string_of_float v)) a.d_res_high;
      Option.map (fun v -> ("percent_possible_obs", string_of_float v)) a.percent_possible_obs;
      Option.map (fun v -> ("Rmerge_I_obs", string_of_float v)) a.rmerge_I_obs;
      Option.map (fun v -> ("Rsym_value", string_of_float v)) a.rsym_value;
      Option.map (fun v -> ("chi_squared", string_of_float v)) a.chi_squared;
      Option.map (fun v -> ("redundancy", string_of_float v)) a.redundancy;
      Option.map (fun v -> ("rejects", string_of_int v)) a.rejects;
      Option.map (fun v -> ("number_obs", string_of_int v)) a.number_obs;
    ]

end

module Pdbx_bond_distance_limits = struct
  type t = {
    atom_type_1: string option;
    atom_type_2: string option;
    lower_limit: float option;
    upper_limit: float option;
  }

  let default = {
    atom_type_1 = None;
    atom_type_2 = None;
    lower_limit = None;
    upper_limit = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_type_1" -> { b with atom_type_1 = (Some v) }
      | "atom_type_2" -> { b with atom_type_2 = (Some v) }
      | "lower_limit" -> { b with lower_limit = (PDBjDict.some_float v) }
      | "upper_limit" -> { b with upper_limit = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_type_1",  v)) a.atom_type_1;
      Option.map (fun v -> ("atom_type_2",  v)) a.atom_type_2;
      Option.map (fun v -> ("lower_limit", string_of_float v)) a.lower_limit;
      Option.map (fun v -> ("upper_limit", string_of_float v)) a.upper_limit;
    ]

end

module Pdbx_soln_scatter = struct
  type t = {
    entry_id: string option;
    id: string option;
    type_: string option;
    source_beamline: string option;
    source_beamline_instrument: string option;
    detector_type: string option;
    detector_specific: string option;
    source_type: string option;
    source_class: string option;
    num_time_frames: int option;
    sample_pH: float option;
    temperature: float option;
    concentration_range: string option;
    buffer_name: string option;
    mean_guiner_radius: float option;
    mean_guiner_radius_esd: float option;
    min_mean_cross_sectional_radii_gyration: float option;
    min_mean_cross_sectional_radii_gyration_esd: float option;
    max_mean_cross_sectional_radii_gyration: float option;
    max_mean_cross_sectional_radii_gyration_esd: float option;
    protein_length: string option;
    data_reduction_software_list: string option;
    data_analysis_software_list: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    type_ = None;
    source_beamline = None;
    source_beamline_instrument = None;
    detector_type = None;
    detector_specific = None;
    source_type = None;
    source_class = None;
    num_time_frames = None;
    sample_pH = None;
    temperature = None;
    concentration_range = None;
    buffer_name = None;
    mean_guiner_radius = None;
    mean_guiner_radius_esd = None;
    min_mean_cross_sectional_radii_gyration = None;
    min_mean_cross_sectional_radii_gyration_esd = None;
    max_mean_cross_sectional_radii_gyration = None;
    max_mean_cross_sectional_radii_gyration_esd = None;
    protein_length = None;
    data_reduction_software_list = None;
    data_analysis_software_list = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "source_beamline" -> { b with source_beamline = (Some v) }
      | "source_beamline_instrument" -> { b with source_beamline_instrument = (Some v) }
      | "detector_type" -> { b with detector_type = (Some v) }
      | "detector_specific" -> { b with detector_specific = (Some v) }
      | "source_type" -> { b with source_type = (Some v) }
      | "source_class" -> { b with source_class = (Some v) }
      | "num_time_frames" -> { b with num_time_frames = (PDBjDict.some_int v) }
      | "sample_pH" -> { b with sample_pH = (PDBjDict.some_float v) }
      | "temperature" -> { b with temperature = (PDBjDict.some_float v) }
      | "concentration_range" -> { b with concentration_range = (Some v) }
      | "buffer_name" -> { b with buffer_name = (Some v) }
      | "mean_guiner_radius" -> { b with mean_guiner_radius = (PDBjDict.some_float v) }
      | "mean_guiner_radius_esd" -> { b with mean_guiner_radius_esd = (PDBjDict.some_float v) }
      | "min_mean_cross_sectional_radii_gyration" -> { b with min_mean_cross_sectional_radii_gyration = (PDBjDict.some_float v) }
      | "min_mean_cross_sectional_radii_gyration_esd" -> { b with min_mean_cross_sectional_radii_gyration_esd = (PDBjDict.some_float v) }
      | "max_mean_cross_sectional_radii_gyration" -> { b with max_mean_cross_sectional_radii_gyration = (PDBjDict.some_float v) }
      | "max_mean_cross_sectional_radii_gyration_esd" -> { b with max_mean_cross_sectional_radii_gyration_esd = (PDBjDict.some_float v) }
      | "protein_length" -> { b with protein_length = (Some v) }
      | "data_reduction_software_list" -> { b with data_reduction_software_list = (Some v) }
      | "data_analysis_software_list" -> { b with data_analysis_software_list = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("source_beamline",  v)) a.source_beamline;
      Option.map (fun v -> ("source_beamline_instrument",  v)) a.source_beamline_instrument;
      Option.map (fun v -> ("detector_type",  v)) a.detector_type;
      Option.map (fun v -> ("detector_specific",  v)) a.detector_specific;
      Option.map (fun v -> ("source_type",  v)) a.source_type;
      Option.map (fun v -> ("source_class",  v)) a.source_class;
      Option.map (fun v -> ("num_time_frames", string_of_int v)) a.num_time_frames;
      Option.map (fun v -> ("sample_pH", string_of_float v)) a.sample_pH;
      Option.map (fun v -> ("temperature", string_of_float v)) a.temperature;
      Option.map (fun v -> ("concentration_range",  v)) a.concentration_range;
      Option.map (fun v -> ("buffer_name",  v)) a.buffer_name;
      Option.map (fun v -> ("mean_guiner_radius", string_of_float v)) a.mean_guiner_radius;
      Option.map (fun v -> ("mean_guiner_radius_esd", string_of_float v)) a.mean_guiner_radius_esd;
      Option.map (fun v -> ("min_mean_cross_sectional_radii_gyration", string_of_float v)) a.min_mean_cross_sectional_radii_gyration;
      Option.map (fun v -> ("min_mean_cross_sectional_radii_gyration_esd", string_of_float v)) a.min_mean_cross_sectional_radii_gyration_esd;
      Option.map (fun v -> ("max_mean_cross_sectional_radii_gyration", string_of_float v)) a.max_mean_cross_sectional_radii_gyration;
      Option.map (fun v -> ("max_mean_cross_sectional_radii_gyration_esd", string_of_float v)) a.max_mean_cross_sectional_radii_gyration_esd;
      Option.map (fun v -> ("protein_length",  v)) a.protein_length;
      Option.map (fun v -> ("data_reduction_software_list",  v)) a.data_reduction_software_list;
      Option.map (fun v -> ("data_analysis_software_list",  v)) a.data_analysis_software_list;
    ]

end

module Pdbx_soln_scatter_model = struct
  type t = {
    scatter_id: string option;
    id: string option;
    details: string option;
    method_: string option;
    software_list: string option;
    software_author_list: string option;
    entry_fitting_list: string option;
    num_conformers_calculated: int option;
    num_conformers_submitted: int option;
    representative_conformer: int option;
    conformer_selection_criteria: string option;
  }

  let default = {
    scatter_id = None;
    id = None;
    details = None;
    method_ = None;
    software_list = None;
    software_author_list = None;
    entry_fitting_list = None;
    num_conformers_calculated = None;
    num_conformers_submitted = None;
    representative_conformer = None;
    conformer_selection_criteria = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "scatter_id" -> { b with scatter_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "software_list" -> { b with software_list = (Some v) }
      | "software_author_list" -> { b with software_author_list = (Some v) }
      | "entry_fitting_list" -> { b with entry_fitting_list = (Some v) }
      | "num_conformers_calculated" -> { b with num_conformers_calculated = (PDBjDict.some_int v) }
      | "num_conformers_submitted" -> { b with num_conformers_submitted = (PDBjDict.some_int v) }
      | "representative_conformer" -> { b with representative_conformer = (PDBjDict.some_int v) }
      | "conformer_selection_criteria" -> { b with conformer_selection_criteria = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("scatter_id",  v)) a.scatter_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("software_list",  v)) a.software_list;
      Option.map (fun v -> ("software_author_list",  v)) a.software_author_list;
      Option.map (fun v -> ("entry_fitting_list",  v)) a.entry_fitting_list;
      Option.map (fun v -> ("num_conformers_calculated", string_of_int v)) a.num_conformers_calculated;
      Option.map (fun v -> ("num_conformers_submitted", string_of_int v)) a.num_conformers_submitted;
      Option.map (fun v -> ("representative_conformer", string_of_int v)) a.representative_conformer;
      Option.map (fun v -> ("conformer_selection_criteria",  v)) a.conformer_selection_criteria;
    ]

end

module Pdbx_chem_comp_descriptor = struct
  type t = {
    comp_id: string option;
    descriptor: string option;
    type_: string option;
    program: string option;
    program_version: string option;
    ordinal: int option;
  }

  let default = {
    comp_id = None;
    descriptor = None;
    type_ = None;
    program = None;
    program_version = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "comp_id" -> { b with comp_id = (Some v) }
      | "descriptor" -> { b with descriptor = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "program" -> { b with program = (Some v) }
      | "program_version" -> { b with program_version = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("descriptor",  v)) a.descriptor;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("program",  v)) a.program;
      Option.map (fun v -> ("program_version",  v)) a.program_version;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Pdbx_chem_comp_identifier = struct
  type t = {
    comp_id: string option;
    identifier: string option;
    type_: string option;
    program: string option;
    program_version: string option;
    ordinal: int option;
  }

  let default = {
    comp_id = None;
    identifier = None;
    type_ = None;
    program = None;
    program_version = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "comp_id" -> { b with comp_id = (Some v) }
      | "identifier" -> { b with identifier = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "program" -> { b with program = (Some v) }
      | "program_version" -> { b with program_version = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("identifier",  v)) a.identifier;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("program",  v)) a.program;
      Option.map (fun v -> ("program_version",  v)) a.program_version;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Pdbx_chem_comp_import = struct
  type t = {
    comp_id: string option;
  }

  let default = {
    comp_id = None;
  }

  let of_mmCIF items =
    match items with
    | [] -> default
    | (_,v)::_ -> { comp_id = (Some v) }

  let to_mmCIF a =
    match a.comp_id with
    | None -> []
    | Some v -> [ ("comp_id",( v)) ]

end

module Pdbx_chem_comp_atom_edit = struct
  type t = {
    ordinal: int option;
    comp_id: string option;
    edit_op: string option;
    atom_id: string option;
    edit_atom_id: string option;
    edit_atom_value: string option;
  }

  let default = {
    ordinal = None;
    comp_id = None;
    edit_op = None;
    atom_id = None;
    edit_atom_id = None;
    edit_atom_value = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "edit_op" -> { b with edit_op = (Some v) }
      | "atom_id" -> { b with atom_id = (Some v) }
      | "edit_atom_id" -> { b with edit_atom_id = (Some v) }
      | "edit_atom_value" -> { b with edit_atom_value = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("edit_op",  v)) a.edit_op;
      Option.map (fun v -> ("atom_id",  v)) a.atom_id;
      Option.map (fun v -> ("edit_atom_id",  v)) a.edit_atom_id;
      Option.map (fun v -> ("edit_atom_value",  v)) a.edit_atom_value;
    ]

end

module Pdbx_chem_comp_bond_edit = struct
  type t = {
    ordinal: int option;
    comp_id: string option;
    edit_op: string option;
    atom_id_1: string option;
    atom_id_2: string option;
    edit_bond_value: string option;
  }

  let default = {
    ordinal = None;
    comp_id = None;
    edit_op = None;
    atom_id_1 = None;
    atom_id_2 = None;
    edit_bond_value = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "edit_op" -> { b with edit_op = (Some v) }
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "edit_bond_value" -> { b with edit_bond_value = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("edit_op",  v)) a.edit_op;
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("edit_bond_value",  v)) a.edit_bond_value;
    ]

end

module Pdbx_chem_comp_audit = struct
  type t = {
    comp_id: string option;
    date: string option;
    annotator: string option;
    processing_site: string option;
    details: string option;
    action_type: string option;
  }

  let default = {
    comp_id = None;
    date = None;
    annotator = None;
    processing_site = None;
    details = None;
    action_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "comp_id" -> { b with comp_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "annotator" -> { b with annotator = (Some v) }
      | "processing_site" -> { b with processing_site = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "action_type" -> { b with action_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("annotator",  v)) a.annotator;
      Option.map (fun v -> ("processing_site",  v)) a.processing_site;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("action_type",  v)) a.action_type;
    ]

end

module Pdbx_validate_close_contact = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id_1: string option;
    auth_atom_id_1: string option;
    auth_comp_id_1: string option;
    auth_seq_id_1: string option;
    auth_atom_id_2: string option;
    auth_asym_id_2: string option;
    auth_comp_id_2: string option;
    auth_seq_id_2: string option;
    pDB_ins_code_1: string option;
    pDB_ins_code_2: string option;
    label_alt_id_1: string option;
    label_alt_id_2: string option;
    symm_as_xyz_1: string option;
    symm_as_xyz_2: string option;
    dist: float option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id_1 = None;
    auth_atom_id_1 = None;
    auth_comp_id_1 = None;
    auth_seq_id_1 = None;
    auth_atom_id_2 = None;
    auth_asym_id_2 = None;
    auth_comp_id_2 = None;
    auth_seq_id_2 = None;
    pDB_ins_code_1 = None;
    pDB_ins_code_2 = None;
    label_alt_id_1 = None;
    label_alt_id_2 = None;
    symm_as_xyz_1 = None;
    symm_as_xyz_2 = None;
    dist = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id_1" -> { b with auth_asym_id_1 = (Some v) }
      | "auth_atom_id_1" -> { b with auth_atom_id_1 = (Some v) }
      | "auth_comp_id_1" -> { b with auth_comp_id_1 = (Some v) }
      | "auth_seq_id_1" -> { b with auth_seq_id_1 = (Some v) }
      | "auth_atom_id_2" -> { b with auth_atom_id_2 = (Some v) }
      | "auth_asym_id_2" -> { b with auth_asym_id_2 = (Some v) }
      | "auth_comp_id_2" -> { b with auth_comp_id_2 = (Some v) }
      | "auth_seq_id_2" -> { b with auth_seq_id_2 = (Some v) }
      | "PDB_ins_code_1" -> { b with pDB_ins_code_1 = (Some v) }
      | "PDB_ins_code_2" -> { b with pDB_ins_code_2 = (Some v) }
      | "label_alt_id_1" -> { b with label_alt_id_1 = (Some v) }
      | "label_alt_id_2" -> { b with label_alt_id_2 = (Some v) }
      | "symm_as_xyz_1" -> { b with symm_as_xyz_1 = (Some v) }
      | "symm_as_xyz_2" -> { b with symm_as_xyz_2 = (Some v) }
      | "dist" -> { b with dist = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id_1",  v)) a.auth_asym_id_1;
      Option.map (fun v -> ("auth_atom_id_1",  v)) a.auth_atom_id_1;
      Option.map (fun v -> ("auth_comp_id_1",  v)) a.auth_comp_id_1;
      Option.map (fun v -> ("auth_seq_id_1",  v)) a.auth_seq_id_1;
      Option.map (fun v -> ("auth_atom_id_2",  v)) a.auth_atom_id_2;
      Option.map (fun v -> ("auth_asym_id_2",  v)) a.auth_asym_id_2;
      Option.map (fun v -> ("auth_comp_id_2",  v)) a.auth_comp_id_2;
      Option.map (fun v -> ("auth_seq_id_2",  v)) a.auth_seq_id_2;
      Option.map (fun v -> ("PDB_ins_code_1",  v)) a.pDB_ins_code_1;
      Option.map (fun v -> ("PDB_ins_code_2",  v)) a.pDB_ins_code_2;
      Option.map (fun v -> ("label_alt_id_1",  v)) a.label_alt_id_1;
      Option.map (fun v -> ("label_alt_id_2",  v)) a.label_alt_id_2;
      Option.map (fun v -> ("symm_as_xyz_1",  v)) a.symm_as_xyz_1;
      Option.map (fun v -> ("symm_as_xyz_2",  v)) a.symm_as_xyz_2;
      Option.map (fun v -> ("dist", string_of_float v)) a.dist;
    ]

end

module Pdbx_validate_symm_contact = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id_1: string option;
    auth_atom_id_1: string option;
    auth_comp_id_1: string option;
    auth_seq_id_1: string option;
    auth_atom_id_2: string option;
    auth_asym_id_2: string option;
    auth_comp_id_2: string option;
    auth_seq_id_2: string option;
    pDB_ins_code_1: string option;
    pDB_ins_code_2: string option;
    label_alt_id_1: string option;
    label_alt_id_2: string option;
    site_symmetry_1: string option;
    site_symmetry_2: string option;
    dist: float option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id_1 = None;
    auth_atom_id_1 = None;
    auth_comp_id_1 = None;
    auth_seq_id_1 = None;
    auth_atom_id_2 = None;
    auth_asym_id_2 = None;
    auth_comp_id_2 = None;
    auth_seq_id_2 = None;
    pDB_ins_code_1 = None;
    pDB_ins_code_2 = None;
    label_alt_id_1 = None;
    label_alt_id_2 = None;
    site_symmetry_1 = None;
    site_symmetry_2 = None;
    dist = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id_1" -> { b with auth_asym_id_1 = (Some v) }
      | "auth_atom_id_1" -> { b with auth_atom_id_1 = (Some v) }
      | "auth_comp_id_1" -> { b with auth_comp_id_1 = (Some v) }
      | "auth_seq_id_1" -> { b with auth_seq_id_1 = (Some v) }
      | "auth_atom_id_2" -> { b with auth_atom_id_2 = (Some v) }
      | "auth_asym_id_2" -> { b with auth_asym_id_2 = (Some v) }
      | "auth_comp_id_2" -> { b with auth_comp_id_2 = (Some v) }
      | "auth_seq_id_2" -> { b with auth_seq_id_2 = (Some v) }
      | "PDB_ins_code_1" -> { b with pDB_ins_code_1 = (Some v) }
      | "PDB_ins_code_2" -> { b with pDB_ins_code_2 = (Some v) }
      | "label_alt_id_1" -> { b with label_alt_id_1 = (Some v) }
      | "label_alt_id_2" -> { b with label_alt_id_2 = (Some v) }
      | "site_symmetry_1" -> { b with site_symmetry_1 = (Some v) }
      | "site_symmetry_2" -> { b with site_symmetry_2 = (Some v) }
      | "dist" -> { b with dist = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id_1",  v)) a.auth_asym_id_1;
      Option.map (fun v -> ("auth_atom_id_1",  v)) a.auth_atom_id_1;
      Option.map (fun v -> ("auth_comp_id_1",  v)) a.auth_comp_id_1;
      Option.map (fun v -> ("auth_seq_id_1",  v)) a.auth_seq_id_1;
      Option.map (fun v -> ("auth_atom_id_2",  v)) a.auth_atom_id_2;
      Option.map (fun v -> ("auth_asym_id_2",  v)) a.auth_asym_id_2;
      Option.map (fun v -> ("auth_comp_id_2",  v)) a.auth_comp_id_2;
      Option.map (fun v -> ("auth_seq_id_2",  v)) a.auth_seq_id_2;
      Option.map (fun v -> ("PDB_ins_code_1",  v)) a.pDB_ins_code_1;
      Option.map (fun v -> ("PDB_ins_code_2",  v)) a.pDB_ins_code_2;
      Option.map (fun v -> ("label_alt_id_1",  v)) a.label_alt_id_1;
      Option.map (fun v -> ("label_alt_id_2",  v)) a.label_alt_id_2;
      Option.map (fun v -> ("site_symmetry_1",  v)) a.site_symmetry_1;
      Option.map (fun v -> ("site_symmetry_2",  v)) a.site_symmetry_2;
      Option.map (fun v -> ("dist", string_of_float v)) a.dist;
    ]

end

module Pdbx_validate_rmsd_bond = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id_1: string option;
    auth_atom_id_1: string option;
    auth_comp_id_1: string option;
    auth_seq_id_1: string option;
    auth_atom_id_2: string option;
    auth_asym_id_2: string option;
    auth_comp_id_2: string option;
    auth_seq_id_2: string option;
    pDB_ins_code_1: string option;
    pDB_ins_code_2: string option;
    label_alt_id_1: string option;
    label_alt_id_2: string option;
    bond_deviation: float option;
    bond_value: float option;
    bond_target_value: float option;
    bond_standard_deviation: float option;
    linker_flag: string option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id_1 = None;
    auth_atom_id_1 = None;
    auth_comp_id_1 = None;
    auth_seq_id_1 = None;
    auth_atom_id_2 = None;
    auth_asym_id_2 = None;
    auth_comp_id_2 = None;
    auth_seq_id_2 = None;
    pDB_ins_code_1 = None;
    pDB_ins_code_2 = None;
    label_alt_id_1 = None;
    label_alt_id_2 = None;
    bond_deviation = None;
    bond_value = None;
    bond_target_value = None;
    bond_standard_deviation = None;
    linker_flag = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id_1" -> { b with auth_asym_id_1 = (Some v) }
      | "auth_atom_id_1" -> { b with auth_atom_id_1 = (Some v) }
      | "auth_comp_id_1" -> { b with auth_comp_id_1 = (Some v) }
      | "auth_seq_id_1" -> { b with auth_seq_id_1 = (Some v) }
      | "auth_atom_id_2" -> { b with auth_atom_id_2 = (Some v) }
      | "auth_asym_id_2" -> { b with auth_asym_id_2 = (Some v) }
      | "auth_comp_id_2" -> { b with auth_comp_id_2 = (Some v) }
      | "auth_seq_id_2" -> { b with auth_seq_id_2 = (Some v) }
      | "PDB_ins_code_1" -> { b with pDB_ins_code_1 = (Some v) }
      | "PDB_ins_code_2" -> { b with pDB_ins_code_2 = (Some v) }
      | "label_alt_id_1" -> { b with label_alt_id_1 = (Some v) }
      | "label_alt_id_2" -> { b with label_alt_id_2 = (Some v) }
      | "bond_deviation" -> { b with bond_deviation = (PDBjDict.some_float v) }
      | "bond_value" -> { b with bond_value = (PDBjDict.some_float v) }
      | "bond_target_value" -> { b with bond_target_value = (PDBjDict.some_float v) }
      | "bond_standard_deviation" -> { b with bond_standard_deviation = (PDBjDict.some_float v) }
      | "linker_flag" -> { b with linker_flag = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id_1",  v)) a.auth_asym_id_1;
      Option.map (fun v -> ("auth_atom_id_1",  v)) a.auth_atom_id_1;
      Option.map (fun v -> ("auth_comp_id_1",  v)) a.auth_comp_id_1;
      Option.map (fun v -> ("auth_seq_id_1",  v)) a.auth_seq_id_1;
      Option.map (fun v -> ("auth_atom_id_2",  v)) a.auth_atom_id_2;
      Option.map (fun v -> ("auth_asym_id_2",  v)) a.auth_asym_id_2;
      Option.map (fun v -> ("auth_comp_id_2",  v)) a.auth_comp_id_2;
      Option.map (fun v -> ("auth_seq_id_2",  v)) a.auth_seq_id_2;
      Option.map (fun v -> ("PDB_ins_code_1",  v)) a.pDB_ins_code_1;
      Option.map (fun v -> ("PDB_ins_code_2",  v)) a.pDB_ins_code_2;
      Option.map (fun v -> ("label_alt_id_1",  v)) a.label_alt_id_1;
      Option.map (fun v -> ("label_alt_id_2",  v)) a.label_alt_id_2;
      Option.map (fun v -> ("bond_deviation", string_of_float v)) a.bond_deviation;
      Option.map (fun v -> ("bond_value", string_of_float v)) a.bond_value;
      Option.map (fun v -> ("bond_target_value", string_of_float v)) a.bond_target_value;
      Option.map (fun v -> ("bond_standard_deviation", string_of_float v)) a.bond_standard_deviation;
      Option.map (fun v -> ("linker_flag",  v)) a.linker_flag;
    ]

end

module Pdbx_validate_rmsd_angle = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id_1: string option;
    auth_atom_id_1: string option;
    auth_comp_id_1: string option;
    auth_seq_id_1: string option;
    auth_atom_id_2: string option;
    auth_asym_id_2: string option;
    auth_comp_id_2: string option;
    auth_seq_id_2: string option;
    auth_atom_id_3: string option;
    auth_asym_id_3: string option;
    auth_comp_id_3: string option;
    auth_seq_id_3: string option;
    pDB_ins_code_1: string option;
    pDB_ins_code_2: string option;
    pDB_ins_code_3: string option;
    label_alt_id_1: string option;
    label_alt_id_2: string option;
    label_alt_id_3: string option;
    angle_deviation: float option;
    angle_value: float option;
    angle_target_value: float option;
    angle_standard_deviation: float option;
    linker_flag: string option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id_1 = None;
    auth_atom_id_1 = None;
    auth_comp_id_1 = None;
    auth_seq_id_1 = None;
    auth_atom_id_2 = None;
    auth_asym_id_2 = None;
    auth_comp_id_2 = None;
    auth_seq_id_2 = None;
    auth_atom_id_3 = None;
    auth_asym_id_3 = None;
    auth_comp_id_3 = None;
    auth_seq_id_3 = None;
    pDB_ins_code_1 = None;
    pDB_ins_code_2 = None;
    pDB_ins_code_3 = None;
    label_alt_id_1 = None;
    label_alt_id_2 = None;
    label_alt_id_3 = None;
    angle_deviation = None;
    angle_value = None;
    angle_target_value = None;
    angle_standard_deviation = None;
    linker_flag = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id_1" -> { b with auth_asym_id_1 = (Some v) }
      | "auth_atom_id_1" -> { b with auth_atom_id_1 = (Some v) }
      | "auth_comp_id_1" -> { b with auth_comp_id_1 = (Some v) }
      | "auth_seq_id_1" -> { b with auth_seq_id_1 = (Some v) }
      | "auth_atom_id_2" -> { b with auth_atom_id_2 = (Some v) }
      | "auth_asym_id_2" -> { b with auth_asym_id_2 = (Some v) }
      | "auth_comp_id_2" -> { b with auth_comp_id_2 = (Some v) }
      | "auth_seq_id_2" -> { b with auth_seq_id_2 = (Some v) }
      | "auth_atom_id_3" -> { b with auth_atom_id_3 = (Some v) }
      | "auth_asym_id_3" -> { b with auth_asym_id_3 = (Some v) }
      | "auth_comp_id_3" -> { b with auth_comp_id_3 = (Some v) }
      | "auth_seq_id_3" -> { b with auth_seq_id_3 = (Some v) }
      | "PDB_ins_code_1" -> { b with pDB_ins_code_1 = (Some v) }
      | "PDB_ins_code_2" -> { b with pDB_ins_code_2 = (Some v) }
      | "PDB_ins_code_3" -> { b with pDB_ins_code_3 = (Some v) }
      | "label_alt_id_1" -> { b with label_alt_id_1 = (Some v) }
      | "label_alt_id_2" -> { b with label_alt_id_2 = (Some v) }
      | "label_alt_id_3" -> { b with label_alt_id_3 = (Some v) }
      | "angle_deviation" -> { b with angle_deviation = (PDBjDict.some_float v) }
      | "angle_value" -> { b with angle_value = (PDBjDict.some_float v) }
      | "angle_target_value" -> { b with angle_target_value = (PDBjDict.some_float v) }
      | "angle_standard_deviation" -> { b with angle_standard_deviation = (PDBjDict.some_float v) }
      | "linker_flag" -> { b with linker_flag = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id_1",  v)) a.auth_asym_id_1;
      Option.map (fun v -> ("auth_atom_id_1",  v)) a.auth_atom_id_1;
      Option.map (fun v -> ("auth_comp_id_1",  v)) a.auth_comp_id_1;
      Option.map (fun v -> ("auth_seq_id_1",  v)) a.auth_seq_id_1;
      Option.map (fun v -> ("auth_atom_id_2",  v)) a.auth_atom_id_2;
      Option.map (fun v -> ("auth_asym_id_2",  v)) a.auth_asym_id_2;
      Option.map (fun v -> ("auth_comp_id_2",  v)) a.auth_comp_id_2;
      Option.map (fun v -> ("auth_seq_id_2",  v)) a.auth_seq_id_2;
      Option.map (fun v -> ("auth_atom_id_3",  v)) a.auth_atom_id_3;
      Option.map (fun v -> ("auth_asym_id_3",  v)) a.auth_asym_id_3;
      Option.map (fun v -> ("auth_comp_id_3",  v)) a.auth_comp_id_3;
      Option.map (fun v -> ("auth_seq_id_3",  v)) a.auth_seq_id_3;
      Option.map (fun v -> ("PDB_ins_code_1",  v)) a.pDB_ins_code_1;
      Option.map (fun v -> ("PDB_ins_code_2",  v)) a.pDB_ins_code_2;
      Option.map (fun v -> ("PDB_ins_code_3",  v)) a.pDB_ins_code_3;
      Option.map (fun v -> ("label_alt_id_1",  v)) a.label_alt_id_1;
      Option.map (fun v -> ("label_alt_id_2",  v)) a.label_alt_id_2;
      Option.map (fun v -> ("label_alt_id_3",  v)) a.label_alt_id_3;
      Option.map (fun v -> ("angle_deviation", string_of_float v)) a.angle_deviation;
      Option.map (fun v -> ("angle_value", string_of_float v)) a.angle_value;
      Option.map (fun v -> ("angle_target_value", string_of_float v)) a.angle_target_value;
      Option.map (fun v -> ("angle_standard_deviation", string_of_float v)) a.angle_standard_deviation;
      Option.map (fun v -> ("linker_flag",  v)) a.linker_flag;
    ]

end

module Pdbx_validate_torsion = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    label_alt_id: string option;
    phi: float option;
    psi: float option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    label_alt_id = None;
    phi = None;
    psi = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "phi" -> { b with phi = (PDBjDict.some_float v) }
      | "psi" -> { b with psi = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("phi", string_of_float v)) a.phi;
      Option.map (fun v -> ("psi", string_of_float v)) a.psi;
    ]

end

module Pdbx_validate_peptide_omega = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id_1: string option;
    auth_asym_id_2: string option;
    auth_comp_id_1: string option;
    auth_comp_id_2: string option;
    auth_seq_id_1: string option;
    auth_seq_id_2: string option;
    pDB_ins_code_1: string option;
    pDB_ins_code_2: string option;
    label_alt_id_1: string option;
    label_alt_id_2: string option;
    omega: float option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id_1 = None;
    auth_asym_id_2 = None;
    auth_comp_id_1 = None;
    auth_comp_id_2 = None;
    auth_seq_id_1 = None;
    auth_seq_id_2 = None;
    pDB_ins_code_1 = None;
    pDB_ins_code_2 = None;
    label_alt_id_1 = None;
    label_alt_id_2 = None;
    omega = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id_1" -> { b with auth_asym_id_1 = (Some v) }
      | "auth_asym_id_2" -> { b with auth_asym_id_2 = (Some v) }
      | "auth_comp_id_1" -> { b with auth_comp_id_1 = (Some v) }
      | "auth_comp_id_2" -> { b with auth_comp_id_2 = (Some v) }
      | "auth_seq_id_1" -> { b with auth_seq_id_1 = (Some v) }
      | "auth_seq_id_2" -> { b with auth_seq_id_2 = (Some v) }
      | "PDB_ins_code_1" -> { b with pDB_ins_code_1 = (Some v) }
      | "PDB_ins_code_2" -> { b with pDB_ins_code_2 = (Some v) }
      | "label_alt_id_1" -> { b with label_alt_id_1 = (Some v) }
      | "label_alt_id_2" -> { b with label_alt_id_2 = (Some v) }
      | "omega" -> { b with omega = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id_1",  v)) a.auth_asym_id_1;
      Option.map (fun v -> ("auth_asym_id_2",  v)) a.auth_asym_id_2;
      Option.map (fun v -> ("auth_comp_id_1",  v)) a.auth_comp_id_1;
      Option.map (fun v -> ("auth_comp_id_2",  v)) a.auth_comp_id_2;
      Option.map (fun v -> ("auth_seq_id_1",  v)) a.auth_seq_id_1;
      Option.map (fun v -> ("auth_seq_id_2",  v)) a.auth_seq_id_2;
      Option.map (fun v -> ("PDB_ins_code_1",  v)) a.pDB_ins_code_1;
      Option.map (fun v -> ("PDB_ins_code_2",  v)) a.pDB_ins_code_2;
      Option.map (fun v -> ("label_alt_id_1",  v)) a.label_alt_id_1;
      Option.map (fun v -> ("label_alt_id_2",  v)) a.label_alt_id_2;
      Option.map (fun v -> ("omega", string_of_float v)) a.omega;
    ]

end

module Pdbx_validate_chiral = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_atom_id: string option;
    label_alt_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    omega: float option;
    details: string option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_atom_id = None;
    label_alt_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    omega = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_atom_id" -> { b with auth_atom_id = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "omega" -> { b with omega = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_atom_id",  v)) a.auth_atom_id;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("omega", string_of_float v)) a.omega;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_validate_planes = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    label_alt_id: string option;
    rmsd: float option;
    type_: string option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    label_alt_id = None;
    rmsd = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "rmsd" -> { b with rmsd = (PDBjDict.some_float v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("rmsd", string_of_float v)) a.rmsd;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_validate_planes_atom = struct
  type t = {
    plane_id: int option;
    id: int option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    auth_atom_id: string option;
    atom_deviation: float option;
  }

  let default = {
    plane_id = None;
    id = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    auth_atom_id = None;
    atom_deviation = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "plane_id" -> { b with plane_id = (PDBjDict.some_int v) }
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "auth_atom_id" -> { b with auth_atom_id = (Some v) }
      | "atom_deviation" -> { b with atom_deviation = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("plane_id", string_of_int v)) a.plane_id;
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("auth_atom_id",  v)) a.auth_atom_id;
      Option.map (fun v -> ("atom_deviation", string_of_float v)) a.atom_deviation;
    ]

end

module Pdbx_validate_main_chain_plane = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    label_alt_id: string option;
    improper_torsion_angle: float option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    label_alt_id = None;
    improper_torsion_angle = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "improper_torsion_angle" -> { b with improper_torsion_angle = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("improper_torsion_angle", string_of_float v)) a.improper_torsion_angle;
    ]

end

module Pdbx_struct_conn_angle = struct
  type t = {
    id: string option;
    ptnr1_label_alt_id: string option;
    ptnr1_label_asym_id: string option;
    ptnr1_label_atom_id: string option;
    ptnr1_label_comp_id: string option;
    ptnr1_label_seq_id: int option;
    ptnr1_auth_asym_id: string option;
    ptnr1_auth_atom_id: string option;
    ptnr1_auth_comp_id: string option;
    ptnr1_auth_seq_id: string option;
    ptnr1_symmetry: string option;
    ptnr2_label_alt_id: string option;
    ptnr2_label_asym_id: string option;
    ptnr2_label_atom_id: string option;
    ptnr2_label_comp_id: string option;
    ptnr2_label_seq_id: int option;
    ptnr2_auth_asym_id: string option;
    ptnr2_auth_atom_id: string option;
    ptnr2_auth_comp_id: string option;
    ptnr2_auth_seq_id: string option;
    ptnr2_symmetry: string option;
    ptnr1_PDB_ins_code: string option;
    ptnr1_auth_alt_id: string option;
    ptnr2_PDB_ins_code: string option;
    ptnr2_auth_alt_id: string option;
    ptnr3_auth_alt_id: string option;
    ptnr3_auth_asym_id: string option;
    ptnr3_auth_atom_id: string option;
    ptnr3_auth_comp_id: string option;
    ptnr3_PDB_ins_code: string option;
    ptnr3_auth_seq_id: string option;
    ptnr3_label_alt_id: string option;
    ptnr3_label_asym_id: string option;
    ptnr3_label_atom_id: string option;
    ptnr3_label_comp_id: string option;
    ptnr3_label_seq_id: int option;
    ptnr3_symmetry: string option;
    value: float option;
    value_esd: float option;
  }

  let default = {
    id = None;
    ptnr1_label_alt_id = None;
    ptnr1_label_asym_id = None;
    ptnr1_label_atom_id = None;
    ptnr1_label_comp_id = None;
    ptnr1_label_seq_id = None;
    ptnr1_auth_asym_id = None;
    ptnr1_auth_atom_id = None;
    ptnr1_auth_comp_id = None;
    ptnr1_auth_seq_id = None;
    ptnr1_symmetry = None;
    ptnr2_label_alt_id = None;
    ptnr2_label_asym_id = None;
    ptnr2_label_atom_id = None;
    ptnr2_label_comp_id = None;
    ptnr2_label_seq_id = None;
    ptnr2_auth_asym_id = None;
    ptnr2_auth_atom_id = None;
    ptnr2_auth_comp_id = None;
    ptnr2_auth_seq_id = None;
    ptnr2_symmetry = None;
    ptnr1_PDB_ins_code = None;
    ptnr1_auth_alt_id = None;
    ptnr2_PDB_ins_code = None;
    ptnr2_auth_alt_id = None;
    ptnr3_auth_alt_id = None;
    ptnr3_auth_asym_id = None;
    ptnr3_auth_atom_id = None;
    ptnr3_auth_comp_id = None;
    ptnr3_PDB_ins_code = None;
    ptnr3_auth_seq_id = None;
    ptnr3_label_alt_id = None;
    ptnr3_label_asym_id = None;
    ptnr3_label_atom_id = None;
    ptnr3_label_comp_id = None;
    ptnr3_label_seq_id = None;
    ptnr3_symmetry = None;
    value = None;
    value_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "ptnr1_label_alt_id" -> { b with ptnr1_label_alt_id = (Some v) }
      | "ptnr1_label_asym_id" -> { b with ptnr1_label_asym_id = (Some v) }
      | "ptnr1_label_atom_id" -> { b with ptnr1_label_atom_id = (Some v) }
      | "ptnr1_label_comp_id" -> { b with ptnr1_label_comp_id = (Some v) }
      | "ptnr1_label_seq_id" -> { b with ptnr1_label_seq_id = (PDBjDict.some_int v) }
      | "ptnr1_auth_asym_id" -> { b with ptnr1_auth_asym_id = (Some v) }
      | "ptnr1_auth_atom_id" -> { b with ptnr1_auth_atom_id = (Some v) }
      | "ptnr1_auth_comp_id" -> { b with ptnr1_auth_comp_id = (Some v) }
      | "ptnr1_auth_seq_id" -> { b with ptnr1_auth_seq_id = (Some v) }
      | "ptnr1_symmetry" -> { b with ptnr1_symmetry = (Some v) }
      | "ptnr2_label_alt_id" -> { b with ptnr2_label_alt_id = (Some v) }
      | "ptnr2_label_asym_id" -> { b with ptnr2_label_asym_id = (Some v) }
      | "ptnr2_label_atom_id" -> { b with ptnr2_label_atom_id = (Some v) }
      | "ptnr2_label_comp_id" -> { b with ptnr2_label_comp_id = (Some v) }
      | "ptnr2_label_seq_id" -> { b with ptnr2_label_seq_id = (PDBjDict.some_int v) }
      | "ptnr2_auth_asym_id" -> { b with ptnr2_auth_asym_id = (Some v) }
      | "ptnr2_auth_atom_id" -> { b with ptnr2_auth_atom_id = (Some v) }
      | "ptnr2_auth_comp_id" -> { b with ptnr2_auth_comp_id = (Some v) }
      | "ptnr2_auth_seq_id" -> { b with ptnr2_auth_seq_id = (Some v) }
      | "ptnr2_symmetry" -> { b with ptnr2_symmetry = (Some v) }
      | "ptnr1_PDB_ins_code" -> { b with ptnr1_PDB_ins_code = (Some v) }
      | "ptnr1_auth_alt_id" -> { b with ptnr1_auth_alt_id = (Some v) }
      | "ptnr2_PDB_ins_code" -> { b with ptnr2_PDB_ins_code = (Some v) }
      | "ptnr2_auth_alt_id" -> { b with ptnr2_auth_alt_id = (Some v) }
      | "ptnr3_auth_alt_id" -> { b with ptnr3_auth_alt_id = (Some v) }
      | "ptnr3_auth_asym_id" -> { b with ptnr3_auth_asym_id = (Some v) }
      | "ptnr3_auth_atom_id" -> { b with ptnr3_auth_atom_id = (Some v) }
      | "ptnr3_auth_comp_id" -> { b with ptnr3_auth_comp_id = (Some v) }
      | "ptnr3_PDB_ins_code" -> { b with ptnr3_PDB_ins_code = (Some v) }
      | "ptnr3_auth_seq_id" -> { b with ptnr3_auth_seq_id = (Some v) }
      | "ptnr3_label_alt_id" -> { b with ptnr3_label_alt_id = (Some v) }
      | "ptnr3_label_asym_id" -> { b with ptnr3_label_asym_id = (Some v) }
      | "ptnr3_label_atom_id" -> { b with ptnr3_label_atom_id = (Some v) }
      | "ptnr3_label_comp_id" -> { b with ptnr3_label_comp_id = (Some v) }
      | "ptnr3_label_seq_id" -> { b with ptnr3_label_seq_id = (PDBjDict.some_int v) }
      | "ptnr3_symmetry" -> { b with ptnr3_symmetry = (Some v) }
      | "value" -> { b with value = (PDBjDict.some_float v) }
      | "value_esd" -> { b with value_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("ptnr1_label_alt_id",  v)) a.ptnr1_label_alt_id;
      Option.map (fun v -> ("ptnr1_label_asym_id",  v)) a.ptnr1_label_asym_id;
      Option.map (fun v -> ("ptnr1_label_atom_id",  v)) a.ptnr1_label_atom_id;
      Option.map (fun v -> ("ptnr1_label_comp_id",  v)) a.ptnr1_label_comp_id;
      Option.map (fun v -> ("ptnr1_label_seq_id", string_of_int v)) a.ptnr1_label_seq_id;
      Option.map (fun v -> ("ptnr1_auth_asym_id",  v)) a.ptnr1_auth_asym_id;
      Option.map (fun v -> ("ptnr1_auth_atom_id",  v)) a.ptnr1_auth_atom_id;
      Option.map (fun v -> ("ptnr1_auth_comp_id",  v)) a.ptnr1_auth_comp_id;
      Option.map (fun v -> ("ptnr1_auth_seq_id",  v)) a.ptnr1_auth_seq_id;
      Option.map (fun v -> ("ptnr1_symmetry",  v)) a.ptnr1_symmetry;
      Option.map (fun v -> ("ptnr2_label_alt_id",  v)) a.ptnr2_label_alt_id;
      Option.map (fun v -> ("ptnr2_label_asym_id",  v)) a.ptnr2_label_asym_id;
      Option.map (fun v -> ("ptnr2_label_atom_id",  v)) a.ptnr2_label_atom_id;
      Option.map (fun v -> ("ptnr2_label_comp_id",  v)) a.ptnr2_label_comp_id;
      Option.map (fun v -> ("ptnr2_label_seq_id", string_of_int v)) a.ptnr2_label_seq_id;
      Option.map (fun v -> ("ptnr2_auth_asym_id",  v)) a.ptnr2_auth_asym_id;
      Option.map (fun v -> ("ptnr2_auth_atom_id",  v)) a.ptnr2_auth_atom_id;
      Option.map (fun v -> ("ptnr2_auth_comp_id",  v)) a.ptnr2_auth_comp_id;
      Option.map (fun v -> ("ptnr2_auth_seq_id",  v)) a.ptnr2_auth_seq_id;
      Option.map (fun v -> ("ptnr2_symmetry",  v)) a.ptnr2_symmetry;
      Option.map (fun v -> ("ptnr1_PDB_ins_code",  v)) a.ptnr1_PDB_ins_code;
      Option.map (fun v -> ("ptnr1_auth_alt_id",  v)) a.ptnr1_auth_alt_id;
      Option.map (fun v -> ("ptnr2_PDB_ins_code",  v)) a.ptnr2_PDB_ins_code;
      Option.map (fun v -> ("ptnr2_auth_alt_id",  v)) a.ptnr2_auth_alt_id;
      Option.map (fun v -> ("ptnr3_auth_alt_id",  v)) a.ptnr3_auth_alt_id;
      Option.map (fun v -> ("ptnr3_auth_asym_id",  v)) a.ptnr3_auth_asym_id;
      Option.map (fun v -> ("ptnr3_auth_atom_id",  v)) a.ptnr3_auth_atom_id;
      Option.map (fun v -> ("ptnr3_auth_comp_id",  v)) a.ptnr3_auth_comp_id;
      Option.map (fun v -> ("ptnr3_PDB_ins_code",  v)) a.ptnr3_PDB_ins_code;
      Option.map (fun v -> ("ptnr3_auth_seq_id",  v)) a.ptnr3_auth_seq_id;
      Option.map (fun v -> ("ptnr3_label_alt_id",  v)) a.ptnr3_label_alt_id;
      Option.map (fun v -> ("ptnr3_label_asym_id",  v)) a.ptnr3_label_asym_id;
      Option.map (fun v -> ("ptnr3_label_atom_id",  v)) a.ptnr3_label_atom_id;
      Option.map (fun v -> ("ptnr3_label_comp_id",  v)) a.ptnr3_label_comp_id;
      Option.map (fun v -> ("ptnr3_label_seq_id", string_of_int v)) a.ptnr3_label_seq_id;
      Option.map (fun v -> ("ptnr3_symmetry",  v)) a.ptnr3_symmetry;
      Option.map (fun v -> ("value", string_of_float v)) a.value;
      Option.map (fun v -> ("value_esd", string_of_float v)) a.value_esd;
    ]

end

module Pdbx_unobs_or_zero_occ_residues = struct
  type t = {
    id: int option;
    polymer_flag: string option;
    occupancy_flag: int option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
  }

  let default = {
    id = None;
    polymer_flag = None;
    occupancy_flag = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "polymer_flag" -> { b with polymer_flag = (Some v) }
      | "occupancy_flag" -> { b with occupancy_flag = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("polymer_flag",  v)) a.polymer_flag;
      Option.map (fun v -> ("occupancy_flag", string_of_int v)) a.occupancy_flag;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
    ]

end

module Pdbx_unobs_or_zero_occ_atoms = struct
  type t = {
    id: int option;
    polymer_flag: string option;
    occupancy_flag: int option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_atom_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    label_alt_id: string option;
    label_atom_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
  }

  let default = {
    id = None;
    polymer_flag = None;
    occupancy_flag = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_atom_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    label_alt_id = None;
    label_atom_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "polymer_flag" -> { b with polymer_flag = (Some v) }
      | "occupancy_flag" -> { b with occupancy_flag = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_atom_id" -> { b with auth_atom_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_atom_id" -> { b with label_atom_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("polymer_flag",  v)) a.polymer_flag;
      Option.map (fun v -> ("occupancy_flag", string_of_int v)) a.occupancy_flag;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_atom_id",  v)) a.auth_atom_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_atom_id",  v)) a.label_atom_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
    ]

end

module Pdbx_entry_details = struct
  type t = {
    entry_id: string option;
    nonpolymer_details: string option;
    sequence_details: string option;
    compound_details: string option;
    source_details: string option;
  }

  let default = {
    entry_id = None;
    nonpolymer_details = None;
    sequence_details = None;
    compound_details = None;
    source_details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "nonpolymer_details" -> { b with nonpolymer_details = (Some v) }
      | "sequence_details" -> { b with sequence_details = (Some v) }
      | "compound_details" -> { b with compound_details = (Some v) }
      | "source_details" -> { b with source_details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("nonpolymer_details",  v)) a.nonpolymer_details;
      Option.map (fun v -> ("sequence_details",  v)) a.sequence_details;
      Option.map (fun v -> ("compound_details",  v)) a.compound_details;
      Option.map (fun v -> ("source_details",  v)) a.source_details;
    ]

end

module Pdbx_struct_mod_residue = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    parent_comp_id: string option;
    details: string option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    parent_comp_id = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "parent_comp_id" -> { b with parent_comp_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("parent_comp_id",  v)) a.parent_comp_id;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_struct_ref_seq_insertion = struct
  type t = {
    id: string option;
    comp_id: string option;
    asym_id: string option;
    auth_asym_id: string option;
    auth_seq_id: string option;
    seq_id: int option;
    pDB_ins_code: string option;
    details: string option;
    db_code: string option;
    db_name: string option;
  }

  let default = {
    id = None;
    comp_id = None;
    asym_id = None;
    auth_asym_id = None;
    auth_seq_id = None;
    seq_id = None;
    pDB_ins_code = None;
    details = None;
    db_code = None;
    db_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "seq_id" -> { b with seq_id = (PDBjDict.some_int v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "db_code" -> { b with db_code = (Some v) }
      | "db_name" -> { b with db_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("seq_id", string_of_int v)) a.seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("db_code",  v)) a.db_code;
      Option.map (fun v -> ("db_name",  v)) a.db_name;
    ]

end

module Pdbx_struct_ref_seq_deletion = struct
  type t = {
    id: string option;
    details: string option;
    asym_id: string option;
    comp_id: string option;
    db_seq_id: int option;
    db_code: string option;
    db_name: string option;
  }

  let default = {
    id = None;
    details = None;
    asym_id = None;
    comp_id = None;
    db_seq_id = None;
    db_code = None;
    db_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "db_seq_id" -> { b with db_seq_id = (PDBjDict.some_int v) }
      | "db_code" -> { b with db_code = (Some v) }
      | "db_name" -> { b with db_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("db_seq_id", string_of_int v)) a.db_seq_id;
      Option.map (fun v -> ("db_code",  v)) a.db_code;
      Option.map (fun v -> ("db_name",  v)) a.db_name;
    ]

end

module Pdbx_remediation_atom_site_mapping = struct
  type t = {
    id: string option;
    group_PDB: string option;
    label_alt_id: string option;
    label_asym_id: string option;
    label_atom_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    pdbx_align: int option;
    pDB_ins_code: string option;
    pre_auth_asym_id: string option;
    pre_auth_atom_id: string option;
    pre_auth_comp_id: string option;
    pre_auth_seq_id: string option;
    pre_PDB_ins_code: string option;
    pre_group_PDB: string option;
    pre_auth_alt_id: string option;
    pre_pdbx_align: int option;
    auth_asym_id: string option;
    auth_atom_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    auth_alt_id: string option;
    occupancy: float option;
    pre_occupancy: float option;
  }

  let default = {
    id = None;
    group_PDB = None;
    label_alt_id = None;
    label_asym_id = None;
    label_atom_id = None;
    label_comp_id = None;
    label_seq_id = None;
    pdbx_align = None;
    pDB_ins_code = None;
    pre_auth_asym_id = None;
    pre_auth_atom_id = None;
    pre_auth_comp_id = None;
    pre_auth_seq_id = None;
    pre_PDB_ins_code = None;
    pre_group_PDB = None;
    pre_auth_alt_id = None;
    pre_pdbx_align = None;
    auth_asym_id = None;
    auth_atom_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    auth_alt_id = None;
    occupancy = None;
    pre_occupancy = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "group_PDB" -> { b with group_PDB = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_atom_id" -> { b with label_atom_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "pdbx_align" -> { b with pdbx_align = (PDBjDict.some_int v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "pre_auth_asym_id" -> { b with pre_auth_asym_id = (Some v) }
      | "pre_auth_atom_id" -> { b with pre_auth_atom_id = (Some v) }
      | "pre_auth_comp_id" -> { b with pre_auth_comp_id = (Some v) }
      | "pre_auth_seq_id" -> { b with pre_auth_seq_id = (Some v) }
      | "pre_PDB_ins_code" -> { b with pre_PDB_ins_code = (Some v) }
      | "pre_group_PDB" -> { b with pre_group_PDB = (Some v) }
      | "pre_auth_alt_id" -> { b with pre_auth_alt_id = (Some v) }
      | "pre_pdbx_align" -> { b with pre_pdbx_align = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_atom_id" -> { b with auth_atom_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "auth_alt_id" -> { b with auth_alt_id = (Some v) }
      | "occupancy" -> { b with occupancy = (PDBjDict.some_float v) }
      | "pre_occupancy" -> { b with pre_occupancy = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("group_PDB",  v)) a.group_PDB;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_atom_id",  v)) a.label_atom_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("pdbx_align", string_of_int v)) a.pdbx_align;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("pre_auth_asym_id",  v)) a.pre_auth_asym_id;
      Option.map (fun v -> ("pre_auth_atom_id",  v)) a.pre_auth_atom_id;
      Option.map (fun v -> ("pre_auth_comp_id",  v)) a.pre_auth_comp_id;
      Option.map (fun v -> ("pre_auth_seq_id",  v)) a.pre_auth_seq_id;
      Option.map (fun v -> ("pre_PDB_ins_code",  v)) a.pre_PDB_ins_code;
      Option.map (fun v -> ("pre_group_PDB",  v)) a.pre_group_PDB;
      Option.map (fun v -> ("pre_auth_alt_id",  v)) a.pre_auth_alt_id;
      Option.map (fun v -> ("pre_pdbx_align", string_of_int v)) a.pre_pdbx_align;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_atom_id",  v)) a.auth_atom_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("auth_alt_id",  v)) a.auth_alt_id;
      Option.map (fun v -> ("occupancy", string_of_float v)) a.occupancy;
      Option.map (fun v -> ("pre_occupancy", string_of_float v)) a.pre_occupancy;
    ]

end

module Pdbx_validate_polymer_linkage = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id_1: string option;
    auth_atom_id_1: string option;
    auth_comp_id_1: string option;
    auth_seq_id_1: string option;
    auth_atom_id_2: string option;
    auth_asym_id_2: string option;
    auth_comp_id_2: string option;
    auth_seq_id_2: string option;
    pDB_ins_code_1: string option;
    pDB_ins_code_2: string option;
    label_alt_id_1: string option;
    label_alt_id_2: string option;
    dist: float option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id_1 = None;
    auth_atom_id_1 = None;
    auth_comp_id_1 = None;
    auth_seq_id_1 = None;
    auth_atom_id_2 = None;
    auth_asym_id_2 = None;
    auth_comp_id_2 = None;
    auth_seq_id_2 = None;
    pDB_ins_code_1 = None;
    pDB_ins_code_2 = None;
    label_alt_id_1 = None;
    label_alt_id_2 = None;
    dist = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id_1" -> { b with auth_asym_id_1 = (Some v) }
      | "auth_atom_id_1" -> { b with auth_atom_id_1 = (Some v) }
      | "auth_comp_id_1" -> { b with auth_comp_id_1 = (Some v) }
      | "auth_seq_id_1" -> { b with auth_seq_id_1 = (Some v) }
      | "auth_atom_id_2" -> { b with auth_atom_id_2 = (Some v) }
      | "auth_asym_id_2" -> { b with auth_asym_id_2 = (Some v) }
      | "auth_comp_id_2" -> { b with auth_comp_id_2 = (Some v) }
      | "auth_seq_id_2" -> { b with auth_seq_id_2 = (Some v) }
      | "PDB_ins_code_1" -> { b with pDB_ins_code_1 = (Some v) }
      | "PDB_ins_code_2" -> { b with pDB_ins_code_2 = (Some v) }
      | "label_alt_id_1" -> { b with label_alt_id_1 = (Some v) }
      | "label_alt_id_2" -> { b with label_alt_id_2 = (Some v) }
      | "dist" -> { b with dist = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id_1",  v)) a.auth_asym_id_1;
      Option.map (fun v -> ("auth_atom_id_1",  v)) a.auth_atom_id_1;
      Option.map (fun v -> ("auth_comp_id_1",  v)) a.auth_comp_id_1;
      Option.map (fun v -> ("auth_seq_id_1",  v)) a.auth_seq_id_1;
      Option.map (fun v -> ("auth_atom_id_2",  v)) a.auth_atom_id_2;
      Option.map (fun v -> ("auth_asym_id_2",  v)) a.auth_asym_id_2;
      Option.map (fun v -> ("auth_comp_id_2",  v)) a.auth_comp_id_2;
      Option.map (fun v -> ("auth_seq_id_2",  v)) a.auth_seq_id_2;
      Option.map (fun v -> ("PDB_ins_code_1",  v)) a.pDB_ins_code_1;
      Option.map (fun v -> ("PDB_ins_code_2",  v)) a.pDB_ins_code_2;
      Option.map (fun v -> ("label_alt_id_1",  v)) a.label_alt_id_1;
      Option.map (fun v -> ("label_alt_id_2",  v)) a.label_alt_id_2;
      Option.map (fun v -> ("dist", string_of_float v)) a.dist;
    ]

end

module Pdbx_helical_symmetry = struct
  type t = {
    entry_id: string option;
    number_of_operations: int option;
    rotation_per_n_subunits: float option;
    rise_per_n_subunits: float option;
    n_subunits_divisor: int option;
    dyad_axis: string option;
    circular_symmetry: int option;
  }

  let default = {
    entry_id = None;
    number_of_operations = None;
    rotation_per_n_subunits = None;
    rise_per_n_subunits = None;
    n_subunits_divisor = None;
    dyad_axis = None;
    circular_symmetry = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "number_of_operations" -> { b with number_of_operations = (PDBjDict.some_int v) }
      | "rotation_per_n_subunits" -> { b with rotation_per_n_subunits = (PDBjDict.some_float v) }
      | "rise_per_n_subunits" -> { b with rise_per_n_subunits = (PDBjDict.some_float v) }
      | "n_subunits_divisor" -> { b with n_subunits_divisor = (PDBjDict.some_int v) }
      | "dyad_axis" -> { b with dyad_axis = (Some v) }
      | "circular_symmetry" -> { b with circular_symmetry = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("number_of_operations", string_of_int v)) a.number_of_operations;
      Option.map (fun v -> ("rotation_per_n_subunits", string_of_float v)) a.rotation_per_n_subunits;
      Option.map (fun v -> ("rise_per_n_subunits", string_of_float v)) a.rise_per_n_subunits;
      Option.map (fun v -> ("n_subunits_divisor", string_of_int v)) a.n_subunits_divisor;
      Option.map (fun v -> ("dyad_axis",  v)) a.dyad_axis;
      Option.map (fun v -> ("circular_symmetry", string_of_int v)) a.circular_symmetry;
    ]

end

module Pdbx_point_symmetry = struct
  type t = {
    entry_id: string option;
    schoenflies_symbol: string option;
    circular_symmetry: int option;
    h_M_notation: string option;
  }

  let default = {
    entry_id = None;
    schoenflies_symbol = None;
    circular_symmetry = None;
    h_M_notation = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "Schoenflies_symbol" -> { b with schoenflies_symbol = (Some v) }
      | "circular_symmetry" -> { b with circular_symmetry = (PDBjDict.some_int v) }
      | "H-M_notation" -> { b with h_M_notation = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("Schoenflies_symbol",  v)) a.schoenflies_symbol;
      Option.map (fun v -> ("circular_symmetry", string_of_int v)) a.circular_symmetry;
      Option.map (fun v -> ("H-M_notation",  v)) a.h_M_notation;
    ]

end

module Pdbx_struct_entity_inst = struct
  type t = {
    details: string option;
    entity_id: string option;
    id: string option;
  }

  let default = {
    details = None;
    entity_id = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Pdbx_struct_oper_list = struct
  type t = {
    id: string option;
    type_: string option;
    name: string option;
    symmetry_operation: string option;
    matrix11: float option;
    matrix12: float option;
    matrix13: float option;
    matrix21: float option;
    matrix22: float option;
    matrix23: float option;
    matrix31: float option;
    matrix32: float option;
    matrix33: float option;
    vector1: float option;
    vector2: float option;
    vector3: float option;
  }

  let default = {
    id = None;
    type_ = None;
    name = None;
    symmetry_operation = None;
    matrix11 = None;
    matrix12 = None;
    matrix13 = None;
    matrix21 = None;
    matrix22 = None;
    matrix23 = None;
    matrix31 = None;
    matrix32 = None;
    matrix33 = None;
    vector1 = None;
    vector2 = None;
    vector3 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "symmetry_operation" -> { b with symmetry_operation = (Some v) }
      | "matrix[1][1]" -> { b with matrix11 = (PDBjDict.some_float v) }
      | "matrix[1][2]" -> { b with matrix12 = (PDBjDict.some_float v) }
      | "matrix[1][3]" -> { b with matrix13 = (PDBjDict.some_float v) }
      | "matrix[2][1]" -> { b with matrix21 = (PDBjDict.some_float v) }
      | "matrix[2][2]" -> { b with matrix22 = (PDBjDict.some_float v) }
      | "matrix[2][3]" -> { b with matrix23 = (PDBjDict.some_float v) }
      | "matrix[3][1]" -> { b with matrix31 = (PDBjDict.some_float v) }
      | "matrix[3][2]" -> { b with matrix32 = (PDBjDict.some_float v) }
      | "matrix[3][3]" -> { b with matrix33 = (PDBjDict.some_float v) }
      | "vector[1]" -> { b with vector1 = (PDBjDict.some_float v) }
      | "vector[2]" -> { b with vector2 = (PDBjDict.some_float v) }
      | "vector[3]" -> { b with vector3 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("symmetry_operation",  v)) a.symmetry_operation;
      Option.map (fun v -> ("matrix[1][1]", string_of_float v)) a.matrix11;
      Option.map (fun v -> ("matrix[1][2]", string_of_float v)) a.matrix12;
      Option.map (fun v -> ("matrix[1][3]", string_of_float v)) a.matrix13;
      Option.map (fun v -> ("matrix[2][1]", string_of_float v)) a.matrix21;
      Option.map (fun v -> ("matrix[2][2]", string_of_float v)) a.matrix22;
      Option.map (fun v -> ("matrix[2][3]", string_of_float v)) a.matrix23;
      Option.map (fun v -> ("matrix[3][1]", string_of_float v)) a.matrix31;
      Option.map (fun v -> ("matrix[3][2]", string_of_float v)) a.matrix32;
      Option.map (fun v -> ("matrix[3][3]", string_of_float v)) a.matrix33;
      Option.map (fun v -> ("vector[1]", string_of_float v)) a.vector1;
      Option.map (fun v -> ("vector[2]", string_of_float v)) a.vector2;
      Option.map (fun v -> ("vector[3]", string_of_float v)) a.vector3;
    ]

end

module Pdbx_struct_assembly = struct
  type t = {
    method_details: string option;
    oligomeric_details: string option;
    oligomeric_count: int option;
    details: string option;
    id: string option;
  }

  let default = {
    method_details = None;
    oligomeric_details = None;
    oligomeric_count = None;
    details = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "method_details" -> { b with method_details = (Some v) }
      | "oligomeric_details" -> { b with oligomeric_details = (Some v) }
      | "oligomeric_count" -> { b with oligomeric_count = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("method_details",  v)) a.method_details;
      Option.map (fun v -> ("oligomeric_details",  v)) a.oligomeric_details;
      Option.map (fun v -> ("oligomeric_count", string_of_int v)) a.oligomeric_count;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Pdbx_struct_assembly_gen = struct
  type t = {
    entity_inst_id: string option;
    asym_id_list: string option;
    auth_asym_id_list: string option;
    assembly_id: string option;
    oper_expression: string option;
  }

  let default = {
    entity_inst_id = None;
    asym_id_list = None;
    auth_asym_id_list = None;
    assembly_id = None;
    oper_expression = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_inst_id" -> { b with entity_inst_id = (Some v) }
      | "asym_id_list" -> { b with asym_id_list = (Some v) }
      | "auth_asym_id_list" -> { b with auth_asym_id_list = (Some v) }
      | "assembly_id" -> { b with assembly_id = (Some v) }
      | "oper_expression" -> { b with oper_expression = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_inst_id",  v)) a.entity_inst_id;
      Option.map (fun v -> ("asym_id_list",  v)) a.asym_id_list;
      Option.map (fun v -> ("auth_asym_id_list",  v)) a.auth_asym_id_list;
      Option.map (fun v -> ("assembly_id",  v)) a.assembly_id;
      Option.map (fun v -> ("oper_expression",  v)) a.oper_expression;
    ]

end

module Pdbx_struct_asym_gen = struct
  type t = {
    entity_inst_id: string option;
    asym_id: string option;
    oper_expression: string option;
  }

  let default = {
    entity_inst_id = None;
    asym_id = None;
    oper_expression = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_inst_id" -> { b with entity_inst_id = (Some v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | "oper_expression" -> { b with oper_expression = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_inst_id",  v)) a.entity_inst_id;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("oper_expression",  v)) a.oper_expression;
    ]

end

module Pdbx_struct_msym_gen = struct
  type t = {
    entity_inst_id: string option;
    msym_id: string option;
    oper_expression: string option;
  }

  let default = {
    entity_inst_id = None;
    msym_id = None;
    oper_expression = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_inst_id" -> { b with entity_inst_id = (Some v) }
      | "msym_id" -> { b with msym_id = (Some v) }
      | "oper_expression" -> { b with oper_expression = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_inst_id",  v)) a.entity_inst_id;
      Option.map (fun v -> ("msym_id",  v)) a.msym_id;
      Option.map (fun v -> ("oper_expression",  v)) a.oper_expression;
    ]

end

module Pdbx_struct_legacy_oper_list = struct
  type t = {
    id: int option;
    name: string option;
    matrix11: float option;
    matrix12: float option;
    matrix13: float option;
    matrix21: float option;
    matrix22: float option;
    matrix23: float option;
    matrix31: float option;
    matrix32: float option;
    matrix33: float option;
    vector1: float option;
    vector2: float option;
    vector3: float option;
  }

  let default = {
    id = None;
    name = None;
    matrix11 = None;
    matrix12 = None;
    matrix13 = None;
    matrix21 = None;
    matrix22 = None;
    matrix23 = None;
    matrix31 = None;
    matrix32 = None;
    matrix33 = None;
    vector1 = None;
    vector2 = None;
    vector3 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "name" -> { b with name = (Some v) }
      | "matrix[1][1]" -> { b with matrix11 = (PDBjDict.some_float v) }
      | "matrix[1][2]" -> { b with matrix12 = (PDBjDict.some_float v) }
      | "matrix[1][3]" -> { b with matrix13 = (PDBjDict.some_float v) }
      | "matrix[2][1]" -> { b with matrix21 = (PDBjDict.some_float v) }
      | "matrix[2][2]" -> { b with matrix22 = (PDBjDict.some_float v) }
      | "matrix[2][3]" -> { b with matrix23 = (PDBjDict.some_float v) }
      | "matrix[3][1]" -> { b with matrix31 = (PDBjDict.some_float v) }
      | "matrix[3][2]" -> { b with matrix32 = (PDBjDict.some_float v) }
      | "matrix[3][3]" -> { b with matrix33 = (PDBjDict.some_float v) }
      | "vector[1]" -> { b with vector1 = (PDBjDict.some_float v) }
      | "vector[2]" -> { b with vector2 = (PDBjDict.some_float v) }
      | "vector[3]" -> { b with vector3 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("matrix[1][1]", string_of_float v)) a.matrix11;
      Option.map (fun v -> ("matrix[1][2]", string_of_float v)) a.matrix12;
      Option.map (fun v -> ("matrix[1][3]", string_of_float v)) a.matrix13;
      Option.map (fun v -> ("matrix[2][1]", string_of_float v)) a.matrix21;
      Option.map (fun v -> ("matrix[2][2]", string_of_float v)) a.matrix22;
      Option.map (fun v -> ("matrix[2][3]", string_of_float v)) a.matrix23;
      Option.map (fun v -> ("matrix[3][1]", string_of_float v)) a.matrix31;
      Option.map (fun v -> ("matrix[3][2]", string_of_float v)) a.matrix32;
      Option.map (fun v -> ("matrix[3][3]", string_of_float v)) a.matrix33;
      Option.map (fun v -> ("vector[1]", string_of_float v)) a.vector1;
      Option.map (fun v -> ("vector[2]", string_of_float v)) a.vector2;
      Option.map (fun v -> ("vector[3]", string_of_float v)) a.vector3;
    ]

end

module Pdbx_chem_comp_atom_feature = struct
  type t = {
    comp_id: string option;
    atom_id: string option;
    feature_type: string option;
  }

  let default = {
    comp_id = None;
    atom_id = None;
    feature_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "comp_id" -> { b with comp_id = (Some v) }
      | "atom_id" -> { b with atom_id = (Some v) }
      | "feature_type" -> { b with feature_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("atom_id",  v)) a.atom_id;
      Option.map (fun v -> ("feature_type",  v)) a.feature_type;
    ]

end

module Pdbx_reference_molecule_family = struct
  type t = {
    family_prd_id: string option;
    name: string option;
    release_status: string option;
    replaces: string option;
    replaced_by: string option;
  }

  let default = {
    family_prd_id = None;
    name = None;
    release_status = None;
    replaces = None;
    replaced_by = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "family_prd_id" -> { b with family_prd_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "release_status" -> { b with release_status = (Some v) }
      | "replaces" -> { b with replaces = (Some v) }
      | "replaced_by" -> { b with replaced_by = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("family_prd_id",  v)) a.family_prd_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("release_status",  v)) a.release_status;
      Option.map (fun v -> ("replaces",  v)) a.replaces;
      Option.map (fun v -> ("replaced_by",  v)) a.replaced_by;
    ]

end

module Pdbx_reference_molecule_list = struct
  type t = {
    prd_id: string option;
    family_prd_id: string option;
  }

  let default = {
    prd_id = None;
    family_prd_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "family_prd_id" -> { b with family_prd_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("family_prd_id",  v)) a.family_prd_id;
    ]

end

module Pdbx_reference_molecule = struct
  type t = {
    prd_id: string option;
    formula_weight: float option;
    formula: string option;
    type_: string option;
    type_evidence_code: string option;
    class_: string option;
    class_evidence_code: string option;
    name: string option;
    represent_as: string option;
    chem_comp_id: string option;
    compound_details: string option;
    description: string option;
    representative_PDB_id_code: string option;
    release_status: string option;
    replaces: string option;
    replaced_by: string option;
  }

  let default = {
    prd_id = None;
    formula_weight = None;
    formula = None;
    type_ = None;
    type_evidence_code = None;
    class_ = None;
    class_evidence_code = None;
    name = None;
    represent_as = None;
    chem_comp_id = None;
    compound_details = None;
    description = None;
    representative_PDB_id_code = None;
    release_status = None;
    replaces = None;
    replaced_by = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "formula_weight" -> { b with formula_weight = (PDBjDict.some_float v) }
      | "formula" -> { b with formula = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "type_evidence_code" -> { b with type_evidence_code = (Some v) }
      | "class" -> { b with class_ = (Some v) }
      | "class_evidence_code" -> { b with class_evidence_code = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "represent_as" -> { b with represent_as = (Some v) }
      | "chem_comp_id" -> { b with chem_comp_id = (Some v) }
      | "compound_details" -> { b with compound_details = (Some v) }
      | "description" -> { b with description = (Some v) }
      | "representative_PDB_id_code" -> { b with representative_PDB_id_code = (Some v) }
      | "release_status" -> { b with release_status = (Some v) }
      | "replaces" -> { b with replaces = (Some v) }
      | "replaced_by" -> { b with replaced_by = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("formula_weight", string_of_float v)) a.formula_weight;
      Option.map (fun v -> ("formula",  v)) a.formula;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("type_evidence_code",  v)) a.type_evidence_code;
      Option.map (fun v -> ("class",  v)) a.class_;
      Option.map (fun v -> ("class_evidence_code",  v)) a.class_evidence_code;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("represent_as",  v)) a.represent_as;
      Option.map (fun v -> ("chem_comp_id",  v)) a.chem_comp_id;
      Option.map (fun v -> ("compound_details",  v)) a.compound_details;
      Option.map (fun v -> ("description",  v)) a.description;
      Option.map (fun v -> ("representative_PDB_id_code",  v)) a.representative_PDB_id_code;
      Option.map (fun v -> ("release_status",  v)) a.release_status;
      Option.map (fun v -> ("replaces",  v)) a.replaces;
      Option.map (fun v -> ("replaced_by",  v)) a.replaced_by;
    ]

end

module Pdbx_reference_entity_list = struct
  type t = {
    prd_id: string option;
    ref_entity_id: string option;
    type_: string option;
    details: string option;
    component_id: int option;
  }

  let default = {
    prd_id = None;
    ref_entity_id = None;
    type_ = None;
    details = None;
    component_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "ref_entity_id" -> { b with ref_entity_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "component_id" -> { b with component_id = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("ref_entity_id",  v)) a.ref_entity_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("component_id", string_of_int v)) a.component_id;
    ]

end

module Pdbx_reference_entity_nonpoly = struct
  type t = {
    prd_id: string option;
    ref_entity_id: string option;
    details: string option;
    name: string option;
    chem_comp_id: string option;
  }

  let default = {
    prd_id = None;
    ref_entity_id = None;
    details = None;
    name = None;
    chem_comp_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "ref_entity_id" -> { b with ref_entity_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "chem_comp_id" -> { b with chem_comp_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("ref_entity_id",  v)) a.ref_entity_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("chem_comp_id",  v)) a.chem_comp_id;
    ]

end

module Pdbx_reference_entity_link = struct
  type t = {
    link_id: int option;
    prd_id: string option;
    details: string option;
    ref_entity_id_1: string option;
    ref_entity_id_2: string option;
    entity_seq_num_1: int option;
    entity_seq_num_2: int option;
    comp_id_1: string option;
    comp_id_2: string option;
    atom_id_1: string option;
    atom_id_2: string option;
    value_order: string option;
    component_1: int option;
    component_2: int option;
    nonpoly_res_num_1: string option;
    nonpoly_res_num_2: string option;
    link_class: string option;
  }

  let default = {
    link_id = None;
    prd_id = None;
    details = None;
    ref_entity_id_1 = None;
    ref_entity_id_2 = None;
    entity_seq_num_1 = None;
    entity_seq_num_2 = None;
    comp_id_1 = None;
    comp_id_2 = None;
    atom_id_1 = None;
    atom_id_2 = None;
    value_order = None;
    component_1 = None;
    component_2 = None;
    nonpoly_res_num_1 = None;
    nonpoly_res_num_2 = None;
    link_class = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "link_id" -> { b with link_id = (PDBjDict.some_int v) }
      | "prd_id" -> { b with prd_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "ref_entity_id_1" -> { b with ref_entity_id_1 = (Some v) }
      | "ref_entity_id_2" -> { b with ref_entity_id_2 = (Some v) }
      | "entity_seq_num_1" -> { b with entity_seq_num_1 = (PDBjDict.some_int v) }
      | "entity_seq_num_2" -> { b with entity_seq_num_2 = (PDBjDict.some_int v) }
      | "comp_id_1" -> { b with comp_id_1 = (Some v) }
      | "comp_id_2" -> { b with comp_id_2 = (Some v) }
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "value_order" -> { b with value_order = (Some v) }
      | "component_1" -> { b with component_1 = (PDBjDict.some_int v) }
      | "component_2" -> { b with component_2 = (PDBjDict.some_int v) }
      | "nonpoly_res_num_1" -> { b with nonpoly_res_num_1 = (Some v) }
      | "nonpoly_res_num_2" -> { b with nonpoly_res_num_2 = (Some v) }
      | "link_class" -> { b with link_class = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("link_id", string_of_int v)) a.link_id;
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("ref_entity_id_1",  v)) a.ref_entity_id_1;
      Option.map (fun v -> ("ref_entity_id_2",  v)) a.ref_entity_id_2;
      Option.map (fun v -> ("entity_seq_num_1", string_of_int v)) a.entity_seq_num_1;
      Option.map (fun v -> ("entity_seq_num_2", string_of_int v)) a.entity_seq_num_2;
      Option.map (fun v -> ("comp_id_1",  v)) a.comp_id_1;
      Option.map (fun v -> ("comp_id_2",  v)) a.comp_id_2;
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("value_order",  v)) a.value_order;
      Option.map (fun v -> ("component_1", string_of_int v)) a.component_1;
      Option.map (fun v -> ("component_2", string_of_int v)) a.component_2;
      Option.map (fun v -> ("nonpoly_res_num_1",  v)) a.nonpoly_res_num_1;
      Option.map (fun v -> ("nonpoly_res_num_2",  v)) a.nonpoly_res_num_2;
      Option.map (fun v -> ("link_class",  v)) a.link_class;
    ]

end

module Pdbx_reference_entity_poly_link = struct
  type t = {
    link_id: int option;
    prd_id: string option;
    details: string option;
    ref_entity_id: string option;
    component_id: int option;
    entity_seq_num_1: int option;
    entity_seq_num_2: int option;
    comp_id_1: string option;
    comp_id_2: string option;
    atom_id_1: string option;
    atom_id_2: string option;
    insert_code_1: string option;
    insert_code_2: string option;
    value_order: string option;
  }

  let default = {
    link_id = None;
    prd_id = None;
    details = None;
    ref_entity_id = None;
    component_id = None;
    entity_seq_num_1 = None;
    entity_seq_num_2 = None;
    comp_id_1 = None;
    comp_id_2 = None;
    atom_id_1 = None;
    atom_id_2 = None;
    insert_code_1 = None;
    insert_code_2 = None;
    value_order = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "link_id" -> { b with link_id = (PDBjDict.some_int v) }
      | "prd_id" -> { b with prd_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "ref_entity_id" -> { b with ref_entity_id = (Some v) }
      | "component_id" -> { b with component_id = (PDBjDict.some_int v) }
      | "entity_seq_num_1" -> { b with entity_seq_num_1 = (PDBjDict.some_int v) }
      | "entity_seq_num_2" -> { b with entity_seq_num_2 = (PDBjDict.some_int v) }
      | "comp_id_1" -> { b with comp_id_1 = (Some v) }
      | "comp_id_2" -> { b with comp_id_2 = (Some v) }
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "insert_code_1" -> { b with insert_code_1 = (Some v) }
      | "insert_code_2" -> { b with insert_code_2 = (Some v) }
      | "value_order" -> { b with value_order = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("link_id", string_of_int v)) a.link_id;
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("ref_entity_id",  v)) a.ref_entity_id;
      Option.map (fun v -> ("component_id", string_of_int v)) a.component_id;
      Option.map (fun v -> ("entity_seq_num_1", string_of_int v)) a.entity_seq_num_1;
      Option.map (fun v -> ("entity_seq_num_2", string_of_int v)) a.entity_seq_num_2;
      Option.map (fun v -> ("comp_id_1",  v)) a.comp_id_1;
      Option.map (fun v -> ("comp_id_2",  v)) a.comp_id_2;
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("insert_code_1",  v)) a.insert_code_1;
      Option.map (fun v -> ("insert_code_2",  v)) a.insert_code_2;
      Option.map (fun v -> ("value_order",  v)) a.value_order;
    ]

end

module Pdbx_reference_entity_poly = struct
  type t = {
    prd_id: string option;
    ref_entity_id: string option;
    type_: string option;
    db_code: string option;
    db_name: string option;
  }

  let default = {
    prd_id = None;
    ref_entity_id = None;
    type_ = None;
    db_code = None;
    db_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "ref_entity_id" -> { b with ref_entity_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "db_code" -> { b with db_code = (Some v) }
      | "db_name" -> { b with db_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("ref_entity_id",  v)) a.ref_entity_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("db_code",  v)) a.db_code;
      Option.map (fun v -> ("db_name",  v)) a.db_name;
    ]

end

module Pdbx_reference_entity_poly_seq = struct
  type t = {
    prd_id: string option;
    ref_entity_id: string option;
    mon_id: string option;
    parent_mon_id: string option;
    num: int option;
    observed: string option;
    hetero: string option;
  }

  let default = {
    prd_id = None;
    ref_entity_id = None;
    mon_id = None;
    parent_mon_id = None;
    num = None;
    observed = None;
    hetero = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "ref_entity_id" -> { b with ref_entity_id = (Some v) }
      | "mon_id" -> { b with mon_id = (Some v) }
      | "parent_mon_id" -> { b with parent_mon_id = (Some v) }
      | "num" -> { b with num = (PDBjDict.some_int v) }
      | "observed" -> { b with observed = (Some v) }
      | "hetero" -> { b with hetero = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("ref_entity_id",  v)) a.ref_entity_id;
      Option.map (fun v -> ("mon_id",  v)) a.mon_id;
      Option.map (fun v -> ("parent_mon_id",  v)) a.parent_mon_id;
      Option.map (fun v -> ("num", string_of_int v)) a.num;
      Option.map (fun v -> ("observed",  v)) a.observed;
      Option.map (fun v -> ("hetero",  v)) a.hetero;
    ]

end

module Pdbx_reference_entity_sequence = struct
  type t = {
    prd_id: string option;
    ref_entity_id: string option;
    type_: string option;
    nRP_flag: string option;
    one_letter_codes: string option;
  }

  let default = {
    prd_id = None;
    ref_entity_id = None;
    type_ = None;
    nRP_flag = None;
    one_letter_codes = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "ref_entity_id" -> { b with ref_entity_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "NRP_flag" -> { b with nRP_flag = (Some v) }
      | "one_letter_codes" -> { b with one_letter_codes = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("ref_entity_id",  v)) a.ref_entity_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("NRP_flag",  v)) a.nRP_flag;
      Option.map (fun v -> ("one_letter_codes",  v)) a.one_letter_codes;
    ]

end

module Pdbx_reference_entity_src_nat = struct
  type t = {
    prd_id: string option;
    ref_entity_id: string option;
    ordinal: int option;
    organism_scientific: string option;
    strain: string option;
    taxid: string option;
    atcc: string option;
    db_code: string option;
    db_name: string option;
    source: string option;
    source_id: string option;
  }

  let default = {
    prd_id = None;
    ref_entity_id = None;
    ordinal = None;
    organism_scientific = None;
    strain = None;
    taxid = None;
    atcc = None;
    db_code = None;
    db_name = None;
    source = None;
    source_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "ref_entity_id" -> { b with ref_entity_id = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "organism_scientific" -> { b with organism_scientific = (Some v) }
      | "strain" -> { b with strain = (Some v) }
      | "taxid" -> { b with taxid = (Some v) }
      | "atcc" -> { b with atcc = (Some v) }
      | "db_code" -> { b with db_code = (Some v) }
      | "db_name" -> { b with db_name = (Some v) }
      | "source" -> { b with source = (Some v) }
      | "source_id" -> { b with source_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("ref_entity_id",  v)) a.ref_entity_id;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("organism_scientific",  v)) a.organism_scientific;
      Option.map (fun v -> ("strain",  v)) a.strain;
      Option.map (fun v -> ("taxid",  v)) a.taxid;
      Option.map (fun v -> ("atcc",  v)) a.atcc;
      Option.map (fun v -> ("db_code",  v)) a.db_code;
      Option.map (fun v -> ("db_name",  v)) a.db_name;
      Option.map (fun v -> ("source",  v)) a.source;
      Option.map (fun v -> ("source_id",  v)) a.source_id;
    ]

end

module Pdbx_reference_molecule_details = struct
  type t = {
    family_prd_id: string option;
    prd_id: string option;
    ordinal: int option;
    source: string option;
    source_id: string option;
    text: string option;
  }

  let default = {
    family_prd_id = None;
    prd_id = None;
    ordinal = None;
    source = None;
    source_id = None;
    text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "family_prd_id" -> { b with family_prd_id = (Some v) }
      | "prd_id" -> { b with prd_id = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "source" -> { b with source = (Some v) }
      | "source_id" -> { b with source_id = (Some v) }
      | "text" -> { b with text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("family_prd_id",  v)) a.family_prd_id;
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("source",  v)) a.source;
      Option.map (fun v -> ("source_id",  v)) a.source_id;
      Option.map (fun v -> ("text",  v)) a.text;
    ]

end

module Pdbx_reference_molecule_synonyms = struct
  type t = {
    family_prd_id: string option;
    prd_id: string option;
    ordinal: int option;
    name: string option;
    source: string option;
    chem_comp_id: string option;
  }

  let default = {
    family_prd_id = None;
    prd_id = None;
    ordinal = None;
    name = None;
    source = None;
    chem_comp_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "family_prd_id" -> { b with family_prd_id = (Some v) }
      | "prd_id" -> { b with prd_id = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "name" -> { b with name = (Some v) }
      | "source" -> { b with source = (Some v) }
      | "chem_comp_id" -> { b with chem_comp_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("family_prd_id",  v)) a.family_prd_id;
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("source",  v)) a.source;
      Option.map (fun v -> ("chem_comp_id",  v)) a.chem_comp_id;
    ]

end

module Pdbx_reference_entity_subcomponents = struct
  type t = {
    prd_id: string option;
    seq: string option;
    chem_comp_id: string option;
  }

  let default = {
    prd_id = None;
    seq = None;
    chem_comp_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "seq" -> { b with seq = (Some v) }
      | "chem_comp_id" -> { b with chem_comp_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("seq",  v)) a.seq;
      Option.map (fun v -> ("chem_comp_id",  v)) a.chem_comp_id;
    ]

end

module Pdbx_reference_molecule_annotation = struct
  type t = {
    family_prd_id: string option;
    prd_id: string option;
    ordinal: int option;
    text: string option;
    type_: string option;
    support: string option;
    source: string option;
    chem_comp_id: string option;
  }

  let default = {
    family_prd_id = None;
    prd_id = None;
    ordinal = None;
    text = None;
    type_ = None;
    support = None;
    source = None;
    chem_comp_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "family_prd_id" -> { b with family_prd_id = (Some v) }
      | "prd_id" -> { b with prd_id = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "text" -> { b with text = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "support" -> { b with support = (Some v) }
      | "source" -> { b with source = (Some v) }
      | "chem_comp_id" -> { b with chem_comp_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("family_prd_id",  v)) a.family_prd_id;
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("text",  v)) a.text;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("support",  v)) a.support;
      Option.map (fun v -> ("source",  v)) a.source;
      Option.map (fun v -> ("chem_comp_id",  v)) a.chem_comp_id;
    ]

end

module Pdbx_reference_molecule_features = struct
  type t = {
    family_prd_id: string option;
    prd_id: string option;
    ordinal: int option;
    source_ordinal: int option;
    type_: string option;
    value: string option;
    source: string option;
    chem_comp_id: string option;
  }

  let default = {
    family_prd_id = None;
    prd_id = None;
    ordinal = None;
    source_ordinal = None;
    type_ = None;
    value = None;
    source = None;
    chem_comp_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "family_prd_id" -> { b with family_prd_id = (Some v) }
      | "prd_id" -> { b with prd_id = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "source_ordinal" -> { b with source_ordinal = (PDBjDict.some_int v) }
      | "type" -> { b with type_ = (Some v) }
      | "value" -> { b with value = (Some v) }
      | "source" -> { b with source = (Some v) }
      | "chem_comp_id" -> { b with chem_comp_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("family_prd_id",  v)) a.family_prd_id;
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("source_ordinal", string_of_int v)) a.source_ordinal;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("value",  v)) a.value;
      Option.map (fun v -> ("source",  v)) a.source;
      Option.map (fun v -> ("chem_comp_id",  v)) a.chem_comp_id;
    ]

end

module Pdbx_reference_molecule_related_structures = struct
  type t = {
    family_prd_id: string option;
    ordinal: int option;
    db_name: string option;
    db_code: string option;
    db_accession: string option;
    name: string option;
    formula: string option;
    citation_id: string option;
  }

  let default = {
    family_prd_id = None;
    ordinal = None;
    db_name = None;
    db_code = None;
    db_accession = None;
    name = None;
    formula = None;
    citation_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "family_prd_id" -> { b with family_prd_id = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "db_name" -> { b with db_name = (Some v) }
      | "db_code" -> { b with db_code = (Some v) }
      | "db_accession" -> { b with db_accession = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "formula" -> { b with formula = (Some v) }
      | "citation_id" -> { b with citation_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("family_prd_id",  v)) a.family_prd_id;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("db_name",  v)) a.db_name;
      Option.map (fun v -> ("db_code",  v)) a.db_code;
      Option.map (fun v -> ("db_accession",  v)) a.db_accession;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("formula",  v)) a.formula;
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
    ]

end

module Pdbx_struct_group_list = struct
  type t = {
    struct_group_id: string option;
    name: string option;
    type_: string option;
    group_enumeration_type: string option;
    description: string option;
    selection: string option;
    selection_details: string option;
  }

  let default = {
    struct_group_id = None;
    name = None;
    type_ = None;
    group_enumeration_type = None;
    description = None;
    selection = None;
    selection_details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "struct_group_id" -> { b with struct_group_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "group_enumeration_type" -> { b with group_enumeration_type = (Some v) }
      | "description" -> { b with description = (Some v) }
      | "selection" -> { b with selection = (Some v) }
      | "selection_details" -> { b with selection_details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("struct_group_id",  v)) a.struct_group_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("group_enumeration_type",  v)) a.group_enumeration_type;
      Option.map (fun v -> ("description",  v)) a.description;
      Option.map (fun v -> ("selection",  v)) a.selection;
      Option.map (fun v -> ("selection_details",  v)) a.selection_details;
    ]

end

module Pdbx_struct_group_components = struct
  type t = {
    ordinal: int option;
    struct_group_id: string option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    label_alt_id: string option;
  }

  let default = {
    ordinal = None;
    struct_group_id = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    label_alt_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "struct_group_id" -> { b with struct_group_id = (Some v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("struct_group_id",  v)) a.struct_group_id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
    ]

end

module Pdbx_struct_group_component_range = struct
  type t = {
    ordinal: int option;
    struct_group_id: string option;
    pDB_model_num: int option;
    beg_auth_asym_id: string option;
    beg_auth_comp_id: string option;
    beg_auth_seq_id: string option;
    beg_PDB_ins_code: string option;
    beg_label_asym_id: string option;
    beg_label_comp_id: string option;
    beg_label_seq_id: int option;
    beg_label_alt_id: string option;
    end_auth_asym_id: string option;
    end_auth_comp_id: string option;
    end_auth_seq_id: string option;
    end_PDB_ins_code: string option;
    end_label_asym_id: string option;
    end_label_comp_id: string option;
    end_label_seq_id: int option;
    end_label_alt_id: string option;
  }

  let default = {
    ordinal = None;
    struct_group_id = None;
    pDB_model_num = None;
    beg_auth_asym_id = None;
    beg_auth_comp_id = None;
    beg_auth_seq_id = None;
    beg_PDB_ins_code = None;
    beg_label_asym_id = None;
    beg_label_comp_id = None;
    beg_label_seq_id = None;
    beg_label_alt_id = None;
    end_auth_asym_id = None;
    end_auth_comp_id = None;
    end_auth_seq_id = None;
    end_PDB_ins_code = None;
    end_label_asym_id = None;
    end_label_comp_id = None;
    end_label_seq_id = None;
    end_label_alt_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "struct_group_id" -> { b with struct_group_id = (Some v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "beg_auth_asym_id" -> { b with beg_auth_asym_id = (Some v) }
      | "beg_auth_comp_id" -> { b with beg_auth_comp_id = (Some v) }
      | "beg_auth_seq_id" -> { b with beg_auth_seq_id = (Some v) }
      | "beg_PDB_ins_code" -> { b with beg_PDB_ins_code = (Some v) }
      | "beg_label_asym_id" -> { b with beg_label_asym_id = (Some v) }
      | "beg_label_comp_id" -> { b with beg_label_comp_id = (Some v) }
      | "beg_label_seq_id" -> { b with beg_label_seq_id = (PDBjDict.some_int v) }
      | "beg_label_alt_id" -> { b with beg_label_alt_id = (Some v) }
      | "end_auth_asym_id" -> { b with end_auth_asym_id = (Some v) }
      | "end_auth_comp_id" -> { b with end_auth_comp_id = (Some v) }
      | "end_auth_seq_id" -> { b with end_auth_seq_id = (Some v) }
      | "end_PDB_ins_code" -> { b with end_PDB_ins_code = (Some v) }
      | "end_label_asym_id" -> { b with end_label_asym_id = (Some v) }
      | "end_label_comp_id" -> { b with end_label_comp_id = (Some v) }
      | "end_label_seq_id" -> { b with end_label_seq_id = (PDBjDict.some_int v) }
      | "end_label_alt_id" -> { b with end_label_alt_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("struct_group_id",  v)) a.struct_group_id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("beg_auth_asym_id",  v)) a.beg_auth_asym_id;
      Option.map (fun v -> ("beg_auth_comp_id",  v)) a.beg_auth_comp_id;
      Option.map (fun v -> ("beg_auth_seq_id",  v)) a.beg_auth_seq_id;
      Option.map (fun v -> ("beg_PDB_ins_code",  v)) a.beg_PDB_ins_code;
      Option.map (fun v -> ("beg_label_asym_id",  v)) a.beg_label_asym_id;
      Option.map (fun v -> ("beg_label_comp_id",  v)) a.beg_label_comp_id;
      Option.map (fun v -> ("beg_label_seq_id", string_of_int v)) a.beg_label_seq_id;
      Option.map (fun v -> ("beg_label_alt_id",  v)) a.beg_label_alt_id;
      Option.map (fun v -> ("end_auth_asym_id",  v)) a.end_auth_asym_id;
      Option.map (fun v -> ("end_auth_comp_id",  v)) a.end_auth_comp_id;
      Option.map (fun v -> ("end_auth_seq_id",  v)) a.end_auth_seq_id;
      Option.map (fun v -> ("end_PDB_ins_code",  v)) a.end_PDB_ins_code;
      Option.map (fun v -> ("end_label_asym_id",  v)) a.end_label_asym_id;
      Option.map (fun v -> ("end_label_comp_id",  v)) a.end_label_comp_id;
      Option.map (fun v -> ("end_label_seq_id", string_of_int v)) a.end_label_seq_id;
      Option.map (fun v -> ("end_label_alt_id",  v)) a.end_label_alt_id;
    ]

end

module Pdbx_prd_audit = struct
  type t = {
    prd_id: string option;
    date: string option;
    annotator: string option;
    processing_site: string option;
    details: string option;
    action_type: string option;
  }

  let default = {
    prd_id = None;
    date = None;
    annotator = None;
    processing_site = None;
    details = None;
    action_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "annotator" -> { b with annotator = (Some v) }
      | "processing_site" -> { b with processing_site = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "action_type" -> { b with action_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("annotator",  v)) a.annotator;
      Option.map (fun v -> ("processing_site",  v)) a.processing_site;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("action_type",  v)) a.action_type;
    ]

end

module Pdbx_family_prd_audit = struct
  type t = {
    family_prd_id: string option;
    date: string option;
    annotator: string option;
    processing_site: string option;
    details: string option;
    action_type: string option;
  }

  let default = {
    family_prd_id = None;
    date = None;
    annotator = None;
    processing_site = None;
    details = None;
    action_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "family_prd_id" -> { b with family_prd_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "annotator" -> { b with annotator = (Some v) }
      | "processing_site" -> { b with processing_site = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "action_type" -> { b with action_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("family_prd_id",  v)) a.family_prd_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("annotator",  v)) a.annotator;
      Option.map (fun v -> ("processing_site",  v)) a.processing_site;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("action_type",  v)) a.action_type;
    ]

end

module Pdbx_molecule = struct
  type t = {
    prd_id: string option;
    instance_id: int option;
    asym_id: string option;
    linked_entity_id: string option;
  }

  let default = {
    prd_id = None;
    instance_id = None;
    asym_id = None;
    linked_entity_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "instance_id" -> { b with instance_id = (PDBjDict.some_int v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | "linked_entity_id" -> { b with linked_entity_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("instance_id", string_of_int v)) a.instance_id;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("linked_entity_id",  v)) a.linked_entity_id;
    ]

end

module Pdbx_molecule_features = struct
  type t = {
    prd_id: string option;
    class_: string option;
    type_: string option;
    name: string option;
    details: string option;
  }

  let default = {
    prd_id = None;
    class_ = None;
    type_ = None;
    name = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "prd_id" -> { b with prd_id = (Some v) }
      | "class" -> { b with class_ = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
      Option.map (fun v -> ("class",  v)) a.class_;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_family_group_index = struct
  type t = {
    id: string option;
    family_prd_id: string option;
  }

  let default = {
    id = None;
    family_prd_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "family_prd_id" -> { b with family_prd_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("family_prd_id",  v)) a.family_prd_id;
    ]

end

module Pdbx_distant_solvent_atoms = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_atom_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    label_alt_id: string option;
    label_atom_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    neighbor_macromolecule_distance: float option;
    neighbor_ligand_distance: float option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_atom_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    label_alt_id = None;
    label_atom_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    neighbor_macromolecule_distance = None;
    neighbor_ligand_distance = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_atom_id" -> { b with auth_atom_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_atom_id" -> { b with label_atom_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "neighbor_macromolecule_distance" -> { b with neighbor_macromolecule_distance = (PDBjDict.some_float v) }
      | "neighbor_ligand_distance" -> { b with neighbor_ligand_distance = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_atom_id",  v)) a.auth_atom_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_atom_id",  v)) a.label_atom_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("neighbor_macromolecule_distance", string_of_float v)) a.neighbor_macromolecule_distance;
      Option.map (fun v -> ("neighbor_ligand_distance", string_of_float v)) a.neighbor_ligand_distance;
    ]

end

module Pdbx_struct_special_symmetry = struct
  type t = {
    id: int option;
    pDB_model_num: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    pDB_ins_code: string option;
    label_alt_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
  }

  let default = {
    id = None;
    pDB_model_num = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    pDB_ins_code = None;
    label_alt_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "PDB_model_num" -> { b with pDB_model_num = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("PDB_model_num", string_of_int v)) a.pDB_model_num;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
    ]

end

module Pdbx_reference_publication_list = struct
  type t = {
    publication_abbrev: string option;
    aSTM_code_type: string option;
    aSTM_code_value: string option;
    iSSN_code_type: string option;
    iSSN_code_value: string option;
    country: string option;
    start_year: string option;
    end_year: string option;
  }

  let default = {
    publication_abbrev = None;
    aSTM_code_type = None;
    aSTM_code_value = None;
    iSSN_code_type = None;
    iSSN_code_value = None;
    country = None;
    start_year = None;
    end_year = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "publication_abbrev" -> { b with publication_abbrev = (Some v) }
      | "ASTM_code_type" -> { b with aSTM_code_type = (Some v) }
      | "ASTM_code_value" -> { b with aSTM_code_value = (Some v) }
      | "ISSN_code_type" -> { b with iSSN_code_type = (Some v) }
      | "ISSN_code_value" -> { b with iSSN_code_value = (Some v) }
      | "country" -> { b with country = (Some v) }
      | "start_year" -> { b with start_year = (Some v) }
      | "end_year" -> { b with end_year = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("publication_abbrev",  v)) a.publication_abbrev;
      Option.map (fun v -> ("ASTM_code_type",  v)) a.aSTM_code_type;
      Option.map (fun v -> ("ASTM_code_value",  v)) a.aSTM_code_value;
      Option.map (fun v -> ("ISSN_code_type",  v)) a.iSSN_code_type;
      Option.map (fun v -> ("ISSN_code_value",  v)) a.iSSN_code_value;
      Option.map (fun v -> ("country",  v)) a.country;
      Option.map (fun v -> ("start_year",  v)) a.start_year;
      Option.map (fun v -> ("end_year",  v)) a.end_year;
    ]

end

module Pdbx_nmr_assigned_chem_shift_list = struct
  type t = {
    chem_shift_13C_err: float option;
    chem_shift_15N_err: float option;
    chem_shift_19F_err: float option;
    chem_shift_1H_err: float option;
    chem_shift_2H_err: float option;
    chem_shift_31P_err: float option;
    chem_shift_reference_id: int option;
    conditions_id: int option;
    data_file_name: string option;
    details: string option;
    entry_id: string option;
    error_derivation_method: string option;
    id: int option;
    label: string option;
    conditions_label: string option;
  }

  let default = {
    chem_shift_13C_err = None;
    chem_shift_15N_err = None;
    chem_shift_19F_err = None;
    chem_shift_1H_err = None;
    chem_shift_2H_err = None;
    chem_shift_31P_err = None;
    chem_shift_reference_id = None;
    conditions_id = None;
    data_file_name = None;
    details = None;
    entry_id = None;
    error_derivation_method = None;
    id = None;
    label = None;
    conditions_label = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "chem_shift_13C_err" -> { b with chem_shift_13C_err = (PDBjDict.some_float v) }
      | "chem_shift_15N_err" -> { b with chem_shift_15N_err = (PDBjDict.some_float v) }
      | "chem_shift_19F_err" -> { b with chem_shift_19F_err = (PDBjDict.some_float v) }
      | "chem_shift_1H_err" -> { b with chem_shift_1H_err = (PDBjDict.some_float v) }
      | "chem_shift_2H_err" -> { b with chem_shift_2H_err = (PDBjDict.some_float v) }
      | "chem_shift_31P_err" -> { b with chem_shift_31P_err = (PDBjDict.some_float v) }
      | "chem_shift_reference_id" -> { b with chem_shift_reference_id = (PDBjDict.some_int v) }
      | "conditions_id" -> { b with conditions_id = (PDBjDict.some_int v) }
      | "data_file_name" -> { b with data_file_name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "error_derivation_method" -> { b with error_derivation_method = (Some v) }
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "label" -> { b with label = (Some v) }
      | "conditions_label" -> { b with conditions_label = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("chem_shift_13C_err", string_of_float v)) a.chem_shift_13C_err;
      Option.map (fun v -> ("chem_shift_15N_err", string_of_float v)) a.chem_shift_15N_err;
      Option.map (fun v -> ("chem_shift_19F_err", string_of_float v)) a.chem_shift_19F_err;
      Option.map (fun v -> ("chem_shift_1H_err", string_of_float v)) a.chem_shift_1H_err;
      Option.map (fun v -> ("chem_shift_2H_err", string_of_float v)) a.chem_shift_2H_err;
      Option.map (fun v -> ("chem_shift_31P_err", string_of_float v)) a.chem_shift_31P_err;
      Option.map (fun v -> ("chem_shift_reference_id", string_of_int v)) a.chem_shift_reference_id;
      Option.map (fun v -> ("conditions_id", string_of_int v)) a.conditions_id;
      Option.map (fun v -> ("data_file_name",  v)) a.data_file_name;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("error_derivation_method",  v)) a.error_derivation_method;
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("label",  v)) a.label;
      Option.map (fun v -> ("conditions_label",  v)) a.conditions_label;
    ]

end

module Pdbx_nmr_chem_shift_experiment = struct
  type t = {
    assigned_chem_shift_list_id: int option;
    entry_id: string option;
    experiment_id: int option;
    experiment_name: string option;
    sample_state: string option;
    solution_id: int option;
  }

  let default = {
    assigned_chem_shift_list_id = None;
    entry_id = None;
    experiment_id = None;
    experiment_name = None;
    sample_state = None;
    solution_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "assigned_chem_shift_list_id" -> { b with assigned_chem_shift_list_id = (PDBjDict.some_int v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "experiment_id" -> { b with experiment_id = (PDBjDict.some_int v) }
      | "experiment_name" -> { b with experiment_name = (Some v) }
      | "sample_state" -> { b with sample_state = (Some v) }
      | "solution_id" -> { b with solution_id = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("assigned_chem_shift_list_id", string_of_int v)) a.assigned_chem_shift_list_id;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("experiment_id", string_of_int v)) a.experiment_id;
      Option.map (fun v -> ("experiment_name",  v)) a.experiment_name;
      Option.map (fun v -> ("sample_state",  v)) a.sample_state;
      Option.map (fun v -> ("solution_id", string_of_int v)) a.solution_id;
    ]

end

module Pdbx_nmr_chem_shift_ref = struct
  type t = {
    atom_group: string option;
    atom_isotope_number: int option;
    atom_type: string option;
    chem_shift_reference_id: int option;
    chem_shift_units: string option;
    chem_shift_val: float option;
    correction_val: float option;
    entry_id: string option;
    external_ref_axis: string option;
    external_ref_loc: string option;
    external_ref_sample_geometry: string option;
    indirect_shift_ratio: float option;
    mol_common_name: string option;
    rank: string option;
    ref_correction_type: string option;
    ref_method: string option;
    ref_type: string option;
    solvent: string option;
  }

  let default = {
    atom_group = None;
    atom_isotope_number = None;
    atom_type = None;
    chem_shift_reference_id = None;
    chem_shift_units = None;
    chem_shift_val = None;
    correction_val = None;
    entry_id = None;
    external_ref_axis = None;
    external_ref_loc = None;
    external_ref_sample_geometry = None;
    indirect_shift_ratio = None;
    mol_common_name = None;
    rank = None;
    ref_correction_type = None;
    ref_method = None;
    ref_type = None;
    solvent = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_group" -> { b with atom_group = (Some v) }
      | "atom_isotope_number" -> { b with atom_isotope_number = (PDBjDict.some_int v) }
      | "atom_type" -> { b with atom_type = (Some v) }
      | "chem_shift_reference_id" -> { b with chem_shift_reference_id = (PDBjDict.some_int v) }
      | "chem_shift_units" -> { b with chem_shift_units = (Some v) }
      | "chem_shift_val" -> { b with chem_shift_val = (PDBjDict.some_float v) }
      | "correction_val" -> { b with correction_val = (PDBjDict.some_float v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "external_ref_axis" -> { b with external_ref_axis = (Some v) }
      | "external_ref_loc" -> { b with external_ref_loc = (Some v) }
      | "external_ref_sample_geometry" -> { b with external_ref_sample_geometry = (Some v) }
      | "indirect_shift_ratio" -> { b with indirect_shift_ratio = (PDBjDict.some_float v) }
      | "mol_common_name" -> { b with mol_common_name = (Some v) }
      | "rank" -> { b with rank = (Some v) }
      | "ref_correction_type" -> { b with ref_correction_type = (Some v) }
      | "ref_method" -> { b with ref_method = (Some v) }
      | "ref_type" -> { b with ref_type = (Some v) }
      | "solvent" -> { b with solvent = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_group",  v)) a.atom_group;
      Option.map (fun v -> ("atom_isotope_number", string_of_int v)) a.atom_isotope_number;
      Option.map (fun v -> ("atom_type",  v)) a.atom_type;
      Option.map (fun v -> ("chem_shift_reference_id", string_of_int v)) a.chem_shift_reference_id;
      Option.map (fun v -> ("chem_shift_units",  v)) a.chem_shift_units;
      Option.map (fun v -> ("chem_shift_val", string_of_float v)) a.chem_shift_val;
      Option.map (fun v -> ("correction_val", string_of_float v)) a.correction_val;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("external_ref_axis",  v)) a.external_ref_axis;
      Option.map (fun v -> ("external_ref_loc",  v)) a.external_ref_loc;
      Option.map (fun v -> ("external_ref_sample_geometry",  v)) a.external_ref_sample_geometry;
      Option.map (fun v -> ("indirect_shift_ratio", string_of_float v)) a.indirect_shift_ratio;
      Option.map (fun v -> ("mol_common_name",  v)) a.mol_common_name;
      Option.map (fun v -> ("rank",  v)) a.rank;
      Option.map (fun v -> ("ref_correction_type",  v)) a.ref_correction_type;
      Option.map (fun v -> ("ref_method",  v)) a.ref_method;
      Option.map (fun v -> ("ref_type",  v)) a.ref_type;
      Option.map (fun v -> ("solvent",  v)) a.solvent;
    ]

end

module Pdbx_nmr_chem_shift_reference = struct
  type t = {
    carbon_shifts_flag: string option;
    details: string option;
    entry_id: string option;
    id: int option;
    label: string option;
    nitrogen_shifts_flag: string option;
    other_shifts_flag: string option;
    phosphorus_shifts_flag: string option;
    proton_shifts_flag: string option;
  }

  let default = {
    carbon_shifts_flag = None;
    details = None;
    entry_id = None;
    id = None;
    label = None;
    nitrogen_shifts_flag = None;
    other_shifts_flag = None;
    phosphorus_shifts_flag = None;
    proton_shifts_flag = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "carbon_shifts_flag" -> { b with carbon_shifts_flag = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "label" -> { b with label = (Some v) }
      | "nitrogen_shifts_flag" -> { b with nitrogen_shifts_flag = (Some v) }
      | "other_shifts_flag" -> { b with other_shifts_flag = (Some v) }
      | "phosphorus_shifts_flag" -> { b with phosphorus_shifts_flag = (Some v) }
      | "proton_shifts_flag" -> { b with proton_shifts_flag = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("carbon_shifts_flag",  v)) a.carbon_shifts_flag;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("label",  v)) a.label;
      Option.map (fun v -> ("nitrogen_shifts_flag",  v)) a.nitrogen_shifts_flag;
      Option.map (fun v -> ("other_shifts_flag",  v)) a.other_shifts_flag;
      Option.map (fun v -> ("phosphorus_shifts_flag",  v)) a.phosphorus_shifts_flag;
      Option.map (fun v -> ("proton_shifts_flag",  v)) a.proton_shifts_flag;
    ]

end

module Pdbx_nmr_chem_shift_software = struct
  type t = {
    assigned_chem_shift_list_id: int option;
    entry_id: string option;
    software_id: int option;
    software_label: string option;
  }

  let default = {
    assigned_chem_shift_list_id = None;
    entry_id = None;
    software_id = None;
    software_label = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "assigned_chem_shift_list_id" -> { b with assigned_chem_shift_list_id = (PDBjDict.some_int v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "software_id" -> { b with software_id = (PDBjDict.some_int v) }
      | "software_label" -> { b with software_label = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("assigned_chem_shift_list_id", string_of_int v)) a.assigned_chem_shift_list_id;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("software_id", string_of_int v)) a.software_id;
      Option.map (fun v -> ("software_label",  v)) a.software_label;
    ]

end

module Pdbx_nmr_constraint_file = struct
  type t = {
    constraint_filename: string option;
    constraint_number: int option;
    constraint_subtype: string option;
    constraint_type: string option;
    entry_id: string option;
    id: int option;
    software_name: string option;
    software_ordinal: int option;
  }

  let default = {
    constraint_filename = None;
    constraint_number = None;
    constraint_subtype = None;
    constraint_type = None;
    entry_id = None;
    id = None;
    software_name = None;
    software_ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "constraint_filename" -> { b with constraint_filename = (Some v) }
      | "constraint_number" -> { b with constraint_number = (PDBjDict.some_int v) }
      | "constraint_subtype" -> { b with constraint_subtype = (Some v) }
      | "constraint_type" -> { b with constraint_type = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "software_name" -> { b with software_name = (Some v) }
      | "software_ordinal" -> { b with software_ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("constraint_filename",  v)) a.constraint_filename;
      Option.map (fun v -> ("constraint_number", string_of_int v)) a.constraint_number;
      Option.map (fun v -> ("constraint_subtype",  v)) a.constraint_subtype;
      Option.map (fun v -> ("constraint_type",  v)) a.constraint_type;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("software_name",  v)) a.software_name;
      Option.map (fun v -> ("software_ordinal", string_of_int v)) a.software_ordinal;
    ]

end

module Pdbx_nmr_software_task = struct
  type t = {
    entry_id: string option;
    software_ordinal: int option;
    task: string option;
  }

  let default = {
    entry_id = None;
    software_ordinal = None;
    task = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "software_ordinal" -> { b with software_ordinal = (PDBjDict.some_int v) }
      | "task" -> { b with task = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("software_ordinal", string_of_int v)) a.software_ordinal;
      Option.map (fun v -> ("task",  v)) a.task;
    ]

end

module Pdbx_nmr_spectral_dim = struct
  type t = {
    id: int option;
    atom_type: string option;
    atom_isotope_number: int option;
    spectral_region: string option;
    magnetization_linkage_id: int option;
    sweep_width: float option;
    encoding_code: string option;
    encoded_source_dimension_id: int option;
    entry_id: string option;
    spectral_peak_list_id: int option;
    sweep_width_units: string option;
    center_frequency_offset: float option;
    under_sampling_type: string option;
  }

  let default = {
    id = None;
    atom_type = None;
    atom_isotope_number = None;
    spectral_region = None;
    magnetization_linkage_id = None;
    sweep_width = None;
    encoding_code = None;
    encoded_source_dimension_id = None;
    entry_id = None;
    spectral_peak_list_id = None;
    sweep_width_units = None;
    center_frequency_offset = None;
    under_sampling_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "atom_type" -> { b with atom_type = (Some v) }
      | "atom_isotope_number" -> { b with atom_isotope_number = (PDBjDict.some_int v) }
      | "spectral_region" -> { b with spectral_region = (Some v) }
      | "magnetization_linkage_id" -> { b with magnetization_linkage_id = (PDBjDict.some_int v) }
      | "sweep_width" -> { b with sweep_width = (PDBjDict.some_float v) }
      | "encoding_code" -> { b with encoding_code = (Some v) }
      | "encoded_source_dimension_id" -> { b with encoded_source_dimension_id = (PDBjDict.some_int v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "spectral_peak_list_id" -> { b with spectral_peak_list_id = (PDBjDict.some_int v) }
      | "sweep_width_units" -> { b with sweep_width_units = (Some v) }
      | "center_frequency_offset" -> { b with center_frequency_offset = (PDBjDict.some_float v) }
      | "under_sampling_type" -> { b with under_sampling_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("atom_type",  v)) a.atom_type;
      Option.map (fun v -> ("atom_isotope_number", string_of_int v)) a.atom_isotope_number;
      Option.map (fun v -> ("spectral_region",  v)) a.spectral_region;
      Option.map (fun v -> ("magnetization_linkage_id", string_of_int v)) a.magnetization_linkage_id;
      Option.map (fun v -> ("sweep_width", string_of_float v)) a.sweep_width;
      Option.map (fun v -> ("encoding_code",  v)) a.encoding_code;
      Option.map (fun v -> ("encoded_source_dimension_id", string_of_int v)) a.encoded_source_dimension_id;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("spectral_peak_list_id", string_of_int v)) a.spectral_peak_list_id;
      Option.map (fun v -> ("sweep_width_units",  v)) a.sweep_width_units;
      Option.map (fun v -> ("center_frequency_offset", string_of_float v)) a.center_frequency_offset;
      Option.map (fun v -> ("under_sampling_type",  v)) a.under_sampling_type;
    ]

end

module Pdbx_nmr_spectral_peak_list = struct
  type t = {
    entry_id: string option;
    id: int option;
    data_file_name: string option;
    solution_id: int option;
    conditions_id: int option;
    experiment_id: int option;
    number_of_spectral_dimensions: int option;
    details: string option;
    text_data_format: string option;
    label: string option;
    conditions_label: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    data_file_name = None;
    solution_id = None;
    conditions_id = None;
    experiment_id = None;
    number_of_spectral_dimensions = None;
    details = None;
    text_data_format = None;
    label = None;
    conditions_label = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "data_file_name" -> { b with data_file_name = (Some v) }
      | "solution_id" -> { b with solution_id = (PDBjDict.some_int v) }
      | "conditions_id" -> { b with conditions_id = (PDBjDict.some_int v) }
      | "experiment_id" -> { b with experiment_id = (PDBjDict.some_int v) }
      | "number_of_spectral_dimensions" -> { b with number_of_spectral_dimensions = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "text_data_format" -> { b with text_data_format = (Some v) }
      | "label" -> { b with label = (Some v) }
      | "conditions_label" -> { b with conditions_label = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("data_file_name",  v)) a.data_file_name;
      Option.map (fun v -> ("solution_id", string_of_int v)) a.solution_id;
      Option.map (fun v -> ("conditions_id", string_of_int v)) a.conditions_id;
      Option.map (fun v -> ("experiment_id", string_of_int v)) a.experiment_id;
      Option.map (fun v -> ("number_of_spectral_dimensions", string_of_int v)) a.number_of_spectral_dimensions;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("text_data_format",  v)) a.text_data_format;
      Option.map (fun v -> ("label",  v)) a.label;
      Option.map (fun v -> ("conditions_label",  v)) a.conditions_label;
    ]

end

module Pdbx_nmr_spectral_peak_software = struct
  type t = {
    software_id: int option;
    entry_id: string option;
    spectral_peak_list_id: int option;
  }

  let default = {
    software_id = None;
    entry_id = None;
    spectral_peak_list_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "software_id" -> { b with software_id = (PDBjDict.some_int v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "spectral_peak_list_id" -> { b with spectral_peak_list_id = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("software_id", string_of_int v)) a.software_id;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("spectral_peak_list_id", string_of_int v)) a.spectral_peak_list_id;
    ]

end

module Pdbx_nmr_systematic_chem_shift_offset = struct
  type t = {
    type_: string option;
    atom_type: string option;
    atom_isotope_number: int option;
    val_: float option;
    val_err: float option;
    entry_id: string option;
    assigned_chem_shift_list_id: int option;
    ordinal: int option;
  }

  let default = {
    type_ = None;
    atom_type = None;
    atom_isotope_number = None;
    val_ = None;
    val_err = None;
    entry_id = None;
    assigned_chem_shift_list_id = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "type" -> { b with type_ = (Some v) }
      | "atom_type" -> { b with atom_type = (Some v) }
      | "atom_isotope_number" -> { b with atom_isotope_number = (PDBjDict.some_int v) }
      | "val" -> { b with val_ = (PDBjDict.some_float v) }
      | "val_err" -> { b with val_err = (PDBjDict.some_float v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "assigned_chem_shift_list_id" -> { b with assigned_chem_shift_list_id = (PDBjDict.some_int v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("atom_type",  v)) a.atom_type;
      Option.map (fun v -> ("atom_isotope_number", string_of_int v)) a.atom_isotope_number;
      Option.map (fun v -> ("val", string_of_float v)) a.val_;
      Option.map (fun v -> ("val_err", string_of_float v)) a.val_err;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("assigned_chem_shift_list_id", string_of_int v)) a.assigned_chem_shift_list_id;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Pdbx_nmr_upload = struct
  type t = {
    data_file_id: int option;
    data_file_name: string option;
    data_file_category: string option;
    data_file_syntax: string option;
    entry_id: string option;
  }

  let default = {
    data_file_id = None;
    data_file_name = None;
    data_file_category = None;
    data_file_syntax = None;
    entry_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "data_file_id" -> { b with data_file_id = (PDBjDict.some_int v) }
      | "data_file_name" -> { b with data_file_name = (Some v) }
      | "data_file_category" -> { b with data_file_category = (Some v) }
      | "data_file_syntax" -> { b with data_file_syntax = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("data_file_id", string_of_int v)) a.data_file_id;
      Option.map (fun v -> ("data_file_name",  v)) a.data_file_name;
      Option.map (fun v -> ("data_file_category",  v)) a.data_file_category;
      Option.map (fun v -> ("data_file_syntax",  v)) a.data_file_syntax;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
    ]

end

module Pdbx_audit_support = struct
  type t = {
    funding_organization: string option;
    country: string option;
    grant_number: string option;
    ordinal: int option;
  }

  let default = {
    funding_organization = None;
    country = None;
    grant_number = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "funding_organization" -> { b with funding_organization = (Some v) }
      | "country" -> { b with country = (Some v) }
      | "grant_number" -> { b with grant_number = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("funding_organization",  v)) a.funding_organization;
      Option.map (fun v -> ("country",  v)) a.country;
      Option.map (fun v -> ("grant_number",  v)) a.grant_number;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Pdbx_chem_comp_subcomponent_struct_conn = struct
  type t = {
    id: int option;
    type_: string option;
    entity_id_1: int option;
    entity_id_2: int option;
    atom_id_1: string option;
    atom_id_2: string option;
    comp_id_1: string option;
    comp_id_2: string option;
    seq_id_1: int option;
    seq_id_2: int option;
  }

  let default = {
    id = None;
    type_ = None;
    entity_id_1 = None;
    entity_id_2 = None;
    atom_id_1 = None;
    atom_id_2 = None;
    comp_id_1 = None;
    comp_id_2 = None;
    seq_id_1 = None;
    seq_id_2 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "type" -> { b with type_ = (Some v) }
      | "entity_id_1" -> { b with entity_id_1 = (PDBjDict.some_int v) }
      | "entity_id_2" -> { b with entity_id_2 = (PDBjDict.some_int v) }
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "comp_id_1" -> { b with comp_id_1 = (Some v) }
      | "comp_id_2" -> { b with comp_id_2 = (Some v) }
      | "seq_id_1" -> { b with seq_id_1 = (PDBjDict.some_int v) }
      | "seq_id_2" -> { b with seq_id_2 = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("entity_id_1", string_of_int v)) a.entity_id_1;
      Option.map (fun v -> ("entity_id_2", string_of_int v)) a.entity_id_2;
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("comp_id_1",  v)) a.comp_id_1;
      Option.map (fun v -> ("comp_id_2",  v)) a.comp_id_2;
      Option.map (fun v -> ("seq_id_1", string_of_int v)) a.seq_id_1;
      Option.map (fun v -> ("seq_id_2", string_of_int v)) a.seq_id_2;
    ]

end

module Pdbx_chem_comp_subcomponent_entity_list = struct
  type t = {
    id: int option;
    parent_comp_id: string option;
    type_: string option;
    class_: string option;
  }

  let default = {
    id = None;
    parent_comp_id = None;
    type_ = None;
    class_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "parent_comp_id" -> { b with parent_comp_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "class" -> { b with class_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("parent_comp_id",  v)) a.parent_comp_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("class",  v)) a.class_;
    ]

end

module Entity_src_nat = struct
  type t = {
    common_name: string option;
    details: string option;
    entity_id: string option;
    genus: string option;
    species: string option;
    strain: string option;
    tissue: string option;
    tissue_fraction: string option;
    pdbx_organism_scientific: string option;
    pdbx_secretion: string option;
    pdbx_fragment: string option;
    pdbx_variant: string option;
    pdbx_cell_line: string option;
    pdbx_atcc: string option;
    pdbx_cellular_location: string option;
    pdbx_organ: string option;
    pdbx_organelle: string option;
    pdbx_cell: string option;
    pdbx_plasmid_name: string option;
    pdbx_plasmid_details: string option;
    pdbx_ncbi_taxonomy_id: string option;
    pdbx_src_id: int option;
    pdbx_alt_source_flag: string option;
    pdbx_beg_seq_num: int option;
    pdbx_end_seq_num: int option;
    pdbx_culture_collection: string option;
  }

  let default = {
    common_name = None;
    details = None;
    entity_id = None;
    genus = None;
    species = None;
    strain = None;
    tissue = None;
    tissue_fraction = None;
    pdbx_organism_scientific = None;
    pdbx_secretion = None;
    pdbx_fragment = None;
    pdbx_variant = None;
    pdbx_cell_line = None;
    pdbx_atcc = None;
    pdbx_cellular_location = None;
    pdbx_organ = None;
    pdbx_organelle = None;
    pdbx_cell = None;
    pdbx_plasmid_name = None;
    pdbx_plasmid_details = None;
    pdbx_ncbi_taxonomy_id = None;
    pdbx_src_id = None;
    pdbx_alt_source_flag = None;
    pdbx_beg_seq_num = None;
    pdbx_end_seq_num = None;
    pdbx_culture_collection = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "common_name" -> { b with common_name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "genus" -> { b with genus = (Some v) }
      | "species" -> { b with species = (Some v) }
      | "strain" -> { b with strain = (Some v) }
      | "tissue" -> { b with tissue = (Some v) }
      | "tissue_fraction" -> { b with tissue_fraction = (Some v) }
      | "pdbx_organism_scientific" -> { b with pdbx_organism_scientific = (Some v) }
      | "pdbx_secretion" -> { b with pdbx_secretion = (Some v) }
      | "pdbx_fragment" -> { b with pdbx_fragment = (Some v) }
      | "pdbx_variant" -> { b with pdbx_variant = (Some v) }
      | "pdbx_cell_line" -> { b with pdbx_cell_line = (Some v) }
      | "pdbx_atcc" -> { b with pdbx_atcc = (Some v) }
      | "pdbx_cellular_location" -> { b with pdbx_cellular_location = (Some v) }
      | "pdbx_organ" -> { b with pdbx_organ = (Some v) }
      | "pdbx_organelle" -> { b with pdbx_organelle = (Some v) }
      | "pdbx_cell" -> { b with pdbx_cell = (Some v) }
      | "pdbx_plasmid_name" -> { b with pdbx_plasmid_name = (Some v) }
      | "pdbx_plasmid_details" -> { b with pdbx_plasmid_details = (Some v) }
      | "pdbx_ncbi_taxonomy_id" -> { b with pdbx_ncbi_taxonomy_id = (Some v) }
      | "pdbx_src_id" -> { b with pdbx_src_id = (PDBjDict.some_int v) }
      | "pdbx_alt_source_flag" -> { b with pdbx_alt_source_flag = (Some v) }
      | "pdbx_beg_seq_num" -> { b with pdbx_beg_seq_num = (PDBjDict.some_int v) }
      | "pdbx_end_seq_num" -> { b with pdbx_end_seq_num = (PDBjDict.some_int v) }
      | "pdbx_culture_collection" -> { b with pdbx_culture_collection = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("common_name",  v)) a.common_name;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("genus",  v)) a.genus;
      Option.map (fun v -> ("species",  v)) a.species;
      Option.map (fun v -> ("strain",  v)) a.strain;
      Option.map (fun v -> ("tissue",  v)) a.tissue;
      Option.map (fun v -> ("tissue_fraction",  v)) a.tissue_fraction;
      Option.map (fun v -> ("pdbx_organism_scientific",  v)) a.pdbx_organism_scientific;
      Option.map (fun v -> ("pdbx_secretion",  v)) a.pdbx_secretion;
      Option.map (fun v -> ("pdbx_fragment",  v)) a.pdbx_fragment;
      Option.map (fun v -> ("pdbx_variant",  v)) a.pdbx_variant;
      Option.map (fun v -> ("pdbx_cell_line",  v)) a.pdbx_cell_line;
      Option.map (fun v -> ("pdbx_atcc",  v)) a.pdbx_atcc;
      Option.map (fun v -> ("pdbx_cellular_location",  v)) a.pdbx_cellular_location;
      Option.map (fun v -> ("pdbx_organ",  v)) a.pdbx_organ;
      Option.map (fun v -> ("pdbx_organelle",  v)) a.pdbx_organelle;
      Option.map (fun v -> ("pdbx_cell",  v)) a.pdbx_cell;
      Option.map (fun v -> ("pdbx_plasmid_name",  v)) a.pdbx_plasmid_name;
      Option.map (fun v -> ("pdbx_plasmid_details",  v)) a.pdbx_plasmid_details;
      Option.map (fun v -> ("pdbx_ncbi_taxonomy_id",  v)) a.pdbx_ncbi_taxonomy_id;
      Option.map (fun v -> ("pdbx_src_id", string_of_int v)) a.pdbx_src_id;
      Option.map (fun v -> ("pdbx_alt_source_flag",  v)) a.pdbx_alt_source_flag;
      Option.map (fun v -> ("pdbx_beg_seq_num", string_of_int v)) a.pdbx_beg_seq_num;
      Option.map (fun v -> ("pdbx_end_seq_num", string_of_int v)) a.pdbx_end_seq_num;
      Option.map (fun v -> ("pdbx_culture_collection",  v)) a.pdbx_culture_collection;
    ]

end

module Entity_src_gen = struct
  type t = {
    entity_id: string option;
    gene_src_common_name: string option;
    gene_src_details: string option;
    gene_src_genus: string option;
    gene_src_species: string option;
    gene_src_strain: string option;
    gene_src_tissue: string option;
    gene_src_tissue_fraction: string option;
    host_org_genus: string option;
    host_org_species: string option;
    pdbx_gene_src_fragment: string option;
    pdbx_gene_src_gene: string option;
    pdbx_gene_src_scientific_name: string option;
    pdbx_gene_src_variant: string option;
    pdbx_gene_src_cell_line: string option;
    pdbx_gene_src_atcc: string option;
    pdbx_gene_src_organ: string option;
    pdbx_gene_src_organelle: string option;
    pdbx_gene_src_plasmid: string option;
    pdbx_gene_src_plasmid_name: string option;
    pdbx_gene_src_cell: string option;
    pdbx_gene_src_cellular_location: string option;
    pdbx_host_org_gene: string option;
    pdbx_host_org_organ: string option;
    pdbx_host_org_organelle: string option;
    pdbx_host_org_cellular_location: string option;
    pdbx_host_org_strain: string option;
    pdbx_host_org_tissue_fraction: string option;
    pdbx_description: string option;
    host_org_common_name: string option;
    host_org_details: string option;
    host_org_strain: string option;
    plasmid_details: string option;
    plasmid_name: string option;
    pdbx_host_org_variant: string option;
    pdbx_host_org_cell_line: string option;
    pdbx_host_org_atcc: string option;
    pdbx_host_org_culture_collection: string option;
    pdbx_host_org_cell: string option;
    pdbx_host_org_scientific_name: string option;
    pdbx_host_org_tissue: string option;
    pdbx_host_org_vector: string option;
    pdbx_host_org_vector_type: string option;
    expression_system_id: string option;
    gene_src_dev_stage: string option;
    start_construct_id: string option;
    pdbx_gene_src_ncbi_taxonomy_id: string option;
    pdbx_host_org_ncbi_taxonomy_id: string option;
    pdbx_src_id: int option;
    pdbx_alt_source_flag: string option;
    pdbx_seq_type: string option;
    pdbx_beg_seq_num: int option;
    pdbx_end_seq_num: int option;
    pdbx_gene_src_culture_collection: string option;
  }

  let default = {
    entity_id = None;
    gene_src_common_name = None;
    gene_src_details = None;
    gene_src_genus = None;
    gene_src_species = None;
    gene_src_strain = None;
    gene_src_tissue = None;
    gene_src_tissue_fraction = None;
    host_org_genus = None;
    host_org_species = None;
    pdbx_gene_src_fragment = None;
    pdbx_gene_src_gene = None;
    pdbx_gene_src_scientific_name = None;
    pdbx_gene_src_variant = None;
    pdbx_gene_src_cell_line = None;
    pdbx_gene_src_atcc = None;
    pdbx_gene_src_organ = None;
    pdbx_gene_src_organelle = None;
    pdbx_gene_src_plasmid = None;
    pdbx_gene_src_plasmid_name = None;
    pdbx_gene_src_cell = None;
    pdbx_gene_src_cellular_location = None;
    pdbx_host_org_gene = None;
    pdbx_host_org_organ = None;
    pdbx_host_org_organelle = None;
    pdbx_host_org_cellular_location = None;
    pdbx_host_org_strain = None;
    pdbx_host_org_tissue_fraction = None;
    pdbx_description = None;
    host_org_common_name = None;
    host_org_details = None;
    host_org_strain = None;
    plasmid_details = None;
    plasmid_name = None;
    pdbx_host_org_variant = None;
    pdbx_host_org_cell_line = None;
    pdbx_host_org_atcc = None;
    pdbx_host_org_culture_collection = None;
    pdbx_host_org_cell = None;
    pdbx_host_org_scientific_name = None;
    pdbx_host_org_tissue = None;
    pdbx_host_org_vector = None;
    pdbx_host_org_vector_type = None;
    expression_system_id = None;
    gene_src_dev_stage = None;
    start_construct_id = None;
    pdbx_gene_src_ncbi_taxonomy_id = None;
    pdbx_host_org_ncbi_taxonomy_id = None;
    pdbx_src_id = None;
    pdbx_alt_source_flag = None;
    pdbx_seq_type = None;
    pdbx_beg_seq_num = None;
    pdbx_end_seq_num = None;
    pdbx_gene_src_culture_collection = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "gene_src_common_name" -> { b with gene_src_common_name = (Some v) }
      | "gene_src_details" -> { b with gene_src_details = (Some v) }
      | "gene_src_genus" -> { b with gene_src_genus = (Some v) }
      | "gene_src_species" -> { b with gene_src_species = (Some v) }
      | "gene_src_strain" -> { b with gene_src_strain = (Some v) }
      | "gene_src_tissue" -> { b with gene_src_tissue = (Some v) }
      | "gene_src_tissue_fraction" -> { b with gene_src_tissue_fraction = (Some v) }
      | "host_org_genus" -> { b with host_org_genus = (Some v) }
      | "host_org_species" -> { b with host_org_species = (Some v) }
      | "pdbx_gene_src_fragment" -> { b with pdbx_gene_src_fragment = (Some v) }
      | "pdbx_gene_src_gene" -> { b with pdbx_gene_src_gene = (Some v) }
      | "pdbx_gene_src_scientific_name" -> { b with pdbx_gene_src_scientific_name = (Some v) }
      | "pdbx_gene_src_variant" -> { b with pdbx_gene_src_variant = (Some v) }
      | "pdbx_gene_src_cell_line" -> { b with pdbx_gene_src_cell_line = (Some v) }
      | "pdbx_gene_src_atcc" -> { b with pdbx_gene_src_atcc = (Some v) }
      | "pdbx_gene_src_organ" -> { b with pdbx_gene_src_organ = (Some v) }
      | "pdbx_gene_src_organelle" -> { b with pdbx_gene_src_organelle = (Some v) }
      | "pdbx_gene_src_plasmid" -> { b with pdbx_gene_src_plasmid = (Some v) }
      | "pdbx_gene_src_plasmid_name" -> { b with pdbx_gene_src_plasmid_name = (Some v) }
      | "pdbx_gene_src_cell" -> { b with pdbx_gene_src_cell = (Some v) }
      | "pdbx_gene_src_cellular_location" -> { b with pdbx_gene_src_cellular_location = (Some v) }
      | "pdbx_host_org_gene" -> { b with pdbx_host_org_gene = (Some v) }
      | "pdbx_host_org_organ" -> { b with pdbx_host_org_organ = (Some v) }
      | "pdbx_host_org_organelle" -> { b with pdbx_host_org_organelle = (Some v) }
      | "pdbx_host_org_cellular_location" -> { b with pdbx_host_org_cellular_location = (Some v) }
      | "pdbx_host_org_strain" -> { b with pdbx_host_org_strain = (Some v) }
      | "pdbx_host_org_tissue_fraction" -> { b with pdbx_host_org_tissue_fraction = (Some v) }
      | "pdbx_description" -> { b with pdbx_description = (Some v) }
      | "host_org_common_name" -> { b with host_org_common_name = (Some v) }
      | "host_org_details" -> { b with host_org_details = (Some v) }
      | "host_org_strain" -> { b with host_org_strain = (Some v) }
      | "plasmid_details" -> { b with plasmid_details = (Some v) }
      | "plasmid_name" -> { b with plasmid_name = (Some v) }
      | "pdbx_host_org_variant" -> { b with pdbx_host_org_variant = (Some v) }
      | "pdbx_host_org_cell_line" -> { b with pdbx_host_org_cell_line = (Some v) }
      | "pdbx_host_org_atcc" -> { b with pdbx_host_org_atcc = (Some v) }
      | "pdbx_host_org_culture_collection" -> { b with pdbx_host_org_culture_collection = (Some v) }
      | "pdbx_host_org_cell" -> { b with pdbx_host_org_cell = (Some v) }
      | "pdbx_host_org_scientific_name" -> { b with pdbx_host_org_scientific_name = (Some v) }
      | "pdbx_host_org_tissue" -> { b with pdbx_host_org_tissue = (Some v) }
      | "pdbx_host_org_vector" -> { b with pdbx_host_org_vector = (Some v) }
      | "pdbx_host_org_vector_type" -> { b with pdbx_host_org_vector_type = (Some v) }
      | "expression_system_id" -> { b with expression_system_id = (Some v) }
      | "gene_src_dev_stage" -> { b with gene_src_dev_stage = (Some v) }
      | "start_construct_id" -> { b with start_construct_id = (Some v) }
      | "pdbx_gene_src_ncbi_taxonomy_id" -> { b with pdbx_gene_src_ncbi_taxonomy_id = (Some v) }
      | "pdbx_host_org_ncbi_taxonomy_id" -> { b with pdbx_host_org_ncbi_taxonomy_id = (Some v) }
      | "pdbx_src_id" -> { b with pdbx_src_id = (PDBjDict.some_int v) }
      | "pdbx_alt_source_flag" -> { b with pdbx_alt_source_flag = (Some v) }
      | "pdbx_seq_type" -> { b with pdbx_seq_type = (Some v) }
      | "pdbx_beg_seq_num" -> { b with pdbx_beg_seq_num = (PDBjDict.some_int v) }
      | "pdbx_end_seq_num" -> { b with pdbx_end_seq_num = (PDBjDict.some_int v) }
      | "pdbx_gene_src_culture_collection" -> { b with pdbx_gene_src_culture_collection = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("gene_src_common_name",  v)) a.gene_src_common_name;
      Option.map (fun v -> ("gene_src_details",  v)) a.gene_src_details;
      Option.map (fun v -> ("gene_src_genus",  v)) a.gene_src_genus;
      Option.map (fun v -> ("gene_src_species",  v)) a.gene_src_species;
      Option.map (fun v -> ("gene_src_strain",  v)) a.gene_src_strain;
      Option.map (fun v -> ("gene_src_tissue",  v)) a.gene_src_tissue;
      Option.map (fun v -> ("gene_src_tissue_fraction",  v)) a.gene_src_tissue_fraction;
      Option.map (fun v -> ("host_org_genus",  v)) a.host_org_genus;
      Option.map (fun v -> ("host_org_species",  v)) a.host_org_species;
      Option.map (fun v -> ("pdbx_gene_src_fragment",  v)) a.pdbx_gene_src_fragment;
      Option.map (fun v -> ("pdbx_gene_src_gene",  v)) a.pdbx_gene_src_gene;
      Option.map (fun v -> ("pdbx_gene_src_scientific_name",  v)) a.pdbx_gene_src_scientific_name;
      Option.map (fun v -> ("pdbx_gene_src_variant",  v)) a.pdbx_gene_src_variant;
      Option.map (fun v -> ("pdbx_gene_src_cell_line",  v)) a.pdbx_gene_src_cell_line;
      Option.map (fun v -> ("pdbx_gene_src_atcc",  v)) a.pdbx_gene_src_atcc;
      Option.map (fun v -> ("pdbx_gene_src_organ",  v)) a.pdbx_gene_src_organ;
      Option.map (fun v -> ("pdbx_gene_src_organelle",  v)) a.pdbx_gene_src_organelle;
      Option.map (fun v -> ("pdbx_gene_src_plasmid",  v)) a.pdbx_gene_src_plasmid;
      Option.map (fun v -> ("pdbx_gene_src_plasmid_name",  v)) a.pdbx_gene_src_plasmid_name;
      Option.map (fun v -> ("pdbx_gene_src_cell",  v)) a.pdbx_gene_src_cell;
      Option.map (fun v -> ("pdbx_gene_src_cellular_location",  v)) a.pdbx_gene_src_cellular_location;
      Option.map (fun v -> ("pdbx_host_org_gene",  v)) a.pdbx_host_org_gene;
      Option.map (fun v -> ("pdbx_host_org_organ",  v)) a.pdbx_host_org_organ;
      Option.map (fun v -> ("pdbx_host_org_organelle",  v)) a.pdbx_host_org_organelle;
      Option.map (fun v -> ("pdbx_host_org_cellular_location",  v)) a.pdbx_host_org_cellular_location;
      Option.map (fun v -> ("pdbx_host_org_strain",  v)) a.pdbx_host_org_strain;
      Option.map (fun v -> ("pdbx_host_org_tissue_fraction",  v)) a.pdbx_host_org_tissue_fraction;
      Option.map (fun v -> ("pdbx_description",  v)) a.pdbx_description;
      Option.map (fun v -> ("host_org_common_name",  v)) a.host_org_common_name;
      Option.map (fun v -> ("host_org_details",  v)) a.host_org_details;
      Option.map (fun v -> ("host_org_strain",  v)) a.host_org_strain;
      Option.map (fun v -> ("plasmid_details",  v)) a.plasmid_details;
      Option.map (fun v -> ("plasmid_name",  v)) a.plasmid_name;
      Option.map (fun v -> ("pdbx_host_org_variant",  v)) a.pdbx_host_org_variant;
      Option.map (fun v -> ("pdbx_host_org_cell_line",  v)) a.pdbx_host_org_cell_line;
      Option.map (fun v -> ("pdbx_host_org_atcc",  v)) a.pdbx_host_org_atcc;
      Option.map (fun v -> ("pdbx_host_org_culture_collection",  v)) a.pdbx_host_org_culture_collection;
      Option.map (fun v -> ("pdbx_host_org_cell",  v)) a.pdbx_host_org_cell;
      Option.map (fun v -> ("pdbx_host_org_scientific_name",  v)) a.pdbx_host_org_scientific_name;
      Option.map (fun v -> ("pdbx_host_org_tissue",  v)) a.pdbx_host_org_tissue;
      Option.map (fun v -> ("pdbx_host_org_vector",  v)) a.pdbx_host_org_vector;
      Option.map (fun v -> ("pdbx_host_org_vector_type",  v)) a.pdbx_host_org_vector_type;
      Option.map (fun v -> ("expression_system_id",  v)) a.expression_system_id;
      Option.map (fun v -> ("gene_src_dev_stage",  v)) a.gene_src_dev_stage;
      Option.map (fun v -> ("start_construct_id",  v)) a.start_construct_id;
      Option.map (fun v -> ("pdbx_gene_src_ncbi_taxonomy_id",  v)) a.pdbx_gene_src_ncbi_taxonomy_id;
      Option.map (fun v -> ("pdbx_host_org_ncbi_taxonomy_id",  v)) a.pdbx_host_org_ncbi_taxonomy_id;
      Option.map (fun v -> ("pdbx_src_id", string_of_int v)) a.pdbx_src_id;
      Option.map (fun v -> ("pdbx_alt_source_flag",  v)) a.pdbx_alt_source_flag;
      Option.map (fun v -> ("pdbx_seq_type",  v)) a.pdbx_seq_type;
      Option.map (fun v -> ("pdbx_beg_seq_num", string_of_int v)) a.pdbx_beg_seq_num;
      Option.map (fun v -> ("pdbx_end_seq_num", string_of_int v)) a.pdbx_end_seq_num;
      Option.map (fun v -> ("pdbx_gene_src_culture_collection",  v)) a.pdbx_gene_src_culture_collection;
    ]

end

module Pdbx_entity_src_syn = struct
  type t = {
    details: string option;
    organism_scientific: string option;
    organism_common_name: string option;
    strain: string option;
    ncbi_taxonomy_id: string option;
    entity_id: string option;
    pdbx_src_id: int option;
    pdbx_alt_source_flag: string option;
    pdbx_beg_seq_num: int option;
    pdbx_end_seq_num: int option;
  }

  let default = {
    details = None;
    organism_scientific = None;
    organism_common_name = None;
    strain = None;
    ncbi_taxonomy_id = None;
    entity_id = None;
    pdbx_src_id = None;
    pdbx_alt_source_flag = None;
    pdbx_beg_seq_num = None;
    pdbx_end_seq_num = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "organism_scientific" -> { b with organism_scientific = (Some v) }
      | "organism_common_name" -> { b with organism_common_name = (Some v) }
      | "strain" -> { b with strain = (Some v) }
      | "ncbi_taxonomy_id" -> { b with ncbi_taxonomy_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "pdbx_src_id" -> { b with pdbx_src_id = (PDBjDict.some_int v) }
      | "pdbx_alt_source_flag" -> { b with pdbx_alt_source_flag = (Some v) }
      | "pdbx_beg_seq_num" -> { b with pdbx_beg_seq_num = (PDBjDict.some_int v) }
      | "pdbx_end_seq_num" -> { b with pdbx_end_seq_num = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("organism_scientific",  v)) a.organism_scientific;
      Option.map (fun v -> ("organism_common_name",  v)) a.organism_common_name;
      Option.map (fun v -> ("strain",  v)) a.strain;
      Option.map (fun v -> ("ncbi_taxonomy_id",  v)) a.ncbi_taxonomy_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("pdbx_src_id", string_of_int v)) a.pdbx_src_id;
      Option.map (fun v -> ("pdbx_alt_source_flag",  v)) a.pdbx_alt_source_flag;
      Option.map (fun v -> ("pdbx_beg_seq_num", string_of_int v)) a.pdbx_beg_seq_num;
      Option.map (fun v -> ("pdbx_end_seq_num", string_of_int v)) a.pdbx_end_seq_num;
    ]

end

module Pdbx_entity_poly_comp_link_list = struct
  type t = {
    link_id: int option;
    details: string option;
    entity_id: string option;
    entity_comp_num_1: int option;
    entity_comp_num_2: int option;
    comp_id_1: string option;
    comp_id_2: string option;
    atom_id_1: string option;
    leaving_atom_id_1: string option;
    atom_stereo_config_1: string option;
    atom_id_2: string option;
    leaving_atom_id_2: string option;
    atom_stereo_config_2: string option;
    value_order: string option;
  }

  let default = {
    link_id = None;
    details = None;
    entity_id = None;
    entity_comp_num_1 = None;
    entity_comp_num_2 = None;
    comp_id_1 = None;
    comp_id_2 = None;
    atom_id_1 = None;
    leaving_atom_id_1 = None;
    atom_stereo_config_1 = None;
    atom_id_2 = None;
    leaving_atom_id_2 = None;
    atom_stereo_config_2 = None;
    value_order = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "link_id" -> { b with link_id = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "entity_comp_num_1" -> { b with entity_comp_num_1 = (PDBjDict.some_int v) }
      | "entity_comp_num_2" -> { b with entity_comp_num_2 = (PDBjDict.some_int v) }
      | "comp_id_1" -> { b with comp_id_1 = (Some v) }
      | "comp_id_2" -> { b with comp_id_2 = (Some v) }
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "leaving_atom_id_1" -> { b with leaving_atom_id_1 = (Some v) }
      | "atom_stereo_config_1" -> { b with atom_stereo_config_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "leaving_atom_id_2" -> { b with leaving_atom_id_2 = (Some v) }
      | "atom_stereo_config_2" -> { b with atom_stereo_config_2 = (Some v) }
      | "value_order" -> { b with value_order = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("link_id", string_of_int v)) a.link_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("entity_comp_num_1", string_of_int v)) a.entity_comp_num_1;
      Option.map (fun v -> ("entity_comp_num_2", string_of_int v)) a.entity_comp_num_2;
      Option.map (fun v -> ("comp_id_1",  v)) a.comp_id_1;
      Option.map (fun v -> ("comp_id_2",  v)) a.comp_id_2;
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("leaving_atom_id_1",  v)) a.leaving_atom_id_1;
      Option.map (fun v -> ("atom_stereo_config_1",  v)) a.atom_stereo_config_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("leaving_atom_id_2",  v)) a.leaving_atom_id_2;
      Option.map (fun v -> ("atom_stereo_config_2",  v)) a.atom_stereo_config_2;
      Option.map (fun v -> ("value_order",  v)) a.value_order;
    ]

end

module Pdbx_linked_entity = struct
  type t = {
    linked_entity_id: string option;
    type_: string option;
    class_: string option;
    name: string option;
    description: string option;
    prd_id: string option;
  }

  let default = {
    linked_entity_id = None;
    type_ = None;
    class_ = None;
    name = None;
    description = None;
    prd_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "linked_entity_id" -> { b with linked_entity_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "class" -> { b with class_ = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "description" -> { b with description = (Some v) }
      | "prd_id" -> { b with prd_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("linked_entity_id",  v)) a.linked_entity_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("class",  v)) a.class_;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("description",  v)) a.description;
      Option.map (fun v -> ("prd_id",  v)) a.prd_id;
    ]

end

module Pdbx_linked_entity_instance_list = struct
  type t = {
    linked_entity_id: string option;
    instance_id: int option;
    asym_id: string option;
  }

  let default = {
    linked_entity_id = None;
    instance_id = None;
    asym_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "linked_entity_id" -> { b with linked_entity_id = (Some v) }
      | "instance_id" -> { b with instance_id = (PDBjDict.some_int v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("linked_entity_id",  v)) a.linked_entity_id;
      Option.map (fun v -> ("instance_id", string_of_int v)) a.instance_id;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
    ]

end

module Pdbx_linked_entity_list = struct
  type t = {
    linked_entity_id: string option;
    entity_id: string option;
    component_id: int option;
    details: string option;
  }

  let default = {
    linked_entity_id = None;
    entity_id = None;
    component_id = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "linked_entity_id" -> { b with linked_entity_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "component_id" -> { b with component_id = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("linked_entity_id",  v)) a.linked_entity_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("component_id", string_of_int v)) a.component_id;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_linked_entity_link_list = struct
  type t = {
    link_id: int option;
    linked_entity_id: string option;
    details: string option;
    entity_id_1: string option;
    entity_id_2: string option;
    entity_seq_num_1: int option;
    entity_seq_num_2: int option;
    comp_id_1: string option;
    comp_id_2: string option;
    atom_id_1: string option;
    atom_id_2: string option;
    value_order: string option;
    component_1: int option;
    component_2: int option;
    link_class: string option;
  }

  let default = {
    link_id = None;
    linked_entity_id = None;
    details = None;
    entity_id_1 = None;
    entity_id_2 = None;
    entity_seq_num_1 = None;
    entity_seq_num_2 = None;
    comp_id_1 = None;
    comp_id_2 = None;
    atom_id_1 = None;
    atom_id_2 = None;
    value_order = None;
    component_1 = None;
    component_2 = None;
    link_class = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "link_id" -> { b with link_id = (PDBjDict.some_int v) }
      | "linked_entity_id" -> { b with linked_entity_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "entity_id_1" -> { b with entity_id_1 = (Some v) }
      | "entity_id_2" -> { b with entity_id_2 = (Some v) }
      | "entity_seq_num_1" -> { b with entity_seq_num_1 = (PDBjDict.some_int v) }
      | "entity_seq_num_2" -> { b with entity_seq_num_2 = (PDBjDict.some_int v) }
      | "comp_id_1" -> { b with comp_id_1 = (Some v) }
      | "comp_id_2" -> { b with comp_id_2 = (Some v) }
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "value_order" -> { b with value_order = (Some v) }
      | "component_1" -> { b with component_1 = (PDBjDict.some_int v) }
      | "component_2" -> { b with component_2 = (PDBjDict.some_int v) }
      | "link_class" -> { b with link_class = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("link_id", string_of_int v)) a.link_id;
      Option.map (fun v -> ("linked_entity_id",  v)) a.linked_entity_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entity_id_1",  v)) a.entity_id_1;
      Option.map (fun v -> ("entity_id_2",  v)) a.entity_id_2;
      Option.map (fun v -> ("entity_seq_num_1", string_of_int v)) a.entity_seq_num_1;
      Option.map (fun v -> ("entity_seq_num_2", string_of_int v)) a.entity_seq_num_2;
      Option.map (fun v -> ("comp_id_1",  v)) a.comp_id_1;
      Option.map (fun v -> ("comp_id_2",  v)) a.comp_id_2;
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("value_order",  v)) a.value_order;
      Option.map (fun v -> ("component_1", string_of_int v)) a.component_1;
      Option.map (fun v -> ("component_2", string_of_int v)) a.component_2;
      Option.map (fun v -> ("link_class",  v)) a.link_class;
    ]

end

module Pdbx_entity_descriptor = struct
  type t = {
    entity_id: string option;
    descriptor: string option;
    type_: string option;
    program: string option;
    program_version: string option;
    ordinal: int option;
  }

  let default = {
    entity_id = None;
    descriptor = None;
    type_ = None;
    program = None;
    program_version = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "descriptor" -> { b with descriptor = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "program" -> { b with program = (Some v) }
      | "program_version" -> { b with program_version = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("descriptor",  v)) a.descriptor;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("program",  v)) a.program;
      Option.map (fun v -> ("program_version",  v)) a.program_version;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Pdbx_reference_linked_entity = struct
  type t = {
    id: int option;
    class_: string option;
    name: string option;
    taxonomy_id: string option;
    taxonomy_class: string option;
    link_to_entity_type: string option;
    link_to_comp_id: string option;
    link_from_entity_type: string option;
  }

  let default = {
    id = None;
    class_ = None;
    name = None;
    taxonomy_id = None;
    taxonomy_class = None;
    link_to_entity_type = None;
    link_to_comp_id = None;
    link_from_entity_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "class" -> { b with class_ = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "taxonomy_id" -> { b with taxonomy_id = (Some v) }
      | "taxonomy_class" -> { b with taxonomy_class = (Some v) }
      | "link_to_entity_type" -> { b with link_to_entity_type = (Some v) }
      | "link_to_comp_id" -> { b with link_to_comp_id = (Some v) }
      | "link_from_entity_type" -> { b with link_from_entity_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("class",  v)) a.class_;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("taxonomy_id",  v)) a.taxonomy_id;
      Option.map (fun v -> ("taxonomy_class",  v)) a.taxonomy_class;
      Option.map (fun v -> ("link_to_entity_type",  v)) a.link_to_entity_type;
      Option.map (fun v -> ("link_to_comp_id",  v)) a.link_to_comp_id;
      Option.map (fun v -> ("link_from_entity_type",  v)) a.link_from_entity_type;
    ]

end

module Pdbx_reference_linked_entity_comp_list = struct
  type t = {
    linked_entity_id: int option;
    list_id: int option;
    name: string option;
    comp_id: string option;
  }

  let default = {
    linked_entity_id = None;
    list_id = None;
    name = None;
    comp_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "linked_entity_id" -> { b with linked_entity_id = (PDBjDict.some_int v) }
      | "list_id" -> { b with list_id = (PDBjDict.some_int v) }
      | "name" -> { b with name = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("linked_entity_id", string_of_int v)) a.linked_entity_id;
      Option.map (fun v -> ("list_id", string_of_int v)) a.list_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
    ]

end

module Pdbx_reference_linked_entity_comp_link = struct
  type t = {
    linked_entity_id: int option;
    link_id: int option;
    list_id_1: int option;
    list_id_2: int option;
    details: string option;
    comp_id_1: string option;
    comp_id_2: string option;
    atom_id_1: string option;
    atom_id_2: string option;
    leaving_atom_id_1: string option;
    atom_stereo_config_1: string option;
    leaving_atom_id_2: string option;
    atom_stereo_config_2: string option;
    value_order: string option;
  }

  let default = {
    linked_entity_id = None;
    link_id = None;
    list_id_1 = None;
    list_id_2 = None;
    details = None;
    comp_id_1 = None;
    comp_id_2 = None;
    atom_id_1 = None;
    atom_id_2 = None;
    leaving_atom_id_1 = None;
    atom_stereo_config_1 = None;
    leaving_atom_id_2 = None;
    atom_stereo_config_2 = None;
    value_order = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "linked_entity_id" -> { b with linked_entity_id = (PDBjDict.some_int v) }
      | "link_id" -> { b with link_id = (PDBjDict.some_int v) }
      | "list_id_1" -> { b with list_id_1 = (PDBjDict.some_int v) }
      | "list_id_2" -> { b with list_id_2 = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "comp_id_1" -> { b with comp_id_1 = (Some v) }
      | "comp_id_2" -> { b with comp_id_2 = (Some v) }
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "leaving_atom_id_1" -> { b with leaving_atom_id_1 = (Some v) }
      | "atom_stereo_config_1" -> { b with atom_stereo_config_1 = (Some v) }
      | "leaving_atom_id_2" -> { b with leaving_atom_id_2 = (Some v) }
      | "atom_stereo_config_2" -> { b with atom_stereo_config_2 = (Some v) }
      | "value_order" -> { b with value_order = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("linked_entity_id", string_of_int v)) a.linked_entity_id;
      Option.map (fun v -> ("link_id", string_of_int v)) a.link_id;
      Option.map (fun v -> ("list_id_1", string_of_int v)) a.list_id_1;
      Option.map (fun v -> ("list_id_2", string_of_int v)) a.list_id_2;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("comp_id_1",  v)) a.comp_id_1;
      Option.map (fun v -> ("comp_id_2",  v)) a.comp_id_2;
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("leaving_atom_id_1",  v)) a.leaving_atom_id_1;
      Option.map (fun v -> ("atom_stereo_config_1",  v)) a.atom_stereo_config_1;
      Option.map (fun v -> ("leaving_atom_id_2",  v)) a.leaving_atom_id_2;
      Option.map (fun v -> ("atom_stereo_config_2",  v)) a.atom_stereo_config_2;
      Option.map (fun v -> ("value_order",  v)) a.value_order;
    ]

end

module Pdbx_reference_linked_entity_link = struct
  type t = {
    linked_entity_id: int option;
    link_id: int option;
    from_list_id: int option;
    details: string option;
    to_comp_id: string option;
    from_comp_id: string option;
    to_atom_id: string option;
    from_atom_id: string option;
    from_leaving_atom_id: string option;
    from_atom_stereo_config: string option;
    value_order: string option;
  }

  let default = {
    linked_entity_id = None;
    link_id = None;
    from_list_id = None;
    details = None;
    to_comp_id = None;
    from_comp_id = None;
    to_atom_id = None;
    from_atom_id = None;
    from_leaving_atom_id = None;
    from_atom_stereo_config = None;
    value_order = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "linked_entity_id" -> { b with linked_entity_id = (PDBjDict.some_int v) }
      | "link_id" -> { b with link_id = (PDBjDict.some_int v) }
      | "from_list_id" -> { b with from_list_id = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "to_comp_id" -> { b with to_comp_id = (Some v) }
      | "from_comp_id" -> { b with from_comp_id = (Some v) }
      | "to_atom_id" -> { b with to_atom_id = (Some v) }
      | "from_atom_id" -> { b with from_atom_id = (Some v) }
      | "from_leaving_atom_id" -> { b with from_leaving_atom_id = (Some v) }
      | "from_atom_stereo_config" -> { b with from_atom_stereo_config = (Some v) }
      | "value_order" -> { b with value_order = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("linked_entity_id", string_of_int v)) a.linked_entity_id;
      Option.map (fun v -> ("link_id", string_of_int v)) a.link_id;
      Option.map (fun v -> ("from_list_id", string_of_int v)) a.from_list_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("to_comp_id",  v)) a.to_comp_id;
      Option.map (fun v -> ("from_comp_id",  v)) a.from_comp_id;
      Option.map (fun v -> ("to_atom_id",  v)) a.to_atom_id;
      Option.map (fun v -> ("from_atom_id",  v)) a.from_atom_id;
      Option.map (fun v -> ("from_leaving_atom_id",  v)) a.from_leaving_atom_id;
      Option.map (fun v -> ("from_atom_stereo_config",  v)) a.from_atom_stereo_config;
      Option.map (fun v -> ("value_order",  v)) a.value_order;
    ]

end

module Pdbx_related_exp_data_set = struct
  type t = {
    ordinal: int option;
    data_reference: string option;
    metadata_reference: string option;
    data_set_type: string option;
    details: string option;
  }

  let default = {
    ordinal = None;
    data_reference = None;
    metadata_reference = None;
    data_set_type = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "data_reference" -> { b with data_reference = (Some v) }
      | "metadata_reference" -> { b with metadata_reference = (Some v) }
      | "data_set_type" -> { b with data_set_type = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("data_reference",  v)) a.data_reference;
      Option.map (fun v -> ("metadata_reference",  v)) a.metadata_reference;
      Option.map (fun v -> ("data_set_type",  v)) a.data_set_type;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_database_status_history = struct
  type t = {
    entry_id: string option;
    ordinal: string option;
    date_begin: string option;
    date_end: string option;
    status_code: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    ordinal = None;
    date_begin = None;
    date_end = None;
    status_code = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "ordinal" -> { b with ordinal = (Some v) }
      | "date_begin" -> { b with date_begin = (Some v) }
      | "date_end" -> { b with date_end = (Some v) }
      | "status_code" -> { b with status_code = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("ordinal",  v)) a.ordinal;
      Option.map (fun v -> ("date_begin",  v)) a.date_begin;
      Option.map (fun v -> ("date_end",  v)) a.date_end;
      Option.map (fun v -> ("status_code",  v)) a.status_code;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Em_assembly = struct
  type t = {
    id: string option;
    entry_id: string option;
    name: string option;
    aggregation_state: string option;
    composition: string option;
    num_components: int option;
    mol_wt_exp: float option;
    mol_wt_theo: float option;
    mol_wt_method: string option;
    details: string option;
  }

  let default = {
    id = None;
    entry_id = None;
    name = None;
    aggregation_state = None;
    composition = None;
    num_components = None;
    mol_wt_exp = None;
    mol_wt_theo = None;
    mol_wt_method = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "aggregation_state" -> { b with aggregation_state = (Some v) }
      | "composition" -> { b with composition = (Some v) }
      | "num_components" -> { b with num_components = (PDBjDict.some_int v) }
      | "mol_wt_exp" -> { b with mol_wt_exp = (PDBjDict.some_float v) }
      | "mol_wt_theo" -> { b with mol_wt_theo = (PDBjDict.some_float v) }
      | "mol_wt_method" -> { b with mol_wt_method = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("aggregation_state",  v)) a.aggregation_state;
      Option.map (fun v -> ("composition",  v)) a.composition;
      Option.map (fun v -> ("num_components", string_of_int v)) a.num_components;
      Option.map (fun v -> ("mol_wt_exp", string_of_float v)) a.mol_wt_exp;
      Option.map (fun v -> ("mol_wt_theo", string_of_float v)) a.mol_wt_theo;
      Option.map (fun v -> ("mol_wt_method",  v)) a.mol_wt_method;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Em_entity_assembly = struct
  type t = {
    id: string option;
    assembly_id: string option;
    parent_id: string option;
    source: string option;
    type_: string option;
    name: string option;
    details: string option;
    go_id: string option;
    ipr_id: string option;
    synonym: string option;
    number_of_copies: int option;
    oligomeric_details: string option;
    entity_id_list: string option;
    ebi_organism_scientific: string option;
    ebi_organism_common: string option;
    ebi_strain: string option;
    ebi_tissue: string option;
    ebi_cell: string option;
    ebi_organelle: string option;
    ebi_cellular_location: string option;
    ebi_engineered: string option;
    ebi_expression_system: string option;
    ebi_expression_system_plasmid: string option;
    mutant_flag: string option;
  }

  let default = {
    id = None;
    assembly_id = None;
    parent_id = None;
    source = None;
    type_ = None;
    name = None;
    details = None;
    go_id = None;
    ipr_id = None;
    synonym = None;
    number_of_copies = None;
    oligomeric_details = None;
    entity_id_list = None;
    ebi_organism_scientific = None;
    ebi_organism_common = None;
    ebi_strain = None;
    ebi_tissue = None;
    ebi_cell = None;
    ebi_organelle = None;
    ebi_cellular_location = None;
    ebi_engineered = None;
    ebi_expression_system = None;
    ebi_expression_system_plasmid = None;
    mutant_flag = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "assembly_id" -> { b with assembly_id = (Some v) }
      | "parent_id" -> { b with parent_id = (Some v) }
      | "source" -> { b with source = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "go_id" -> { b with go_id = (Some v) }
      | "ipr_id" -> { b with ipr_id = (Some v) }
      | "synonym" -> { b with synonym = (Some v) }
      | "number_of_copies" -> { b with number_of_copies = (PDBjDict.some_int v) }
      | "oligomeric_details" -> { b with oligomeric_details = (Some v) }
      | "entity_id_list" -> { b with entity_id_list = (Some v) }
      | "ebi_organism_scientific" -> { b with ebi_organism_scientific = (Some v) }
      | "ebi_organism_common" -> { b with ebi_organism_common = (Some v) }
      | "ebi_strain" -> { b with ebi_strain = (Some v) }
      | "ebi_tissue" -> { b with ebi_tissue = (Some v) }
      | "ebi_cell" -> { b with ebi_cell = (Some v) }
      | "ebi_organelle" -> { b with ebi_organelle = (Some v) }
      | "ebi_cellular_location" -> { b with ebi_cellular_location = (Some v) }
      | "ebi_engineered" -> { b with ebi_engineered = (Some v) }
      | "ebi_expression_system" -> { b with ebi_expression_system = (Some v) }
      | "ebi_expression_system_plasmid" -> { b with ebi_expression_system_plasmid = (Some v) }
      | "mutant_flag" -> { b with mutant_flag = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("assembly_id",  v)) a.assembly_id;
      Option.map (fun v -> ("parent_id",  v)) a.parent_id;
      Option.map (fun v -> ("source",  v)) a.source;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("go_id",  v)) a.go_id;
      Option.map (fun v -> ("ipr_id",  v)) a.ipr_id;
      Option.map (fun v -> ("synonym",  v)) a.synonym;
      Option.map (fun v -> ("number_of_copies", string_of_int v)) a.number_of_copies;
      Option.map (fun v -> ("oligomeric_details",  v)) a.oligomeric_details;
      Option.map (fun v -> ("entity_id_list",  v)) a.entity_id_list;
      Option.map (fun v -> ("ebi_organism_scientific",  v)) a.ebi_organism_scientific;
      Option.map (fun v -> ("ebi_organism_common",  v)) a.ebi_organism_common;
      Option.map (fun v -> ("ebi_strain",  v)) a.ebi_strain;
      Option.map (fun v -> ("ebi_tissue",  v)) a.ebi_tissue;
      Option.map (fun v -> ("ebi_cell",  v)) a.ebi_cell;
      Option.map (fun v -> ("ebi_organelle",  v)) a.ebi_organelle;
      Option.map (fun v -> ("ebi_cellular_location",  v)) a.ebi_cellular_location;
      Option.map (fun v -> ("ebi_engineered",  v)) a.ebi_engineered;
      Option.map (fun v -> ("ebi_expression_system",  v)) a.ebi_expression_system;
      Option.map (fun v -> ("ebi_expression_system_plasmid",  v)) a.ebi_expression_system_plasmid;
      Option.map (fun v -> ("mutant_flag",  v)) a.mutant_flag;
    ]

end

module Em_virus_entity = struct
  type t = {
    id: string option;
    virus_host_category: string option;
    virus_host_species: string option;
    virus_host_growth_cell: string option;
    virus_type: string option;
    virus_isolate: string option;
    ictvdb_id: string option;
    entity_assembly_id: string option;
    enveloped: string option;
    empty: string option;
    details: string option;
  }

  let default = {
    id = None;
    virus_host_category = None;
    virus_host_species = None;
    virus_host_growth_cell = None;
    virus_type = None;
    virus_isolate = None;
    ictvdb_id = None;
    entity_assembly_id = None;
    enveloped = None;
    empty = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "virus_host_category" -> { b with virus_host_category = (Some v) }
      | "virus_host_species" -> { b with virus_host_species = (Some v) }
      | "virus_host_growth_cell" -> { b with virus_host_growth_cell = (Some v) }
      | "virus_type" -> { b with virus_type = (Some v) }
      | "virus_isolate" -> { b with virus_isolate = (Some v) }
      | "ictvdb_id" -> { b with ictvdb_id = (Some v) }
      | "entity_assembly_id" -> { b with entity_assembly_id = (Some v) }
      | "enveloped" -> { b with enveloped = (Some v) }
      | "empty" -> { b with empty = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("virus_host_category",  v)) a.virus_host_category;
      Option.map (fun v -> ("virus_host_species",  v)) a.virus_host_species;
      Option.map (fun v -> ("virus_host_growth_cell",  v)) a.virus_host_growth_cell;
      Option.map (fun v -> ("virus_type",  v)) a.virus_type;
      Option.map (fun v -> ("virus_isolate",  v)) a.virus_isolate;
      Option.map (fun v -> ("ictvdb_id",  v)) a.ictvdb_id;
      Option.map (fun v -> ("entity_assembly_id",  v)) a.entity_assembly_id;
      Option.map (fun v -> ("enveloped",  v)) a.enveloped;
      Option.map (fun v -> ("empty",  v)) a.empty;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Em_sample_preparation = struct
  type t = {
    entry_id: string option;
    id: string option;
    ph: float option;
    buffer_id: string option;
    sample_concentration: float option;
    _2d_crystal_grow_id: string option;
    support_id: string option;
    entity_assembly_id: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    ph = None;
    buffer_id = None;
    sample_concentration = None;
    _2d_crystal_grow_id = None;
    support_id = None;
    entity_assembly_id = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "ph" -> { b with ph = (PDBjDict.some_float v) }
      | "buffer_id" -> { b with buffer_id = (Some v) }
      | "sample_concentration" -> { b with sample_concentration = (PDBjDict.some_float v) }
      | "2d_crystal_grow_id" -> { b with _2d_crystal_grow_id = (Some v) }
      | "support_id" -> { b with support_id = (Some v) }
      | "entity_assembly_id" -> { b with entity_assembly_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("ph", string_of_float v)) a.ph;
      Option.map (fun v -> ("buffer_id",  v)) a.buffer_id;
      Option.map (fun v -> ("sample_concentration", string_of_float v)) a.sample_concentration;
      Option.map (fun v -> ("2d_crystal_grow_id",  v)) a._2d_crystal_grow_id;
      Option.map (fun v -> ("support_id",  v)) a.support_id;
      Option.map (fun v -> ("entity_assembly_id",  v)) a.entity_assembly_id;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Em_sample_support = struct
  type t = {
    id: string option;
    film_material: string option;
    method_: string option;
    grid_material: string option;
    grid_mesh_size: int option;
    grid_type: string option;
    pretreatment: string option;
    details: string option;
    specimen_id: string option;
    citation_id: string option;
  }

  let default = {
    id = None;
    film_material = None;
    method_ = None;
    grid_material = None;
    grid_mesh_size = None;
    grid_type = None;
    pretreatment = None;
    details = None;
    specimen_id = None;
    citation_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "film_material" -> { b with film_material = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "grid_material" -> { b with grid_material = (Some v) }
      | "grid_mesh_size" -> { b with grid_mesh_size = (PDBjDict.some_int v) }
      | "grid_type" -> { b with grid_type = (Some v) }
      | "pretreatment" -> { b with pretreatment = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "specimen_id" -> { b with specimen_id = (Some v) }
      | "citation_id" -> { b with citation_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("film_material",  v)) a.film_material;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("grid_material",  v)) a.grid_material;
      Option.map (fun v -> ("grid_mesh_size", string_of_int v)) a.grid_mesh_size;
      Option.map (fun v -> ("grid_type",  v)) a.grid_type;
      Option.map (fun v -> ("pretreatment",  v)) a.pretreatment;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("specimen_id",  v)) a.specimen_id;
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
    ]

end

module Em_buffer = struct
  type t = {
    id: string option;
    specimen_id: string option;
    name: string option;
    details: string option;
    pH: float option;
  }

  let default = {
    id = None;
    specimen_id = None;
    name = None;
    details = None;
    pH = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "specimen_id" -> { b with specimen_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "pH" -> { b with pH = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("specimen_id",  v)) a.specimen_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("pH", string_of_float v)) a.pH;
    ]

end

module Em_vitrification = struct
  type t = {
    entry_id: string option;
    id: string option;
    sample_preparation_id: string option;
    specimen_id: string option;
    cryogen_name: string option;
    humidity: float option;
    temp: float option;
    chamber_temperature: float option;
    instrument: string option;
    method_: string option;
    time_resolved_state: string option;
    citation_id: string option;
    details: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    sample_preparation_id = None;
    specimen_id = None;
    cryogen_name = None;
    humidity = None;
    temp = None;
    chamber_temperature = None;
    instrument = None;
    method_ = None;
    time_resolved_state = None;
    citation_id = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "sample_preparation_id" -> { b with sample_preparation_id = (Some v) }
      | "specimen_id" -> { b with specimen_id = (Some v) }
      | "cryogen_name" -> { b with cryogen_name = (Some v) }
      | "humidity" -> { b with humidity = (PDBjDict.some_float v) }
      | "temp" -> { b with temp = (PDBjDict.some_float v) }
      | "chamber_temperature" -> { b with chamber_temperature = (PDBjDict.some_float v) }
      | "instrument" -> { b with instrument = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "time_resolved_state" -> { b with time_resolved_state = (Some v) }
      | "citation_id" -> { b with citation_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("sample_preparation_id",  v)) a.sample_preparation_id;
      Option.map (fun v -> ("specimen_id",  v)) a.specimen_id;
      Option.map (fun v -> ("cryogen_name",  v)) a.cryogen_name;
      Option.map (fun v -> ("humidity", string_of_float v)) a.humidity;
      Option.map (fun v -> ("temp", string_of_float v)) a.temp;
      Option.map (fun v -> ("chamber_temperature", string_of_float v)) a.chamber_temperature;
      Option.map (fun v -> ("instrument",  v)) a.instrument;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("time_resolved_state",  v)) a.time_resolved_state;
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Em_imaging = struct
  type t = {
    entry_id: string option;
    id: string option;
    astigmatism: string option;
    electron_beam_tilt_params: string option;
    residual_tilt: float option;
    sample_support_id: string option;
    detector_id: string option;
    scans_id: string option;
    microscope_id: string option;
    microscope_model: string option;
    specimen_holder_type: string option;
    specimen_holder_model: string option;
    details: string option;
    date: string option;
    accelerating_voltage: int option;
    illumination_mode: string option;
    mode: string option;
    nominal_cs: float option;
    nominal_defocus_min: float option;
    nominal_defocus_max: float option;
    calibrated_defocus_min: float option;
    calibrated_defocus_max: float option;
    tilt_angle_min: float option;
    tilt_angle_max: float option;
    nominal_magnification: int option;
    calibrated_magnification: int option;
    electron_source: string option;
    electron_dose: float option;
    energy_filter: string option;
    energy_window: string option;
    citation_id: string option;
    temperature: float option;
    detector_distance: float option;
    recording_temperature_minimum: float option;
    recording_temperature_maximum: float option;
    alignment_procedure: string option;
    c2_aperture_diameter: float option;
    specimen_id: string option;
    cryogen: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    astigmatism = None;
    electron_beam_tilt_params = None;
    residual_tilt = None;
    sample_support_id = None;
    detector_id = None;
    scans_id = None;
    microscope_id = None;
    microscope_model = None;
    specimen_holder_type = None;
    specimen_holder_model = None;
    details = None;
    date = None;
    accelerating_voltage = None;
    illumination_mode = None;
    mode = None;
    nominal_cs = None;
    nominal_defocus_min = None;
    nominal_defocus_max = None;
    calibrated_defocus_min = None;
    calibrated_defocus_max = None;
    tilt_angle_min = None;
    tilt_angle_max = None;
    nominal_magnification = None;
    calibrated_magnification = None;
    electron_source = None;
    electron_dose = None;
    energy_filter = None;
    energy_window = None;
    citation_id = None;
    temperature = None;
    detector_distance = None;
    recording_temperature_minimum = None;
    recording_temperature_maximum = None;
    alignment_procedure = None;
    c2_aperture_diameter = None;
    specimen_id = None;
    cryogen = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "astigmatism" -> { b with astigmatism = (Some v) }
      | "electron_beam_tilt_params" -> { b with electron_beam_tilt_params = (Some v) }
      | "residual_tilt" -> { b with residual_tilt = (PDBjDict.some_float v) }
      | "sample_support_id" -> { b with sample_support_id = (Some v) }
      | "detector_id" -> { b with detector_id = (Some v) }
      | "scans_id" -> { b with scans_id = (Some v) }
      | "microscope_id" -> { b with microscope_id = (Some v) }
      | "microscope_model" -> { b with microscope_model = (Some v) }
      | "specimen_holder_type" -> { b with specimen_holder_type = (Some v) }
      | "specimen_holder_model" -> { b with specimen_holder_model = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "accelerating_voltage" -> { b with accelerating_voltage = (PDBjDict.some_int v) }
      | "illumination_mode" -> { b with illumination_mode = (Some v) }
      | "mode" -> { b with mode = (Some v) }
      | "nominal_cs" -> { b with nominal_cs = (PDBjDict.some_float v) }
      | "nominal_defocus_min" -> { b with nominal_defocus_min = (PDBjDict.some_float v) }
      | "nominal_defocus_max" -> { b with nominal_defocus_max = (PDBjDict.some_float v) }
      | "calibrated_defocus_min" -> { b with calibrated_defocus_min = (PDBjDict.some_float v) }
      | "calibrated_defocus_max" -> { b with calibrated_defocus_max = (PDBjDict.some_float v) }
      | "tilt_angle_min" -> { b with tilt_angle_min = (PDBjDict.some_float v) }
      | "tilt_angle_max" -> { b with tilt_angle_max = (PDBjDict.some_float v) }
      | "nominal_magnification" -> { b with nominal_magnification = (PDBjDict.some_int v) }
      | "calibrated_magnification" -> { b with calibrated_magnification = (PDBjDict.some_int v) }
      | "electron_source" -> { b with electron_source = (Some v) }
      | "electron_dose" -> { b with electron_dose = (PDBjDict.some_float v) }
      | "energy_filter" -> { b with energy_filter = (Some v) }
      | "energy_window" -> { b with energy_window = (Some v) }
      | "citation_id" -> { b with citation_id = (Some v) }
      | "temperature" -> { b with temperature = (PDBjDict.some_float v) }
      | "detector_distance" -> { b with detector_distance = (PDBjDict.some_float v) }
      | "recording_temperature_minimum" -> { b with recording_temperature_minimum = (PDBjDict.some_float v) }
      | "recording_temperature_maximum" -> { b with recording_temperature_maximum = (PDBjDict.some_float v) }
      | "alignment_procedure" -> { b with alignment_procedure = (Some v) }
      | "c2_aperture_diameter" -> { b with c2_aperture_diameter = (PDBjDict.some_float v) }
      | "specimen_id" -> { b with specimen_id = (Some v) }
      | "cryogen" -> { b with cryogen = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("astigmatism",  v)) a.astigmatism;
      Option.map (fun v -> ("electron_beam_tilt_params",  v)) a.electron_beam_tilt_params;
      Option.map (fun v -> ("residual_tilt", string_of_float v)) a.residual_tilt;
      Option.map (fun v -> ("sample_support_id",  v)) a.sample_support_id;
      Option.map (fun v -> ("detector_id",  v)) a.detector_id;
      Option.map (fun v -> ("scans_id",  v)) a.scans_id;
      Option.map (fun v -> ("microscope_id",  v)) a.microscope_id;
      Option.map (fun v -> ("microscope_model",  v)) a.microscope_model;
      Option.map (fun v -> ("specimen_holder_type",  v)) a.specimen_holder_type;
      Option.map (fun v -> ("specimen_holder_model",  v)) a.specimen_holder_model;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("accelerating_voltage", string_of_int v)) a.accelerating_voltage;
      Option.map (fun v -> ("illumination_mode",  v)) a.illumination_mode;
      Option.map (fun v -> ("mode",  v)) a.mode;
      Option.map (fun v -> ("nominal_cs", string_of_float v)) a.nominal_cs;
      Option.map (fun v -> ("nominal_defocus_min", string_of_float v)) a.nominal_defocus_min;
      Option.map (fun v -> ("nominal_defocus_max", string_of_float v)) a.nominal_defocus_max;
      Option.map (fun v -> ("calibrated_defocus_min", string_of_float v)) a.calibrated_defocus_min;
      Option.map (fun v -> ("calibrated_defocus_max", string_of_float v)) a.calibrated_defocus_max;
      Option.map (fun v -> ("tilt_angle_min", string_of_float v)) a.tilt_angle_min;
      Option.map (fun v -> ("tilt_angle_max", string_of_float v)) a.tilt_angle_max;
      Option.map (fun v -> ("nominal_magnification", string_of_int v)) a.nominal_magnification;
      Option.map (fun v -> ("calibrated_magnification", string_of_int v)) a.calibrated_magnification;
      Option.map (fun v -> ("electron_source",  v)) a.electron_source;
      Option.map (fun v -> ("electron_dose", string_of_float v)) a.electron_dose;
      Option.map (fun v -> ("energy_filter",  v)) a.energy_filter;
      Option.map (fun v -> ("energy_window",  v)) a.energy_window;
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
      Option.map (fun v -> ("temperature", string_of_float v)) a.temperature;
      Option.map (fun v -> ("detector_distance", string_of_float v)) a.detector_distance;
      Option.map (fun v -> ("recording_temperature_minimum", string_of_float v)) a.recording_temperature_minimum;
      Option.map (fun v -> ("recording_temperature_maximum", string_of_float v)) a.recording_temperature_maximum;
      Option.map (fun v -> ("alignment_procedure",  v)) a.alignment_procedure;
      Option.map (fun v -> ("c2_aperture_diameter", string_of_float v)) a.c2_aperture_diameter;
      Option.map (fun v -> ("specimen_id",  v)) a.specimen_id;
      Option.map (fun v -> ("cryogen",  v)) a.cryogen;
    ]

end

module Em_detector = struct
  type t = {
    entry_id: string option;
    id: string option;
    details: string option;
    type_: string option;
    detective_quantum_efficiency: float option;
    mode: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    details = None;
    type_ = None;
    detective_quantum_efficiency = None;
    mode = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "detective_quantum_efficiency" -> { b with detective_quantum_efficiency = (PDBjDict.some_float v) }
      | "mode" -> { b with mode = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("detective_quantum_efficiency", string_of_float v)) a.detective_quantum_efficiency;
      Option.map (fun v -> ("mode",  v)) a.mode;
    ]

end

module Em_image_scans = struct
  type t = {
    entry_id: string option;
    id: string option;
    number_digital_images: int option;
    details: string option;
    scanner_model: string option;
    sampling_size: float option;
    od_range: float option;
    quant_bit_size: int option;
    citation_id: string option;
    dimension_height: string option;
    dimension_width: string option;
    frames_per_image: string option;
    image_recording_id: string option;
    used_frames_per_image: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    number_digital_images = None;
    details = None;
    scanner_model = None;
    sampling_size = None;
    od_range = None;
    quant_bit_size = None;
    citation_id = None;
    dimension_height = None;
    dimension_width = None;
    frames_per_image = None;
    image_recording_id = None;
    used_frames_per_image = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "number_digital_images" -> { b with number_digital_images = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "scanner_model" -> { b with scanner_model = (Some v) }
      | "sampling_size" -> { b with sampling_size = (PDBjDict.some_float v) }
      | "od_range" -> { b with od_range = (PDBjDict.some_float v) }
      | "quant_bit_size" -> { b with quant_bit_size = (PDBjDict.some_int v) }
      | "citation_id" -> { b with citation_id = (Some v) }
      | "dimension_height" -> { b with dimension_height = (Some v) }
      | "dimension_width" -> { b with dimension_width = (Some v) }
      | "frames_per_image" -> { b with frames_per_image = (Some v) }
      | "image_recording_id" -> { b with image_recording_id = (Some v) }
      | "used_frames_per_image" -> { b with used_frames_per_image = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("number_digital_images", string_of_int v)) a.number_digital_images;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("scanner_model",  v)) a.scanner_model;
      Option.map (fun v -> ("sampling_size", string_of_float v)) a.sampling_size;
      Option.map (fun v -> ("od_range", string_of_float v)) a.od_range;
      Option.map (fun v -> ("quant_bit_size", string_of_int v)) a.quant_bit_size;
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
      Option.map (fun v -> ("dimension_height",  v)) a.dimension_height;
      Option.map (fun v -> ("dimension_width",  v)) a.dimension_width;
      Option.map (fun v -> ("frames_per_image",  v)) a.frames_per_image;
      Option.map (fun v -> ("image_recording_id",  v)) a.image_recording_id;
      Option.map (fun v -> ("used_frames_per_image",  v)) a.used_frames_per_image;
    ]

end

module Em_2d_projection_selection = struct
  type t = {
    entry_id: string option;
    id: string option;
    num_particles: int option;
    software_name: string option;
    method_: string option;
    details: string option;
    citation_id: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    num_particles = None;
    software_name = None;
    method_ = None;
    details = None;
    citation_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "num_particles" -> { b with num_particles = (PDBjDict.some_int v) }
      | "software_name" -> { b with software_name = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "citation_id" -> { b with citation_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("num_particles", string_of_int v)) a.num_particles;
      Option.map (fun v -> ("software_name",  v)) a.software_name;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
    ]

end

module Em_3d_reconstruction = struct
  type t = {
    entry_id: string option;
    id: string option;
    method_: string option;
    algorithm: string option;
    citation_id: string option;
    details: string option;
    resolution: float option;
    resolution_method: string option;
    magnification_calibration: string option;
    ctf_correction_method: string option;
    nominal_pixel_size: float option;
    actual_pixel_size: float option;
    num_particles: int option;
    euler_angles_details: string option;
    num_class_averages: int option;
    software: string option;
    fsc_type: string option;
    refinement_type: string option;
    image_processing_id: string option;
    symmetry_type: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    method_ = None;
    algorithm = None;
    citation_id = None;
    details = None;
    resolution = None;
    resolution_method = None;
    magnification_calibration = None;
    ctf_correction_method = None;
    nominal_pixel_size = None;
    actual_pixel_size = None;
    num_particles = None;
    euler_angles_details = None;
    num_class_averages = None;
    software = None;
    fsc_type = None;
    refinement_type = None;
    image_processing_id = None;
    symmetry_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "algorithm" -> { b with algorithm = (Some v) }
      | "citation_id" -> { b with citation_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "resolution" -> { b with resolution = (PDBjDict.some_float v) }
      | "resolution_method" -> { b with resolution_method = (Some v) }
      | "magnification_calibration" -> { b with magnification_calibration = (Some v) }
      | "ctf_correction_method" -> { b with ctf_correction_method = (Some v) }
      | "nominal_pixel_size" -> { b with nominal_pixel_size = (PDBjDict.some_float v) }
      | "actual_pixel_size" -> { b with actual_pixel_size = (PDBjDict.some_float v) }
      | "num_particles" -> { b with num_particles = (PDBjDict.some_int v) }
      | "euler_angles_details" -> { b with euler_angles_details = (Some v) }
      | "num_class_averages" -> { b with num_class_averages = (PDBjDict.some_int v) }
      | "software" -> { b with software = (Some v) }
      | "fsc_type" -> { b with fsc_type = (Some v) }
      | "refinement_type" -> { b with refinement_type = (Some v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "symmetry_type" -> { b with symmetry_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("algorithm",  v)) a.algorithm;
      Option.map (fun v -> ("citation_id",  v)) a.citation_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("resolution", string_of_float v)) a.resolution;
      Option.map (fun v -> ("resolution_method",  v)) a.resolution_method;
      Option.map (fun v -> ("magnification_calibration",  v)) a.magnification_calibration;
      Option.map (fun v -> ("ctf_correction_method",  v)) a.ctf_correction_method;
      Option.map (fun v -> ("nominal_pixel_size", string_of_float v)) a.nominal_pixel_size;
      Option.map (fun v -> ("actual_pixel_size", string_of_float v)) a.actual_pixel_size;
      Option.map (fun v -> ("num_particles", string_of_int v)) a.num_particles;
      Option.map (fun v -> ("euler_angles_details",  v)) a.euler_angles_details;
      Option.map (fun v -> ("num_class_averages", string_of_int v)) a.num_class_averages;
      Option.map (fun v -> ("software",  v)) a.software;
      Option.map (fun v -> ("fsc_type",  v)) a.fsc_type;
      Option.map (fun v -> ("refinement_type",  v)) a.refinement_type;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("symmetry_type",  v)) a.symmetry_type;
    ]

end

module Em_3d_fitting = struct
  type t = {
    id: string option;
    entry_id: string option;
    method_: string option;
    target_criteria: string option;
    software_name: string option;
    details: string option;
    overall_b_value: float option;
    ref_space: string option;
    ref_protocol: string option;
  }

  let default = {
    id = None;
    entry_id = None;
    method_ = None;
    target_criteria = None;
    software_name = None;
    details = None;
    overall_b_value = None;
    ref_space = None;
    ref_protocol = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "target_criteria" -> { b with target_criteria = (Some v) }
      | "software_name" -> { b with software_name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "overall_b_value" -> { b with overall_b_value = (PDBjDict.some_float v) }
      | "ref_space" -> { b with ref_space = (Some v) }
      | "ref_protocol" -> { b with ref_protocol = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("target_criteria",  v)) a.target_criteria;
      Option.map (fun v -> ("software_name",  v)) a.software_name;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("overall_b_value", string_of_float v)) a.overall_b_value;
      Option.map (fun v -> ("ref_space",  v)) a.ref_space;
      Option.map (fun v -> ("ref_protocol",  v)) a.ref_protocol;
    ]

end

module Em_3d_fitting_list = struct
  type t = {
    id: string option;
    _3d_fitting_id: string option;
    pdb_entry_id: string option;
    pdb_chain_id: string option;
    pdb_chain_residue_range: string option;
    details: string option;
  }

  let default = {
    id = None;
    _3d_fitting_id = None;
    pdb_entry_id = None;
    pdb_chain_id = None;
    pdb_chain_residue_range = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "3d_fitting_id" -> { b with _3d_fitting_id = (Some v) }
      | "pdb_entry_id" -> { b with pdb_entry_id = (Some v) }
      | "pdb_chain_id" -> { b with pdb_chain_id = (Some v) }
      | "pdb_chain_residue_range" -> { b with pdb_chain_residue_range = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("3d_fitting_id",  v)) a._3d_fitting_id;
      Option.map (fun v -> ("pdb_entry_id",  v)) a.pdb_entry_id;
      Option.map (fun v -> ("pdb_chain_id",  v)) a.pdb_chain_id;
      Option.map (fun v -> ("pdb_chain_residue_range",  v)) a.pdb_chain_residue_range;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Em_helical_entity = struct
  type t = {
    id: string option;
    entity_assembly_id: string option;
    image_processing_id: string option;
    details: string option;
    dyad: string option;
    axial_symmetry: string option;
    angular_rotation_per_subunit: float option;
    axial_rise_per_subunit: float option;
    hand: string option;
  }

  let default = {
    id = None;
    entity_assembly_id = None;
    image_processing_id = None;
    details = None;
    dyad = None;
    axial_symmetry = None;
    angular_rotation_per_subunit = None;
    axial_rise_per_subunit = None;
    hand = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "entity_assembly_id" -> { b with entity_assembly_id = (Some v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "dyad" -> { b with dyad = (Some v) }
      | "axial_symmetry" -> { b with axial_symmetry = (Some v) }
      | "angular_rotation_per_subunit" -> { b with angular_rotation_per_subunit = (PDBjDict.some_float v) }
      | "axial_rise_per_subunit" -> { b with axial_rise_per_subunit = (PDBjDict.some_float v) }
      | "hand" -> { b with hand = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("entity_assembly_id",  v)) a.entity_assembly_id;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("dyad",  v)) a.dyad;
      Option.map (fun v -> ("axial_symmetry",  v)) a.axial_symmetry;
      Option.map (fun v -> ("angular_rotation_per_subunit", string_of_float v)) a.angular_rotation_per_subunit;
      Option.map (fun v -> ("axial_rise_per_subunit", string_of_float v)) a.axial_rise_per_subunit;
      Option.map (fun v -> ("hand",  v)) a.hand;
    ]

end

module Em_experiment = struct
  type t = {
    entry_id: string option;
    id: string option;
    reconstruction_method: string option;
    aggregation_state: string option;
    specimen_type: string option;
    entity_assembly_id: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    reconstruction_method = None;
    aggregation_state = None;
    specimen_type = None;
    entity_assembly_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "reconstruction_method" -> { b with reconstruction_method = (Some v) }
      | "aggregation_state" -> { b with aggregation_state = (Some v) }
      | "specimen_type" -> { b with specimen_type = (Some v) }
      | "entity_assembly_id" -> { b with entity_assembly_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("reconstruction_method",  v)) a.reconstruction_method;
      Option.map (fun v -> ("aggregation_state",  v)) a.aggregation_state;
      Option.map (fun v -> ("specimen_type",  v)) a.specimen_type;
      Option.map (fun v -> ("entity_assembly_id",  v)) a.entity_assembly_id;
    ]

end

module Em_single_particle_entity = struct
  type t = {
    entry_id: string option;
    id: string option;
    symmetry_type: string option;
    image_processing_id: string option;
    point_symmetry: string option;
  }

  let default = {
    entry_id = None;
    id = None;
    symmetry_type = None;
    image_processing_id = None;
    point_symmetry = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "symmetry_type" -> { b with symmetry_type = (Some v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "point_symmetry" -> { b with point_symmetry = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("symmetry_type",  v)) a.symmetry_type;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("point_symmetry",  v)) a.point_symmetry;
    ]

end

module Em_admin = struct
  type t = {
    current_status: string option;
    deposition_date: string option;
    deposition_site: string option;
    details: string option;
    entry_id: string option;
    last_update: string option;
    map_release_date: string option;
    map_hold_date: string option;
    header_release_date: string option;
    obsoleted_date: string option;
    replace_existing_entry_flag: string option;
    title: string option;
  }

  let default = {
    current_status = None;
    deposition_date = None;
    deposition_site = None;
    details = None;
    entry_id = None;
    last_update = None;
    map_release_date = None;
    map_hold_date = None;
    header_release_date = None;
    obsoleted_date = None;
    replace_existing_entry_flag = None;
    title = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "current_status" -> { b with current_status = (Some v) }
      | "deposition_date" -> { b with deposition_date = (Some v) }
      | "deposition_site" -> { b with deposition_site = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "last_update" -> { b with last_update = (Some v) }
      | "map_release_date" -> { b with map_release_date = (Some v) }
      | "map_hold_date" -> { b with map_hold_date = (Some v) }
      | "header_release_date" -> { b with header_release_date = (Some v) }
      | "obsoleted_date" -> { b with obsoleted_date = (Some v) }
      | "replace_existing_entry_flag" -> { b with replace_existing_entry_flag = (Some v) }
      | "title" -> { b with title = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("current_status",  v)) a.current_status;
      Option.map (fun v -> ("deposition_date",  v)) a.deposition_date;
      Option.map (fun v -> ("deposition_site",  v)) a.deposition_site;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("last_update",  v)) a.last_update;
      Option.map (fun v -> ("map_release_date",  v)) a.map_release_date;
      Option.map (fun v -> ("map_hold_date",  v)) a.map_hold_date;
      Option.map (fun v -> ("header_release_date",  v)) a.header_release_date;
      Option.map (fun v -> ("obsoleted_date",  v)) a.obsoleted_date;
      Option.map (fun v -> ("replace_existing_entry_flag",  v)) a.replace_existing_entry_flag;
      Option.map (fun v -> ("title",  v)) a.title;
    ]

end

module Em_author_list = struct
  type t = {
    author: string option;
    ordinal: string option;
  }

  let default = {
    author = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "author" -> { b with author = (Some v) }
      | "ordinal" -> { b with ordinal = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("author",  v)) a.author;
      Option.map (fun v -> ("ordinal",  v)) a.ordinal;
    ]

end

module Em_db_reference = struct
  type t = {
    access_code: string option;
    db_name: string option;
    details: string option;
    id: string option;
    relationship: string option;
  }

  let default = {
    access_code = None;
    db_name = None;
    details = None;
    id = None;
    relationship = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "access_code" -> { b with access_code = (Some v) }
      | "db_name" -> { b with db_name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "relationship" -> { b with relationship = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("access_code",  v)) a.access_code;
      Option.map (fun v -> ("db_name",  v)) a.db_name;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("relationship",  v)) a.relationship;
    ]

end

module Em_db_reference_auxiliary = struct
  type t = {
    id: string option;
    link: string option;
    link_type: string option;
  }

  let default = {
    id = None;
    link = None;
    link_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "link" -> { b with link = (Some v) }
      | "link_type" -> { b with link_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("link",  v)) a.link;
      Option.map (fun v -> ("link_type",  v)) a.link_type;
    ]

end

module Em_depui = struct
  type t = {
    depositor_hold_instructions: string option;
    entry_id: string option;
    macromolecule_description: string option;
    obsolete_instructions: string option;
    same_authors_as_pdb: string option;
    same_title_as_pdb: string option;
  }

  let default = {
    depositor_hold_instructions = None;
    entry_id = None;
    macromolecule_description = None;
    obsolete_instructions = None;
    same_authors_as_pdb = None;
    same_title_as_pdb = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "depositor_hold_instructions" -> { b with depositor_hold_instructions = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "macromolecule_description" -> { b with macromolecule_description = (Some v) }
      | "obsolete_instructions" -> { b with obsolete_instructions = (Some v) }
      | "same_authors_as_pdb" -> { b with same_authors_as_pdb = (Some v) }
      | "same_title_as_pdb" -> { b with same_title_as_pdb = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("depositor_hold_instructions",  v)) a.depositor_hold_instructions;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("macromolecule_description",  v)) a.macromolecule_description;
      Option.map (fun v -> ("obsolete_instructions",  v)) a.obsolete_instructions;
      Option.map (fun v -> ("same_authors_as_pdb",  v)) a.same_authors_as_pdb;
      Option.map (fun v -> ("same_title_as_pdb",  v)) a.same_title_as_pdb;
    ]

end

module Em_obsolete = struct
  type t = {
    date: string option;
    details: string option;
    entry: string option;
    id: string option;
  }

  let default = {
    date = None;
    details = None;
    entry = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "date" -> { b with date = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "entry" -> { b with entry = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entry",  v)) a.entry;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Em_supersede = struct
  type t = {
    date: string option;
    details: string option;
    entry: string option;
    id: string option;
  }

  let default = {
    date = None;
    details = None;
    entry = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "date" -> { b with date = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "entry" -> { b with entry = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("entry",  v)) a.entry;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Em_entity_assembly_molwt = struct
  type t = {
    entity_assembly_id: string option;
    experimental_flag: string option;
    id: string option;
    units: string option;
    value: float option;
    method_: string option;
  }

  let default = {
    entity_assembly_id = None;
    experimental_flag = None;
    id = None;
    units = None;
    value = None;
    method_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_assembly_id" -> { b with entity_assembly_id = (Some v) }
      | "experimental_flag" -> { b with experimental_flag = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "units" -> { b with units = (Some v) }
      | "value" -> { b with value = (PDBjDict.some_float v) }
      | "method" -> { b with method_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_assembly_id",  v)) a.entity_assembly_id;
      Option.map (fun v -> ("experimental_flag",  v)) a.experimental_flag;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("units",  v)) a.units;
      Option.map (fun v -> ("value", string_of_float v)) a.value;
      Option.map (fun v -> ("method",  v)) a.method_;
    ]

end

module Em_entity_assembly_naturalsource = struct
  type t = {
    cell: string option;
    cellular_location: string option;
    entity_assembly_id: string option;
    id: string option;
    ncbi_tax_id: string option;
    organism: string option;
    organelle: string option;
    organ: string option;
    strain: string option;
    tissue: string option;
  }

  let default = {
    cell = None;
    cellular_location = None;
    entity_assembly_id = None;
    id = None;
    ncbi_tax_id = None;
    organism = None;
    organelle = None;
    organ = None;
    strain = None;
    tissue = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "cell" -> { b with cell = (Some v) }
      | "cellular_location" -> { b with cellular_location = (Some v) }
      | "entity_assembly_id" -> { b with entity_assembly_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "ncbi_tax_id" -> { b with ncbi_tax_id = (Some v) }
      | "organism" -> { b with organism = (Some v) }
      | "organelle" -> { b with organelle = (Some v) }
      | "organ" -> { b with organ = (Some v) }
      | "strain" -> { b with strain = (Some v) }
      | "tissue" -> { b with tissue = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("cell",  v)) a.cell;
      Option.map (fun v -> ("cellular_location",  v)) a.cellular_location;
      Option.map (fun v -> ("entity_assembly_id",  v)) a.entity_assembly_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("ncbi_tax_id",  v)) a.ncbi_tax_id;
      Option.map (fun v -> ("organism",  v)) a.organism;
      Option.map (fun v -> ("organelle",  v)) a.organelle;
      Option.map (fun v -> ("organ",  v)) a.organ;
      Option.map (fun v -> ("strain",  v)) a.strain;
      Option.map (fun v -> ("tissue",  v)) a.tissue;
    ]

end

module Em_entity_assembly_recombinant = struct
  type t = {
    cell: string option;
    entity_assembly_id: string option;
    id: string option;
    ncbi_tax_id: string option;
    organism: string option;
    plasmid: string option;
    strain: string option;
  }

  let default = {
    cell = None;
    entity_assembly_id = None;
    id = None;
    ncbi_tax_id = None;
    organism = None;
    plasmid = None;
    strain = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "cell" -> { b with cell = (Some v) }
      | "entity_assembly_id" -> { b with entity_assembly_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "ncbi_tax_id" -> { b with ncbi_tax_id = (Some v) }
      | "organism" -> { b with organism = (Some v) }
      | "plasmid" -> { b with plasmid = (Some v) }
      | "strain" -> { b with strain = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("cell",  v)) a.cell;
      Option.map (fun v -> ("entity_assembly_id",  v)) a.entity_assembly_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("ncbi_tax_id",  v)) a.ncbi_tax_id;
      Option.map (fun v -> ("organism",  v)) a.organism;
      Option.map (fun v -> ("plasmid",  v)) a.plasmid;
      Option.map (fun v -> ("strain",  v)) a.strain;
    ]

end

module Em_virus_natural_host = struct
  type t = {
    entity_assembly_id: string option;
    id: string option;
    ncbi_tax_id: string option;
    organism: string option;
    strain: string option;
  }

  let default = {
    entity_assembly_id = None;
    id = None;
    ncbi_tax_id = None;
    organism = None;
    strain = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_assembly_id" -> { b with entity_assembly_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "ncbi_tax_id" -> { b with ncbi_tax_id = (Some v) }
      | "organism" -> { b with organism = (Some v) }
      | "strain" -> { b with strain = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_assembly_id",  v)) a.entity_assembly_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("ncbi_tax_id",  v)) a.ncbi_tax_id;
      Option.map (fun v -> ("organism",  v)) a.organism;
      Option.map (fun v -> ("strain",  v)) a.strain;
    ]

end

module Em_virus_shell = struct
  type t = {
    diameter: float option;
    entity_assembly_id: string option;
    id: string option;
    name: string option;
    triangulation: string option;
  }

  let default = {
    diameter = None;
    entity_assembly_id = None;
    id = None;
    name = None;
    triangulation = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "diameter" -> { b with diameter = (PDBjDict.some_float v) }
      | "entity_assembly_id" -> { b with entity_assembly_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "triangulation" -> { b with triangulation = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("diameter", string_of_float v)) a.diameter;
      Option.map (fun v -> ("entity_assembly_id",  v)) a.entity_assembly_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("triangulation",  v)) a.triangulation;
    ]

end

module Em_specimen = struct
  type t = {
    concentration: float option;
    details: string option;
    embedding_applied: string option;
    experiment_id: string option;
    id: string option;
    shadowing_applied: string option;
    staining_applied: string option;
    vitrification_applied: string option;
  }

  let default = {
    concentration = None;
    details = None;
    embedding_applied = None;
    experiment_id = None;
    id = None;
    shadowing_applied = None;
    staining_applied = None;
    vitrification_applied = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "concentration" -> { b with concentration = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | "embedding_applied" -> { b with embedding_applied = (Some v) }
      | "experiment_id" -> { b with experiment_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "shadowing_applied" -> { b with shadowing_applied = (Some v) }
      | "staining_applied" -> { b with staining_applied = (Some v) }
      | "vitrification_applied" -> { b with vitrification_applied = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("concentration", string_of_float v)) a.concentration;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("embedding_applied",  v)) a.embedding_applied;
      Option.map (fun v -> ("experiment_id",  v)) a.experiment_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("shadowing_applied",  v)) a.shadowing_applied;
      Option.map (fun v -> ("staining_applied",  v)) a.staining_applied;
      Option.map (fun v -> ("vitrification_applied",  v)) a.vitrification_applied;
    ]

end

module Em_embedding = struct
  type t = {
    details: string option;
    id: string option;
    material: string option;
    specimen_id: string option;
  }

  let default = {
    details = None;
    id = None;
    material = None;
    specimen_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "material" -> { b with material = (Some v) }
      | "specimen_id" -> { b with specimen_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("material",  v)) a.material;
      Option.map (fun v -> ("specimen_id",  v)) a.specimen_id;
    ]

end

module Em_fiducial_markers = struct
  type t = {
    diameter: string option;
    em_tomography_specimen_id: string option;
    id: string option;
    manufacturer: string option;
  }

  let default = {
    diameter = None;
    em_tomography_specimen_id = None;
    id = None;
    manufacturer = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "diameter" -> { b with diameter = (Some v) }
      | "em_tomography_specimen_id" -> { b with em_tomography_specimen_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "manufacturer" -> { b with manufacturer = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("diameter",  v)) a.diameter;
      Option.map (fun v -> ("em_tomography_specimen_id",  v)) a.em_tomography_specimen_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("manufacturer",  v)) a.manufacturer;
    ]

end

module Em_focused_ion_beam = struct
  type t = {
    current: float option;
    details: string option;
    dose_rate: string option;
    duration: string option;
    em_tomography_specimen_id: string option;
    final_thickness: string option;
    id: string option;
    initial_thickness: string option;
    instrument: string option;
    ion: string option;
    temperature: string option;
    voltage: string option;
  }

  let default = {
    current = None;
    details = None;
    dose_rate = None;
    duration = None;
    em_tomography_specimen_id = None;
    final_thickness = None;
    id = None;
    initial_thickness = None;
    instrument = None;
    ion = None;
    temperature = None;
    voltage = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "current" -> { b with current = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | "dose_rate" -> { b with dose_rate = (Some v) }
      | "duration" -> { b with duration = (Some v) }
      | "em_tomography_specimen_id" -> { b with em_tomography_specimen_id = (Some v) }
      | "final_thickness" -> { b with final_thickness = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "initial_thickness" -> { b with initial_thickness = (Some v) }
      | "instrument" -> { b with instrument = (Some v) }
      | "ion" -> { b with ion = (Some v) }
      | "temperature" -> { b with temperature = (Some v) }
      | "voltage" -> { b with voltage = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("current", string_of_float v)) a.current;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("dose_rate",  v)) a.dose_rate;
      Option.map (fun v -> ("duration",  v)) a.duration;
      Option.map (fun v -> ("em_tomography_specimen_id",  v)) a.em_tomography_specimen_id;
      Option.map (fun v -> ("final_thickness",  v)) a.final_thickness;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("initial_thickness",  v)) a.initial_thickness;
      Option.map (fun v -> ("instrument",  v)) a.instrument;
      Option.map (fun v -> ("ion",  v)) a.ion;
      Option.map (fun v -> ("temperature",  v)) a.temperature;
      Option.map (fun v -> ("voltage",  v)) a.voltage;
    ]

end

module Em_grid_pretreatment = struct
  type t = {
    atmosphere: string option;
    id: string option;
    pressure: float option;
    sample_support_id: string option;
    time: string option;
    type_: string option;
  }

  let default = {
    atmosphere = None;
    id = None;
    pressure = None;
    sample_support_id = None;
    time = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atmosphere" -> { b with atmosphere = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "pressure" -> { b with pressure = (PDBjDict.some_float v) }
      | "sample_support_id" -> { b with sample_support_id = (Some v) }
      | "time" -> { b with time = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atmosphere",  v)) a.atmosphere;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("pressure", string_of_float v)) a.pressure;
      Option.map (fun v -> ("sample_support_id",  v)) a.sample_support_id;
      Option.map (fun v -> ("time",  v)) a.time;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Em_ultramicrotomy = struct
  type t = {
    details: string option;
    em_tomography_specimen_id: string option;
    final_thickness: string option;
    id: string option;
    instrument: string option;
    temperature: string option;
  }

  let default = {
    details = None;
    em_tomography_specimen_id = None;
    final_thickness = None;
    id = None;
    instrument = None;
    temperature = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "em_tomography_specimen_id" -> { b with em_tomography_specimen_id = (Some v) }
      | "final_thickness" -> { b with final_thickness = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "instrument" -> { b with instrument = (Some v) }
      | "temperature" -> { b with temperature = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("em_tomography_specimen_id",  v)) a.em_tomography_specimen_id;
      Option.map (fun v -> ("final_thickness",  v)) a.final_thickness;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("instrument",  v)) a.instrument;
      Option.map (fun v -> ("temperature",  v)) a.temperature;
    ]

end

module Em_high_pressure_freezing = struct
  type t = {
    details: string option;
    em_tomography_specimen_id: string option;
    id: string option;
    instrument: string option;
  }

  let default = {
    details = None;
    em_tomography_specimen_id = None;
    id = None;
    instrument = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "em_tomography_specimen_id" -> { b with em_tomography_specimen_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "instrument" -> { b with instrument = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("em_tomography_specimen_id",  v)) a.em_tomography_specimen_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("instrument",  v)) a.instrument;
    ]

end

module Em_shadowing = struct
  type t = {
    angle: float option;
    details: string option;
    id: string option;
    material: string option;
    specimen_id: string option;
    thickness: float option;
  }

  let default = {
    angle = None;
    details = None;
    id = None;
    material = None;
    specimen_id = None;
    thickness = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "angle" -> { b with angle = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "material" -> { b with material = (Some v) }
      | "specimen_id" -> { b with specimen_id = (Some v) }
      | "thickness" -> { b with thickness = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("angle", string_of_float v)) a.angle;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("material",  v)) a.material;
      Option.map (fun v -> ("specimen_id",  v)) a.specimen_id;
      Option.map (fun v -> ("thickness", string_of_float v)) a.thickness;
    ]

end

module Em_tomography_specimen = struct
  type t = {
    cryo_protectant: string option;
    details: string option;
    fiducial_markers: string option;
    high_pressure_freezing: string option;
    id: string option;
    sectioning: string option;
    specimen_id: string option;
  }

  let default = {
    cryo_protectant = None;
    details = None;
    fiducial_markers = None;
    high_pressure_freezing = None;
    id = None;
    sectioning = None;
    specimen_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "cryo_protectant" -> { b with cryo_protectant = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "fiducial_markers" -> { b with fiducial_markers = (Some v) }
      | "high_pressure_freezing" -> { b with high_pressure_freezing = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "sectioning" -> { b with sectioning = (Some v) }
      | "specimen_id" -> { b with specimen_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("cryo_protectant",  v)) a.cryo_protectant;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("fiducial_markers",  v)) a.fiducial_markers;
      Option.map (fun v -> ("high_pressure_freezing",  v)) a.high_pressure_freezing;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("sectioning",  v)) a.sectioning;
      Option.map (fun v -> ("specimen_id",  v)) a.specimen_id;
    ]

end

module Em_crystal_formation = struct
  type t = {
    atmosphere: string option;
    details: string option;
    id: string option;
    instrument: string option;
    lipid_mixture: string option;
    lipid_protein_ratio: float option;
    specimen_id: string option;
    temperature: string option;
    time: string option;
    time_unit: string option;
  }

  let default = {
    atmosphere = None;
    details = None;
    id = None;
    instrument = None;
    lipid_mixture = None;
    lipid_protein_ratio = None;
    specimen_id = None;
    temperature = None;
    time = None;
    time_unit = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atmosphere" -> { b with atmosphere = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "instrument" -> { b with instrument = (Some v) }
      | "lipid_mixture" -> { b with lipid_mixture = (Some v) }
      | "lipid_protein_ratio" -> { b with lipid_protein_ratio = (PDBjDict.some_float v) }
      | "specimen_id" -> { b with specimen_id = (Some v) }
      | "temperature" -> { b with temperature = (Some v) }
      | "time" -> { b with time = (Some v) }
      | "time_unit" -> { b with time_unit = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atmosphere",  v)) a.atmosphere;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("instrument",  v)) a.instrument;
      Option.map (fun v -> ("lipid_mixture",  v)) a.lipid_mixture;
      Option.map (fun v -> ("lipid_protein_ratio", string_of_float v)) a.lipid_protein_ratio;
      Option.map (fun v -> ("specimen_id",  v)) a.specimen_id;
      Option.map (fun v -> ("temperature",  v)) a.temperature;
      Option.map (fun v -> ("time",  v)) a.time;
      Option.map (fun v -> ("time_unit",  v)) a.time_unit;
    ]

end

module Em_staining = struct
  type t = {
    details: string option;
    id: string option;
    material: string option;
    specimen_id: string option;
    type_: string option;
  }

  let default = {
    details = None;
    id = None;
    material = None;
    specimen_id = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "material" -> { b with material = (Some v) }
      | "specimen_id" -> { b with specimen_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("material",  v)) a.material;
      Option.map (fun v -> ("specimen_id",  v)) a.specimen_id;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Em_support_film = struct
  type t = {
    id: string option;
    material: string option;
    sample_support_id: string option;
    thickness: float option;
    topology: string option;
  }

  let default = {
    id = None;
    material = None;
    sample_support_id = None;
    thickness = None;
    topology = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "material" -> { b with material = (Some v) }
      | "sample_support_id" -> { b with sample_support_id = (Some v) }
      | "thickness" -> { b with thickness = (PDBjDict.some_float v) }
      | "topology" -> { b with topology = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("material",  v)) a.material;
      Option.map (fun v -> ("sample_support_id",  v)) a.sample_support_id;
      Option.map (fun v -> ("thickness", string_of_float v)) a.thickness;
      Option.map (fun v -> ("topology",  v)) a.topology;
    ]

end

module Em_buffer_component = struct
  type t = {
    buffer_id: string option;
    concentration: float option;
    concentration_units: string option;
    formula: string option;
    id: string option;
    name: string option;
  }

  let default = {
    buffer_id = None;
    concentration = None;
    concentration_units = None;
    formula = None;
    id = None;
    name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "buffer_id" -> { b with buffer_id = (Some v) }
      | "concentration" -> { b with concentration = (PDBjDict.some_float v) }
      | "concentration_units" -> { b with concentration_units = (Some v) }
      | "formula" -> { b with formula = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("buffer_id",  v)) a.buffer_id;
      Option.map (fun v -> ("concentration", string_of_float v)) a.concentration;
      Option.map (fun v -> ("concentration_units",  v)) a.concentration_units;
      Option.map (fun v -> ("formula",  v)) a.formula;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
    ]

end

module Em_diffraction = struct
  type t = {
    camera_length: float option;
    id: string option;
    imaging_id: string option;
    tilt_angle_list: string option;
  }

  let default = {
    camera_length = None;
    id = None;
    imaging_id = None;
    tilt_angle_list = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "camera_length" -> { b with camera_length = (PDBjDict.some_float v) }
      | "id" -> { b with id = (Some v) }
      | "imaging_id" -> { b with imaging_id = (Some v) }
      | "tilt_angle_list" -> { b with tilt_angle_list = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("camera_length", string_of_float v)) a.camera_length;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("imaging_id",  v)) a.imaging_id;
      Option.map (fun v -> ("tilt_angle_list",  v)) a.tilt_angle_list;
    ]

end

module Em_diffraction_shell = struct
  type t = {
    em_diffraction_stats_id: string option;
    fourier_space_coverage: float option;
    high_resolution: float option;
    id: string option;
    low_resolution: float option;
    multiplicity: float option;
    num_structure_factors: string option;
    phase_residual: float option;
  }

  let default = {
    em_diffraction_stats_id = None;
    fourier_space_coverage = None;
    high_resolution = None;
    id = None;
    low_resolution = None;
    multiplicity = None;
    num_structure_factors = None;
    phase_residual = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "em_diffraction_stats_id" -> { b with em_diffraction_stats_id = (Some v) }
      | "fourier_space_coverage" -> { b with fourier_space_coverage = (PDBjDict.some_float v) }
      | "high_resolution" -> { b with high_resolution = (PDBjDict.some_float v) }
      | "id" -> { b with id = (Some v) }
      | "low_resolution" -> { b with low_resolution = (PDBjDict.some_float v) }
      | "multiplicity" -> { b with multiplicity = (PDBjDict.some_float v) }
      | "num_structure_factors" -> { b with num_structure_factors = (Some v) }
      | "phase_residual" -> { b with phase_residual = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("em_diffraction_stats_id",  v)) a.em_diffraction_stats_id;
      Option.map (fun v -> ("fourier_space_coverage", string_of_float v)) a.fourier_space_coverage;
      Option.map (fun v -> ("high_resolution", string_of_float v)) a.high_resolution;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("low_resolution", string_of_float v)) a.low_resolution;
      Option.map (fun v -> ("multiplicity", string_of_float v)) a.multiplicity;
      Option.map (fun v -> ("num_structure_factors",  v)) a.num_structure_factors;
      Option.map (fun v -> ("phase_residual", string_of_float v)) a.phase_residual;
    ]

end

module Em_diffraction_stats = struct
  type t = {
    details: string option;
    fourier_space_coverage: float option;
    high_resolution: float option;
    id: string option;
    image_processing_id: string option;
    num_intensities_measured: string option;
    num_structure_factors: string option;
    overall_phase_error: float option;
    overall_phase_residual: float option;
    phase_error_rejection_criteria: string option;
    r_merge: float option;
    r_sym: float option;
  }

  let default = {
    details = None;
    fourier_space_coverage = None;
    high_resolution = None;
    id = None;
    image_processing_id = None;
    num_intensities_measured = None;
    num_structure_factors = None;
    overall_phase_error = None;
    overall_phase_residual = None;
    phase_error_rejection_criteria = None;
    r_merge = None;
    r_sym = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "fourier_space_coverage" -> { b with fourier_space_coverage = (PDBjDict.some_float v) }
      | "high_resolution" -> { b with high_resolution = (PDBjDict.some_float v) }
      | "id" -> { b with id = (Some v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "num_intensities_measured" -> { b with num_intensities_measured = (Some v) }
      | "num_structure_factors" -> { b with num_structure_factors = (Some v) }
      | "overall_phase_error" -> { b with overall_phase_error = (PDBjDict.some_float v) }
      | "overall_phase_residual" -> { b with overall_phase_residual = (PDBjDict.some_float v) }
      | "phase_error_rejection_criteria" -> { b with phase_error_rejection_criteria = (Some v) }
      | "r_merge" -> { b with r_merge = (PDBjDict.some_float v) }
      | "r_sym" -> { b with r_sym = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("fourier_space_coverage", string_of_float v)) a.fourier_space_coverage;
      Option.map (fun v -> ("high_resolution", string_of_float v)) a.high_resolution;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("num_intensities_measured",  v)) a.num_intensities_measured;
      Option.map (fun v -> ("num_structure_factors",  v)) a.num_structure_factors;
      Option.map (fun v -> ("overall_phase_error", string_of_float v)) a.overall_phase_error;
      Option.map (fun v -> ("overall_phase_residual", string_of_float v)) a.overall_phase_residual;
      Option.map (fun v -> ("phase_error_rejection_criteria",  v)) a.phase_error_rejection_criteria;
      Option.map (fun v -> ("r_merge", string_of_float v)) a.r_merge;
      Option.map (fun v -> ("r_sym", string_of_float v)) a.r_sym;
    ]

end

module Em_tomography = struct
  type t = {
    axis1_angle_increment: float option;
    axis1_max_angle: float option;
    axis1_min_angle: float option;
    axis2_angle_increment: float option;
    axis2_max_angle: float option;
    axis2_min_angle: float option;
    dual_tilt_axis_rotation: float option;
    id: string option;
    imaging_id: string option;
  }

  let default = {
    axis1_angle_increment = None;
    axis1_max_angle = None;
    axis1_min_angle = None;
    axis2_angle_increment = None;
    axis2_max_angle = None;
    axis2_min_angle = None;
    dual_tilt_axis_rotation = None;
    id = None;
    imaging_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "axis1_angle_increment" -> { b with axis1_angle_increment = (PDBjDict.some_float v) }
      | "axis1_max_angle" -> { b with axis1_max_angle = (PDBjDict.some_float v) }
      | "axis1_min_angle" -> { b with axis1_min_angle = (PDBjDict.some_float v) }
      | "axis2_angle_increment" -> { b with axis2_angle_increment = (PDBjDict.some_float v) }
      | "axis2_max_angle" -> { b with axis2_max_angle = (PDBjDict.some_float v) }
      | "axis2_min_angle" -> { b with axis2_min_angle = (PDBjDict.some_float v) }
      | "dual_tilt_axis_rotation" -> { b with dual_tilt_axis_rotation = (PDBjDict.some_float v) }
      | "id" -> { b with id = (Some v) }
      | "imaging_id" -> { b with imaging_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("axis1_angle_increment", string_of_float v)) a.axis1_angle_increment;
      Option.map (fun v -> ("axis1_max_angle", string_of_float v)) a.axis1_max_angle;
      Option.map (fun v -> ("axis1_min_angle", string_of_float v)) a.axis1_min_angle;
      Option.map (fun v -> ("axis2_angle_increment", string_of_float v)) a.axis2_angle_increment;
      Option.map (fun v -> ("axis2_max_angle", string_of_float v)) a.axis2_max_angle;
      Option.map (fun v -> ("axis2_min_angle", string_of_float v)) a.axis2_min_angle;
      Option.map (fun v -> ("dual_tilt_axis_rotation", string_of_float v)) a.dual_tilt_axis_rotation;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("imaging_id",  v)) a.imaging_id;
    ]

end

module Em_image_recording = struct
  type t = {
    average_exposure_time: float option;
    avg_electron_dose_per_image: float option;
    details: string option;
    detector_mode: string option;
    film_or_detector_model: string option;
    id: string option;
    imaging_id: string option;
    num_diffraction_images: string option;
    num_grids_imaged: string option;
    num_real_images: string option;
  }

  let default = {
    average_exposure_time = None;
    avg_electron_dose_per_image = None;
    details = None;
    detector_mode = None;
    film_or_detector_model = None;
    id = None;
    imaging_id = None;
    num_diffraction_images = None;
    num_grids_imaged = None;
    num_real_images = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "average_exposure_time" -> { b with average_exposure_time = (PDBjDict.some_float v) }
      | "avg_electron_dose_per_image" -> { b with avg_electron_dose_per_image = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | "detector_mode" -> { b with detector_mode = (Some v) }
      | "film_or_detector_model" -> { b with film_or_detector_model = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "imaging_id" -> { b with imaging_id = (Some v) }
      | "num_diffraction_images" -> { b with num_diffraction_images = (Some v) }
      | "num_grids_imaged" -> { b with num_grids_imaged = (Some v) }
      | "num_real_images" -> { b with num_real_images = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("average_exposure_time", string_of_float v)) a.average_exposure_time;
      Option.map (fun v -> ("avg_electron_dose_per_image", string_of_float v)) a.avg_electron_dose_per_image;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("detector_mode",  v)) a.detector_mode;
      Option.map (fun v -> ("film_or_detector_model",  v)) a.film_or_detector_model;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("imaging_id",  v)) a.imaging_id;
      Option.map (fun v -> ("num_diffraction_images",  v)) a.num_diffraction_images;
      Option.map (fun v -> ("num_grids_imaged",  v)) a.num_grids_imaged;
      Option.map (fun v -> ("num_real_images",  v)) a.num_real_images;
    ]

end

module Em_imaging_optics = struct
  type t = {
    chr_aberration_corrector: string option;
    energyfilter_lower: string option;
    energyfilter_name: string option;
    energyfilter_upper: string option;
    id: string option;
    imaging_id: string option;
    phase_plate: string option;
    sph_aberration_corrector: string option;
  }

  let default = {
    chr_aberration_corrector = None;
    energyfilter_lower = None;
    energyfilter_name = None;
    energyfilter_upper = None;
    id = None;
    imaging_id = None;
    phase_plate = None;
    sph_aberration_corrector = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "chr_aberration_corrector" -> { b with chr_aberration_corrector = (Some v) }
      | "energyfilter_lower" -> { b with energyfilter_lower = (Some v) }
      | "energyfilter_name" -> { b with energyfilter_name = (Some v) }
      | "energyfilter_upper" -> { b with energyfilter_upper = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "imaging_id" -> { b with imaging_id = (Some v) }
      | "phase_plate" -> { b with phase_plate = (Some v) }
      | "sph_aberration_corrector" -> { b with sph_aberration_corrector = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("chr_aberration_corrector",  v)) a.chr_aberration_corrector;
      Option.map (fun v -> ("energyfilter_lower",  v)) a.energyfilter_lower;
      Option.map (fun v -> ("energyfilter_name",  v)) a.energyfilter_name;
      Option.map (fun v -> ("energyfilter_upper",  v)) a.energyfilter_upper;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("imaging_id",  v)) a.imaging_id;
      Option.map (fun v -> ("phase_plate",  v)) a.phase_plate;
      Option.map (fun v -> ("sph_aberration_corrector",  v)) a.sph_aberration_corrector;
    ]

end

module Em_final_classification = struct
  type t = {
    avg_num_images_per_class: string option;
    details: string option;
    id: string option;
    image_processing_id: string option;
    num_classes: string option;
    type_: string option;
  }

  let default = {
    avg_num_images_per_class = None;
    details = None;
    id = None;
    image_processing_id = None;
    num_classes = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "avg_num_images_per_class" -> { b with avg_num_images_per_class = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "num_classes" -> { b with num_classes = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("avg_num_images_per_class",  v)) a.avg_num_images_per_class;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("num_classes",  v)) a.num_classes;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Em_start_model = struct
  type t = {
    details: string option;
    emdb_id: string option;
    id: string option;
    image_processing_id: string option;
    insilico_model: string option;
    orthogonal_tilt_angle1: float option;
    orthogonal_tilt_angle2: float option;
    orthogonal_tilt_num_images: string option;
    other: string option;
    pdb_id: string option;
    random_conical_tilt_angle: float option;
    random_conical_tilt_num_images: string option;
    type_: string option;
  }

  let default = {
    details = None;
    emdb_id = None;
    id = None;
    image_processing_id = None;
    insilico_model = None;
    orthogonal_tilt_angle1 = None;
    orthogonal_tilt_angle2 = None;
    orthogonal_tilt_num_images = None;
    other = None;
    pdb_id = None;
    random_conical_tilt_angle = None;
    random_conical_tilt_num_images = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "emdb_id" -> { b with emdb_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "insilico_model" -> { b with insilico_model = (Some v) }
      | "orthogonal_tilt_angle1" -> { b with orthogonal_tilt_angle1 = (PDBjDict.some_float v) }
      | "orthogonal_tilt_angle2" -> { b with orthogonal_tilt_angle2 = (PDBjDict.some_float v) }
      | "orthogonal_tilt_num_images" -> { b with orthogonal_tilt_num_images = (Some v) }
      | "other" -> { b with other = (Some v) }
      | "pdb_id" -> { b with pdb_id = (Some v) }
      | "random_conical_tilt_angle" -> { b with random_conical_tilt_angle = (PDBjDict.some_float v) }
      | "random_conical_tilt_num_images" -> { b with random_conical_tilt_num_images = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("emdb_id",  v)) a.emdb_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("insilico_model",  v)) a.insilico_model;
      Option.map (fun v -> ("orthogonal_tilt_angle1", string_of_float v)) a.orthogonal_tilt_angle1;
      Option.map (fun v -> ("orthogonal_tilt_angle2", string_of_float v)) a.orthogonal_tilt_angle2;
      Option.map (fun v -> ("orthogonal_tilt_num_images",  v)) a.orthogonal_tilt_num_images;
      Option.map (fun v -> ("other",  v)) a.other;
      Option.map (fun v -> ("pdb_id",  v)) a.pdb_id;
      Option.map (fun v -> ("random_conical_tilt_angle", string_of_float v)) a.random_conical_tilt_angle;
      Option.map (fun v -> ("random_conical_tilt_num_images",  v)) a.random_conical_tilt_num_images;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Em_software = struct
  type t = {
    category: string option;
    details: string option;
    id: string option;
    image_processing_id: string option;
    fitting_id: string option;
    imaging_id: string option;
    name: string option;
    version: string option;
  }

  let default = {
    category = None;
    details = None;
    id = None;
    image_processing_id = None;
    fitting_id = None;
    imaging_id = None;
    name = None;
    version = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "category" -> { b with category = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "fitting_id" -> { b with fitting_id = (Some v) }
      | "imaging_id" -> { b with imaging_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "version" -> { b with version = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("category",  v)) a.category;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("fitting_id",  v)) a.fitting_id;
      Option.map (fun v -> ("imaging_id",  v)) a.imaging_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("version",  v)) a.version;
    ]

end

module Em_euler_angle_assignment = struct
  type t = {
    details: string option;
    id: string option;
    image_processing_id: string option;
    order: string option;
    proj_matching_angular_sampling: float option;
    proj_matching_merit_function: string option;
    proj_matching_num_projections: string option;
    type_: string option;
  }

  let default = {
    details = None;
    id = None;
    image_processing_id = None;
    order = None;
    proj_matching_angular_sampling = None;
    proj_matching_merit_function = None;
    proj_matching_num_projections = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "order" -> { b with order = (Some v) }
      | "proj_matching_angular_sampling" -> { b with proj_matching_angular_sampling = (PDBjDict.some_float v) }
      | "proj_matching_merit_function" -> { b with proj_matching_merit_function = (Some v) }
      | "proj_matching_num_projections" -> { b with proj_matching_num_projections = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("order",  v)) a.order;
      Option.map (fun v -> ("proj_matching_angular_sampling", string_of_float v)) a.proj_matching_angular_sampling;
      Option.map (fun v -> ("proj_matching_merit_function",  v)) a.proj_matching_merit_function;
      Option.map (fun v -> ("proj_matching_num_projections",  v)) a.proj_matching_num_projections;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Em_ctf_correction = struct
  type t = {
    amplitude_correction: string option;
    amplitude_correction_factor: float option;
    amplitude_correction_space: string option;
    correction_operation: string option;
    details: string option;
    em_image_processing_id: string option;
    id: string option;
    phase_reversal: string option;
    phase_reversal_anisotropic: string option;
    phase_reversal_correction_space: string option;
    type_: string option;
  }

  let default = {
    amplitude_correction = None;
    amplitude_correction_factor = None;
    amplitude_correction_space = None;
    correction_operation = None;
    details = None;
    em_image_processing_id = None;
    id = None;
    phase_reversal = None;
    phase_reversal_anisotropic = None;
    phase_reversal_correction_space = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "amplitude_correction" -> { b with amplitude_correction = (Some v) }
      | "amplitude_correction_factor" -> { b with amplitude_correction_factor = (PDBjDict.some_float v) }
      | "amplitude_correction_space" -> { b with amplitude_correction_space = (Some v) }
      | "correction_operation" -> { b with correction_operation = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "em_image_processing_id" -> { b with em_image_processing_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "phase_reversal" -> { b with phase_reversal = (Some v) }
      | "phase_reversal_anisotropic" -> { b with phase_reversal_anisotropic = (Some v) }
      | "phase_reversal_correction_space" -> { b with phase_reversal_correction_space = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("amplitude_correction",  v)) a.amplitude_correction;
      Option.map (fun v -> ("amplitude_correction_factor", string_of_float v)) a.amplitude_correction_factor;
      Option.map (fun v -> ("amplitude_correction_space",  v)) a.amplitude_correction_space;
      Option.map (fun v -> ("correction_operation",  v)) a.correction_operation;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("em_image_processing_id",  v)) a.em_image_processing_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("phase_reversal",  v)) a.phase_reversal;
      Option.map (fun v -> ("phase_reversal_anisotropic",  v)) a.phase_reversal_anisotropic;
      Option.map (fun v -> ("phase_reversal_correction_space",  v)) a.phase_reversal_correction_space;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Em_volume_selection = struct
  type t = {
    details: string option;
    id: string option;
    image_processing_id: string option;
    method_: string option;
    num_tomograms: string option;
    num_volumes_extracted: string option;
    reference_model: string option;
  }

  let default = {
    details = None;
    id = None;
    image_processing_id = None;
    method_ = None;
    num_tomograms = None;
    num_volumes_extracted = None;
    reference_model = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "num_tomograms" -> { b with num_tomograms = (Some v) }
      | "num_volumes_extracted" -> { b with num_volumes_extracted = (Some v) }
      | "reference_model" -> { b with reference_model = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("num_tomograms",  v)) a.num_tomograms;
      Option.map (fun v -> ("num_volumes_extracted",  v)) a.num_volumes_extracted;
      Option.map (fun v -> ("reference_model",  v)) a.reference_model;
    ]

end

module Em_3d_crystal_entity = struct
  type t = {
    angle_alpha: float option;
    angle_beta: float option;
    angle_gamma: float option;
    image_processing_id: string option;
    id: string option;
    length_a: float option;
    length_b: float option;
    length_c: float option;
    space_group_name: string option;
    space_group_num: int option;
  }

  let default = {
    angle_alpha = None;
    angle_beta = None;
    angle_gamma = None;
    image_processing_id = None;
    id = None;
    length_a = None;
    length_b = None;
    length_c = None;
    space_group_name = None;
    space_group_num = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "angle_alpha" -> { b with angle_alpha = (PDBjDict.some_float v) }
      | "angle_beta" -> { b with angle_beta = (PDBjDict.some_float v) }
      | "angle_gamma" -> { b with angle_gamma = (PDBjDict.some_float v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "length_a" -> { b with length_a = (PDBjDict.some_float v) }
      | "length_b" -> { b with length_b = (PDBjDict.some_float v) }
      | "length_c" -> { b with length_c = (PDBjDict.some_float v) }
      | "space_group_name" -> { b with space_group_name = (Some v) }
      | "space_group_num" -> { b with space_group_num = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("angle_alpha", string_of_float v)) a.angle_alpha;
      Option.map (fun v -> ("angle_beta", string_of_float v)) a.angle_beta;
      Option.map (fun v -> ("angle_gamma", string_of_float v)) a.angle_gamma;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("length_a", string_of_float v)) a.length_a;
      Option.map (fun v -> ("length_b", string_of_float v)) a.length_b;
      Option.map (fun v -> ("length_c", string_of_float v)) a.length_c;
      Option.map (fun v -> ("space_group_name",  v)) a.space_group_name;
      Option.map (fun v -> ("space_group_num", string_of_int v)) a.space_group_num;
    ]

end

module Em_2d_crystal_entity = struct
  type t = {
    angle_gamma: float option;
    c_sampling_length: float option;
    image_processing_id: string option;
    id: string option;
    entity_assembly_id: string option;
    length_a: float option;
    length_b: float option;
    length_c: float option;
    space_group_name_H_M: string option;
  }

  let default = {
    angle_gamma = None;
    c_sampling_length = None;
    image_processing_id = None;
    id = None;
    entity_assembly_id = None;
    length_a = None;
    length_b = None;
    length_c = None;
    space_group_name_H_M = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "angle_gamma" -> { b with angle_gamma = (PDBjDict.some_float v) }
      | "c_sampling_length" -> { b with c_sampling_length = (PDBjDict.some_float v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "entity_assembly_id" -> { b with entity_assembly_id = (Some v) }
      | "length_a" -> { b with length_a = (PDBjDict.some_float v) }
      | "length_b" -> { b with length_b = (PDBjDict.some_float v) }
      | "length_c" -> { b with length_c = (PDBjDict.some_float v) }
      | "space_group_name_H-M" -> { b with space_group_name_H_M = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("angle_gamma", string_of_float v)) a.angle_gamma;
      Option.map (fun v -> ("c_sampling_length", string_of_float v)) a.c_sampling_length;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("entity_assembly_id",  v)) a.entity_assembly_id;
      Option.map (fun v -> ("length_a", string_of_float v)) a.length_a;
      Option.map (fun v -> ("length_b", string_of_float v)) a.length_b;
      Option.map (fun v -> ("length_c", string_of_float v)) a.length_c;
      Option.map (fun v -> ("space_group_name_H-M",  v)) a.space_group_name_H_M;
    ]

end

module Em_image_processing = struct
  type t = {
    details: string option;
    id: string option;
    image_recording_id: string option;
  }

  let default = {
    details = None;
    id = None;
    image_recording_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "image_recording_id" -> { b with image_recording_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("image_recording_id",  v)) a.image_recording_id;
    ]

end

module Em_particle_selection = struct
  type t = {
    details: string option;
    id: string option;
    image_processing_id: string option;
    method_: string option;
    num_particles_selected: string option;
    reference_model: string option;
  }

  let default = {
    details = None;
    id = None;
    image_processing_id = None;
    method_ = None;
    num_particles_selected = None;
    reference_model = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "image_processing_id" -> { b with image_processing_id = (Some v) }
      | "method" -> { b with method_ = (Some v) }
      | "num_particles_selected" -> { b with num_particles_selected = (Some v) }
      | "reference_model" -> { b with reference_model = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("image_processing_id",  v)) a.image_processing_id;
      Option.map (fun v -> ("method",  v)) a.method_;
      Option.map (fun v -> ("num_particles_selected",  v)) a.num_particles_selected;
      Option.map (fun v -> ("reference_model",  v)) a.reference_model;
    ]

end

module Em_map = struct
  type t = {
    annotation_details: string option;
    axis_order_fast: string option;
    axis_order_medium: string option;
    axis_order_slow: string option;
    cell_a: float option;
    cell_b: float option;
    cell_c: float option;
    cell_alpha: float option;
    cell_beta: float option;
    cell_gamma: float option;
    contour_level: float option;
    contour_level_source: string option;
    data_type: string option;
    dimensions_col: string option;
    dimensions_row: string option;
    dimensions_sec: string option;
    endian_type: string option;
    file: string option;
    format: string option;
    id: string option;
    partition: string option;
    entry_id: string option;
    label: string option;
    limit_col: int option;
    limit_row: int option;
    limit_sec: int option;
    origin_col: int option;
    origin_row: int option;
    origin_sec: int option;
    pixel_spacing_x: float option;
    pixel_spacing_y: float option;
    pixel_spacing_z: float option;
    size_kb: string option;
    spacing_x: string option;
    spacing_y: string option;
    spacing_z: string option;
    statistics_average: float option;
    statistics_maximum: float option;
    statistics_minimum: float option;
    statistics_std: float option;
    symmetry_space_group: string option;
    type_: string option;
  }

  let default = {
    annotation_details = None;
    axis_order_fast = None;
    axis_order_medium = None;
    axis_order_slow = None;
    cell_a = None;
    cell_b = None;
    cell_c = None;
    cell_alpha = None;
    cell_beta = None;
    cell_gamma = None;
    contour_level = None;
    contour_level_source = None;
    data_type = None;
    dimensions_col = None;
    dimensions_row = None;
    dimensions_sec = None;
    endian_type = None;
    file = None;
    format = None;
    id = None;
    partition = None;
    entry_id = None;
    label = None;
    limit_col = None;
    limit_row = None;
    limit_sec = None;
    origin_col = None;
    origin_row = None;
    origin_sec = None;
    pixel_spacing_x = None;
    pixel_spacing_y = None;
    pixel_spacing_z = None;
    size_kb = None;
    spacing_x = None;
    spacing_y = None;
    spacing_z = None;
    statistics_average = None;
    statistics_maximum = None;
    statistics_minimum = None;
    statistics_std = None;
    symmetry_space_group = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "annotation_details" -> { b with annotation_details = (Some v) }
      | "axis_order_fast" -> { b with axis_order_fast = (Some v) }
      | "axis_order_medium" -> { b with axis_order_medium = (Some v) }
      | "axis_order_slow" -> { b with axis_order_slow = (Some v) }
      | "cell_a" -> { b with cell_a = (PDBjDict.some_float v) }
      | "cell_b" -> { b with cell_b = (PDBjDict.some_float v) }
      | "cell_c" -> { b with cell_c = (PDBjDict.some_float v) }
      | "cell_alpha" -> { b with cell_alpha = (PDBjDict.some_float v) }
      | "cell_beta" -> { b with cell_beta = (PDBjDict.some_float v) }
      | "cell_gamma" -> { b with cell_gamma = (PDBjDict.some_float v) }
      | "contour_level" -> { b with contour_level = (PDBjDict.some_float v) }
      | "contour_level_source" -> { b with contour_level_source = (Some v) }
      | "data_type" -> { b with data_type = (Some v) }
      | "dimensions_col" -> { b with dimensions_col = (Some v) }
      | "dimensions_row" -> { b with dimensions_row = (Some v) }
      | "dimensions_sec" -> { b with dimensions_sec = (Some v) }
      | "endian_type" -> { b with endian_type = (Some v) }
      | "file" -> { b with file = (Some v) }
      | "format" -> { b with format = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "partition" -> { b with partition = (Some v) }
      | "entry_id" -> { b with entry_id = (Some v) }
      | "label" -> { b with label = (Some v) }
      | "limit_col" -> { b with limit_col = (PDBjDict.some_int v) }
      | "limit_row" -> { b with limit_row = (PDBjDict.some_int v) }
      | "limit_sec" -> { b with limit_sec = (PDBjDict.some_int v) }
      | "origin_col" -> { b with origin_col = (PDBjDict.some_int v) }
      | "origin_row" -> { b with origin_row = (PDBjDict.some_int v) }
      | "origin_sec" -> { b with origin_sec = (PDBjDict.some_int v) }
      | "pixel_spacing_x" -> { b with pixel_spacing_x = (PDBjDict.some_float v) }
      | "pixel_spacing_y" -> { b with pixel_spacing_y = (PDBjDict.some_float v) }
      | "pixel_spacing_z" -> { b with pixel_spacing_z = (PDBjDict.some_float v) }
      | "size_kb" -> { b with size_kb = (Some v) }
      | "spacing_x" -> { b with spacing_x = (Some v) }
      | "spacing_y" -> { b with spacing_y = (Some v) }
      | "spacing_z" -> { b with spacing_z = (Some v) }
      | "statistics_average" -> { b with statistics_average = (PDBjDict.some_float v) }
      | "statistics_maximum" -> { b with statistics_maximum = (PDBjDict.some_float v) }
      | "statistics_minimum" -> { b with statistics_minimum = (PDBjDict.some_float v) }
      | "statistics_std" -> { b with statistics_std = (PDBjDict.some_float v) }
      | "symmetry_space_group" -> { b with symmetry_space_group = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("annotation_details",  v)) a.annotation_details;
      Option.map (fun v -> ("axis_order_fast",  v)) a.axis_order_fast;
      Option.map (fun v -> ("axis_order_medium",  v)) a.axis_order_medium;
      Option.map (fun v -> ("axis_order_slow",  v)) a.axis_order_slow;
      Option.map (fun v -> ("cell_a", string_of_float v)) a.cell_a;
      Option.map (fun v -> ("cell_b", string_of_float v)) a.cell_b;
      Option.map (fun v -> ("cell_c", string_of_float v)) a.cell_c;
      Option.map (fun v -> ("cell_alpha", string_of_float v)) a.cell_alpha;
      Option.map (fun v -> ("cell_beta", string_of_float v)) a.cell_beta;
      Option.map (fun v -> ("cell_gamma", string_of_float v)) a.cell_gamma;
      Option.map (fun v -> ("contour_level", string_of_float v)) a.contour_level;
      Option.map (fun v -> ("contour_level_source",  v)) a.contour_level_source;
      Option.map (fun v -> ("data_type",  v)) a.data_type;
      Option.map (fun v -> ("dimensions_col",  v)) a.dimensions_col;
      Option.map (fun v -> ("dimensions_row",  v)) a.dimensions_row;
      Option.map (fun v -> ("dimensions_sec",  v)) a.dimensions_sec;
      Option.map (fun v -> ("endian_type",  v)) a.endian_type;
      Option.map (fun v -> ("file",  v)) a.file;
      Option.map (fun v -> ("format",  v)) a.format;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("partition",  v)) a.partition;
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("label",  v)) a.label;
      Option.map (fun v -> ("limit_col", string_of_int v)) a.limit_col;
      Option.map (fun v -> ("limit_row", string_of_int v)) a.limit_row;
      Option.map (fun v -> ("limit_sec", string_of_int v)) a.limit_sec;
      Option.map (fun v -> ("origin_col", string_of_int v)) a.origin_col;
      Option.map (fun v -> ("origin_row", string_of_int v)) a.origin_row;
      Option.map (fun v -> ("origin_sec", string_of_int v)) a.origin_sec;
      Option.map (fun v -> ("pixel_spacing_x", string_of_float v)) a.pixel_spacing_x;
      Option.map (fun v -> ("pixel_spacing_y", string_of_float v)) a.pixel_spacing_y;
      Option.map (fun v -> ("pixel_spacing_z", string_of_float v)) a.pixel_spacing_z;
      Option.map (fun v -> ("size_kb",  v)) a.size_kb;
      Option.map (fun v -> ("spacing_x",  v)) a.spacing_x;
      Option.map (fun v -> ("spacing_y",  v)) a.spacing_y;
      Option.map (fun v -> ("spacing_z",  v)) a.spacing_z;
      Option.map (fun v -> ("statistics_average", string_of_float v)) a.statistics_average;
      Option.map (fun v -> ("statistics_maximum", string_of_float v)) a.statistics_maximum;
      Option.map (fun v -> ("statistics_minimum", string_of_float v)) a.statistics_minimum;
      Option.map (fun v -> ("statistics_std", string_of_float v)) a.statistics_std;
      Option.map (fun v -> ("symmetry_space_group",  v)) a.symmetry_space_group;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Em_fsc_curve = struct
  type t = {
    details: string option;
    file: string option;
    id: string option;
  }

  let default = {
    details = None;
    file = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "file" -> { b with file = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("file",  v)) a.file;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Em_interpret_figure = struct
  type t = {
    details: string option;
    file: string option;
    id: string option;
  }

  let default = {
    details = None;
    file = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "file" -> { b with file = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("file",  v)) a.file;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Em_layer_lines = struct
  type t = {
    details: string option;
    experiment_id: string option;
    file: string option;
    id: string option;
  }

  let default = {
    details = None;
    experiment_id = None;
    file = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "experiment_id" -> { b with experiment_id = (Some v) }
      | "file" -> { b with file = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("experiment_id",  v)) a.experiment_id;
      Option.map (fun v -> ("file",  v)) a.file;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Em_structure_factors = struct
  type t = {
    details: string option;
    experiment_id: string option;
    file: string option;
    id: string option;
  }

  let default = {
    details = None;
    experiment_id = None;
    file = None;
    id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "experiment_id" -> { b with experiment_id = (Some v) }
      | "file" -> { b with file = (Some v) }
      | "id" -> { b with id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("experiment_id",  v)) a.experiment_id;
      Option.map (fun v -> ("file",  v)) a.file;
      Option.map (fun v -> ("id",  v)) a.id;
    ]

end

module Em_depositor_info = struct
  type t = {
    entry_id: string option;
    em_method_selection: string option;
    molecular_description_flag: string option;
  }

  let default = {
    entry_id = None;
    em_method_selection = None;
    molecular_description_flag = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "em_method_selection" -> { b with em_method_selection = (Some v) }
      | "molecular_description_flag" -> { b with molecular_description_flag = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("em_method_selection",  v)) a.em_method_selection;
      Option.map (fun v -> ("molecular_description_flag",  v)) a.molecular_description_flag;
    ]

end

module Em_map_depositor_info = struct
  type t = {
    entry_id: string option;
    experiment_id: string option;
    id: string option;
    map_type: string option;
    upload_file_name: string option;
    upload_format: string option;
    contour_level: float option;
    annotation_details: string option;
    pixel_spacing_x: float option;
    pixel_spacing_y: float option;
    pixel_spacing_z: float option;
  }

  let default = {
    entry_id = None;
    experiment_id = None;
    id = None;
    map_type = None;
    upload_file_name = None;
    upload_format = None;
    contour_level = None;
    annotation_details = None;
    pixel_spacing_x = None;
    pixel_spacing_y = None;
    pixel_spacing_z = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "experiment_id" -> { b with experiment_id = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "map_type" -> { b with map_type = (Some v) }
      | "upload_file_name" -> { b with upload_file_name = (Some v) }
      | "upload_format" -> { b with upload_format = (Some v) }
      | "contour_level" -> { b with contour_level = (PDBjDict.some_float v) }
      | "annotation_details" -> { b with annotation_details = (Some v) }
      | "pixel_spacing_x" -> { b with pixel_spacing_x = (PDBjDict.some_float v) }
      | "pixel_spacing_y" -> { b with pixel_spacing_y = (PDBjDict.some_float v) }
      | "pixel_spacing_z" -> { b with pixel_spacing_z = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("experiment_id",  v)) a.experiment_id;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("map_type",  v)) a.map_type;
      Option.map (fun v -> ("upload_file_name",  v)) a.upload_file_name;
      Option.map (fun v -> ("upload_format",  v)) a.upload_format;
      Option.map (fun v -> ("contour_level", string_of_float v)) a.contour_level;
      Option.map (fun v -> ("annotation_details",  v)) a.annotation_details;
      Option.map (fun v -> ("pixel_spacing_x", string_of_float v)) a.pixel_spacing_x;
      Option.map (fun v -> ("pixel_spacing_y", string_of_float v)) a.pixel_spacing_y;
      Option.map (fun v -> ("pixel_spacing_z", string_of_float v)) a.pixel_spacing_z;
    ]

end

module Em_mask_depositor_info = struct
  type t = {
    id: string option;
    upload_file_name: string option;
    upload_format: string option;
    contour_level: float option;
    annotation_details: string option;
    pixel_spacing_x: float option;
    pixel_spacing_y: float option;
    pixel_spacing_z: float option;
  }

  let default = {
    id = None;
    upload_file_name = None;
    upload_format = None;
    contour_level = None;
    annotation_details = None;
    pixel_spacing_x = None;
    pixel_spacing_y = None;
    pixel_spacing_z = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "upload_file_name" -> { b with upload_file_name = (Some v) }
      | "upload_format" -> { b with upload_format = (Some v) }
      | "contour_level" -> { b with contour_level = (PDBjDict.some_float v) }
      | "annotation_details" -> { b with annotation_details = (Some v) }
      | "pixel_spacing_x" -> { b with pixel_spacing_x = (PDBjDict.some_float v) }
      | "pixel_spacing_y" -> { b with pixel_spacing_y = (PDBjDict.some_float v) }
      | "pixel_spacing_z" -> { b with pixel_spacing_z = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("upload_file_name",  v)) a.upload_file_name;
      Option.map (fun v -> ("upload_format",  v)) a.upload_format;
      Option.map (fun v -> ("contour_level", string_of_float v)) a.contour_level;
      Option.map (fun v -> ("annotation_details",  v)) a.annotation_details;
      Option.map (fun v -> ("pixel_spacing_x", string_of_float v)) a.pixel_spacing_x;
      Option.map (fun v -> ("pixel_spacing_y", string_of_float v)) a.pixel_spacing_y;
      Option.map (fun v -> ("pixel_spacing_z", string_of_float v)) a.pixel_spacing_z;
    ]

end

module Em_figure_depositor_info = struct
  type t = {
    id: string option;
    experiment_id: string option;
    upload_file_name: string option;
    details: string option;
  }

  let default = {
    id = None;
    experiment_id = None;
    upload_file_name = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "experiment_id" -> { b with experiment_id = (Some v) }
      | "upload_file_name" -> { b with upload_file_name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("experiment_id",  v)) a.experiment_id;
      Option.map (fun v -> ("upload_file_name",  v)) a.upload_file_name;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Em_layer_lines_depositor_info = struct
  type t = {
    id: string option;
    experiment_id: string option;
    upload_file_name: string option;
    details: string option;
  }

  let default = {
    id = None;
    experiment_id = None;
    upload_file_name = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "experiment_id" -> { b with experiment_id = (Some v) }
      | "upload_file_name" -> { b with upload_file_name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("experiment_id",  v)) a.experiment_id;
      Option.map (fun v -> ("upload_file_name",  v)) a.upload_file_name;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Em_structure_factors_depositor_info = struct
  type t = {
    id: string option;
    experiment_id: string option;
    upload_file_name: string option;
    details: string option;
  }

  let default = {
    id = None;
    experiment_id = None;
    upload_file_name = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "experiment_id" -> { b with experiment_id = (Some v) }
      | "upload_file_name" -> { b with upload_file_name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("experiment_id",  v)) a.experiment_id;
      Option.map (fun v -> ("upload_file_name",  v)) a.upload_file_name;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_seq_map_depositor_info = struct
  type t = {
    entity_id: string option;
    auth_asym_id: string option;
    one_letter_code: string option;
    one_letter_code_mod: string option;
  }

  let default = {
    entity_id = None;
    auth_asym_id = None;
    one_letter_code = None;
    one_letter_code_mod = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "one_letter_code" -> { b with one_letter_code = (Some v) }
      | "one_letter_code_mod" -> { b with one_letter_code_mod = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("one_letter_code",  v)) a.one_letter_code;
      Option.map (fun v -> ("one_letter_code_mod",  v)) a.one_letter_code_mod;
    ]

end

module Pdbx_chem_comp_depositor_info = struct
  type t = {
    ordinal: int option;
    comp_id: string option;
    alt_comp_id: string option;
    name: string option;
    formula: string option;
    type_: string option;
    descriptor: string option;
    descriptor_type: string option;
    in_dictionary_flag: string option;
    details: string option;
  }

  let default = {
    ordinal = None;
    comp_id = None;
    alt_comp_id = None;
    name = None;
    formula = None;
    type_ = None;
    descriptor = None;
    descriptor_type = None;
    in_dictionary_flag = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "alt_comp_id" -> { b with alt_comp_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "formula" -> { b with formula = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "descriptor" -> { b with descriptor = (Some v) }
      | "descriptor_type" -> { b with descriptor_type = (Some v) }
      | "in_dictionary_flag" -> { b with in_dictionary_flag = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("alt_comp_id",  v)) a.alt_comp_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("formula",  v)) a.formula;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("descriptor",  v)) a.descriptor;
      Option.map (fun v -> ("descriptor_type",  v)) a.descriptor_type;
      Option.map (fun v -> ("in_dictionary_flag",  v)) a.in_dictionary_flag;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_struct_ref_seq_depositor_info = struct
  type t = {
    ref_id: string option;
    entity_id: string option;
    db_align_beg: int option;
    db_align_end: int option;
    details: string option;
    db_accession: string option;
    db_code: string option;
    db_name: string option;
    db_seq_one_letter_code: string option;
    seq_align_begin: string option;
    seq_align_end: string option;
  }

  let default = {
    ref_id = None;
    entity_id = None;
    db_align_beg = None;
    db_align_end = None;
    details = None;
    db_accession = None;
    db_code = None;
    db_name = None;
    db_seq_one_letter_code = None;
    seq_align_begin = None;
    seq_align_end = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ref_id" -> { b with ref_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "db_align_beg" -> { b with db_align_beg = (PDBjDict.some_int v) }
      | "db_align_end" -> { b with db_align_end = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "db_accession" -> { b with db_accession = (Some v) }
      | "db_code" -> { b with db_code = (Some v) }
      | "db_name" -> { b with db_name = (Some v) }
      | "db_seq_one_letter_code" -> { b with db_seq_one_letter_code = (Some v) }
      | "seq_align_begin" -> { b with seq_align_begin = (Some v) }
      | "seq_align_end" -> { b with seq_align_end = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ref_id",  v)) a.ref_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("db_align_beg", string_of_int v)) a.db_align_beg;
      Option.map (fun v -> ("db_align_end", string_of_int v)) a.db_align_end;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("db_accession",  v)) a.db_accession;
      Option.map (fun v -> ("db_code",  v)) a.db_code;
      Option.map (fun v -> ("db_name",  v)) a.db_name;
      Option.map (fun v -> ("db_seq_one_letter_code",  v)) a.db_seq_one_letter_code;
      Option.map (fun v -> ("seq_align_begin",  v)) a.seq_align_begin;
      Option.map (fun v -> ("seq_align_end",  v)) a.seq_align_end;
    ]

end

module Pdbx_struct_ref_seq_dif_depositor_info = struct
  type t = {
    ordinal: int option;
    ref_id: string option;
    entity_id: string option;
    db_mon_id: string option;
    db_seq_id: int option;
    details: string option;
    auth_mon_id: string option;
    auth_seq_id: int option;
    db_accession: string option;
    db_code: string option;
    db_name: string option;
    annotation: string option;
  }

  let default = {
    ordinal = None;
    ref_id = None;
    entity_id = None;
    db_mon_id = None;
    db_seq_id = None;
    details = None;
    auth_mon_id = None;
    auth_seq_id = None;
    db_accession = None;
    db_code = None;
    db_name = None;
    annotation = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "ref_id" -> { b with ref_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "db_mon_id" -> { b with db_mon_id = (Some v) }
      | "db_seq_id" -> { b with db_seq_id = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | "auth_mon_id" -> { b with auth_mon_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (PDBjDict.some_int v) }
      | "db_accession" -> { b with db_accession = (Some v) }
      | "db_code" -> { b with db_code = (Some v) }
      | "db_name" -> { b with db_name = (Some v) }
      | "annotation" -> { b with annotation = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("ref_id",  v)) a.ref_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("db_mon_id",  v)) a.db_mon_id;
      Option.map (fun v -> ("db_seq_id", string_of_int v)) a.db_seq_id;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("auth_mon_id",  v)) a.auth_mon_id;
      Option.map (fun v -> ("auth_seq_id", string_of_int v)) a.auth_seq_id;
      Option.map (fun v -> ("db_accession",  v)) a.db_accession;
      Option.map (fun v -> ("db_code",  v)) a.db_code;
      Option.map (fun v -> ("db_name",  v)) a.db_name;
      Option.map (fun v -> ("annotation",  v)) a.annotation;
    ]

end

module Pdbx_struct_assembly_prop_depositor_info = struct
  type t = {
    biol_id: string option;
    type_: string option;
    value: string option;
    details: string option;
  }

  let default = {
    biol_id = None;
    type_ = None;
    value = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "biol_id" -> { b with biol_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "value" -> { b with value = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("biol_id",  v)) a.biol_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("value",  v)) a.value;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_struct_assembly_depositor_info = struct
  type t = {
    details: string option;
    id: string option;
    method_details: string option;
    oligomeric_details: string option;
    oligomeric_count: string option;
    matrix_flag: string option;
    upload_file_name: string option;
  }

  let default = {
    details = None;
    id = None;
    method_details = None;
    oligomeric_details = None;
    oligomeric_count = None;
    matrix_flag = None;
    upload_file_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "id" -> { b with id = (Some v) }
      | "method_details" -> { b with method_details = (Some v) }
      | "oligomeric_details" -> { b with oligomeric_details = (Some v) }
      | "oligomeric_count" -> { b with oligomeric_count = (Some v) }
      | "matrix_flag" -> { b with matrix_flag = (Some v) }
      | "upload_file_name" -> { b with upload_file_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("method_details",  v)) a.method_details;
      Option.map (fun v -> ("oligomeric_details",  v)) a.oligomeric_details;
      Option.map (fun v -> ("oligomeric_count",  v)) a.oligomeric_count;
      Option.map (fun v -> ("matrix_flag",  v)) a.matrix_flag;
      Option.map (fun v -> ("upload_file_name",  v)) a.upload_file_name;
    ]

end

module Pdbx_struct_assembly_gen_depositor_info = struct
  type t = {
    id: string option;
    asym_id_list: string option;
    assembly_id: string option;
    oper_expression: string option;
    full_matrices: string option;
    symmetry_operation: string option;
    at_unit_matrix: string option;
    chain_id_list: string option;
    all_chains: string option;
    helical_rotation: float option;
    helical_rise: float option;
  }

  let default = {
    id = None;
    asym_id_list = None;
    assembly_id = None;
    oper_expression = None;
    full_matrices = None;
    symmetry_operation = None;
    at_unit_matrix = None;
    chain_id_list = None;
    all_chains = None;
    helical_rotation = None;
    helical_rise = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "asym_id_list" -> { b with asym_id_list = (Some v) }
      | "assembly_id" -> { b with assembly_id = (Some v) }
      | "oper_expression" -> { b with oper_expression = (Some v) }
      | "full_matrices" -> { b with full_matrices = (Some v) }
      | "symmetry_operation" -> { b with symmetry_operation = (Some v) }
      | "at_unit_matrix" -> { b with at_unit_matrix = (Some v) }
      | "chain_id_list" -> { b with chain_id_list = (Some v) }
      | "all_chains" -> { b with all_chains = (Some v) }
      | "helical_rotation" -> { b with helical_rotation = (PDBjDict.some_float v) }
      | "helical_rise" -> { b with helical_rise = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("asym_id_list",  v)) a.asym_id_list;
      Option.map (fun v -> ("assembly_id",  v)) a.assembly_id;
      Option.map (fun v -> ("oper_expression",  v)) a.oper_expression;
      Option.map (fun v -> ("full_matrices",  v)) a.full_matrices;
      Option.map (fun v -> ("symmetry_operation",  v)) a.symmetry_operation;
      Option.map (fun v -> ("at_unit_matrix",  v)) a.at_unit_matrix;
      Option.map (fun v -> ("chain_id_list",  v)) a.chain_id_list;
      Option.map (fun v -> ("all_chains",  v)) a.all_chains;
      Option.map (fun v -> ("helical_rotation", string_of_float v)) a.helical_rotation;
      Option.map (fun v -> ("helical_rise", string_of_float v)) a.helical_rise;
    ]

end

module Pdbx_struct_oper_list_depositor_info = struct
  type t = {
    id: string option;
    type_: string option;
    name: string option;
    symmetry_operation: string option;
    matrix11: float option;
    matrix12: float option;
    matrix13: float option;
    matrix21: float option;
    matrix22: float option;
    matrix23: float option;
    matrix31: float option;
    matrix32: float option;
    matrix33: float option;
    vector1: float option;
    vector2: float option;
    vector3: float option;
  }

  let default = {
    id = None;
    type_ = None;
    name = None;
    symmetry_operation = None;
    matrix11 = None;
    matrix12 = None;
    matrix13 = None;
    matrix21 = None;
    matrix22 = None;
    matrix23 = None;
    matrix31 = None;
    matrix32 = None;
    matrix33 = None;
    vector1 = None;
    vector2 = None;
    vector3 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "symmetry_operation" -> { b with symmetry_operation = (Some v) }
      | "matrix[1][1]" -> { b with matrix11 = (PDBjDict.some_float v) }
      | "matrix[1][2]" -> { b with matrix12 = (PDBjDict.some_float v) }
      | "matrix[1][3]" -> { b with matrix13 = (PDBjDict.some_float v) }
      | "matrix[2][1]" -> { b with matrix21 = (PDBjDict.some_float v) }
      | "matrix[2][2]" -> { b with matrix22 = (PDBjDict.some_float v) }
      | "matrix[2][3]" -> { b with matrix23 = (PDBjDict.some_float v) }
      | "matrix[3][1]" -> { b with matrix31 = (PDBjDict.some_float v) }
      | "matrix[3][2]" -> { b with matrix32 = (PDBjDict.some_float v) }
      | "matrix[3][3]" -> { b with matrix33 = (PDBjDict.some_float v) }
      | "vector[1]" -> { b with vector1 = (PDBjDict.some_float v) }
      | "vector[2]" -> { b with vector2 = (PDBjDict.some_float v) }
      | "vector[3]" -> { b with vector3 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("symmetry_operation",  v)) a.symmetry_operation;
      Option.map (fun v -> ("matrix[1][1]", string_of_float v)) a.matrix11;
      Option.map (fun v -> ("matrix[1][2]", string_of_float v)) a.matrix12;
      Option.map (fun v -> ("matrix[1][3]", string_of_float v)) a.matrix13;
      Option.map (fun v -> ("matrix[2][1]", string_of_float v)) a.matrix21;
      Option.map (fun v -> ("matrix[2][2]", string_of_float v)) a.matrix22;
      Option.map (fun v -> ("matrix[2][3]", string_of_float v)) a.matrix23;
      Option.map (fun v -> ("matrix[3][1]", string_of_float v)) a.matrix31;
      Option.map (fun v -> ("matrix[3][2]", string_of_float v)) a.matrix32;
      Option.map (fun v -> ("matrix[3][3]", string_of_float v)) a.matrix33;
      Option.map (fun v -> ("vector[1]", string_of_float v)) a.vector1;
      Option.map (fun v -> ("vector[2]", string_of_float v)) a.vector2;
      Option.map (fun v -> ("vector[3]", string_of_float v)) a.vector3;
    ]

end

module Pdbx_point_symmetry_depositor_info = struct
  type t = {
    entry_id: string option;
    schoenflies_symbol: string option;
    circular_symmetry: int option;
    h_M_notation: string option;
    status_flag: string option;
  }

  let default = {
    entry_id = None;
    schoenflies_symbol = None;
    circular_symmetry = None;
    h_M_notation = None;
    status_flag = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "Schoenflies_symbol" -> { b with schoenflies_symbol = (Some v) }
      | "circular_symmetry" -> { b with circular_symmetry = (PDBjDict.some_int v) }
      | "H-M_notation" -> { b with h_M_notation = (Some v) }
      | "status_flag" -> { b with status_flag = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("Schoenflies_symbol",  v)) a.schoenflies_symbol;
      Option.map (fun v -> ("circular_symmetry", string_of_int v)) a.circular_symmetry;
      Option.map (fun v -> ("H-M_notation",  v)) a.h_M_notation;
      Option.map (fun v -> ("status_flag",  v)) a.status_flag;
    ]

end

module Pdbx_helical_symmetry_depositor_info = struct
  type t = {
    entry_id: string option;
    number_of_operations: int option;
    rotation_per_n_subunits: float option;
    rise_per_n_subunits: float option;
    n_subunits_divisor: int option;
    dyad_axis: string option;
    circular_symmetry: int option;
    status_flag: string option;
  }

  let default = {
    entry_id = None;
    number_of_operations = None;
    rotation_per_n_subunits = None;
    rise_per_n_subunits = None;
    n_subunits_divisor = None;
    dyad_axis = None;
    circular_symmetry = None;
    status_flag = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "number_of_operations" -> { b with number_of_operations = (PDBjDict.some_int v) }
      | "rotation_per_n_subunits" -> { b with rotation_per_n_subunits = (PDBjDict.some_float v) }
      | "rise_per_n_subunits" -> { b with rise_per_n_subunits = (PDBjDict.some_float v) }
      | "n_subunits_divisor" -> { b with n_subunits_divisor = (PDBjDict.some_int v) }
      | "dyad_axis" -> { b with dyad_axis = (Some v) }
      | "circular_symmetry" -> { b with circular_symmetry = (PDBjDict.some_int v) }
      | "status_flag" -> { b with status_flag = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("number_of_operations", string_of_int v)) a.number_of_operations;
      Option.map (fun v -> ("rotation_per_n_subunits", string_of_float v)) a.rotation_per_n_subunits;
      Option.map (fun v -> ("rise_per_n_subunits", string_of_float v)) a.rise_per_n_subunits;
      Option.map (fun v -> ("n_subunits_divisor", string_of_int v)) a.n_subunits_divisor;
      Option.map (fun v -> ("dyad_axis",  v)) a.dyad_axis;
      Option.map (fun v -> ("circular_symmetry", string_of_int v)) a.circular_symmetry;
      Option.map (fun v -> ("status_flag",  v)) a.status_flag;
    ]

end

module Pdbx_struct_assembly_auth_evidence_depositor_info = struct
  type t = {
    id: string option;
    assembly_id: string option;
    experimental_support: string option;
    details: string option;
  }

  let default = {
    id = None;
    assembly_id = None;
    experimental_support = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "assembly_id" -> { b with assembly_id = (Some v) }
      | "experimental_support" -> { b with experimental_support = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("assembly_id",  v)) a.assembly_id;
      Option.map (fun v -> ("experimental_support",  v)) a.experimental_support;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_solvent_atom_site_mapping = struct
  type t = {
    id: string option;
    label_alt_id: string option;
    label_asym_id: string option;
    label_atom_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    pDB_ins_code: string option;
    pre_auth_asym_id: string option;
    pre_auth_atom_id: string option;
    pre_auth_comp_id: string option;
    pre_auth_seq_id: string option;
    pre_PDB_ins_code: string option;
    pre_auth_alt_id: string option;
    auth_asym_id: string option;
    auth_atom_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    auth_alt_id: string option;
    occupancy: float option;
    cartn_x: float option;
    cartn_y: float option;
    cartn_z: float option;
    pre_Cartn_x: float option;
    pre_Cartn_y: float option;
    pre_Cartn_z: float option;
    symmetry: string option;
    symmetry_as_xyz: string option;
  }

  let default = {
    id = None;
    label_alt_id = None;
    label_asym_id = None;
    label_atom_id = None;
    label_comp_id = None;
    label_seq_id = None;
    pDB_ins_code = None;
    pre_auth_asym_id = None;
    pre_auth_atom_id = None;
    pre_auth_comp_id = None;
    pre_auth_seq_id = None;
    pre_PDB_ins_code = None;
    pre_auth_alt_id = None;
    auth_asym_id = None;
    auth_atom_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    auth_alt_id = None;
    occupancy = None;
    cartn_x = None;
    cartn_y = None;
    cartn_z = None;
    pre_Cartn_x = None;
    pre_Cartn_y = None;
    pre_Cartn_z = None;
    symmetry = None;
    symmetry_as_xyz = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_atom_id" -> { b with label_atom_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "pre_auth_asym_id" -> { b with pre_auth_asym_id = (Some v) }
      | "pre_auth_atom_id" -> { b with pre_auth_atom_id = (Some v) }
      | "pre_auth_comp_id" -> { b with pre_auth_comp_id = (Some v) }
      | "pre_auth_seq_id" -> { b with pre_auth_seq_id = (Some v) }
      | "pre_PDB_ins_code" -> { b with pre_PDB_ins_code = (Some v) }
      | "pre_auth_alt_id" -> { b with pre_auth_alt_id = (Some v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_atom_id" -> { b with auth_atom_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "auth_alt_id" -> { b with auth_alt_id = (Some v) }
      | "occupancy" -> { b with occupancy = (PDBjDict.some_float v) }
      | "Cartn_x" -> { b with cartn_x = (PDBjDict.some_float v) }
      | "Cartn_y" -> { b with cartn_y = (PDBjDict.some_float v) }
      | "Cartn_z" -> { b with cartn_z = (PDBjDict.some_float v) }
      | "pre_Cartn_x" -> { b with pre_Cartn_x = (PDBjDict.some_float v) }
      | "pre_Cartn_y" -> { b with pre_Cartn_y = (PDBjDict.some_float v) }
      | "pre_Cartn_z" -> { b with pre_Cartn_z = (PDBjDict.some_float v) }
      | "symmetry" -> { b with symmetry = (Some v) }
      | "symmetry_as_xyz" -> { b with symmetry_as_xyz = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_atom_id",  v)) a.label_atom_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("pre_auth_asym_id",  v)) a.pre_auth_asym_id;
      Option.map (fun v -> ("pre_auth_atom_id",  v)) a.pre_auth_atom_id;
      Option.map (fun v -> ("pre_auth_comp_id",  v)) a.pre_auth_comp_id;
      Option.map (fun v -> ("pre_auth_seq_id",  v)) a.pre_auth_seq_id;
      Option.map (fun v -> ("pre_PDB_ins_code",  v)) a.pre_PDB_ins_code;
      Option.map (fun v -> ("pre_auth_alt_id",  v)) a.pre_auth_alt_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_atom_id",  v)) a.auth_atom_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("auth_alt_id",  v)) a.auth_alt_id;
      Option.map (fun v -> ("occupancy", string_of_float v)) a.occupancy;
      Option.map (fun v -> ("Cartn_x", string_of_float v)) a.cartn_x;
      Option.map (fun v -> ("Cartn_y", string_of_float v)) a.cartn_y;
      Option.map (fun v -> ("Cartn_z", string_of_float v)) a.cartn_z;
      Option.map (fun v -> ("pre_Cartn_x", string_of_float v)) a.pre_Cartn_x;
      Option.map (fun v -> ("pre_Cartn_y", string_of_float v)) a.pre_Cartn_y;
      Option.map (fun v -> ("pre_Cartn_z", string_of_float v)) a.pre_Cartn_z;
      Option.map (fun v -> ("symmetry",  v)) a.symmetry;
      Option.map (fun v -> ("symmetry_as_xyz",  v)) a.symmetry_as_xyz;
    ]

end

module Pdbx_molecule_features_depositor_info = struct
  type t = {
    entity_id: string option;
    class_: string option;
    type_: string option;
    name: string option;
    details: string option;
  }

  let default = {
    entity_id = None;
    class_ = None;
    type_ = None;
    name = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "class" -> { b with class_ = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("class",  v)) a.class_;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_chem_comp_instance_depositor_info = struct
  type t = {
    ordinal: int option;
    label_alt_id: string option;
    comp_id: string option;
    pDB_ins_code: string option;
    auth_asym_id: string option;
    auth_seq_id: string option;
    in_polymer_flag: string option;
    author_provided_flag: string option;
    formula: string option;
  }

  let default = {
    ordinal = None;
    label_alt_id = None;
    comp_id = None;
    pDB_ins_code = None;
    auth_asym_id = None;
    auth_seq_id = None;
    in_polymer_flag = None;
    author_provided_flag = None;
    formula = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "PDB_ins_code" -> { b with pDB_ins_code = (Some v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "in_polymer_flag" -> { b with in_polymer_flag = (Some v) }
      | "author_provided_flag" -> { b with author_provided_flag = (Some v) }
      | "formula" -> { b with formula = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("PDB_ins_code",  v)) a.pDB_ins_code;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("in_polymer_flag",  v)) a.in_polymer_flag;
      Option.map (fun v -> ("author_provided_flag",  v)) a.author_provided_flag;
      Option.map (fun v -> ("formula",  v)) a.formula;
    ]

end

module Pdbx_depui_status_flags = struct
  type t = {
    dep_dataset_id: string option;
    primary_citation_status: string option;
    corresponding_author_status: string option;
    reference_citation_status: string option;
    is_grant_funded: string option;
    has_ncs_data: string option;
    prediction_target: string option;
    has_helical_symmetry: string option;
    has_point_symmetry: string option;
    has_cyclic_symmetry: string option;
    has_accepted_terms_and_conditions: string option;
    has_viewed_validation_report: string option;
    validated_model_file_name: string option;
    merge_prior_model_file_name: string option;
    merge_replace_model_file_name: string option;
    merge_output_model_file_name: string option;
    is_ligand_processing_complete: string option;
    sample_xyz_sequence_alignments_valid: string option;
    has_sas_data: string option;
    is_sas_deposited: string option;
    use_sas_refine: string option;
  }

  let default = {
    dep_dataset_id = None;
    primary_citation_status = None;
    corresponding_author_status = None;
    reference_citation_status = None;
    is_grant_funded = None;
    has_ncs_data = None;
    prediction_target = None;
    has_helical_symmetry = None;
    has_point_symmetry = None;
    has_cyclic_symmetry = None;
    has_accepted_terms_and_conditions = None;
    has_viewed_validation_report = None;
    validated_model_file_name = None;
    merge_prior_model_file_name = None;
    merge_replace_model_file_name = None;
    merge_output_model_file_name = None;
    is_ligand_processing_complete = None;
    sample_xyz_sequence_alignments_valid = None;
    has_sas_data = None;
    is_sas_deposited = None;
    use_sas_refine = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "dep_dataset_id" -> { b with dep_dataset_id = (Some v) }
      | "primary_citation_status" -> { b with primary_citation_status = (Some v) }
      | "corresponding_author_status" -> { b with corresponding_author_status = (Some v) }
      | "reference_citation_status" -> { b with reference_citation_status = (Some v) }
      | "is_grant_funded" -> { b with is_grant_funded = (Some v) }
      | "has_ncs_data" -> { b with has_ncs_data = (Some v) }
      | "prediction_target" -> { b with prediction_target = (Some v) }
      | "has_helical_symmetry" -> { b with has_helical_symmetry = (Some v) }
      | "has_point_symmetry" -> { b with has_point_symmetry = (Some v) }
      | "has_cyclic_symmetry" -> { b with has_cyclic_symmetry = (Some v) }
      | "has_accepted_terms_and_conditions" -> { b with has_accepted_terms_and_conditions = (Some v) }
      | "has_viewed_validation_report" -> { b with has_viewed_validation_report = (Some v) }
      | "validated_model_file_name" -> { b with validated_model_file_name = (Some v) }
      | "merge_prior_model_file_name" -> { b with merge_prior_model_file_name = (Some v) }
      | "merge_replace_model_file_name" -> { b with merge_replace_model_file_name = (Some v) }
      | "merge_output_model_file_name" -> { b with merge_output_model_file_name = (Some v) }
      | "is_ligand_processing_complete" -> { b with is_ligand_processing_complete = (Some v) }
      | "sample_xyz_sequence_alignments_valid" -> { b with sample_xyz_sequence_alignments_valid = (Some v) }
      | "has_sas_data" -> { b with has_sas_data = (Some v) }
      | "is_sas_deposited" -> { b with is_sas_deposited = (Some v) }
      | "use_sas_refine" -> { b with use_sas_refine = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("dep_dataset_id",  v)) a.dep_dataset_id;
      Option.map (fun v -> ("primary_citation_status",  v)) a.primary_citation_status;
      Option.map (fun v -> ("corresponding_author_status",  v)) a.corresponding_author_status;
      Option.map (fun v -> ("reference_citation_status",  v)) a.reference_citation_status;
      Option.map (fun v -> ("is_grant_funded",  v)) a.is_grant_funded;
      Option.map (fun v -> ("has_ncs_data",  v)) a.has_ncs_data;
      Option.map (fun v -> ("prediction_target",  v)) a.prediction_target;
      Option.map (fun v -> ("has_helical_symmetry",  v)) a.has_helical_symmetry;
      Option.map (fun v -> ("has_point_symmetry",  v)) a.has_point_symmetry;
      Option.map (fun v -> ("has_cyclic_symmetry",  v)) a.has_cyclic_symmetry;
      Option.map (fun v -> ("has_accepted_terms_and_conditions",  v)) a.has_accepted_terms_and_conditions;
      Option.map (fun v -> ("has_viewed_validation_report",  v)) a.has_viewed_validation_report;
      Option.map (fun v -> ("validated_model_file_name",  v)) a.validated_model_file_name;
      Option.map (fun v -> ("merge_prior_model_file_name",  v)) a.merge_prior_model_file_name;
      Option.map (fun v -> ("merge_replace_model_file_name",  v)) a.merge_replace_model_file_name;
      Option.map (fun v -> ("merge_output_model_file_name",  v)) a.merge_output_model_file_name;
      Option.map (fun v -> ("is_ligand_processing_complete",  v)) a.is_ligand_processing_complete;
      Option.map (fun v -> ("sample_xyz_sequence_alignments_valid",  v)) a.sample_xyz_sequence_alignments_valid;
      Option.map (fun v -> ("has_sas_data",  v)) a.has_sas_data;
      Option.map (fun v -> ("is_sas_deposited",  v)) a.is_sas_deposited;
      Option.map (fun v -> ("use_sas_refine",  v)) a.use_sas_refine;
    ]

end

module Pdbx_depui_upload = struct
  type t = {
    ordinal: int option;
    file_content_type: string option;
    file_type: string option;
    file_name: string option;
    file_size: int option;
    valid_flag: string option;
    diagnostic_message: string option;
    sequence_align: string option;
  }

  let default = {
    ordinal = None;
    file_content_type = None;
    file_type = None;
    file_name = None;
    file_size = None;
    valid_flag = None;
    diagnostic_message = None;
    sequence_align = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "file_content_type" -> { b with file_content_type = (Some v) }
      | "file_type" -> { b with file_type = (Some v) }
      | "file_name" -> { b with file_name = (Some v) }
      | "file_size" -> { b with file_size = (PDBjDict.some_int v) }
      | "valid_flag" -> { b with valid_flag = (Some v) }
      | "diagnostic_message" -> { b with diagnostic_message = (Some v) }
      | "sequence_align" -> { b with sequence_align = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("file_content_type",  v)) a.file_content_type;
      Option.map (fun v -> ("file_type",  v)) a.file_type;
      Option.map (fun v -> ("file_name",  v)) a.file_name;
      Option.map (fun v -> ("file_size", string_of_int v)) a.file_size;
      Option.map (fun v -> ("valid_flag",  v)) a.valid_flag;
      Option.map (fun v -> ("diagnostic_message",  v)) a.diagnostic_message;
      Option.map (fun v -> ("sequence_align",  v)) a.sequence_align;
    ]

end

module Pdbx_depui_validation_status_flags = struct
  type t = {
    dep_dataset_id: string option;
    residual_B_factors_flag: string option;
    occupancy_outliers_low: int option;
    occupancy_outliers_high: int option;
    adp_outliers_low: int option;
    solvent_outliers: int option;
  }

  let default = {
    dep_dataset_id = None;
    residual_B_factors_flag = None;
    occupancy_outliers_low = None;
    occupancy_outliers_high = None;
    adp_outliers_low = None;
    solvent_outliers = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "dep_dataset_id" -> { b with dep_dataset_id = (Some v) }
      | "residual_B_factors_flag" -> { b with residual_B_factors_flag = (Some v) }
      | "occupancy_outliers_low" -> { b with occupancy_outliers_low = (PDBjDict.some_int v) }
      | "occupancy_outliers_high" -> { b with occupancy_outliers_high = (PDBjDict.some_int v) }
      | "adp_outliers_low" -> { b with adp_outliers_low = (PDBjDict.some_int v) }
      | "solvent_outliers" -> { b with solvent_outliers = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("dep_dataset_id",  v)) a.dep_dataset_id;
      Option.map (fun v -> ("residual_B_factors_flag",  v)) a.residual_B_factors_flag;
      Option.map (fun v -> ("occupancy_outliers_low", string_of_int v)) a.occupancy_outliers_low;
      Option.map (fun v -> ("occupancy_outliers_high", string_of_int v)) a.occupancy_outliers_high;
      Option.map (fun v -> ("adp_outliers_low", string_of_int v)) a.adp_outliers_low;
      Option.map (fun v -> ("solvent_outliers", string_of_int v)) a.solvent_outliers;
    ]

end

module Pdbx_chem_comp_upload_depositor_info = struct
  type t = {
    ordinal: int option;
    comp_id: string option;
    upload_file_type: string option;
    upload_file_name: string option;
  }

  let default = {
    ordinal = None;
    comp_id = None;
    upload_file_type = None;
    upload_file_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "upload_file_type" -> { b with upload_file_type = (Some v) }
      | "upload_file_name" -> { b with upload_file_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("upload_file_type",  v)) a.upload_file_type;
      Option.map (fun v -> ("upload_file_name",  v)) a.upload_file_name;
    ]

end

module Pdbx_depui_entity_status_flags = struct
  type t = {
    dep_dataset_id: string option;
    entity_id: string option;
    has_mutation: string option;
    sample_xyz_sequence_alignments_valid: string option;
  }

  let default = {
    dep_dataset_id = None;
    entity_id = None;
    has_mutation = None;
    sample_xyz_sequence_alignments_valid = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "dep_dataset_id" -> { b with dep_dataset_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "has_mutation" -> { b with has_mutation = (Some v) }
      | "sample_xyz_sequence_alignments_valid" -> { b with sample_xyz_sequence_alignments_valid = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("dep_dataset_id",  v)) a.dep_dataset_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("has_mutation",  v)) a.has_mutation;
      Option.map (fun v -> ("sample_xyz_sequence_alignments_valid",  v)) a.sample_xyz_sequence_alignments_valid;
    ]

end

module Pdbx_depui_entity_features = struct
  type t = {
    dep_dataset_id: string option;
    entity_id: string option;
    type_: string option;
  }

  let default = {
    dep_dataset_id = None;
    entity_id = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "dep_dataset_id" -> { b with dep_dataset_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("dep_dataset_id",  v)) a.dep_dataset_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_deposition_message_info = struct
  type t = {
    ordinal: int option;
    deposition_data_set_id: string option;
    message_id: string option;
    timestamp: string option;
    sender: string option;
    content_type: string option;
    content_value: string option;
    parent_message_id: string option;
    message_subject: string option;
    message_text: string option;
    message_type: string option;
    send_status: string option;
  }

  let default = {
    ordinal = None;
    deposition_data_set_id = None;
    message_id = None;
    timestamp = None;
    sender = None;
    content_type = None;
    content_value = None;
    parent_message_id = None;
    message_subject = None;
    message_text = None;
    message_type = None;
    send_status = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "deposition_data_set_id" -> { b with deposition_data_set_id = (Some v) }
      | "message_id" -> { b with message_id = (Some v) }
      | "timestamp" -> { b with timestamp = (Some v) }
      | "sender" -> { b with sender = (Some v) }
      | "content_type" -> { b with content_type = (Some v) }
      | "content_value" -> { b with content_value = (Some v) }
      | "parent_message_id" -> { b with parent_message_id = (Some v) }
      | "message_subject" -> { b with message_subject = (Some v) }
      | "message_text" -> { b with message_text = (Some v) }
      | "message_type" -> { b with message_type = (Some v) }
      | "send_status" -> { b with send_status = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("deposition_data_set_id",  v)) a.deposition_data_set_id;
      Option.map (fun v -> ("message_id",  v)) a.message_id;
      Option.map (fun v -> ("timestamp",  v)) a.timestamp;
      Option.map (fun v -> ("sender",  v)) a.sender;
      Option.map (fun v -> ("content_type",  v)) a.content_type;
      Option.map (fun v -> ("content_value",  v)) a.content_value;
      Option.map (fun v -> ("parent_message_id",  v)) a.parent_message_id;
      Option.map (fun v -> ("message_subject",  v)) a.message_subject;
      Option.map (fun v -> ("message_text",  v)) a.message_text;
      Option.map (fun v -> ("message_type",  v)) a.message_type;
      Option.map (fun v -> ("send_status",  v)) a.send_status;
    ]

end

module Pdbx_deposition_message_file_reference = struct
  type t = {
    ordinal: int option;
    deposition_data_set_id: string option;
    message_id: string option;
    content_type: string option;
    content_format: string option;
    partition_number: string option;
    version_id: string option;
    storage_type: string option;
  }

  let default = {
    ordinal = None;
    deposition_data_set_id = None;
    message_id = None;
    content_type = None;
    content_format = None;
    partition_number = None;
    version_id = None;
    storage_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "deposition_data_set_id" -> { b with deposition_data_set_id = (Some v) }
      | "message_id" -> { b with message_id = (Some v) }
      | "content_type" -> { b with content_type = (Some v) }
      | "content_format" -> { b with content_format = (Some v) }
      | "partition_number" -> { b with partition_number = (Some v) }
      | "version_id" -> { b with version_id = (Some v) }
      | "storage_type" -> { b with storage_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("deposition_data_set_id",  v)) a.deposition_data_set_id;
      Option.map (fun v -> ("message_id",  v)) a.message_id;
      Option.map (fun v -> ("content_type",  v)) a.content_type;
      Option.map (fun v -> ("content_format",  v)) a.content_format;
      Option.map (fun v -> ("partition_number",  v)) a.partition_number;
      Option.map (fun v -> ("version_id",  v)) a.version_id;
      Option.map (fun v -> ("storage_type",  v)) a.storage_type;
    ]

end

module Pdbx_depui_entry_details = struct
  type t = {
    dep_dataset_id: string option;
    wwpdb_site_id: string option;
    experimental_methods: string option;
    requested_accession_types: string option;
    validated_contact_email: string option;
    country: string option;
    structural_genomics_flag: string option;
    related_database_name: string option;
    related_database_code: string option;
    replace_pdb_id: string option;
  }

  let default = {
    dep_dataset_id = None;
    wwpdb_site_id = None;
    experimental_methods = None;
    requested_accession_types = None;
    validated_contact_email = None;
    country = None;
    structural_genomics_flag = None;
    related_database_name = None;
    related_database_code = None;
    replace_pdb_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "dep_dataset_id" -> { b with dep_dataset_id = (Some v) }
      | "wwpdb_site_id" -> { b with wwpdb_site_id = (Some v) }
      | "experimental_methods" -> { b with experimental_methods = (Some v) }
      | "requested_accession_types" -> { b with requested_accession_types = (Some v) }
      | "validated_contact_email" -> { b with validated_contact_email = (Some v) }
      | "country" -> { b with country = (Some v) }
      | "structural_genomics_flag" -> { b with structural_genomics_flag = (Some v) }
      | "related_database_name" -> { b with related_database_name = (Some v) }
      | "related_database_code" -> { b with related_database_code = (Some v) }
      | "replace_pdb_id" -> { b with replace_pdb_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("dep_dataset_id",  v)) a.dep_dataset_id;
      Option.map (fun v -> ("wwpdb_site_id",  v)) a.wwpdb_site_id;
      Option.map (fun v -> ("experimental_methods",  v)) a.experimental_methods;
      Option.map (fun v -> ("requested_accession_types",  v)) a.requested_accession_types;
      Option.map (fun v -> ("validated_contact_email",  v)) a.validated_contact_email;
      Option.map (fun v -> ("country",  v)) a.country;
      Option.map (fun v -> ("structural_genomics_flag",  v)) a.structural_genomics_flag;
      Option.map (fun v -> ("related_database_name",  v)) a.related_database_name;
      Option.map (fun v -> ("related_database_code",  v)) a.related_database_code;
      Option.map (fun v -> ("replace_pdb_id",  v)) a.replace_pdb_id;
    ]

end

module Pdbx_data_processing_status = struct
  type t = {
    task_name: string option;
    status: string option;
  }

  let default = {
    task_name = None;
    status = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "task_name" -> { b with task_name = (Some v) }
      | "status" -> { b with status = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("task_name",  v)) a.task_name;
      Option.map (fun v -> ("status",  v)) a.status;
    ]

end

module Pdbx_entity_instance_feature = struct
  type t = {
    details: string option;
    feature_type: string option;
    auth_asym_id: string option;
    asym_id: string option;
    auth_seq_num: string option;
    seq_num: int option;
    comp_id: string option;
    auth_comp_id: string option;
    ordinal: int option;
  }

  let default = {
    details = None;
    feature_type = None;
    auth_asym_id = None;
    asym_id = None;
    auth_seq_num = None;
    seq_num = None;
    comp_id = None;
    auth_comp_id = None;
    ordinal = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "details" -> { b with details = (Some v) }
      | "feature_type" -> { b with feature_type = (Some v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | "auth_seq_num" -> { b with auth_seq_num = (Some v) }
      | "seq_num" -> { b with seq_num = (PDBjDict.some_int v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("feature_type",  v)) a.feature_type;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("auth_seq_num",  v)) a.auth_seq_num;
      Option.map (fun v -> ("seq_num", string_of_int v)) a.seq_num;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
    ]

end

module Pdbx_entity_src_gen_depositor_info = struct
  type t = {
    src_id: int option;
    entity_id: string option;
    seq_type: string option;
    beg_seq_num: int option;
    end_seq_num: int option;
    gene_src_gene: string option;
    gene_src_scientific_name: string option;
    host_org_gene: string option;
    host_org_scientific_name: string option;
    host_org_strain: string option;
    gene_src_ncbi_taxonomy_id: int option;
    host_org_ncbi_taxonomy_id: int option;
    host_org_vector_type: string option;
    plasmid_name: string option;
  }

  let default = {
    src_id = None;
    entity_id = None;
    seq_type = None;
    beg_seq_num = None;
    end_seq_num = None;
    gene_src_gene = None;
    gene_src_scientific_name = None;
    host_org_gene = None;
    host_org_scientific_name = None;
    host_org_strain = None;
    gene_src_ncbi_taxonomy_id = None;
    host_org_ncbi_taxonomy_id = None;
    host_org_vector_type = None;
    plasmid_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "src_id" -> { b with src_id = (PDBjDict.some_int v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "seq_type" -> { b with seq_type = (Some v) }
      | "beg_seq_num" -> { b with beg_seq_num = (PDBjDict.some_int v) }
      | "end_seq_num" -> { b with end_seq_num = (PDBjDict.some_int v) }
      | "gene_src_gene" -> { b with gene_src_gene = (Some v) }
      | "gene_src_scientific_name" -> { b with gene_src_scientific_name = (Some v) }
      | "host_org_gene" -> { b with host_org_gene = (Some v) }
      | "host_org_scientific_name" -> { b with host_org_scientific_name = (Some v) }
      | "host_org_strain" -> { b with host_org_strain = (Some v) }
      | "gene_src_ncbi_taxonomy_id" -> { b with gene_src_ncbi_taxonomy_id = (PDBjDict.some_int v) }
      | "host_org_ncbi_taxonomy_id" -> { b with host_org_ncbi_taxonomy_id = (PDBjDict.some_int v) }
      | "host_org_vector_type" -> { b with host_org_vector_type = (Some v) }
      | "plasmid_name" -> { b with plasmid_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("src_id", string_of_int v)) a.src_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("seq_type",  v)) a.seq_type;
      Option.map (fun v -> ("beg_seq_num", string_of_int v)) a.beg_seq_num;
      Option.map (fun v -> ("end_seq_num", string_of_int v)) a.end_seq_num;
      Option.map (fun v -> ("gene_src_gene",  v)) a.gene_src_gene;
      Option.map (fun v -> ("gene_src_scientific_name",  v)) a.gene_src_scientific_name;
      Option.map (fun v -> ("host_org_gene",  v)) a.host_org_gene;
      Option.map (fun v -> ("host_org_scientific_name",  v)) a.host_org_scientific_name;
      Option.map (fun v -> ("host_org_strain",  v)) a.host_org_strain;
      Option.map (fun v -> ("gene_src_ncbi_taxonomy_id", string_of_int v)) a.gene_src_ncbi_taxonomy_id;
      Option.map (fun v -> ("host_org_ncbi_taxonomy_id", string_of_int v)) a.host_org_ncbi_taxonomy_id;
      Option.map (fun v -> ("host_org_vector_type",  v)) a.host_org_vector_type;
      Option.map (fun v -> ("plasmid_name",  v)) a.plasmid_name;
    ]

end

module Pdbx_chem_comp_model = struct
  type t = {
    id: string option;
    comp_id: string option;
  }

  let default = {
    id = None;
    comp_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "comp_id" -> { b with comp_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
    ]

end

module Pdbx_chem_comp_model_atom = struct
  type t = {
    atom_id: string option;
    ordinal_id: int option;
    model_id: string option;
    charge: int option;
    model_Cartn_x: float option;
    model_Cartn_y: float option;
    model_Cartn_z: float option;
    type_symbol: string option;
  }

  let default = {
    atom_id = None;
    ordinal_id = None;
    model_id = None;
    charge = None;
    model_Cartn_x = None;
    model_Cartn_y = None;
    model_Cartn_z = None;
    type_symbol = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_id" -> { b with atom_id = (Some v) }
      | "ordinal_id" -> { b with ordinal_id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (Some v) }
      | "charge" -> { b with charge = (PDBjDict.some_int v) }
      | "model_Cartn_x" -> { b with model_Cartn_x = (PDBjDict.some_float v) }
      | "model_Cartn_y" -> { b with model_Cartn_y = (PDBjDict.some_float v) }
      | "model_Cartn_z" -> { b with model_Cartn_z = (PDBjDict.some_float v) }
      | "type_symbol" -> { b with type_symbol = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_id",  v)) a.atom_id;
      Option.map (fun v -> ("ordinal_id", string_of_int v)) a.ordinal_id;
      Option.map (fun v -> ("model_id",  v)) a.model_id;
      Option.map (fun v -> ("charge", string_of_int v)) a.charge;
      Option.map (fun v -> ("model_Cartn_x", string_of_float v)) a.model_Cartn_x;
      Option.map (fun v -> ("model_Cartn_y", string_of_float v)) a.model_Cartn_y;
      Option.map (fun v -> ("model_Cartn_z", string_of_float v)) a.model_Cartn_z;
      Option.map (fun v -> ("type_symbol",  v)) a.type_symbol;
    ]

end

module Pdbx_chem_comp_model_bond = struct
  type t = {
    atom_id_1: string option;
    atom_id_2: string option;
    model_id: string option;
    value_order: string option;
    ordinal_id: int option;
  }

  let default = {
    atom_id_1 = None;
    atom_id_2 = None;
    model_id = None;
    value_order = None;
    ordinal_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "atom_id_1" -> { b with atom_id_1 = (Some v) }
      | "atom_id_2" -> { b with atom_id_2 = (Some v) }
      | "model_id" -> { b with model_id = (Some v) }
      | "value_order" -> { b with value_order = (Some v) }
      | "ordinal_id" -> { b with ordinal_id = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("atom_id_1",  v)) a.atom_id_1;
      Option.map (fun v -> ("atom_id_2",  v)) a.atom_id_2;
      Option.map (fun v -> ("model_id",  v)) a.model_id;
      Option.map (fun v -> ("value_order",  v)) a.value_order;
      Option.map (fun v -> ("ordinal_id", string_of_int v)) a.ordinal_id;
    ]

end

module Pdbx_chem_comp_model_feature = struct
  type t = {
    model_id: string option;
    feature_name: string option;
    feature_value: string option;
  }

  let default = {
    model_id = None;
    feature_name = None;
    feature_value = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "model_id" -> { b with model_id = (Some v) }
      | "feature_name" -> { b with feature_name = (Some v) }
      | "feature_value" -> { b with feature_value = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("model_id",  v)) a.model_id;
      Option.map (fun v -> ("feature_name",  v)) a.feature_name;
      Option.map (fun v -> ("feature_value",  v)) a.feature_value;
    ]

end

module Pdbx_chem_comp_model_descriptor = struct
  type t = {
    model_id: string option;
    descriptor: string option;
    type_: string option;
  }

  let default = {
    model_id = None;
    descriptor = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "model_id" -> { b with model_id = (Some v) }
      | "descriptor" -> { b with descriptor = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("model_id",  v)) a.model_id;
      Option.map (fun v -> ("descriptor",  v)) a.descriptor;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_chem_comp_model_audit = struct
  type t = {
    model_id: string option;
    date: string option;
    annotator: string option;
    processing_site: string option;
    details: string option;
    action_type: string option;
  }

  let default = {
    model_id = None;
    date = None;
    annotator = None;
    processing_site = None;
    details = None;
    action_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "model_id" -> { b with model_id = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "annotator" -> { b with annotator = (Some v) }
      | "processing_site" -> { b with processing_site = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "action_type" -> { b with action_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("model_id",  v)) a.model_id;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("annotator",  v)) a.annotator;
      Option.map (fun v -> ("processing_site",  v)) a.processing_site;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("action_type",  v)) a.action_type;
    ]

end

module Pdbx_chem_comp_model_reference = struct
  type t = {
    model_id: string option;
    db_name: string option;
    db_code: string option;
  }

  let default = {
    model_id = None;
    db_name = None;
    db_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "model_id" -> { b with model_id = (Some v) }
      | "db_name" -> { b with db_name = (Some v) }
      | "db_code" -> { b with db_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("model_id",  v)) a.model_id;
      Option.map (fun v -> ("db_name",  v)) a.db_name;
      Option.map (fun v -> ("db_code",  v)) a.db_code;
    ]

end

module Pdbx_view_category_group = struct
  type t = {
    view_group_id: string option;
    description: string option;
  }

  let default = {
    view_group_id = None;
    description = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "view_group_id" -> { b with view_group_id = (Some v) }
      | "description" -> { b with description = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("view_group_id",  v)) a.view_group_id;
      Option.map (fun v -> ("description",  v)) a.description;
    ]

end

module Pdbx_view_category = struct
  type t = {
    view_group_id: string option;
    category_id: string option;
    category_view_name: string option;
  }

  let default = {
    view_group_id = None;
    category_id = None;
    category_view_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "view_group_id" -> { b with view_group_id = (Some v) }
      | "category_id" -> { b with category_id = (Some v) }
      | "category_view_name" -> { b with category_view_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("view_group_id",  v)) a.view_group_id;
      Option.map (fun v -> ("category_id",  v)) a.category_id;
      Option.map (fun v -> ("category_view_name",  v)) a.category_view_name;
    ]

end

module Pdbx_view_item = struct
  type t = {
    item_name: string option;
    category_id: string option;
    item_view_name: string option;
    item_view_mandatory_code: string option;
    item_view_allow_alternate_value: string option;
  }

  let default = {
    item_name = None;
    category_id = None;
    item_view_name = None;
    item_view_mandatory_code = None;
    item_view_allow_alternate_value = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "item_name" -> { b with item_name = (Some v) }
      | "category_id" -> { b with category_id = (Some v) }
      | "item_view_name" -> { b with item_view_name = (Some v) }
      | "item_view_mandatory_code" -> { b with item_view_mandatory_code = (Some v) }
      | "item_view_allow_alternate_value" -> { b with item_view_allow_alternate_value = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("item_name",  v)) a.item_name;
      Option.map (fun v -> ("category_id",  v)) a.category_id;
      Option.map (fun v -> ("item_view_name",  v)) a.item_view_name;
      Option.map (fun v -> ("item_view_mandatory_code",  v)) a.item_view_mandatory_code;
      Option.map (fun v -> ("item_view_allow_alternate_value",  v)) a.item_view_allow_alternate_value;
    ]

end

module Pdbx_coord = struct
  type t = {
    entry_id: string option;
    chain_atoms_Y_P: string option;
    hydrogen_atoms_Y_N: string option;
    solvent_atoms_Y_N: string option;
    structure_factors_Y_N: string option;
  }

  let default = {
    entry_id = None;
    chain_atoms_Y_P = None;
    hydrogen_atoms_Y_N = None;
    solvent_atoms_Y_N = None;
    structure_factors_Y_N = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "chain_atoms_Y_P" -> { b with chain_atoms_Y_P = (Some v) }
      | "hydrogen_atoms_Y_N" -> { b with hydrogen_atoms_Y_N = (Some v) }
      | "solvent_atoms_Y_N" -> { b with solvent_atoms_Y_N = (Some v) }
      | "structure_factors_Y_N" -> { b with structure_factors_Y_N = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("chain_atoms_Y_P",  v)) a.chain_atoms_Y_P;
      Option.map (fun v -> ("hydrogen_atoms_Y_N",  v)) a.hydrogen_atoms_Y_N;
      Option.map (fun v -> ("solvent_atoms_Y_N",  v)) a.solvent_atoms_Y_N;
      Option.map (fun v -> ("structure_factors_Y_N",  v)) a.structure_factors_Y_N;
    ]

end

module Pdbx_connect = struct
  type t = {
    res_name: string option;
    hetgroup_name: string option;
    formul: string option;
    hetgroup_chemical_name: string option;
    parent_residue: string option;
    formal_charge: int option;
    class_1: string option;
    class_2: string option;
    type_: string option;
    status: string option;
    date: string option;
    modified_date: string option;
  }

  let default = {
    res_name = None;
    hetgroup_name = None;
    formul = None;
    hetgroup_chemical_name = None;
    parent_residue = None;
    formal_charge = None;
    class_1 = None;
    class_2 = None;
    type_ = None;
    status = None;
    date = None;
    modified_date = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "res_name" -> { b with res_name = (Some v) }
      | "hetgroup_name" -> { b with hetgroup_name = (Some v) }
      | "formul" -> { b with formul = (Some v) }
      | "hetgroup_chemical_name" -> { b with hetgroup_chemical_name = (Some v) }
      | "parent_residue" -> { b with parent_residue = (Some v) }
      | "formal_charge" -> { b with formal_charge = (PDBjDict.some_int v) }
      | "class_1" -> { b with class_1 = (Some v) }
      | "class_2" -> { b with class_2 = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "status" -> { b with status = (Some v) }
      | "date" -> { b with date = (Some v) }
      | "modified_date" -> { b with modified_date = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("res_name",  v)) a.res_name;
      Option.map (fun v -> ("hetgroup_name",  v)) a.hetgroup_name;
      Option.map (fun v -> ("formul",  v)) a.formul;
      Option.map (fun v -> ("hetgroup_chemical_name",  v)) a.hetgroup_chemical_name;
      Option.map (fun v -> ("parent_residue",  v)) a.parent_residue;
      Option.map (fun v -> ("formal_charge", string_of_int v)) a.formal_charge;
      Option.map (fun v -> ("class_1",  v)) a.class_1;
      Option.map (fun v -> ("class_2",  v)) a.class_2;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("status",  v)) a.status;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("modified_date",  v)) a.modified_date;
    ]

end

module Pdbx_connect_type = struct
  type t = {
    res_name: string option;
    ndbTokenType: string option;
    modified: string option;
  }

  let default = {
    res_name = None;
    ndbTokenType = None;
    modified = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "res_name" -> { b with res_name = (Some v) }
      | "ndbTokenType" -> { b with ndbTokenType = (Some v) }
      | "modified" -> { b with modified = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("res_name",  v)) a.res_name;
      Option.map (fun v -> ("ndbTokenType",  v)) a.ndbTokenType;
      Option.map (fun v -> ("modified",  v)) a.modified;
    ]

end

module Pdbx_connect_modification = struct
  type t = {
    res_name: string option;
    modification: string option;
  }

  let default = {
    res_name = None;
    modification = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "res_name" -> { b with res_name = (Some v) }
      | "modification" -> { b with modification = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("res_name",  v)) a.res_name;
      Option.map (fun v -> ("modification",  v)) a.modification;
    ]

end

module Pdbx_connect_atom = struct
  type t = {
    res_name: string option;
    atom_name: string option;
    connect_to: string option;
    type_symbol: string option;
    charge: int option;
    bond_type: string option;
    align_pos: int option;
  }

  let default = {
    res_name = None;
    atom_name = None;
    connect_to = None;
    type_symbol = None;
    charge = None;
    bond_type = None;
    align_pos = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "res_name" -> { b with res_name = (Some v) }
      | "atom_name" -> { b with atom_name = (Some v) }
      | "connect_to" -> { b with connect_to = (Some v) }
      | "type_symbol" -> { b with type_symbol = (Some v) }
      | "charge" -> { b with charge = (PDBjDict.some_int v) }
      | "bond_type" -> { b with bond_type = (Some v) }
      | "align_pos" -> { b with align_pos = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("res_name",  v)) a.res_name;
      Option.map (fun v -> ("atom_name",  v)) a.atom_name;
      Option.map (fun v -> ("connect_to",  v)) a.connect_to;
      Option.map (fun v -> ("type_symbol",  v)) a.type_symbol;
      Option.map (fun v -> ("charge", string_of_int v)) a.charge;
      Option.map (fun v -> ("bond_type",  v)) a.bond_type;
      Option.map (fun v -> ("align_pos", string_of_int v)) a.align_pos;
    ]

end

module Pdbx_database_PDB_master = struct
  type t = {
    entry_id: string option;
    num_remark: int option;
    num_ftnote: int option;
    num_het: int option;
    num_helix: int option;
    num_sheet: int option;
    num_turn: int option;
    num_site: int option;
    num_trans: int option;
    num_coord: int option;
    num_ter: int option;
    num_conect: int option;
    num_seqres: int option;
  }

  let default = {
    entry_id = None;
    num_remark = None;
    num_ftnote = None;
    num_het = None;
    num_helix = None;
    num_sheet = None;
    num_turn = None;
    num_site = None;
    num_trans = None;
    num_coord = None;
    num_ter = None;
    num_conect = None;
    num_seqres = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "num_remark" -> { b with num_remark = (PDBjDict.some_int v) }
      | "num_ftnote" -> { b with num_ftnote = (PDBjDict.some_int v) }
      | "num_het" -> { b with num_het = (PDBjDict.some_int v) }
      | "num_helix" -> { b with num_helix = (PDBjDict.some_int v) }
      | "num_sheet" -> { b with num_sheet = (PDBjDict.some_int v) }
      | "num_turn" -> { b with num_turn = (PDBjDict.some_int v) }
      | "num_site" -> { b with num_site = (PDBjDict.some_int v) }
      | "num_trans" -> { b with num_trans = (PDBjDict.some_int v) }
      | "num_coord" -> { b with num_coord = (PDBjDict.some_int v) }
      | "num_ter" -> { b with num_ter = (PDBjDict.some_int v) }
      | "num_conect" -> { b with num_conect = (PDBjDict.some_int v) }
      | "num_seqres" -> { b with num_seqres = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("num_remark", string_of_int v)) a.num_remark;
      Option.map (fun v -> ("num_ftnote", string_of_int v)) a.num_ftnote;
      Option.map (fun v -> ("num_het", string_of_int v)) a.num_het;
      Option.map (fun v -> ("num_helix", string_of_int v)) a.num_helix;
      Option.map (fun v -> ("num_sheet", string_of_int v)) a.num_sheet;
      Option.map (fun v -> ("num_turn", string_of_int v)) a.num_turn;
      Option.map (fun v -> ("num_site", string_of_int v)) a.num_site;
      Option.map (fun v -> ("num_trans", string_of_int v)) a.num_trans;
      Option.map (fun v -> ("num_coord", string_of_int v)) a.num_coord;
      Option.map (fun v -> ("num_ter", string_of_int v)) a.num_ter;
      Option.map (fun v -> ("num_conect", string_of_int v)) a.num_conect;
      Option.map (fun v -> ("num_seqres", string_of_int v)) a.num_seqres;
    ]

end

module Pdbx_database_pdb_omit = struct
  type t = {
    entry_id: string option;
    record_name: string option;
  }

  let default = {
    entry_id = None;
    record_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "record_name" -> { b with record_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("record_name",  v)) a.record_name;
    ]

end

module Pdbx_dbref = struct
  type t = {
    pdb_id_code: string option;
    chain_id: string option;
    begin_res_number: string option;
    begin_ins_code: string option;
    end_res_number: string option;
    end_ins_code: string option;
    database_name: string option;
    database_accession: string option;
    database_id_code: string option;
    database_begin_res_number: string option;
    database_begin_ins_code: string option;
    database_end_res_number: string option;
    database_end_ins_code: string option;
  }

  let default = {
    pdb_id_code = None;
    chain_id = None;
    begin_res_number = None;
    begin_ins_code = None;
    end_res_number = None;
    end_ins_code = None;
    database_name = None;
    database_accession = None;
    database_id_code = None;
    database_begin_res_number = None;
    database_begin_ins_code = None;
    database_end_res_number = None;
    database_end_ins_code = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdb_id_code" -> { b with pdb_id_code = (Some v) }
      | "chain_id" -> { b with chain_id = (Some v) }
      | "begin_res_number" -> { b with begin_res_number = (Some v) }
      | "begin_ins_code" -> { b with begin_ins_code = (Some v) }
      | "end_res_number" -> { b with end_res_number = (Some v) }
      | "end_ins_code" -> { b with end_ins_code = (Some v) }
      | "database_name" -> { b with database_name = (Some v) }
      | "database_accession" -> { b with database_accession = (Some v) }
      | "database_id_code" -> { b with database_id_code = (Some v) }
      | "database_begin_res_number" -> { b with database_begin_res_number = (Some v) }
      | "database_begin_ins_code" -> { b with database_begin_ins_code = (Some v) }
      | "database_end_res_number" -> { b with database_end_res_number = (Some v) }
      | "database_end_ins_code" -> { b with database_end_ins_code = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdb_id_code",  v)) a.pdb_id_code;
      Option.map (fun v -> ("chain_id",  v)) a.chain_id;
      Option.map (fun v -> ("begin_res_number",  v)) a.begin_res_number;
      Option.map (fun v -> ("begin_ins_code",  v)) a.begin_ins_code;
      Option.map (fun v -> ("end_res_number",  v)) a.end_res_number;
      Option.map (fun v -> ("end_ins_code",  v)) a.end_ins_code;
      Option.map (fun v -> ("database_name",  v)) a.database_name;
      Option.map (fun v -> ("database_accession",  v)) a.database_accession;
      Option.map (fun v -> ("database_id_code",  v)) a.database_id_code;
      Option.map (fun v -> ("database_begin_res_number",  v)) a.database_begin_res_number;
      Option.map (fun v -> ("database_begin_ins_code",  v)) a.database_begin_ins_code;
      Option.map (fun v -> ("database_end_res_number",  v)) a.database_end_res_number;
      Option.map (fun v -> ("database_end_ins_code",  v)) a.database_end_ins_code;
    ]

end

module Pdbx_drug_info = struct
  type t = {
    id: string option;
    name: string option;
    num_per_asym_unit: int option;
    num_of_whole_molecule: int option;
    size_of_molecule_per_asym_unit: string option;
  }

  let default = {
    id = None;
    name = None;
    num_per_asym_unit = None;
    num_of_whole_molecule = None;
    size_of_molecule_per_asym_unit = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "num_per_asym_unit" -> { b with num_per_asym_unit = (PDBjDict.some_int v) }
      | "num_of_whole_molecule" -> { b with num_of_whole_molecule = (PDBjDict.some_int v) }
      | "size_of_molecule_per_asym_unit" -> { b with size_of_molecule_per_asym_unit = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("num_per_asym_unit", string_of_int v)) a.num_per_asym_unit;
      Option.map (fun v -> ("num_of_whole_molecule", string_of_int v)) a.num_of_whole_molecule;
      Option.map (fun v -> ("size_of_molecule_per_asym_unit",  v)) a.size_of_molecule_per_asym_unit;
    ]

end

module Pdbx_inhibitor_info = struct
  type t = {
    id: int option;
    name: string option;
    num_per_asym_unit: int option;
  }

  let default = {
    id = None;
    name = None;
    num_per_asym_unit = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "name" -> { b with name = (Some v) }
      | "num_per_asym_unit" -> { b with num_per_asym_unit = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("num_per_asym_unit", string_of_int v)) a.num_per_asym_unit;
    ]

end

module Pdbx_ion_info = struct
  type t = {
    id: string option;
    name: string option;
    numb_per_asym_unit: int option;
  }

  let default = {
    id = None;
    name = None;
    numb_per_asym_unit = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "numb_per_asym_unit" -> { b with numb_per_asym_unit = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("numb_per_asym_unit", string_of_int v)) a.numb_per_asym_unit;
    ]

end

module Pdbx_hybrid = struct
  type t = {
    id: string option;
    sugar_name: string option;
    strand_id: string option;
    residue_names: string option;
  }

  let default = {
    id = None;
    sugar_name = None;
    strand_id = None;
    residue_names = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "sugar_name" -> { b with sugar_name = (Some v) }
      | "strand_id" -> { b with strand_id = (Some v) }
      | "residue_names" -> { b with residue_names = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("sugar_name",  v)) a.sugar_name;
      Option.map (fun v -> ("strand_id",  v)) a.strand_id;
      Option.map (fun v -> ("residue_names",  v)) a.residue_names;
    ]

end

module Pdbx_na_strand_info = struct
  type t = {
    id: string option;
    num_of_NA_strands_per_asym_unit: int option;
    num_of_NA_strands_per_biol_unit: int option;
    fract_NA_strand_per_asym_unit: string option;
  }

  let default = {
    id = None;
    num_of_NA_strands_per_asym_unit = None;
    num_of_NA_strands_per_biol_unit = None;
    fract_NA_strand_per_asym_unit = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "num_of_NA_strands_per_asym_unit" -> { b with num_of_NA_strands_per_asym_unit = (PDBjDict.some_int v) }
      | "num_of_NA_strands_per_biol_unit" -> { b with num_of_NA_strands_per_biol_unit = (PDBjDict.some_int v) }
      | "fract_NA_strand_per_asym_unit" -> { b with fract_NA_strand_per_asym_unit = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("num_of_NA_strands_per_asym_unit", string_of_int v)) a.num_of_NA_strands_per_asym_unit;
      Option.map (fun v -> ("num_of_NA_strands_per_biol_unit", string_of_int v)) a.num_of_NA_strands_per_biol_unit;
      Option.map (fun v -> ("fract_NA_strand_per_asym_unit",  v)) a.fract_NA_strand_per_asym_unit;
    ]

end

module Pdbx_nonstandard_list = struct
  type t = {
    id: string option;
    auth_asym_id: string option;
    auth_seq_id: string option;
    label_asym_id: string option;
    label_seq_num: string option;
    label_seq_id: int option;
    ins_code: string option;
    number_atoms_nh: int option;
  }

  let default = {
    id = None;
    auth_asym_id = None;
    auth_seq_id = None;
    label_asym_id = None;
    label_seq_num = None;
    label_seq_id = None;
    ins_code = None;
    number_atoms_nh = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_seq_num" -> { b with label_seq_num = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "ins_code" -> { b with ins_code = (Some v) }
      | "number_atoms_nh" -> { b with number_atoms_nh = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_seq_num",  v)) a.label_seq_num;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("ins_code",  v)) a.ins_code;
      Option.map (fun v -> ("number_atoms_nh", string_of_int v)) a.number_atoms_nh;
    ]

end

module Pdbx_pdb_compnd = struct
  type t = {
    id: string option;
    text: string option;
  }

  let default = {
    id = None;
    text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "text" -> { b with text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("text",  v)) a.text;
    ]

end

module Pdbx_pdb_source = struct
  type t = {
    id: string option;
    text: string option;
  }

  let default = {
    id = None;
    text = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "text" -> { b with text = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("text",  v)) a.text;
    ]

end

module Pdbx_protein_info = struct
  type t = {
    id: string option;
    name: string option;
    num_per_asym_unit: int option;
  }

  let default = {
    id = None;
    name = None;
    num_per_asym_unit = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "num_per_asym_unit" -> { b with num_per_asym_unit = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("num_per_asym_unit", string_of_int v)) a.num_per_asym_unit;
    ]

end

module Pdbx_solvent_info = struct
  type t = {
    id: string option;
    name: string option;
    numb_per_asym_unit: int option;
  }

  let default = {
    id = None;
    name = None;
    numb_per_asym_unit = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "numb_per_asym_unit" -> { b with numb_per_asym_unit = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("numb_per_asym_unit", string_of_int v)) a.numb_per_asym_unit;
    ]

end

module Pdbx_source = struct
  type t = {
    src_method: string option;
  }

  let default = {
    src_method = None;
  }

  let of_mmCIF items =
    match items with
    | [] -> default
    | (_,v)::_ -> { src_method = (Some v) }

  let to_mmCIF a =
    match a.src_method with
    | None -> []
    | Some v -> [ ("src_method",( v)) ]

end

module Pdbx_struct_biol_func = struct
  type t = {
    id: string option;
    biol_id: string option;
    function_: string option;
  }

  let default = {
    id = None;
    biol_id = None;
    function_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "biol_id" -> { b with biol_id = (Some v) }
      | "function" -> { b with function_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("biol_id",  v)) a.biol_id;
      Option.map (fun v -> ("function",  v)) a.function_;
    ]

end

module Pdbx_struct_pack_gen = struct
  type t = {
    id: string option;
    asym_id: string option;
    symmetry: string option;
    color_red: float option;
    color_green: float option;
    color_blue: float option;
    crystal_type: int option;
    packing_type: int option;
  }

  let default = {
    id = None;
    asym_id = None;
    symmetry = None;
    color_red = None;
    color_green = None;
    color_blue = None;
    crystal_type = None;
    packing_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | "symmetry" -> { b with symmetry = (Some v) }
      | "color_red" -> { b with color_red = (PDBjDict.some_float v) }
      | "color_green" -> { b with color_green = (PDBjDict.some_float v) }
      | "color_blue" -> { b with color_blue = (PDBjDict.some_float v) }
      | "crystal_type" -> { b with crystal_type = (PDBjDict.some_int v) }
      | "packing_type" -> { b with packing_type = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("symmetry",  v)) a.symmetry;
      Option.map (fun v -> ("color_red", string_of_float v)) a.color_red;
      Option.map (fun v -> ("color_green", string_of_float v)) a.color_green;
      Option.map (fun v -> ("color_blue", string_of_float v)) a.color_blue;
      Option.map (fun v -> ("crystal_type", string_of_int v)) a.crystal_type;
      Option.map (fun v -> ("packing_type", string_of_int v)) a.packing_type;
    ]

end

module Pdbx_trna_info = struct
  type t = {
    id: string option;
    name: string option;
    num_per_asym_unit: int option;
  }

  let default = {
    id = None;
    name = None;
    num_per_asym_unit = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "num_per_asym_unit" -> { b with num_per_asym_unit = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("num_per_asym_unit", string_of_int v)) a.num_per_asym_unit;
    ]

end

module Pdbx_unpair = struct
  type t = {
    chain_id: string option;
    residue_name: string option;
    residue_number: string option;
  }

  let default = {
    chain_id = None;
    residue_name = None;
    residue_number = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "chain_id" -> { b with chain_id = (Some v) }
      | "residue_name" -> { b with residue_name = (Some v) }
      | "residue_number" -> { b with residue_number = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("chain_id",  v)) a.chain_id;
      Option.map (fun v -> ("residue_name",  v)) a.residue_name;
      Option.map (fun v -> ("residue_number",  v)) a.residue_number;
    ]

end

module Pdbx_refine_ls_restr_ncs = struct
  type t = {
    dom_id: string option;
    type_: string option;
    number: int option;
    rms_dev: float option;
    weight: float option;
  }

  let default = {
    dom_id = None;
    type_ = None;
    number = None;
    rms_dev = None;
    weight = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "dom_id" -> { b with dom_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "number" -> { b with number = (PDBjDict.some_int v) }
      | "rms_dev" -> { b with rms_dev = (PDBjDict.some_float v) }
      | "weight" -> { b with weight = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("dom_id",  v)) a.dom_id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("number", string_of_int v)) a.number;
      Option.map (fun v -> ("rms_dev", string_of_float v)) a.rms_dev;
      Option.map (fun v -> ("weight", string_of_float v)) a.weight;
    ]

end

module Pdbx_struct_ncs_virus_gen = struct
  type t = {
    id: string option;
    oper_id: string option;
    asym_id: string option;
    pdb_chain_id: string option;
  }

  let default = {
    id = None;
    oper_id = None;
    asym_id = None;
    pdb_chain_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "oper_id" -> { b with oper_id = (Some v) }
      | "asym_id" -> { b with asym_id = (Some v) }
      | "pdb_chain_id" -> { b with pdb_chain_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("oper_id",  v)) a.oper_id;
      Option.map (fun v -> ("asym_id",  v)) a.asym_id;
      Option.map (fun v -> ("pdb_chain_id",  v)) a.pdb_chain_id;
    ]

end

module Pdbx_sequence_annotation = struct
  type t = {
    pdb_chain_id: string option;
    ncbi_taxid: string option;
  }

  let default = {
    pdb_chain_id = None;
    ncbi_taxid = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdb_chain_id" -> { b with pdb_chain_id = (Some v) }
      | "ncbi_taxid" -> { b with ncbi_taxid = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdb_chain_id",  v)) a.pdb_chain_id;
      Option.map (fun v -> ("ncbi_taxid",  v)) a.ncbi_taxid;
    ]

end

module Pdbx_chem_comp_synonyms = struct
  type t = {
    name: string option;
    synonym: string option;
  }

  let default = {
    name = None;
    synonym = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "name" -> { b with name = (Some v) }
      | "synonym" -> { b with synonym = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("synonym",  v)) a.synonym;
    ]

end

module Pdbx_post_process_details = struct
  type t = {
    entry_id: string option;
    text: string option;
    seq_details: string option;
  }

  let default = {
    entry_id = None;
    text = None;
    seq_details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "text" -> { b with text = (Some v) }
      | "seq_details" -> { b with seq_details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("text",  v)) a.text;
      Option.map (fun v -> ("seq_details",  v)) a.seq_details;
    ]

end

module Pdbx_post_process_status = struct
  type t = {
    entry_id: string option;
    cycle_id: string option;
    date_begin: string option;
    date_end: string option;
    details: string option;
    annotator: string option;
  }

  let default = {
    entry_id = None;
    cycle_id = None;
    date_begin = None;
    date_end = None;
    details = None;
    annotator = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "cycle_id" -> { b with cycle_id = (Some v) }
      | "date_begin" -> { b with date_begin = (Some v) }
      | "date_end" -> { b with date_end = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "annotator" -> { b with annotator = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("cycle_id",  v)) a.cycle_id;
      Option.map (fun v -> ("date_begin",  v)) a.date_begin;
      Option.map (fun v -> ("date_end",  v)) a.date_end;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("annotator",  v)) a.annotator;
    ]

end

module Pdbx_struct_link = struct
  type t = {
    id: string option;
    type_: string option;
    ptnr1_label_alt_id: string option;
    ptnr1_label_asym_id: string option;
    ptnr1_label_atom_id: string option;
    ptnr1_label_comp_id: string option;
    ptnr1_label_seq_id: int option;
    ptnr1_label_ins_code: string option;
    ptnr1_symmetry: string option;
    ptnr2_label_alt_id: string option;
    ptnr2_label_asym_id: string option;
    ptnr2_label_atom_id: string option;
    ptnr2_label_comp_id: string option;
    ptnr2_label_seq_id: int option;
    ptnr2_label_ins_code: string option;
    ptnr2_symmetry: string option;
    details: string option;
    pdbx_dist_value: float option;
  }

  let default = {
    id = None;
    type_ = None;
    ptnr1_label_alt_id = None;
    ptnr1_label_asym_id = None;
    ptnr1_label_atom_id = None;
    ptnr1_label_comp_id = None;
    ptnr1_label_seq_id = None;
    ptnr1_label_ins_code = None;
    ptnr1_symmetry = None;
    ptnr2_label_alt_id = None;
    ptnr2_label_asym_id = None;
    ptnr2_label_atom_id = None;
    ptnr2_label_comp_id = None;
    ptnr2_label_seq_id = None;
    ptnr2_label_ins_code = None;
    ptnr2_symmetry = None;
    details = None;
    pdbx_dist_value = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "ptnr1_label_alt_id" -> { b with ptnr1_label_alt_id = (Some v) }
      | "ptnr1_label_asym_id" -> { b with ptnr1_label_asym_id = (Some v) }
      | "ptnr1_label_atom_id" -> { b with ptnr1_label_atom_id = (Some v) }
      | "ptnr1_label_comp_id" -> { b with ptnr1_label_comp_id = (Some v) }
      | "ptnr1_label_seq_id" -> { b with ptnr1_label_seq_id = (PDBjDict.some_int v) }
      | "ptnr1_label_ins_code" -> { b with ptnr1_label_ins_code = (Some v) }
      | "ptnr1_symmetry" -> { b with ptnr1_symmetry = (Some v) }
      | "ptnr2_label_alt_id" -> { b with ptnr2_label_alt_id = (Some v) }
      | "ptnr2_label_asym_id" -> { b with ptnr2_label_asym_id = (Some v) }
      | "ptnr2_label_atom_id" -> { b with ptnr2_label_atom_id = (Some v) }
      | "ptnr2_label_comp_id" -> { b with ptnr2_label_comp_id = (Some v) }
      | "ptnr2_label_seq_id" -> { b with ptnr2_label_seq_id = (PDBjDict.some_int v) }
      | "ptnr2_label_ins_code" -> { b with ptnr2_label_ins_code = (Some v) }
      | "ptnr2_symmetry" -> { b with ptnr2_symmetry = (Some v) }
      | "details" -> { b with details = (Some v) }
      | "pdbx_dist_value" -> { b with pdbx_dist_value = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("ptnr1_label_alt_id",  v)) a.ptnr1_label_alt_id;
      Option.map (fun v -> ("ptnr1_label_asym_id",  v)) a.ptnr1_label_asym_id;
      Option.map (fun v -> ("ptnr1_label_atom_id",  v)) a.ptnr1_label_atom_id;
      Option.map (fun v -> ("ptnr1_label_comp_id",  v)) a.ptnr1_label_comp_id;
      Option.map (fun v -> ("ptnr1_label_seq_id", string_of_int v)) a.ptnr1_label_seq_id;
      Option.map (fun v -> ("ptnr1_label_ins_code",  v)) a.ptnr1_label_ins_code;
      Option.map (fun v -> ("ptnr1_symmetry",  v)) a.ptnr1_symmetry;
      Option.map (fun v -> ("ptnr2_label_alt_id",  v)) a.ptnr2_label_alt_id;
      Option.map (fun v -> ("ptnr2_label_asym_id",  v)) a.ptnr2_label_asym_id;
      Option.map (fun v -> ("ptnr2_label_atom_id",  v)) a.ptnr2_label_atom_id;
      Option.map (fun v -> ("ptnr2_label_comp_id",  v)) a.ptnr2_label_comp_id;
      Option.map (fun v -> ("ptnr2_label_seq_id", string_of_int v)) a.ptnr2_label_seq_id;
      Option.map (fun v -> ("ptnr2_label_ins_code",  v)) a.ptnr2_label_ins_code;
      Option.map (fun v -> ("ptnr2_symmetry",  v)) a.ptnr2_symmetry;
      Option.map (fun v -> ("details",  v)) a.details;
      Option.map (fun v -> ("pdbx_dist_value", string_of_float v)) a.pdbx_dist_value;
    ]

end

module Pdbx_missing_residue_list = struct
  type t = {
    pdb_model_id: int option;
    pdb_chain_id: string option;
    pdb_residue_name: string option;
    pdb_residue_number: string option;
    pdb_insertion_code: string option;
    label_seq_id: int option;
  }

  let default = {
    pdb_model_id = None;
    pdb_chain_id = None;
    pdb_residue_name = None;
    pdb_residue_number = None;
    pdb_insertion_code = None;
    label_seq_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdb_model_id" -> { b with pdb_model_id = (PDBjDict.some_int v) }
      | "pdb_chain_id" -> { b with pdb_chain_id = (Some v) }
      | "pdb_residue_name" -> { b with pdb_residue_name = (Some v) }
      | "pdb_residue_number" -> { b with pdb_residue_number = (Some v) }
      | "pdb_insertion_code" -> { b with pdb_insertion_code = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdb_model_id", string_of_int v)) a.pdb_model_id;
      Option.map (fun v -> ("pdb_chain_id",  v)) a.pdb_chain_id;
      Option.map (fun v -> ("pdb_residue_name",  v)) a.pdb_residue_name;
      Option.map (fun v -> ("pdb_residue_number",  v)) a.pdb_residue_number;
      Option.map (fun v -> ("pdb_insertion_code",  v)) a.pdb_insertion_code;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
    ]

end

module Pdbx_data_processing_cell = struct
  type t = {
    entry_id: string option;
    a: float option;
    a_tolerance: float option;
    b: float option;
    b_tolerance: float option;
    c: float option;
    c_tolerance: float option;
    alpha: float option;
    alpha_tolerance: float option;
    beta: float option;
    beta_tolerance: float option;
    gamma: float option;
    gamma_tolerance: float option;
    volume: float option;
    mosaicity: float option;
    resolution_range: string option;
    space_group: string option;
  }

  let default = {
    entry_id = None;
    a = None;
    a_tolerance = None;
    b = None;
    b_tolerance = None;
    c = None;
    c_tolerance = None;
    alpha = None;
    alpha_tolerance = None;
    beta = None;
    beta_tolerance = None;
    gamma = None;
    gamma_tolerance = None;
    volume = None;
    mosaicity = None;
    resolution_range = None;
    space_group = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "a" -> { b with a = (PDBjDict.some_float v) }
      | "a_tolerance" -> { b with a_tolerance = (PDBjDict.some_float v) }
      | "b" -> { b with b = (PDBjDict.some_float v) }
      | "b_tolerance" -> { b with b_tolerance = (PDBjDict.some_float v) }
      | "c" -> { b with c = (PDBjDict.some_float v) }
      | "c_tolerance" -> { b with c_tolerance = (PDBjDict.some_float v) }
      | "alpha" -> { b with alpha = (PDBjDict.some_float v) }
      | "alpha_tolerance" -> { b with alpha_tolerance = (PDBjDict.some_float v) }
      | "beta" -> { b with beta = (PDBjDict.some_float v) }
      | "beta_tolerance" -> { b with beta_tolerance = (PDBjDict.some_float v) }
      | "gamma" -> { b with gamma = (PDBjDict.some_float v) }
      | "gamma_tolerance" -> { b with gamma_tolerance = (PDBjDict.some_float v) }
      | "volume" -> { b with volume = (PDBjDict.some_float v) }
      | "mosaicity" -> { b with mosaicity = (PDBjDict.some_float v) }
      | "resolution_range" -> { b with resolution_range = (Some v) }
      | "space_group" -> { b with space_group = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("a", string_of_float v)) a.a;
      Option.map (fun v -> ("a_tolerance", string_of_float v)) a.a_tolerance;
      Option.map (fun v -> ("b", string_of_float v)) a.b;
      Option.map (fun v -> ("b_tolerance", string_of_float v)) a.b_tolerance;
      Option.map (fun v -> ("c", string_of_float v)) a.c;
      Option.map (fun v -> ("c_tolerance", string_of_float v)) a.c_tolerance;
      Option.map (fun v -> ("alpha", string_of_float v)) a.alpha;
      Option.map (fun v -> ("alpha_tolerance", string_of_float v)) a.alpha_tolerance;
      Option.map (fun v -> ("beta", string_of_float v)) a.beta;
      Option.map (fun v -> ("beta_tolerance", string_of_float v)) a.beta_tolerance;
      Option.map (fun v -> ("gamma", string_of_float v)) a.gamma;
      Option.map (fun v -> ("gamma_tolerance", string_of_float v)) a.gamma_tolerance;
      Option.map (fun v -> ("volume", string_of_float v)) a.volume;
      Option.map (fun v -> ("mosaicity", string_of_float v)) a.mosaicity;
      Option.map (fun v -> ("resolution_range",  v)) a.resolution_range;
      Option.map (fun v -> ("space_group",  v)) a.space_group;
    ]

end

module Pdbx_data_processing_reflns = struct
  type t = {
    entry_id: string option;
    number_all: int option;
    number_marked_reject: int option;
    percent_marked_reject: float option;
    percent_rejected: float option;
    r_factor_all_linear: float option;
  }

  let default = {
    entry_id = None;
    number_all = None;
    number_marked_reject = None;
    percent_marked_reject = None;
    percent_rejected = None;
    r_factor_all_linear = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "number_all" -> { b with number_all = (PDBjDict.some_int v) }
      | "number_marked_reject" -> { b with number_marked_reject = (PDBjDict.some_int v) }
      | "percent_marked_reject" -> { b with percent_marked_reject = (PDBjDict.some_float v) }
      | "percent_rejected" -> { b with percent_rejected = (PDBjDict.some_float v) }
      | "R_factor_all_linear" -> { b with r_factor_all_linear = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("number_all", string_of_int v)) a.number_all;
      Option.map (fun v -> ("number_marked_reject", string_of_int v)) a.number_marked_reject;
      Option.map (fun v -> ("percent_marked_reject", string_of_float v)) a.percent_marked_reject;
      Option.map (fun v -> ("percent_rejected", string_of_float v)) a.percent_rejected;
      Option.map (fun v -> ("R_factor_all_linear", string_of_float v)) a.r_factor_all_linear;
    ]

end

module Pdbx_data_processing_detector = struct
  type t = {
    entry_id: string option;
    name: string option;
    wavelength: float option;
    polarization: float option;
    beam_position_x: float option;
    beam_position_y: float option;
    cassette_rot_x: float option;
    cassette_rot_y: float option;
    cassette_rot_z: float option;
    scale_y: float option;
    skew: float option;
    crossfire_x: float option;
    crossfire_y: float option;
    crossfire_xy: float option;
    date: string option;
    experimentor: string option;
    crystal_data_id: string option;
    processing_path: string option;
    processing_files: string option;
  }

  let default = {
    entry_id = None;
    name = None;
    wavelength = None;
    polarization = None;
    beam_position_x = None;
    beam_position_y = None;
    cassette_rot_x = None;
    cassette_rot_y = None;
    cassette_rot_z = None;
    scale_y = None;
    skew = None;
    crossfire_x = None;
    crossfire_y = None;
    crossfire_xy = None;
    date = None;
    experimentor = None;
    crystal_data_id = None;
    processing_path = None;
    processing_files = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "wavelength" -> { b with wavelength = (PDBjDict.some_float v) }
      | "polarization" -> { b with polarization = (PDBjDict.some_float v) }
      | "beam_position_x" -> { b with beam_position_x = (PDBjDict.some_float v) }
      | "beam_position_y" -> { b with beam_position_y = (PDBjDict.some_float v) }
      | "cassette_rot_x" -> { b with cassette_rot_x = (PDBjDict.some_float v) }
      | "cassette_rot_y" -> { b with cassette_rot_y = (PDBjDict.some_float v) }
      | "cassette_rot_z" -> { b with cassette_rot_z = (PDBjDict.some_float v) }
      | "scale_y" -> { b with scale_y = (PDBjDict.some_float v) }
      | "skew" -> { b with skew = (PDBjDict.some_float v) }
      | "crossfire_x" -> { b with crossfire_x = (PDBjDict.some_float v) }
      | "crossfire_y" -> { b with crossfire_y = (PDBjDict.some_float v) }
      | "crossfire_xy" -> { b with crossfire_xy = (PDBjDict.some_float v) }
      | "date" -> { b with date = (Some v) }
      | "experimentor" -> { b with experimentor = (Some v) }
      | "crystal_data_id" -> { b with crystal_data_id = (Some v) }
      | "processing_path" -> { b with processing_path = (Some v) }
      | "processing_files" -> { b with processing_files = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("wavelength", string_of_float v)) a.wavelength;
      Option.map (fun v -> ("polarization", string_of_float v)) a.polarization;
      Option.map (fun v -> ("beam_position_x", string_of_float v)) a.beam_position_x;
      Option.map (fun v -> ("beam_position_y", string_of_float v)) a.beam_position_y;
      Option.map (fun v -> ("cassette_rot_x", string_of_float v)) a.cassette_rot_x;
      Option.map (fun v -> ("cassette_rot_y", string_of_float v)) a.cassette_rot_y;
      Option.map (fun v -> ("cassette_rot_z", string_of_float v)) a.cassette_rot_z;
      Option.map (fun v -> ("scale_y", string_of_float v)) a.scale_y;
      Option.map (fun v -> ("skew", string_of_float v)) a.skew;
      Option.map (fun v -> ("crossfire_x", string_of_float v)) a.crossfire_x;
      Option.map (fun v -> ("crossfire_y", string_of_float v)) a.crossfire_y;
      Option.map (fun v -> ("crossfire_xy", string_of_float v)) a.crossfire_xy;
      Option.map (fun v -> ("date",  v)) a.date;
      Option.map (fun v -> ("experimentor",  v)) a.experimentor;
      Option.map (fun v -> ("crystal_data_id",  v)) a.crystal_data_id;
      Option.map (fun v -> ("processing_path",  v)) a.processing_path;
      Option.map (fun v -> ("processing_files",  v)) a.processing_files;
    ]

end

module Pdbx_chem_comp_nonstandard = struct
  type t = {
    comp_id: string option;
    type_: string option;
  }

  let default = {
    comp_id = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "comp_id" -> { b with comp_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("comp_id",  v)) a.comp_id;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_entity_poly_protein_class = struct
  type t = {
    entity_id: string option;
    class_: string option;
  }

  let default = {
    entity_id = None;
    class_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "class" -> { b with class_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("class",  v)) a.class_;
    ]

end

module Pdbx_entity_name_taxonomy_tree = struct
  type t = {
    id: string option;
    parent_id: string option;
  }

  let default = {
    id = None;
    parent_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "parent_id" -> { b with parent_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("parent_id",  v)) a.parent_id;
    ]

end

module Pdbx_entity_name_taxonomy = struct
  type t = {
    id: string option;
    name: string option;
    name_type: string option;
  }

  let default = {
    id = None;
    name = None;
    name_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "name" -> { b with name = (Some v) }
      | "name_type" -> { b with name_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("name_type",  v)) a.name_type;
    ]

end

module Pdbx_entity_name_instance = struct
  type t = {
    name: string option;
    pdb_id: string option;
    rcsb_id: string option;
    entity_id: string option;
    pdb_chain_id: string option;
    pdb_mol_id: string option;
  }

  let default = {
    name = None;
    pdb_id = None;
    rcsb_id = None;
    entity_id = None;
    pdb_chain_id = None;
    pdb_mol_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "name" -> { b with name = (Some v) }
      | "pdb_id" -> { b with pdb_id = (Some v) }
      | "rcsb_id" -> { b with rcsb_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "pdb_chain_id" -> { b with pdb_chain_id = (Some v) }
      | "pdb_mol_id" -> { b with pdb_mol_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("name",  v)) a.name;
      Option.map (fun v -> ("pdb_id",  v)) a.pdb_id;
      Option.map (fun v -> ("rcsb_id",  v)) a.rcsb_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("pdb_chain_id",  v)) a.pdb_chain_id;
      Option.map (fun v -> ("pdb_mol_id",  v)) a.pdb_mol_id;
    ]

end

module Pdbx_tableinfo = struct
  type t = {
    tablename: string option;
    description: string option;
    type_: int option;
    table_serial_no: int option;
    group_name: string option;
    wWW_Selection_Criteria: int option;
    wWW_Report_Criteria: int option;
  }

  let default = {
    tablename = None;
    description = None;
    type_ = None;
    table_serial_no = None;
    group_name = None;
    wWW_Selection_Criteria = None;
    wWW_Report_Criteria = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "tablename" -> { b with tablename = (Some v) }
      | "description" -> { b with description = (Some v) }
      | "type" -> { b with type_ = (PDBjDict.some_int v) }
      | "table_serial_no" -> { b with table_serial_no = (PDBjDict.some_int v) }
      | "group_name" -> { b with group_name = (Some v) }
      | "WWW_Selection_Criteria" -> { b with wWW_Selection_Criteria = (PDBjDict.some_int v) }
      | "WWW_Report_Criteria" -> { b with wWW_Report_Criteria = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("tablename",  v)) a.tablename;
      Option.map (fun v -> ("description",  v)) a.description;
      Option.map (fun v -> ("type", string_of_int v)) a.type_;
      Option.map (fun v -> ("table_serial_no", string_of_int v)) a.table_serial_no;
      Option.map (fun v -> ("group_name",  v)) a.group_name;
      Option.map (fun v -> ("WWW_Selection_Criteria", string_of_int v)) a.wWW_Selection_Criteria;
      Option.map (fun v -> ("WWW_Report_Criteria", string_of_int v)) a.wWW_Report_Criteria;
    ]

end

module Pdbx_columninfo = struct
  type t = {
    columnname: string option;
    tablename: string option;
    description: string option;
    example: string option;
    type_: int option;
    table_serial_no: int option;
    column_serial_no: int option;
    wWW_Selection_Criteria: int option;
    wWW_Report_Criteria: int option;
  }

  let default = {
    columnname = None;
    tablename = None;
    description = None;
    example = None;
    type_ = None;
    table_serial_no = None;
    column_serial_no = None;
    wWW_Selection_Criteria = None;
    wWW_Report_Criteria = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "columnname" -> { b with columnname = (Some v) }
      | "tablename" -> { b with tablename = (Some v) }
      | "description" -> { b with description = (Some v) }
      | "example" -> { b with example = (Some v) }
      | "type" -> { b with type_ = (PDBjDict.some_int v) }
      | "table_serial_no" -> { b with table_serial_no = (PDBjDict.some_int v) }
      | "column_serial_no" -> { b with column_serial_no = (PDBjDict.some_int v) }
      | "WWW_Selection_Criteria" -> { b with wWW_Selection_Criteria = (PDBjDict.some_int v) }
      | "WWW_Report_Criteria" -> { b with wWW_Report_Criteria = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("columnname",  v)) a.columnname;
      Option.map (fun v -> ("tablename",  v)) a.tablename;
      Option.map (fun v -> ("description",  v)) a.description;
      Option.map (fun v -> ("example",  v)) a.example;
      Option.map (fun v -> ("type", string_of_int v)) a.type_;
      Option.map (fun v -> ("table_serial_no", string_of_int v)) a.table_serial_no;
      Option.map (fun v -> ("column_serial_no", string_of_int v)) a.column_serial_no;
      Option.map (fun v -> ("WWW_Selection_Criteria", string_of_int v)) a.wWW_Selection_Criteria;
      Option.map (fun v -> ("WWW_Report_Criteria", string_of_int v)) a.wWW_Report_Criteria;
    ]

end

module Pdbx_val_angle = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id_1: string option;
    auth_atom_id_1: string option;
    auth_comp_id_1: string option;
    auth_seq_id_1: string option;
    auth_atom_id_2: string option;
    auth_asym_id_2: string option;
    auth_comp_id_2: string option;
    auth_seq_id_2: string option;
    auth_atom_id_3: string option;
    auth_asym_id_3: string option;
    auth_comp_id_3: string option;
    auth_seq_id_3: string option;
    auth_PDB_insert_id_1: string option;
    auth_PDB_insert_id_2: string option;
    auth_PDB_insert_id_3: string option;
    label_alt_id_1: string option;
    label_asym_id_1: string option;
    label_atom_id_1: string option;
    label_comp_id_1: string option;
    label_seq_id_1: int option;
    label_alt_id_2: string option;
    label_asym_id_2: string option;
    label_atom_id_2: string option;
    label_comp_id_2: string option;
    label_seq_id_2: int option;
    label_alt_id_3: string option;
    label_asym_id_3: string option;
    label_atom_id_3: string option;
    label_comp_id_3: string option;
    label_seq_id_3: int option;
    angle: float option;
    angle_deviation: float option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id_1 = None;
    auth_atom_id_1 = None;
    auth_comp_id_1 = None;
    auth_seq_id_1 = None;
    auth_atom_id_2 = None;
    auth_asym_id_2 = None;
    auth_comp_id_2 = None;
    auth_seq_id_2 = None;
    auth_atom_id_3 = None;
    auth_asym_id_3 = None;
    auth_comp_id_3 = None;
    auth_seq_id_3 = None;
    auth_PDB_insert_id_1 = None;
    auth_PDB_insert_id_2 = None;
    auth_PDB_insert_id_3 = None;
    label_alt_id_1 = None;
    label_asym_id_1 = None;
    label_atom_id_1 = None;
    label_comp_id_1 = None;
    label_seq_id_1 = None;
    label_alt_id_2 = None;
    label_asym_id_2 = None;
    label_atom_id_2 = None;
    label_comp_id_2 = None;
    label_seq_id_2 = None;
    label_alt_id_3 = None;
    label_asym_id_3 = None;
    label_atom_id_3 = None;
    label_comp_id_3 = None;
    label_seq_id_3 = None;
    angle = None;
    angle_deviation = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id_1" -> { b with auth_asym_id_1 = (Some v) }
      | "auth_atom_id_1" -> { b with auth_atom_id_1 = (Some v) }
      | "auth_comp_id_1" -> { b with auth_comp_id_1 = (Some v) }
      | "auth_seq_id_1" -> { b with auth_seq_id_1 = (Some v) }
      | "auth_atom_id_2" -> { b with auth_atom_id_2 = (Some v) }
      | "auth_asym_id_2" -> { b with auth_asym_id_2 = (Some v) }
      | "auth_comp_id_2" -> { b with auth_comp_id_2 = (Some v) }
      | "auth_seq_id_2" -> { b with auth_seq_id_2 = (Some v) }
      | "auth_atom_id_3" -> { b with auth_atom_id_3 = (Some v) }
      | "auth_asym_id_3" -> { b with auth_asym_id_3 = (Some v) }
      | "auth_comp_id_3" -> { b with auth_comp_id_3 = (Some v) }
      | "auth_seq_id_3" -> { b with auth_seq_id_3 = (Some v) }
      | "auth_PDB_insert_id_1" -> { b with auth_PDB_insert_id_1 = (Some v) }
      | "auth_PDB_insert_id_2" -> { b with auth_PDB_insert_id_2 = (Some v) }
      | "auth_PDB_insert_id_3" -> { b with auth_PDB_insert_id_3 = (Some v) }
      | "label_alt_id_1" -> { b with label_alt_id_1 = (Some v) }
      | "label_asym_id_1" -> { b with label_asym_id_1 = (Some v) }
      | "label_atom_id_1" -> { b with label_atom_id_1 = (Some v) }
      | "label_comp_id_1" -> { b with label_comp_id_1 = (Some v) }
      | "label_seq_id_1" -> { b with label_seq_id_1 = (PDBjDict.some_int v) }
      | "label_alt_id_2" -> { b with label_alt_id_2 = (Some v) }
      | "label_asym_id_2" -> { b with label_asym_id_2 = (Some v) }
      | "label_atom_id_2" -> { b with label_atom_id_2 = (Some v) }
      | "label_comp_id_2" -> { b with label_comp_id_2 = (Some v) }
      | "label_seq_id_2" -> { b with label_seq_id_2 = (PDBjDict.some_int v) }
      | "label_alt_id_3" -> { b with label_alt_id_3 = (Some v) }
      | "label_asym_id_3" -> { b with label_asym_id_3 = (Some v) }
      | "label_atom_id_3" -> { b with label_atom_id_3 = (Some v) }
      | "label_comp_id_3" -> { b with label_comp_id_3 = (Some v) }
      | "label_seq_id_3" -> { b with label_seq_id_3 = (PDBjDict.some_int v) }
      | "angle" -> { b with angle = (PDBjDict.some_float v) }
      | "angle_deviation" -> { b with angle_deviation = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id_1",  v)) a.auth_asym_id_1;
      Option.map (fun v -> ("auth_atom_id_1",  v)) a.auth_atom_id_1;
      Option.map (fun v -> ("auth_comp_id_1",  v)) a.auth_comp_id_1;
      Option.map (fun v -> ("auth_seq_id_1",  v)) a.auth_seq_id_1;
      Option.map (fun v -> ("auth_atom_id_2",  v)) a.auth_atom_id_2;
      Option.map (fun v -> ("auth_asym_id_2",  v)) a.auth_asym_id_2;
      Option.map (fun v -> ("auth_comp_id_2",  v)) a.auth_comp_id_2;
      Option.map (fun v -> ("auth_seq_id_2",  v)) a.auth_seq_id_2;
      Option.map (fun v -> ("auth_atom_id_3",  v)) a.auth_atom_id_3;
      Option.map (fun v -> ("auth_asym_id_3",  v)) a.auth_asym_id_3;
      Option.map (fun v -> ("auth_comp_id_3",  v)) a.auth_comp_id_3;
      Option.map (fun v -> ("auth_seq_id_3",  v)) a.auth_seq_id_3;
      Option.map (fun v -> ("auth_PDB_insert_id_1",  v)) a.auth_PDB_insert_id_1;
      Option.map (fun v -> ("auth_PDB_insert_id_2",  v)) a.auth_PDB_insert_id_2;
      Option.map (fun v -> ("auth_PDB_insert_id_3",  v)) a.auth_PDB_insert_id_3;
      Option.map (fun v -> ("label_alt_id_1",  v)) a.label_alt_id_1;
      Option.map (fun v -> ("label_asym_id_1",  v)) a.label_asym_id_1;
      Option.map (fun v -> ("label_atom_id_1",  v)) a.label_atom_id_1;
      Option.map (fun v -> ("label_comp_id_1",  v)) a.label_comp_id_1;
      Option.map (fun v -> ("label_seq_id_1", string_of_int v)) a.label_seq_id_1;
      Option.map (fun v -> ("label_alt_id_2",  v)) a.label_alt_id_2;
      Option.map (fun v -> ("label_asym_id_2",  v)) a.label_asym_id_2;
      Option.map (fun v -> ("label_atom_id_2",  v)) a.label_atom_id_2;
      Option.map (fun v -> ("label_comp_id_2",  v)) a.label_comp_id_2;
      Option.map (fun v -> ("label_seq_id_2", string_of_int v)) a.label_seq_id_2;
      Option.map (fun v -> ("label_alt_id_3",  v)) a.label_alt_id_3;
      Option.map (fun v -> ("label_asym_id_3",  v)) a.label_asym_id_3;
      Option.map (fun v -> ("label_atom_id_3",  v)) a.label_atom_id_3;
      Option.map (fun v -> ("label_comp_id_3",  v)) a.label_comp_id_3;
      Option.map (fun v -> ("label_seq_id_3", string_of_int v)) a.label_seq_id_3;
      Option.map (fun v -> ("angle", string_of_float v)) a.angle;
      Option.map (fun v -> ("angle_deviation", string_of_float v)) a.angle_deviation;
    ]

end

module Pdbx_val_bond = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id_1: string option;
    auth_atom_id_1: string option;
    auth_comp_id_1: string option;
    auth_seq_id_1: string option;
    auth_atom_id_2: string option;
    auth_asym_id_2: string option;
    auth_comp_id_2: string option;
    auth_seq_id_2: string option;
    auth_PDB_insert_id_1: string option;
    auth_PDB_insert_id_2: string option;
    label_alt_id_1: string option;
    label_asym_id_1: string option;
    label_atom_id_1: string option;
    label_comp_id_1: string option;
    label_seq_id_1: int option;
    label_alt_id_2: string option;
    label_asym_id_2: string option;
    label_atom_id_2: string option;
    label_comp_id_2: string option;
    label_seq_id_2: int option;
    bond: float option;
    bond_deviation: float option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id_1 = None;
    auth_atom_id_1 = None;
    auth_comp_id_1 = None;
    auth_seq_id_1 = None;
    auth_atom_id_2 = None;
    auth_asym_id_2 = None;
    auth_comp_id_2 = None;
    auth_seq_id_2 = None;
    auth_PDB_insert_id_1 = None;
    auth_PDB_insert_id_2 = None;
    label_alt_id_1 = None;
    label_asym_id_1 = None;
    label_atom_id_1 = None;
    label_comp_id_1 = None;
    label_seq_id_1 = None;
    label_alt_id_2 = None;
    label_asym_id_2 = None;
    label_atom_id_2 = None;
    label_comp_id_2 = None;
    label_seq_id_2 = None;
    bond = None;
    bond_deviation = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id_1" -> { b with auth_asym_id_1 = (Some v) }
      | "auth_atom_id_1" -> { b with auth_atom_id_1 = (Some v) }
      | "auth_comp_id_1" -> { b with auth_comp_id_1 = (Some v) }
      | "auth_seq_id_1" -> { b with auth_seq_id_1 = (Some v) }
      | "auth_atom_id_2" -> { b with auth_atom_id_2 = (Some v) }
      | "auth_asym_id_2" -> { b with auth_asym_id_2 = (Some v) }
      | "auth_comp_id_2" -> { b with auth_comp_id_2 = (Some v) }
      | "auth_seq_id_2" -> { b with auth_seq_id_2 = (Some v) }
      | "auth_PDB_insert_id_1" -> { b with auth_PDB_insert_id_1 = (Some v) }
      | "auth_PDB_insert_id_2" -> { b with auth_PDB_insert_id_2 = (Some v) }
      | "label_alt_id_1" -> { b with label_alt_id_1 = (Some v) }
      | "label_asym_id_1" -> { b with label_asym_id_1 = (Some v) }
      | "label_atom_id_1" -> { b with label_atom_id_1 = (Some v) }
      | "label_comp_id_1" -> { b with label_comp_id_1 = (Some v) }
      | "label_seq_id_1" -> { b with label_seq_id_1 = (PDBjDict.some_int v) }
      | "label_alt_id_2" -> { b with label_alt_id_2 = (Some v) }
      | "label_asym_id_2" -> { b with label_asym_id_2 = (Some v) }
      | "label_atom_id_2" -> { b with label_atom_id_2 = (Some v) }
      | "label_comp_id_2" -> { b with label_comp_id_2 = (Some v) }
      | "label_seq_id_2" -> { b with label_seq_id_2 = (PDBjDict.some_int v) }
      | "bond" -> { b with bond = (PDBjDict.some_float v) }
      | "bond_deviation" -> { b with bond_deviation = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id_1",  v)) a.auth_asym_id_1;
      Option.map (fun v -> ("auth_atom_id_1",  v)) a.auth_atom_id_1;
      Option.map (fun v -> ("auth_comp_id_1",  v)) a.auth_comp_id_1;
      Option.map (fun v -> ("auth_seq_id_1",  v)) a.auth_seq_id_1;
      Option.map (fun v -> ("auth_atom_id_2",  v)) a.auth_atom_id_2;
      Option.map (fun v -> ("auth_asym_id_2",  v)) a.auth_asym_id_2;
      Option.map (fun v -> ("auth_comp_id_2",  v)) a.auth_comp_id_2;
      Option.map (fun v -> ("auth_seq_id_2",  v)) a.auth_seq_id_2;
      Option.map (fun v -> ("auth_PDB_insert_id_1",  v)) a.auth_PDB_insert_id_1;
      Option.map (fun v -> ("auth_PDB_insert_id_2",  v)) a.auth_PDB_insert_id_2;
      Option.map (fun v -> ("label_alt_id_1",  v)) a.label_alt_id_1;
      Option.map (fun v -> ("label_asym_id_1",  v)) a.label_asym_id_1;
      Option.map (fun v -> ("label_atom_id_1",  v)) a.label_atom_id_1;
      Option.map (fun v -> ("label_comp_id_1",  v)) a.label_comp_id_1;
      Option.map (fun v -> ("label_seq_id_1", string_of_int v)) a.label_seq_id_1;
      Option.map (fun v -> ("label_alt_id_2",  v)) a.label_alt_id_2;
      Option.map (fun v -> ("label_asym_id_2",  v)) a.label_asym_id_2;
      Option.map (fun v -> ("label_atom_id_2",  v)) a.label_atom_id_2;
      Option.map (fun v -> ("label_comp_id_2",  v)) a.label_comp_id_2;
      Option.map (fun v -> ("label_seq_id_2", string_of_int v)) a.label_seq_id_2;
      Option.map (fun v -> ("bond", string_of_float v)) a.bond;
      Option.map (fun v -> ("bond_deviation", string_of_float v)) a.bond_deviation;
    ]

end

module Pdbx_val_contact = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id_1: string option;
    auth_atom_id_1: string option;
    auth_comp_id_1: string option;
    auth_seq_id_1: string option;
    auth_atom_id_2: string option;
    auth_asym_id_2: string option;
    auth_comp_id_2: string option;
    auth_seq_id_2: string option;
    auth_PDB_insert_id_1: string option;
    auth_PDB_insert_id_2: string option;
    label_alt_id_1: string option;
    label_asym_id_1: string option;
    label_atom_id_1: string option;
    label_comp_id_1: string option;
    label_seq_id_1: int option;
    label_alt_id_2: string option;
    label_asym_id_2: string option;
    label_atom_id_2: string option;
    label_comp_id_2: string option;
    label_seq_id_2: int option;
    dist: float option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id_1 = None;
    auth_atom_id_1 = None;
    auth_comp_id_1 = None;
    auth_seq_id_1 = None;
    auth_atom_id_2 = None;
    auth_asym_id_2 = None;
    auth_comp_id_2 = None;
    auth_seq_id_2 = None;
    auth_PDB_insert_id_1 = None;
    auth_PDB_insert_id_2 = None;
    label_alt_id_1 = None;
    label_asym_id_1 = None;
    label_atom_id_1 = None;
    label_comp_id_1 = None;
    label_seq_id_1 = None;
    label_alt_id_2 = None;
    label_asym_id_2 = None;
    label_atom_id_2 = None;
    label_comp_id_2 = None;
    label_seq_id_2 = None;
    dist = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id_1" -> { b with auth_asym_id_1 = (Some v) }
      | "auth_atom_id_1" -> { b with auth_atom_id_1 = (Some v) }
      | "auth_comp_id_1" -> { b with auth_comp_id_1 = (Some v) }
      | "auth_seq_id_1" -> { b with auth_seq_id_1 = (Some v) }
      | "auth_atom_id_2" -> { b with auth_atom_id_2 = (Some v) }
      | "auth_asym_id_2" -> { b with auth_asym_id_2 = (Some v) }
      | "auth_comp_id_2" -> { b with auth_comp_id_2 = (Some v) }
      | "auth_seq_id_2" -> { b with auth_seq_id_2 = (Some v) }
      | "auth_PDB_insert_id_1" -> { b with auth_PDB_insert_id_1 = (Some v) }
      | "auth_PDB_insert_id_2" -> { b with auth_PDB_insert_id_2 = (Some v) }
      | "label_alt_id_1" -> { b with label_alt_id_1 = (Some v) }
      | "label_asym_id_1" -> { b with label_asym_id_1 = (Some v) }
      | "label_atom_id_1" -> { b with label_atom_id_1 = (Some v) }
      | "label_comp_id_1" -> { b with label_comp_id_1 = (Some v) }
      | "label_seq_id_1" -> { b with label_seq_id_1 = (PDBjDict.some_int v) }
      | "label_alt_id_2" -> { b with label_alt_id_2 = (Some v) }
      | "label_asym_id_2" -> { b with label_asym_id_2 = (Some v) }
      | "label_atom_id_2" -> { b with label_atom_id_2 = (Some v) }
      | "label_comp_id_2" -> { b with label_comp_id_2 = (Some v) }
      | "label_seq_id_2" -> { b with label_seq_id_2 = (PDBjDict.some_int v) }
      | "dist" -> { b with dist = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id_1",  v)) a.auth_asym_id_1;
      Option.map (fun v -> ("auth_atom_id_1",  v)) a.auth_atom_id_1;
      Option.map (fun v -> ("auth_comp_id_1",  v)) a.auth_comp_id_1;
      Option.map (fun v -> ("auth_seq_id_1",  v)) a.auth_seq_id_1;
      Option.map (fun v -> ("auth_atom_id_2",  v)) a.auth_atom_id_2;
      Option.map (fun v -> ("auth_asym_id_2",  v)) a.auth_asym_id_2;
      Option.map (fun v -> ("auth_comp_id_2",  v)) a.auth_comp_id_2;
      Option.map (fun v -> ("auth_seq_id_2",  v)) a.auth_seq_id_2;
      Option.map (fun v -> ("auth_PDB_insert_id_1",  v)) a.auth_PDB_insert_id_1;
      Option.map (fun v -> ("auth_PDB_insert_id_2",  v)) a.auth_PDB_insert_id_2;
      Option.map (fun v -> ("label_alt_id_1",  v)) a.label_alt_id_1;
      Option.map (fun v -> ("label_asym_id_1",  v)) a.label_asym_id_1;
      Option.map (fun v -> ("label_atom_id_1",  v)) a.label_atom_id_1;
      Option.map (fun v -> ("label_comp_id_1",  v)) a.label_comp_id_1;
      Option.map (fun v -> ("label_seq_id_1", string_of_int v)) a.label_seq_id_1;
      Option.map (fun v -> ("label_alt_id_2",  v)) a.label_alt_id_2;
      Option.map (fun v -> ("label_asym_id_2",  v)) a.label_asym_id_2;
      Option.map (fun v -> ("label_atom_id_2",  v)) a.label_atom_id_2;
      Option.map (fun v -> ("label_comp_id_2",  v)) a.label_comp_id_2;
      Option.map (fun v -> ("label_seq_id_2", string_of_int v)) a.label_seq_id_2;
      Option.map (fun v -> ("dist", string_of_float v)) a.dist;
    ]

end

module Pdbx_val_sym_contact = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id_1: string option;
    auth_atom_id_1: string option;
    auth_comp_id_1: string option;
    auth_seq_id_1: string option;
    auth_atom_id_2: string option;
    auth_asym_id_2: string option;
    auth_comp_id_2: string option;
    auth_seq_id_2: string option;
    auth_PDB_insert_id_1: string option;
    auth_PDB_insert_id_2: string option;
    label_alt_id_1: string option;
    label_asym_id_1: string option;
    label_atom_id_1: string option;
    label_comp_id_1: string option;
    label_seq_id_1: int option;
    label_alt_id_2: string option;
    label_asym_id_2: string option;
    label_atom_id_2: string option;
    label_comp_id_2: string option;
    label_seq_id_2: int option;
    site_symmetry_1: string option;
    site_symmetry_2: string option;
    dist: float option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id_1 = None;
    auth_atom_id_1 = None;
    auth_comp_id_1 = None;
    auth_seq_id_1 = None;
    auth_atom_id_2 = None;
    auth_asym_id_2 = None;
    auth_comp_id_2 = None;
    auth_seq_id_2 = None;
    auth_PDB_insert_id_1 = None;
    auth_PDB_insert_id_2 = None;
    label_alt_id_1 = None;
    label_asym_id_1 = None;
    label_atom_id_1 = None;
    label_comp_id_1 = None;
    label_seq_id_1 = None;
    label_alt_id_2 = None;
    label_asym_id_2 = None;
    label_atom_id_2 = None;
    label_comp_id_2 = None;
    label_seq_id_2 = None;
    site_symmetry_1 = None;
    site_symmetry_2 = None;
    dist = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id_1" -> { b with auth_asym_id_1 = (Some v) }
      | "auth_atom_id_1" -> { b with auth_atom_id_1 = (Some v) }
      | "auth_comp_id_1" -> { b with auth_comp_id_1 = (Some v) }
      | "auth_seq_id_1" -> { b with auth_seq_id_1 = (Some v) }
      | "auth_atom_id_2" -> { b with auth_atom_id_2 = (Some v) }
      | "auth_asym_id_2" -> { b with auth_asym_id_2 = (Some v) }
      | "auth_comp_id_2" -> { b with auth_comp_id_2 = (Some v) }
      | "auth_seq_id_2" -> { b with auth_seq_id_2 = (Some v) }
      | "auth_PDB_insert_id_1" -> { b with auth_PDB_insert_id_1 = (Some v) }
      | "auth_PDB_insert_id_2" -> { b with auth_PDB_insert_id_2 = (Some v) }
      | "label_alt_id_1" -> { b with label_alt_id_1 = (Some v) }
      | "label_asym_id_1" -> { b with label_asym_id_1 = (Some v) }
      | "label_atom_id_1" -> { b with label_atom_id_1 = (Some v) }
      | "label_comp_id_1" -> { b with label_comp_id_1 = (Some v) }
      | "label_seq_id_1" -> { b with label_seq_id_1 = (PDBjDict.some_int v) }
      | "label_alt_id_2" -> { b with label_alt_id_2 = (Some v) }
      | "label_asym_id_2" -> { b with label_asym_id_2 = (Some v) }
      | "label_atom_id_2" -> { b with label_atom_id_2 = (Some v) }
      | "label_comp_id_2" -> { b with label_comp_id_2 = (Some v) }
      | "label_seq_id_2" -> { b with label_seq_id_2 = (PDBjDict.some_int v) }
      | "site_symmetry_1" -> { b with site_symmetry_1 = (Some v) }
      | "site_symmetry_2" -> { b with site_symmetry_2 = (Some v) }
      | "dist" -> { b with dist = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id_1",  v)) a.auth_asym_id_1;
      Option.map (fun v -> ("auth_atom_id_1",  v)) a.auth_atom_id_1;
      Option.map (fun v -> ("auth_comp_id_1",  v)) a.auth_comp_id_1;
      Option.map (fun v -> ("auth_seq_id_1",  v)) a.auth_seq_id_1;
      Option.map (fun v -> ("auth_atom_id_2",  v)) a.auth_atom_id_2;
      Option.map (fun v -> ("auth_asym_id_2",  v)) a.auth_asym_id_2;
      Option.map (fun v -> ("auth_comp_id_2",  v)) a.auth_comp_id_2;
      Option.map (fun v -> ("auth_seq_id_2",  v)) a.auth_seq_id_2;
      Option.map (fun v -> ("auth_PDB_insert_id_1",  v)) a.auth_PDB_insert_id_1;
      Option.map (fun v -> ("auth_PDB_insert_id_2",  v)) a.auth_PDB_insert_id_2;
      Option.map (fun v -> ("label_alt_id_1",  v)) a.label_alt_id_1;
      Option.map (fun v -> ("label_asym_id_1",  v)) a.label_asym_id_1;
      Option.map (fun v -> ("label_atom_id_1",  v)) a.label_atom_id_1;
      Option.map (fun v -> ("label_comp_id_1",  v)) a.label_comp_id_1;
      Option.map (fun v -> ("label_seq_id_1", string_of_int v)) a.label_seq_id_1;
      Option.map (fun v -> ("label_alt_id_2",  v)) a.label_alt_id_2;
      Option.map (fun v -> ("label_asym_id_2",  v)) a.label_asym_id_2;
      Option.map (fun v -> ("label_atom_id_2",  v)) a.label_atom_id_2;
      Option.map (fun v -> ("label_comp_id_2",  v)) a.label_comp_id_2;
      Option.map (fun v -> ("label_seq_id_2", string_of_int v)) a.label_seq_id_2;
      Option.map (fun v -> ("site_symmetry_1",  v)) a.site_symmetry_1;
      Option.map (fun v -> ("site_symmetry_2",  v)) a.site_symmetry_2;
      Option.map (fun v -> ("dist", string_of_float v)) a.dist;
    ]

end

module Pdbx_rmch_outlier = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    auth_PDB_insert_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    phi: float option;
    psi: float option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    auth_PDB_insert_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    phi = None;
    psi = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "auth_PDB_insert_id" -> { b with auth_PDB_insert_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "phi" -> { b with phi = (PDBjDict.some_float v) }
      | "psi" -> { b with psi = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("auth_PDB_insert_id",  v)) a.auth_PDB_insert_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("phi", string_of_float v)) a.phi;
      Option.map (fun v -> ("psi", string_of_float v)) a.psi;
    ]

end

module Pdbx_missing_atom_poly = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    auth_PDB_insert_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    atom_name: string option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    auth_PDB_insert_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    atom_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "auth_PDB_insert_id" -> { b with auth_PDB_insert_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "atom_name" -> { b with atom_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("auth_PDB_insert_id",  v)) a.auth_PDB_insert_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("atom_name",  v)) a.atom_name;
    ]

end

module Pdbx_missing_atom_nonpoly = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    auth_PDB_insert_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    atom_name: string option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    auth_PDB_insert_id = None;
    label_asym_id = None;
    label_comp_id = None;
    atom_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "auth_PDB_insert_id" -> { b with auth_PDB_insert_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "atom_name" -> { b with atom_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("auth_PDB_insert_id",  v)) a.auth_PDB_insert_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("atom_name",  v)) a.atom_name;
    ]

end

module Pdbx_val_chiral = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    auth_PDB_insert_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    label_seq_id: int option;
    chiral_center_atom_name: string option;
    chiral_neighbor_atom_name: string option;
    chiral_center_atom_alt_id: string option;
    chiral_neighbor_atom_alt_id: string option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    auth_PDB_insert_id = None;
    label_asym_id = None;
    label_comp_id = None;
    label_seq_id = None;
    chiral_center_atom_name = None;
    chiral_neighbor_atom_name = None;
    chiral_center_atom_alt_id = None;
    chiral_neighbor_atom_alt_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "auth_PDB_insert_id" -> { b with auth_PDB_insert_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "chiral_center_atom_name" -> { b with chiral_center_atom_name = (Some v) }
      | "chiral_neighbor_atom_name" -> { b with chiral_neighbor_atom_name = (Some v) }
      | "chiral_center_atom_alt_id" -> { b with chiral_center_atom_alt_id = (Some v) }
      | "chiral_neighbor_atom_alt_id" -> { b with chiral_neighbor_atom_alt_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("auth_PDB_insert_id",  v)) a.auth_PDB_insert_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("chiral_center_atom_name",  v)) a.chiral_center_atom_name;
      Option.map (fun v -> ("chiral_neighbor_atom_name",  v)) a.chiral_neighbor_atom_name;
      Option.map (fun v -> ("chiral_center_atom_alt_id",  v)) a.chiral_center_atom_alt_id;
      Option.map (fun v -> ("chiral_neighbor_atom_alt_id",  v)) a.chiral_neighbor_atom_alt_id;
    ]

end

module Pdbx_atlas = struct
  type t = {
    entry_id: string option;
    page_id: int option;
    page_name: string option;
  }

  let default = {
    entry_id = None;
    page_id = None;
    page_name = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "page_id" -> { b with page_id = (PDBjDict.some_int v) }
      | "page_name" -> { b with page_name = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("page_id", string_of_int v)) a.page_id;
      Option.map (fun v -> ("page_name",  v)) a.page_name;
    ]

end

module Pdbx_summary_flags = struct
  type t = {
    entry_id: string option;
    flag_id: string option;
    flag_value: string option;
  }

  let default = {
    entry_id = None;
    flag_id = None;
    flag_value = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "flag_id" -> { b with flag_id = (Some v) }
      | "flag_value" -> { b with flag_value = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("flag_id",  v)) a.flag_id;
      Option.map (fun v -> ("flag_value",  v)) a.flag_value;
    ]

end

module Pdbx_entity_func_bind_mode = struct
  type t = {
    id: string option;
    domain_id: string option;
    entity_id: string option;
    protein_binds_to: string option;
    type_: string option;
  }

  let default = {
    id = None;
    domain_id = None;
    entity_id = None;
    protein_binds_to = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "domain_id" -> { b with domain_id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "protein_binds_to" -> { b with protein_binds_to = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("domain_id",  v)) a.domain_id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("protein_binds_to",  v)) a.protein_binds_to;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_entity_func_enzyme = struct
  type t = {
    bind_mode_id: string option;
    type_: string option;
  }

  let default = {
    bind_mode_id = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "bind_mode_id" -> { b with bind_mode_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("bind_mode_id",  v)) a.bind_mode_id;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_entity_func_regulatory = struct
  type t = {
    bind_mode_id: string option;
    type_: string option;
  }

  let default = {
    bind_mode_id = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "bind_mode_id" -> { b with bind_mode_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("bind_mode_id",  v)) a.bind_mode_id;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_entity_func_structural = struct
  type t = {
    bind_mode_id: string option;
    type_: string option;
  }

  let default = {
    bind_mode_id = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "bind_mode_id" -> { b with bind_mode_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("bind_mode_id",  v)) a.bind_mode_id;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_entity_func_other = struct
  type t = {
    bind_mode_id: string option;
    type_: string option;
  }

  let default = {
    bind_mode_id = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "bind_mode_id" -> { b with bind_mode_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("bind_mode_id",  v)) a.bind_mode_id;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_entity_poly_domain = struct
  type t = {
    id: string option;
    entity_id: string option;
    begin_mon_id: string option;
    begin_seq_num: int option;
    end_mon_id: string option;
    end_seq_num: int option;
  }

  let default = {
    id = None;
    entity_id = None;
    begin_mon_id = None;
    begin_seq_num = None;
    end_mon_id = None;
    end_seq_num = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "entity_id" -> { b with entity_id = (Some v) }
      | "begin_mon_id" -> { b with begin_mon_id = (Some v) }
      | "begin_seq_num" -> { b with begin_seq_num = (PDBjDict.some_int v) }
      | "end_mon_id" -> { b with end_mon_id = (Some v) }
      | "end_seq_num" -> { b with end_seq_num = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("begin_mon_id",  v)) a.begin_mon_id;
      Option.map (fun v -> ("begin_seq_num", string_of_int v)) a.begin_seq_num;
      Option.map (fun v -> ("end_mon_id",  v)) a.end_mon_id;
      Option.map (fun v -> ("end_seq_num", string_of_int v)) a.end_seq_num;
    ]

end

module Pdbx_na_struct_keywds = struct
  type t = {
    entry_id: string option;
    conformation_type: string option;
    strand_description: string option;
    special_feature: string option;
  }

  let default = {
    entry_id = None;
    conformation_type = None;
    strand_description = None;
    special_feature = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "conformation_type" -> { b with conformation_type = (Some v) }
      | "strand_description" -> { b with strand_description = (Some v) }
      | "special_feature" -> { b with special_feature = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("conformation_type",  v)) a.conformation_type;
      Option.map (fun v -> ("strand_description",  v)) a.strand_description;
      Option.map (fun v -> ("special_feature",  v)) a.special_feature;
    ]

end

module Pdbx_entity_poly_na_type = struct
  type t = {
    entity_id: string option;
    type_: string option;
  }

  let default = {
    entity_id = None;
    type_ = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("type",  v)) a.type_;
    ]

end

module Pdbx_entity_poly_na_nonstandard = struct
  type t = {
    entity_id: string option;
    feature: string option;
  }

  let default = {
    entity_id = None;
    feature = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entity_id" -> { b with entity_id = (Some v) }
      | "feature" -> { b with feature = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entity_id",  v)) a.entity_id;
      Option.map (fun v -> ("feature",  v)) a.feature;
    ]

end

module Pdbx_virtual_angle = struct
  type t = {
    model_id: int option;
    atom_site_id_1: string option;
    atom_site_label_alt_id_1: string option;
    atom_site_label_atom_id_1: string option;
    atom_site_label_comp_id_1: string option;
    atom_site_label_seq_id_1: int option;
    atom_site_label_asym_id_1: string option;
    atom_site_id_2: string option;
    atom_site_label_alt_id_2: string option;
    atom_site_label_atom_id_2: string option;
    atom_site_label_comp_id_2: string option;
    atom_site_label_seq_id_2: int option;
    atom_site_label_asym_id_2: string option;
    atom_site_id_3: string option;
    atom_site_label_alt_id_3: string option;
    atom_site_label_atom_id_3: string option;
    atom_site_label_comp_id_3: string option;
    atom_site_label_seq_id_3: int option;
    atom_site_label_asym_id_3: string option;
    atom_site_auth_asym_id_1: string option;
    atom_site_auth_atom_id_1: string option;
    atom_site_auth_comp_id_1: string option;
    atom_site_auth_seq_id_1: string option;
    atom_site_auth_atom_id_2: string option;
    atom_site_auth_asym_id_2: string option;
    atom_site_auth_comp_id_2: string option;
    atom_site_auth_seq_id_2: string option;
    atom_site_auth_atom_id_3: string option;
    atom_site_auth_asym_id_3: string option;
    atom_site_auth_comp_id_3: string option;
    atom_site_auth_seq_id_3: string option;
    site_symmetry_1: string option;
    site_symmetry_2: string option;
    site_symmetry_3: string option;
    value: float option;
    value_esd: float option;
  }

  let default = {
    model_id = None;
    atom_site_id_1 = None;
    atom_site_label_alt_id_1 = None;
    atom_site_label_atom_id_1 = None;
    atom_site_label_comp_id_1 = None;
    atom_site_label_seq_id_1 = None;
    atom_site_label_asym_id_1 = None;
    atom_site_id_2 = None;
    atom_site_label_alt_id_2 = None;
    atom_site_label_atom_id_2 = None;
    atom_site_label_comp_id_2 = None;
    atom_site_label_seq_id_2 = None;
    atom_site_label_asym_id_2 = None;
    atom_site_id_3 = None;
    atom_site_label_alt_id_3 = None;
    atom_site_label_atom_id_3 = None;
    atom_site_label_comp_id_3 = None;
    atom_site_label_seq_id_3 = None;
    atom_site_label_asym_id_3 = None;
    atom_site_auth_asym_id_1 = None;
    atom_site_auth_atom_id_1 = None;
    atom_site_auth_comp_id_1 = None;
    atom_site_auth_seq_id_1 = None;
    atom_site_auth_atom_id_2 = None;
    atom_site_auth_asym_id_2 = None;
    atom_site_auth_comp_id_2 = None;
    atom_site_auth_seq_id_2 = None;
    atom_site_auth_atom_id_3 = None;
    atom_site_auth_asym_id_3 = None;
    atom_site_auth_comp_id_3 = None;
    atom_site_auth_seq_id_3 = None;
    site_symmetry_1 = None;
    site_symmetry_2 = None;
    site_symmetry_3 = None;
    value = None;
    value_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "atom_site_id_1" -> { b with atom_site_id_1 = (Some v) }
      | "atom_site_label_alt_id_1" -> { b with atom_site_label_alt_id_1 = (Some v) }
      | "atom_site_label_atom_id_1" -> { b with atom_site_label_atom_id_1 = (Some v) }
      | "atom_site_label_comp_id_1" -> { b with atom_site_label_comp_id_1 = (Some v) }
      | "atom_site_label_seq_id_1" -> { b with atom_site_label_seq_id_1 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_1" -> { b with atom_site_label_asym_id_1 = (Some v) }
      | "atom_site_id_2" -> { b with atom_site_id_2 = (Some v) }
      | "atom_site_label_alt_id_2" -> { b with atom_site_label_alt_id_2 = (Some v) }
      | "atom_site_label_atom_id_2" -> { b with atom_site_label_atom_id_2 = (Some v) }
      | "atom_site_label_comp_id_2" -> { b with atom_site_label_comp_id_2 = (Some v) }
      | "atom_site_label_seq_id_2" -> { b with atom_site_label_seq_id_2 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_2" -> { b with atom_site_label_asym_id_2 = (Some v) }
      | "atom_site_id_3" -> { b with atom_site_id_3 = (Some v) }
      | "atom_site_label_alt_id_3" -> { b with atom_site_label_alt_id_3 = (Some v) }
      | "atom_site_label_atom_id_3" -> { b with atom_site_label_atom_id_3 = (Some v) }
      | "atom_site_label_comp_id_3" -> { b with atom_site_label_comp_id_3 = (Some v) }
      | "atom_site_label_seq_id_3" -> { b with atom_site_label_seq_id_3 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_3" -> { b with atom_site_label_asym_id_3 = (Some v) }
      | "atom_site_auth_asym_id_1" -> { b with atom_site_auth_asym_id_1 = (Some v) }
      | "atom_site_auth_atom_id_1" -> { b with atom_site_auth_atom_id_1 = (Some v) }
      | "atom_site_auth_comp_id_1" -> { b with atom_site_auth_comp_id_1 = (Some v) }
      | "atom_site_auth_seq_id_1" -> { b with atom_site_auth_seq_id_1 = (Some v) }
      | "atom_site_auth_atom_id_2" -> { b with atom_site_auth_atom_id_2 = (Some v) }
      | "atom_site_auth_asym_id_2" -> { b with atom_site_auth_asym_id_2 = (Some v) }
      | "atom_site_auth_comp_id_2" -> { b with atom_site_auth_comp_id_2 = (Some v) }
      | "atom_site_auth_seq_id_2" -> { b with atom_site_auth_seq_id_2 = (Some v) }
      | "atom_site_auth_atom_id_3" -> { b with atom_site_auth_atom_id_3 = (Some v) }
      | "atom_site_auth_asym_id_3" -> { b with atom_site_auth_asym_id_3 = (Some v) }
      | "atom_site_auth_comp_id_3" -> { b with atom_site_auth_comp_id_3 = (Some v) }
      | "atom_site_auth_seq_id_3" -> { b with atom_site_auth_seq_id_3 = (Some v) }
      | "site_symmetry_1" -> { b with site_symmetry_1 = (Some v) }
      | "site_symmetry_2" -> { b with site_symmetry_2 = (Some v) }
      | "site_symmetry_3" -> { b with site_symmetry_3 = (Some v) }
      | "value" -> { b with value = (PDBjDict.some_float v) }
      | "value_esd" -> { b with value_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("atom_site_id_1",  v)) a.atom_site_id_1;
      Option.map (fun v -> ("atom_site_label_alt_id_1",  v)) a.atom_site_label_alt_id_1;
      Option.map (fun v -> ("atom_site_label_atom_id_1",  v)) a.atom_site_label_atom_id_1;
      Option.map (fun v -> ("atom_site_label_comp_id_1",  v)) a.atom_site_label_comp_id_1;
      Option.map (fun v -> ("atom_site_label_seq_id_1", string_of_int v)) a.atom_site_label_seq_id_1;
      Option.map (fun v -> ("atom_site_label_asym_id_1",  v)) a.atom_site_label_asym_id_1;
      Option.map (fun v -> ("atom_site_id_2",  v)) a.atom_site_id_2;
      Option.map (fun v -> ("atom_site_label_alt_id_2",  v)) a.atom_site_label_alt_id_2;
      Option.map (fun v -> ("atom_site_label_atom_id_2",  v)) a.atom_site_label_atom_id_2;
      Option.map (fun v -> ("atom_site_label_comp_id_2",  v)) a.atom_site_label_comp_id_2;
      Option.map (fun v -> ("atom_site_label_seq_id_2", string_of_int v)) a.atom_site_label_seq_id_2;
      Option.map (fun v -> ("atom_site_label_asym_id_2",  v)) a.atom_site_label_asym_id_2;
      Option.map (fun v -> ("atom_site_id_3",  v)) a.atom_site_id_3;
      Option.map (fun v -> ("atom_site_label_alt_id_3",  v)) a.atom_site_label_alt_id_3;
      Option.map (fun v -> ("atom_site_label_atom_id_3",  v)) a.atom_site_label_atom_id_3;
      Option.map (fun v -> ("atom_site_label_comp_id_3",  v)) a.atom_site_label_comp_id_3;
      Option.map (fun v -> ("atom_site_label_seq_id_3", string_of_int v)) a.atom_site_label_seq_id_3;
      Option.map (fun v -> ("atom_site_label_asym_id_3",  v)) a.atom_site_label_asym_id_3;
      Option.map (fun v -> ("atom_site_auth_asym_id_1",  v)) a.atom_site_auth_asym_id_1;
      Option.map (fun v -> ("atom_site_auth_atom_id_1",  v)) a.atom_site_auth_atom_id_1;
      Option.map (fun v -> ("atom_site_auth_comp_id_1",  v)) a.atom_site_auth_comp_id_1;
      Option.map (fun v -> ("atom_site_auth_seq_id_1",  v)) a.atom_site_auth_seq_id_1;
      Option.map (fun v -> ("atom_site_auth_atom_id_2",  v)) a.atom_site_auth_atom_id_2;
      Option.map (fun v -> ("atom_site_auth_asym_id_2",  v)) a.atom_site_auth_asym_id_2;
      Option.map (fun v -> ("atom_site_auth_comp_id_2",  v)) a.atom_site_auth_comp_id_2;
      Option.map (fun v -> ("atom_site_auth_seq_id_2",  v)) a.atom_site_auth_seq_id_2;
      Option.map (fun v -> ("atom_site_auth_atom_id_3",  v)) a.atom_site_auth_atom_id_3;
      Option.map (fun v -> ("atom_site_auth_asym_id_3",  v)) a.atom_site_auth_asym_id_3;
      Option.map (fun v -> ("atom_site_auth_comp_id_3",  v)) a.atom_site_auth_comp_id_3;
      Option.map (fun v -> ("atom_site_auth_seq_id_3",  v)) a.atom_site_auth_seq_id_3;
      Option.map (fun v -> ("site_symmetry_1",  v)) a.site_symmetry_1;
      Option.map (fun v -> ("site_symmetry_2",  v)) a.site_symmetry_2;
      Option.map (fun v -> ("site_symmetry_3",  v)) a.site_symmetry_3;
      Option.map (fun v -> ("value", string_of_float v)) a.value;
      Option.map (fun v -> ("value_esd", string_of_float v)) a.value_esd;
    ]

end

module Pdbx_virtual_bond = struct
  type t = {
    model_id: int option;
    atom_site_id_1: string option;
    atom_site_label_alt_id_1: string option;
    atom_site_label_atom_id_1: string option;
    atom_site_label_comp_id_1: string option;
    atom_site_label_seq_id_1: int option;
    atom_site_label_asym_id_1: string option;
    atom_site_id_2: string option;
    atom_site_label_alt_id_2: string option;
    atom_site_label_atom_id_2: string option;
    atom_site_label_comp_id_2: string option;
    atom_site_label_seq_id_2: int option;
    atom_site_label_asym_id_2: string option;
    atom_site_auth_atom_id_1: string option;
    atom_site_auth_asym_id_1: string option;
    atom_site_auth_comp_id_1: string option;
    atom_site_auth_seq_id_1: string option;
    atom_site_auth_atom_id_2: string option;
    atom_site_auth_asym_id_2: string option;
    atom_site_auth_comp_id_2: string option;
    atom_site_auth_seq_id_2: int option;
    dist: float option;
    dist_esd: float option;
    site_symmetry_1: string option;
    site_symmetry_2: string option;
  }

  let default = {
    model_id = None;
    atom_site_id_1 = None;
    atom_site_label_alt_id_1 = None;
    atom_site_label_atom_id_1 = None;
    atom_site_label_comp_id_1 = None;
    atom_site_label_seq_id_1 = None;
    atom_site_label_asym_id_1 = None;
    atom_site_id_2 = None;
    atom_site_label_alt_id_2 = None;
    atom_site_label_atom_id_2 = None;
    atom_site_label_comp_id_2 = None;
    atom_site_label_seq_id_2 = None;
    atom_site_label_asym_id_2 = None;
    atom_site_auth_atom_id_1 = None;
    atom_site_auth_asym_id_1 = None;
    atom_site_auth_comp_id_1 = None;
    atom_site_auth_seq_id_1 = None;
    atom_site_auth_atom_id_2 = None;
    atom_site_auth_asym_id_2 = None;
    atom_site_auth_comp_id_2 = None;
    atom_site_auth_seq_id_2 = None;
    dist = None;
    dist_esd = None;
    site_symmetry_1 = None;
    site_symmetry_2 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "atom_site_id_1" -> { b with atom_site_id_1 = (Some v) }
      | "atom_site_label_alt_id_1" -> { b with atom_site_label_alt_id_1 = (Some v) }
      | "atom_site_label_atom_id_1" -> { b with atom_site_label_atom_id_1 = (Some v) }
      | "atom_site_label_comp_id_1" -> { b with atom_site_label_comp_id_1 = (Some v) }
      | "atom_site_label_seq_id_1" -> { b with atom_site_label_seq_id_1 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_1" -> { b with atom_site_label_asym_id_1 = (Some v) }
      | "atom_site_id_2" -> { b with atom_site_id_2 = (Some v) }
      | "atom_site_label_alt_id_2" -> { b with atom_site_label_alt_id_2 = (Some v) }
      | "atom_site_label_atom_id_2" -> { b with atom_site_label_atom_id_2 = (Some v) }
      | "atom_site_label_comp_id_2" -> { b with atom_site_label_comp_id_2 = (Some v) }
      | "atom_site_label_seq_id_2" -> { b with atom_site_label_seq_id_2 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_2" -> { b with atom_site_label_asym_id_2 = (Some v) }
      | "atom_site_auth_atom_id_1" -> { b with atom_site_auth_atom_id_1 = (Some v) }
      | "atom_site_auth_asym_id_1" -> { b with atom_site_auth_asym_id_1 = (Some v) }
      | "atom_site_auth_comp_id_1" -> { b with atom_site_auth_comp_id_1 = (Some v) }
      | "atom_site_auth_seq_id_1" -> { b with atom_site_auth_seq_id_1 = (Some v) }
      | "atom_site_auth_atom_id_2" -> { b with atom_site_auth_atom_id_2 = (Some v) }
      | "atom_site_auth_asym_id_2" -> { b with atom_site_auth_asym_id_2 = (Some v) }
      | "atom_site_auth_comp_id_2" -> { b with atom_site_auth_comp_id_2 = (Some v) }
      | "atom_site_auth_seq_id_2" -> { b with atom_site_auth_seq_id_2 = (PDBjDict.some_int v) }
      | "dist" -> { b with dist = (PDBjDict.some_float v) }
      | "dist_esd" -> { b with dist_esd = (PDBjDict.some_float v) }
      | "site_symmetry_1" -> { b with site_symmetry_1 = (Some v) }
      | "site_symmetry_2" -> { b with site_symmetry_2 = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("atom_site_id_1",  v)) a.atom_site_id_1;
      Option.map (fun v -> ("atom_site_label_alt_id_1",  v)) a.atom_site_label_alt_id_1;
      Option.map (fun v -> ("atom_site_label_atom_id_1",  v)) a.atom_site_label_atom_id_1;
      Option.map (fun v -> ("atom_site_label_comp_id_1",  v)) a.atom_site_label_comp_id_1;
      Option.map (fun v -> ("atom_site_label_seq_id_1", string_of_int v)) a.atom_site_label_seq_id_1;
      Option.map (fun v -> ("atom_site_label_asym_id_1",  v)) a.atom_site_label_asym_id_1;
      Option.map (fun v -> ("atom_site_id_2",  v)) a.atom_site_id_2;
      Option.map (fun v -> ("atom_site_label_alt_id_2",  v)) a.atom_site_label_alt_id_2;
      Option.map (fun v -> ("atom_site_label_atom_id_2",  v)) a.atom_site_label_atom_id_2;
      Option.map (fun v -> ("atom_site_label_comp_id_2",  v)) a.atom_site_label_comp_id_2;
      Option.map (fun v -> ("atom_site_label_seq_id_2", string_of_int v)) a.atom_site_label_seq_id_2;
      Option.map (fun v -> ("atom_site_label_asym_id_2",  v)) a.atom_site_label_asym_id_2;
      Option.map (fun v -> ("atom_site_auth_atom_id_1",  v)) a.atom_site_auth_atom_id_1;
      Option.map (fun v -> ("atom_site_auth_asym_id_1",  v)) a.atom_site_auth_asym_id_1;
      Option.map (fun v -> ("atom_site_auth_comp_id_1",  v)) a.atom_site_auth_comp_id_1;
      Option.map (fun v -> ("atom_site_auth_seq_id_1",  v)) a.atom_site_auth_seq_id_1;
      Option.map (fun v -> ("atom_site_auth_atom_id_2",  v)) a.atom_site_auth_atom_id_2;
      Option.map (fun v -> ("atom_site_auth_asym_id_2",  v)) a.atom_site_auth_asym_id_2;
      Option.map (fun v -> ("atom_site_auth_comp_id_2",  v)) a.atom_site_auth_comp_id_2;
      Option.map (fun v -> ("atom_site_auth_seq_id_2", string_of_int v)) a.atom_site_auth_seq_id_2;
      Option.map (fun v -> ("dist", string_of_float v)) a.dist;
      Option.map (fun v -> ("dist_esd", string_of_float v)) a.dist_esd;
      Option.map (fun v -> ("site_symmetry_1",  v)) a.site_symmetry_1;
      Option.map (fun v -> ("site_symmetry_2",  v)) a.site_symmetry_2;
    ]

end

module Pdbx_virtual_torsion = struct
  type t = {
    model_id: int option;
    atom_site_id_1: string option;
    atom_site_label_alt_id_1: string option;
    atom_site_label_atom_id_1: string option;
    atom_site_label_comp_id_1: string option;
    atom_site_label_seq_id_1: int option;
    atom_site_label_asym_id_1: string option;
    atom_site_id_2: string option;
    atom_site_label_alt_id_2: string option;
    atom_site_label_atom_id_2: string option;
    atom_site_label_comp_id_2: string option;
    atom_site_label_seq_id_2: int option;
    atom_site_label_asym_id_2: string option;
    atom_site_id_3: string option;
    atom_site_label_alt_id_3: string option;
    atom_site_label_atom_id_3: string option;
    atom_site_label_comp_id_3: string option;
    atom_site_label_seq_id_3: int option;
    atom_site_label_asym_id_3: string option;
    atom_site_id_4: string option;
    atom_site_label_alt_id_4: string option;
    atom_site_label_atom_id_4: string option;
    atom_site_label_comp_id_4: string option;
    atom_site_label_seq_id_4: int option;
    atom_site_label_asym_id_4: string option;
    atom_site_auth_atom_id_1: string option;
    atom_site_auth_asym_id_1: string option;
    atom_site_auth_comp_id_1: string option;
    atom_site_auth_seq_id_1: string option;
    atom_site_auth_atom_id_2: string option;
    atom_site_auth_asym_id_2: string option;
    atom_site_auth_comp_id_2: string option;
    atom_site_auth_seq_id_2: string option;
    atom_site_auth_atom_id_3: string option;
    atom_site_auth_asym_id_3: string option;
    atom_site_auth_comp_id_3: string option;
    atom_site_auth_seq_id_3: string option;
    atom_site_auth_atom_id_4: string option;
    atom_site_auth_asym_id_4: string option;
    atom_site_auth_comp_id_4: string option;
    atom_site_auth_seq_id_4: string option;
    site_symmetry_1: string option;
    site_symmetry_2: string option;
    site_symmetry_3: string option;
    site_symmetry_4: string option;
    value: float option;
    value_esd: float option;
  }

  let default = {
    model_id = None;
    atom_site_id_1 = None;
    atom_site_label_alt_id_1 = None;
    atom_site_label_atom_id_1 = None;
    atom_site_label_comp_id_1 = None;
    atom_site_label_seq_id_1 = None;
    atom_site_label_asym_id_1 = None;
    atom_site_id_2 = None;
    atom_site_label_alt_id_2 = None;
    atom_site_label_atom_id_2 = None;
    atom_site_label_comp_id_2 = None;
    atom_site_label_seq_id_2 = None;
    atom_site_label_asym_id_2 = None;
    atom_site_id_3 = None;
    atom_site_label_alt_id_3 = None;
    atom_site_label_atom_id_3 = None;
    atom_site_label_comp_id_3 = None;
    atom_site_label_seq_id_3 = None;
    atom_site_label_asym_id_3 = None;
    atom_site_id_4 = None;
    atom_site_label_alt_id_4 = None;
    atom_site_label_atom_id_4 = None;
    atom_site_label_comp_id_4 = None;
    atom_site_label_seq_id_4 = None;
    atom_site_label_asym_id_4 = None;
    atom_site_auth_atom_id_1 = None;
    atom_site_auth_asym_id_1 = None;
    atom_site_auth_comp_id_1 = None;
    atom_site_auth_seq_id_1 = None;
    atom_site_auth_atom_id_2 = None;
    atom_site_auth_asym_id_2 = None;
    atom_site_auth_comp_id_2 = None;
    atom_site_auth_seq_id_2 = None;
    atom_site_auth_atom_id_3 = None;
    atom_site_auth_asym_id_3 = None;
    atom_site_auth_comp_id_3 = None;
    atom_site_auth_seq_id_3 = None;
    atom_site_auth_atom_id_4 = None;
    atom_site_auth_asym_id_4 = None;
    atom_site_auth_comp_id_4 = None;
    atom_site_auth_seq_id_4 = None;
    site_symmetry_1 = None;
    site_symmetry_2 = None;
    site_symmetry_3 = None;
    site_symmetry_4 = None;
    value = None;
    value_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "atom_site_id_1" -> { b with atom_site_id_1 = (Some v) }
      | "atom_site_label_alt_id_1" -> { b with atom_site_label_alt_id_1 = (Some v) }
      | "atom_site_label_atom_id_1" -> { b with atom_site_label_atom_id_1 = (Some v) }
      | "atom_site_label_comp_id_1" -> { b with atom_site_label_comp_id_1 = (Some v) }
      | "atom_site_label_seq_id_1" -> { b with atom_site_label_seq_id_1 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_1" -> { b with atom_site_label_asym_id_1 = (Some v) }
      | "atom_site_id_2" -> { b with atom_site_id_2 = (Some v) }
      | "atom_site_label_alt_id_2" -> { b with atom_site_label_alt_id_2 = (Some v) }
      | "atom_site_label_atom_id_2" -> { b with atom_site_label_atom_id_2 = (Some v) }
      | "atom_site_label_comp_id_2" -> { b with atom_site_label_comp_id_2 = (Some v) }
      | "atom_site_label_seq_id_2" -> { b with atom_site_label_seq_id_2 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_2" -> { b with atom_site_label_asym_id_2 = (Some v) }
      | "atom_site_id_3" -> { b with atom_site_id_3 = (Some v) }
      | "atom_site_label_alt_id_3" -> { b with atom_site_label_alt_id_3 = (Some v) }
      | "atom_site_label_atom_id_3" -> { b with atom_site_label_atom_id_3 = (Some v) }
      | "atom_site_label_comp_id_3" -> { b with atom_site_label_comp_id_3 = (Some v) }
      | "atom_site_label_seq_id_3" -> { b with atom_site_label_seq_id_3 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_3" -> { b with atom_site_label_asym_id_3 = (Some v) }
      | "atom_site_id_4" -> { b with atom_site_id_4 = (Some v) }
      | "atom_site_label_alt_id_4" -> { b with atom_site_label_alt_id_4 = (Some v) }
      | "atom_site_label_atom_id_4" -> { b with atom_site_label_atom_id_4 = (Some v) }
      | "atom_site_label_comp_id_4" -> { b with atom_site_label_comp_id_4 = (Some v) }
      | "atom_site_label_seq_id_4" -> { b with atom_site_label_seq_id_4 = (PDBjDict.some_int v) }
      | "atom_site_label_asym_id_4" -> { b with atom_site_label_asym_id_4 = (Some v) }
      | "atom_site_auth_atom_id_1" -> { b with atom_site_auth_atom_id_1 = (Some v) }
      | "atom_site_auth_asym_id_1" -> { b with atom_site_auth_asym_id_1 = (Some v) }
      | "atom_site_auth_comp_id_1" -> { b with atom_site_auth_comp_id_1 = (Some v) }
      | "atom_site_auth_seq_id_1" -> { b with atom_site_auth_seq_id_1 = (Some v) }
      | "atom_site_auth_atom_id_2" -> { b with atom_site_auth_atom_id_2 = (Some v) }
      | "atom_site_auth_asym_id_2" -> { b with atom_site_auth_asym_id_2 = (Some v) }
      | "atom_site_auth_comp_id_2" -> { b with atom_site_auth_comp_id_2 = (Some v) }
      | "atom_site_auth_seq_id_2" -> { b with atom_site_auth_seq_id_2 = (Some v) }
      | "atom_site_auth_atom_id_3" -> { b with atom_site_auth_atom_id_3 = (Some v) }
      | "atom_site_auth_asym_id_3" -> { b with atom_site_auth_asym_id_3 = (Some v) }
      | "atom_site_auth_comp_id_3" -> { b with atom_site_auth_comp_id_3 = (Some v) }
      | "atom_site_auth_seq_id_3" -> { b with atom_site_auth_seq_id_3 = (Some v) }
      | "atom_site_auth_atom_id_4" -> { b with atom_site_auth_atom_id_4 = (Some v) }
      | "atom_site_auth_asym_id_4" -> { b with atom_site_auth_asym_id_4 = (Some v) }
      | "atom_site_auth_comp_id_4" -> { b with atom_site_auth_comp_id_4 = (Some v) }
      | "atom_site_auth_seq_id_4" -> { b with atom_site_auth_seq_id_4 = (Some v) }
      | "site_symmetry_1" -> { b with site_symmetry_1 = (Some v) }
      | "site_symmetry_2" -> { b with site_symmetry_2 = (Some v) }
      | "site_symmetry_3" -> { b with site_symmetry_3 = (Some v) }
      | "site_symmetry_4" -> { b with site_symmetry_4 = (Some v) }
      | "value" -> { b with value = (PDBjDict.some_float v) }
      | "value_esd" -> { b with value_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("atom_site_id_1",  v)) a.atom_site_id_1;
      Option.map (fun v -> ("atom_site_label_alt_id_1",  v)) a.atom_site_label_alt_id_1;
      Option.map (fun v -> ("atom_site_label_atom_id_1",  v)) a.atom_site_label_atom_id_1;
      Option.map (fun v -> ("atom_site_label_comp_id_1",  v)) a.atom_site_label_comp_id_1;
      Option.map (fun v -> ("atom_site_label_seq_id_1", string_of_int v)) a.atom_site_label_seq_id_1;
      Option.map (fun v -> ("atom_site_label_asym_id_1",  v)) a.atom_site_label_asym_id_1;
      Option.map (fun v -> ("atom_site_id_2",  v)) a.atom_site_id_2;
      Option.map (fun v -> ("atom_site_label_alt_id_2",  v)) a.atom_site_label_alt_id_2;
      Option.map (fun v -> ("atom_site_label_atom_id_2",  v)) a.atom_site_label_atom_id_2;
      Option.map (fun v -> ("atom_site_label_comp_id_2",  v)) a.atom_site_label_comp_id_2;
      Option.map (fun v -> ("atom_site_label_seq_id_2", string_of_int v)) a.atom_site_label_seq_id_2;
      Option.map (fun v -> ("atom_site_label_asym_id_2",  v)) a.atom_site_label_asym_id_2;
      Option.map (fun v -> ("atom_site_id_3",  v)) a.atom_site_id_3;
      Option.map (fun v -> ("atom_site_label_alt_id_3",  v)) a.atom_site_label_alt_id_3;
      Option.map (fun v -> ("atom_site_label_atom_id_3",  v)) a.atom_site_label_atom_id_3;
      Option.map (fun v -> ("atom_site_label_comp_id_3",  v)) a.atom_site_label_comp_id_3;
      Option.map (fun v -> ("atom_site_label_seq_id_3", string_of_int v)) a.atom_site_label_seq_id_3;
      Option.map (fun v -> ("atom_site_label_asym_id_3",  v)) a.atom_site_label_asym_id_3;
      Option.map (fun v -> ("atom_site_id_4",  v)) a.atom_site_id_4;
      Option.map (fun v -> ("atom_site_label_alt_id_4",  v)) a.atom_site_label_alt_id_4;
      Option.map (fun v -> ("atom_site_label_atom_id_4",  v)) a.atom_site_label_atom_id_4;
      Option.map (fun v -> ("atom_site_label_comp_id_4",  v)) a.atom_site_label_comp_id_4;
      Option.map (fun v -> ("atom_site_label_seq_id_4", string_of_int v)) a.atom_site_label_seq_id_4;
      Option.map (fun v -> ("atom_site_label_asym_id_4",  v)) a.atom_site_label_asym_id_4;
      Option.map (fun v -> ("atom_site_auth_atom_id_1",  v)) a.atom_site_auth_atom_id_1;
      Option.map (fun v -> ("atom_site_auth_asym_id_1",  v)) a.atom_site_auth_asym_id_1;
      Option.map (fun v -> ("atom_site_auth_comp_id_1",  v)) a.atom_site_auth_comp_id_1;
      Option.map (fun v -> ("atom_site_auth_seq_id_1",  v)) a.atom_site_auth_seq_id_1;
      Option.map (fun v -> ("atom_site_auth_atom_id_2",  v)) a.atom_site_auth_atom_id_2;
      Option.map (fun v -> ("atom_site_auth_asym_id_2",  v)) a.atom_site_auth_asym_id_2;
      Option.map (fun v -> ("atom_site_auth_comp_id_2",  v)) a.atom_site_auth_comp_id_2;
      Option.map (fun v -> ("atom_site_auth_seq_id_2",  v)) a.atom_site_auth_seq_id_2;
      Option.map (fun v -> ("atom_site_auth_atom_id_3",  v)) a.atom_site_auth_atom_id_3;
      Option.map (fun v -> ("atom_site_auth_asym_id_3",  v)) a.atom_site_auth_asym_id_3;
      Option.map (fun v -> ("atom_site_auth_comp_id_3",  v)) a.atom_site_auth_comp_id_3;
      Option.map (fun v -> ("atom_site_auth_seq_id_3",  v)) a.atom_site_auth_seq_id_3;
      Option.map (fun v -> ("atom_site_auth_atom_id_4",  v)) a.atom_site_auth_atom_id_4;
      Option.map (fun v -> ("atom_site_auth_asym_id_4",  v)) a.atom_site_auth_asym_id_4;
      Option.map (fun v -> ("atom_site_auth_comp_id_4",  v)) a.atom_site_auth_comp_id_4;
      Option.map (fun v -> ("atom_site_auth_seq_id_4",  v)) a.atom_site_auth_seq_id_4;
      Option.map (fun v -> ("site_symmetry_1",  v)) a.site_symmetry_1;
      Option.map (fun v -> ("site_symmetry_2",  v)) a.site_symmetry_2;
      Option.map (fun v -> ("site_symmetry_3",  v)) a.site_symmetry_3;
      Option.map (fun v -> ("site_symmetry_4",  v)) a.site_symmetry_4;
      Option.map (fun v -> ("value", string_of_float v)) a.value;
      Option.map (fun v -> ("value_esd", string_of_float v)) a.value_esd;
    ]

end

module Pdbx_sequence_pattern = struct
  type t = {
    label_asym_id: string option;
    auth_asym_id: string option;
    pattern_count: int option;
    sequence_pattern: string option;
  }

  let default = {
    label_asym_id = None;
    auth_asym_id = None;
    pattern_count = None;
    sequence_pattern = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "pattern_count" -> { b with pattern_count = (PDBjDict.some_int v) }
      | "sequence_pattern" -> { b with sequence_pattern = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("pattern_count", string_of_int v)) a.pattern_count;
      Option.map (fun v -> ("sequence_pattern",  v)) a.sequence_pattern;
    ]

end

module Pdbx_stereochemistry = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    auth_seq_id: string option;
    label_seq_id: int option;
    label_atom_id: string option;
    label_alt_id: string option;
    label_atom_id_u: string option;
    label_alt_id_u: string option;
    label_atom_id_v: string option;
    label_alt_id_v: string option;
    label_atom_id_w: string option;
    label_alt_id_w: string option;
    volume3: float option;
    angle_out_of_plane: float option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id = None;
    label_asym_id = None;
    label_comp_id = None;
    auth_seq_id = None;
    label_seq_id = None;
    label_atom_id = None;
    label_alt_id = None;
    label_atom_id_u = None;
    label_alt_id_u = None;
    label_atom_id_v = None;
    label_alt_id_v = None;
    label_atom_id_w = None;
    label_alt_id_w = None;
    volume3 = None;
    angle_out_of_plane = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "label_atom_id" -> { b with label_atom_id = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_atom_id_u" -> { b with label_atom_id_u = (Some v) }
      | "label_alt_id_u" -> { b with label_alt_id_u = (Some v) }
      | "label_atom_id_v" -> { b with label_atom_id_v = (Some v) }
      | "label_alt_id_v" -> { b with label_alt_id_v = (Some v) }
      | "label_atom_id_w" -> { b with label_atom_id_w = (Some v) }
      | "label_alt_id_w" -> { b with label_alt_id_w = (Some v) }
      | "volume3" -> { b with volume3 = (PDBjDict.some_float v) }
      | "angle_out_of_plane" -> { b with angle_out_of_plane = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("label_atom_id",  v)) a.label_atom_id;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_atom_id_u",  v)) a.label_atom_id_u;
      Option.map (fun v -> ("label_alt_id_u",  v)) a.label_alt_id_u;
      Option.map (fun v -> ("label_atom_id_v",  v)) a.label_atom_id_v;
      Option.map (fun v -> ("label_alt_id_v",  v)) a.label_alt_id_v;
      Option.map (fun v -> ("label_atom_id_w",  v)) a.label_atom_id_w;
      Option.map (fun v -> ("label_alt_id_w",  v)) a.label_alt_id_w;
      Option.map (fun v -> ("volume3", string_of_float v)) a.volume3;
      Option.map (fun v -> ("angle_out_of_plane", string_of_float v)) a.angle_out_of_plane;
    ]

end

module Pdbx_rms_devs_covalent = struct
  type t = {
    entry_id: string option;
    rms_bonds: float option;
    num_bonds: int option;
    rms_bonds_base: float option;
    num_bonds_base: int option;
    rms_bonds_sugar: float option;
    num_bonds_sugar: int option;
    rms_bonds_phosphate: float option;
    num_bonds_phosphate: int option;
    rms_angles: float option;
    num_angles: int option;
    rms_angles_base: float option;
    num_angles_base: int option;
    rms_angles_sugar: float option;
    num_angles_sugar: int option;
    rms_angles_phosphate: float option;
    num_angles_phosphate: int option;
  }

  let default = {
    entry_id = None;
    rms_bonds = None;
    num_bonds = None;
    rms_bonds_base = None;
    num_bonds_base = None;
    rms_bonds_sugar = None;
    num_bonds_sugar = None;
    rms_bonds_phosphate = None;
    num_bonds_phosphate = None;
    rms_angles = None;
    num_angles = None;
    rms_angles_base = None;
    num_angles_base = None;
    rms_angles_sugar = None;
    num_angles_sugar = None;
    rms_angles_phosphate = None;
    num_angles_phosphate = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "rms_bonds" -> { b with rms_bonds = (PDBjDict.some_float v) }
      | "num_bonds" -> { b with num_bonds = (PDBjDict.some_int v) }
      | "rms_bonds_base" -> { b with rms_bonds_base = (PDBjDict.some_float v) }
      | "num_bonds_base" -> { b with num_bonds_base = (PDBjDict.some_int v) }
      | "rms_bonds_sugar" -> { b with rms_bonds_sugar = (PDBjDict.some_float v) }
      | "num_bonds_sugar" -> { b with num_bonds_sugar = (PDBjDict.some_int v) }
      | "rms_bonds_phosphate" -> { b with rms_bonds_phosphate = (PDBjDict.some_float v) }
      | "num_bonds_phosphate" -> { b with num_bonds_phosphate = (PDBjDict.some_int v) }
      | "rms_angles" -> { b with rms_angles = (PDBjDict.some_float v) }
      | "num_angles" -> { b with num_angles = (PDBjDict.some_int v) }
      | "rms_angles_base" -> { b with rms_angles_base = (PDBjDict.some_float v) }
      | "num_angles_base" -> { b with num_angles_base = (PDBjDict.some_int v) }
      | "rms_angles_sugar" -> { b with rms_angles_sugar = (PDBjDict.some_float v) }
      | "num_angles_sugar" -> { b with num_angles_sugar = (PDBjDict.some_int v) }
      | "rms_angles_phosphate" -> { b with rms_angles_phosphate = (PDBjDict.some_float v) }
      | "num_angles_phosphate" -> { b with num_angles_phosphate = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("rms_bonds", string_of_float v)) a.rms_bonds;
      Option.map (fun v -> ("num_bonds", string_of_int v)) a.num_bonds;
      Option.map (fun v -> ("rms_bonds_base", string_of_float v)) a.rms_bonds_base;
      Option.map (fun v -> ("num_bonds_base", string_of_int v)) a.num_bonds_base;
      Option.map (fun v -> ("rms_bonds_sugar", string_of_float v)) a.rms_bonds_sugar;
      Option.map (fun v -> ("num_bonds_sugar", string_of_int v)) a.num_bonds_sugar;
      Option.map (fun v -> ("rms_bonds_phosphate", string_of_float v)) a.rms_bonds_phosphate;
      Option.map (fun v -> ("num_bonds_phosphate", string_of_int v)) a.num_bonds_phosphate;
      Option.map (fun v -> ("rms_angles", string_of_float v)) a.rms_angles;
      Option.map (fun v -> ("num_angles", string_of_int v)) a.num_angles;
      Option.map (fun v -> ("rms_angles_base", string_of_float v)) a.rms_angles_base;
      Option.map (fun v -> ("num_angles_base", string_of_int v)) a.num_angles_base;
      Option.map (fun v -> ("rms_angles_sugar", string_of_float v)) a.rms_angles_sugar;
      Option.map (fun v -> ("num_angles_sugar", string_of_int v)) a.num_angles_sugar;
      Option.map (fun v -> ("rms_angles_phosphate", string_of_float v)) a.rms_angles_phosphate;
      Option.map (fun v -> ("num_angles_phosphate", string_of_int v)) a.num_angles_phosphate;
    ]

end

module Pdbx_rms_devs_cov_by_monomer = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    auth_seq_id: string option;
    label_seq_id: int option;
    rms_bonds: float option;
    num_bonds: int option;
    rms_angles: float option;
    num_angles: int option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id = None;
    label_asym_id = None;
    label_comp_id = None;
    auth_seq_id = None;
    label_seq_id = None;
    rms_bonds = None;
    num_bonds = None;
    rms_angles = None;
    num_angles = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "rms_bonds" -> { b with rms_bonds = (PDBjDict.some_float v) }
      | "num_bonds" -> { b with num_bonds = (PDBjDict.some_int v) }
      | "rms_angles" -> { b with rms_angles = (PDBjDict.some_float v) }
      | "num_angles" -> { b with num_angles = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("rms_bonds", string_of_float v)) a.rms_bonds;
      Option.map (fun v -> ("num_bonds", string_of_int v)) a.num_bonds;
      Option.map (fun v -> ("rms_angles", string_of_float v)) a.rms_angles;
      Option.map (fun v -> ("num_angles", string_of_int v)) a.num_angles;
    ]

end

module Pdbx_sugar_phosphate_geometry = struct
  type t = {
    id: int option;
    model_id: int option;
    auth_asym_id: string option;
    label_asym_id: string option;
    label_comp_id: string option;
    auth_seq_id: string option;
    label_seq_id: int option;
    neighbor_comp_id_5prime: string option;
    neighbor_comp_id_3prime: string option;
    o3_p_o5_c5: float option;
    p_o5_c5_c4: float option;
    o5_c5_c4_c3: float option;
    c5_c4_c3_o3: float option;
    c4_c3_o3_p: float option;
    c3_o3_p_o5: float option;
    c4_o4_c1_n1_9: float option;
    o4_c1_n1_9_c2_4: float option;
    o4_c1_n1_9_c6_8: float option;
    c4_o4_c1_c2: float option;
    o4_c1_c2_c3: float option;
    c1_c2_c3_c4: float option;
    c2_c3_c4_o4: float option;
    c3_c4_o4_c1: float option;
    c5_c4_c3_c2: float option;
    o4_c4_c3_o3: float option;
    o3_c3_c2_o2: float option;
    o5_c5_c4_o4: float option;
    pseudorot: float option;
    maxtorsion: float option;
    next_label_comp_id: string option;
    next_label_seq_id: int option;
    next_o3_p_o5_c5: float option;
    next_p_o5_c5_c4: float option;
    next_o5_c5_c4_c3: float option;
    next_c5_c4_c3_o3: float option;
    next_c4_c3_o3_p: float option;
    next_c3_o3_p_o5: float option;
    next_c4_o4_c1_n1_9: float option;
    next_o4_c1_n1_9_c2_4: float option;
    c1_c2: float option;
    c2_c3: float option;
    c3_c4: float option;
    c4_o4: float option;
    o4_c1: float option;
    p_o5: float option;
    o5_c5: float option;
    c5_c4: float option;
    c3_o3: float option;
    o3_p: float option;
    p_o1p: float option;
    p_o2p: float option;
    c1_n9_1: float option;
    n1_c2: float option;
    n1_c6: float option;
    n9_c4: float option;
    n9_c8: float option;
    c1_c2_c3: float option;
    c2_c3_c4: float option;
    c3_c4_o4: float option;
    c4_o4_c1: float option;
    o4_c1_c2: float option;
    p_o5_c5: float option;
    o5_c5_c4: float option;
    c5_c4_c3: float option;
    c4_c3_o3: float option;
    c3_o3_p: float option;
    o3_p_o5: float option;
    o4_c1_n1_9: float option;
    c1_n1_9_c2_4: float option;
    c5_c4_o4: float option;
    c2_c3_o3: float option;
    o1p_p_o2p: float option;
    c2_c1_n1_9: float option;
    c1_n1_9_c6_8: float option;
  }

  let default = {
    id = None;
    model_id = None;
    auth_asym_id = None;
    label_asym_id = None;
    label_comp_id = None;
    auth_seq_id = None;
    label_seq_id = None;
    neighbor_comp_id_5prime = None;
    neighbor_comp_id_3prime = None;
    o3_p_o5_c5 = None;
    p_o5_c5_c4 = None;
    o5_c5_c4_c3 = None;
    c5_c4_c3_o3 = None;
    c4_c3_o3_p = None;
    c3_o3_p_o5 = None;
    c4_o4_c1_n1_9 = None;
    o4_c1_n1_9_c2_4 = None;
    o4_c1_n1_9_c6_8 = None;
    c4_o4_c1_c2 = None;
    o4_c1_c2_c3 = None;
    c1_c2_c3_c4 = None;
    c2_c3_c4_o4 = None;
    c3_c4_o4_c1 = None;
    c5_c4_c3_c2 = None;
    o4_c4_c3_o3 = None;
    o3_c3_c2_o2 = None;
    o5_c5_c4_o4 = None;
    pseudorot = None;
    maxtorsion = None;
    next_label_comp_id = None;
    next_label_seq_id = None;
    next_o3_p_o5_c5 = None;
    next_p_o5_c5_c4 = None;
    next_o5_c5_c4_c3 = None;
    next_c5_c4_c3_o3 = None;
    next_c4_c3_o3_p = None;
    next_c3_o3_p_o5 = None;
    next_c4_o4_c1_n1_9 = None;
    next_o4_c1_n1_9_c2_4 = None;
    c1_c2 = None;
    c2_c3 = None;
    c3_c4 = None;
    c4_o4 = None;
    o4_c1 = None;
    p_o5 = None;
    o5_c5 = None;
    c5_c4 = None;
    c3_o3 = None;
    o3_p = None;
    p_o1p = None;
    p_o2p = None;
    c1_n9_1 = None;
    n1_c2 = None;
    n1_c6 = None;
    n9_c4 = None;
    n9_c8 = None;
    c1_c2_c3 = None;
    c2_c3_c4 = None;
    c3_c4_o4 = None;
    c4_o4_c1 = None;
    o4_c1_c2 = None;
    p_o5_c5 = None;
    o5_c5_c4 = None;
    c5_c4_c3 = None;
    c4_c3_o3 = None;
    c3_o3_p = None;
    o3_p_o5 = None;
    o4_c1_n1_9 = None;
    c1_n1_9_c2_4 = None;
    c5_c4_o4 = None;
    c2_c3_o3 = None;
    o1p_p_o2p = None;
    c2_c1_n1_9 = None;
    c1_n1_9_c6_8 = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (PDBjDict.some_int v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "label_asym_id" -> { b with label_asym_id = (Some v) }
      | "label_comp_id" -> { b with label_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "label_seq_id" -> { b with label_seq_id = (PDBjDict.some_int v) }
      | "neighbor_comp_id_5prime" -> { b with neighbor_comp_id_5prime = (Some v) }
      | "neighbor_comp_id_3prime" -> { b with neighbor_comp_id_3prime = (Some v) }
      | "o3_p_o5_c5" -> { b with o3_p_o5_c5 = (PDBjDict.some_float v) }
      | "p_o5_c5_c4" -> { b with p_o5_c5_c4 = (PDBjDict.some_float v) }
      | "o5_c5_c4_c3" -> { b with o5_c5_c4_c3 = (PDBjDict.some_float v) }
      | "c5_c4_c3_o3" -> { b with c5_c4_c3_o3 = (PDBjDict.some_float v) }
      | "c4_c3_o3_p" -> { b with c4_c3_o3_p = (PDBjDict.some_float v) }
      | "c3_o3_p_o5" -> { b with c3_o3_p_o5 = (PDBjDict.some_float v) }
      | "c4_o4_c1_n1_9" -> { b with c4_o4_c1_n1_9 = (PDBjDict.some_float v) }
      | "o4_c1_n1_9_c2_4" -> { b with o4_c1_n1_9_c2_4 = (PDBjDict.some_float v) }
      | "o4_c1_n1_9_c6_8" -> { b with o4_c1_n1_9_c6_8 = (PDBjDict.some_float v) }
      | "c4_o4_c1_c2" -> { b with c4_o4_c1_c2 = (PDBjDict.some_float v) }
      | "o4_c1_c2_c3" -> { b with o4_c1_c2_c3 = (PDBjDict.some_float v) }
      | "c1_c2_c3_c4" -> { b with c1_c2_c3_c4 = (PDBjDict.some_float v) }
      | "c2_c3_c4_o4" -> { b with c2_c3_c4_o4 = (PDBjDict.some_float v) }
      | "c3_c4_o4_c1" -> { b with c3_c4_o4_c1 = (PDBjDict.some_float v) }
      | "c5_c4_c3_c2" -> { b with c5_c4_c3_c2 = (PDBjDict.some_float v) }
      | "o4_c4_c3_o3" -> { b with o4_c4_c3_o3 = (PDBjDict.some_float v) }
      | "o3_c3_c2_o2" -> { b with o3_c3_c2_o2 = (PDBjDict.some_float v) }
      | "o5_c5_c4_o4" -> { b with o5_c5_c4_o4 = (PDBjDict.some_float v) }
      | "pseudorot" -> { b with pseudorot = (PDBjDict.some_float v) }
      | "maxtorsion" -> { b with maxtorsion = (PDBjDict.some_float v) }
      | "next_label_comp_id" -> { b with next_label_comp_id = (Some v) }
      | "next_label_seq_id" -> { b with next_label_seq_id = (PDBjDict.some_int v) }
      | "next_o3_p_o5_c5" -> { b with next_o3_p_o5_c5 = (PDBjDict.some_float v) }
      | "next_p_o5_c5_c4" -> { b with next_p_o5_c5_c4 = (PDBjDict.some_float v) }
      | "next_o5_c5_c4_c3" -> { b with next_o5_c5_c4_c3 = (PDBjDict.some_float v) }
      | "next_c5_c4_c3_o3" -> { b with next_c5_c4_c3_o3 = (PDBjDict.some_float v) }
      | "next_c4_c3_o3_p" -> { b with next_c4_c3_o3_p = (PDBjDict.some_float v) }
      | "next_c3_o3_p_o5" -> { b with next_c3_o3_p_o5 = (PDBjDict.some_float v) }
      | "next_c4_o4_c1_n1_9" -> { b with next_c4_o4_c1_n1_9 = (PDBjDict.some_float v) }
      | "next_o4_c1_n1_9_c2_4" -> { b with next_o4_c1_n1_9_c2_4 = (PDBjDict.some_float v) }
      | "c1_c2" -> { b with c1_c2 = (PDBjDict.some_float v) }
      | "c2_c3" -> { b with c2_c3 = (PDBjDict.some_float v) }
      | "c3_c4" -> { b with c3_c4 = (PDBjDict.some_float v) }
      | "c4_o4" -> { b with c4_o4 = (PDBjDict.some_float v) }
      | "o4_c1" -> { b with o4_c1 = (PDBjDict.some_float v) }
      | "p_o5" -> { b with p_o5 = (PDBjDict.some_float v) }
      | "o5_c5" -> { b with o5_c5 = (PDBjDict.some_float v) }
      | "c5_c4" -> { b with c5_c4 = (PDBjDict.some_float v) }
      | "c3_o3" -> { b with c3_o3 = (PDBjDict.some_float v) }
      | "o3_p" -> { b with o3_p = (PDBjDict.some_float v) }
      | "p_o1p" -> { b with p_o1p = (PDBjDict.some_float v) }
      | "p_o2p" -> { b with p_o2p = (PDBjDict.some_float v) }
      | "c1_n9_1" -> { b with c1_n9_1 = (PDBjDict.some_float v) }
      | "n1_c2" -> { b with n1_c2 = (PDBjDict.some_float v) }
      | "n1_c6" -> { b with n1_c6 = (PDBjDict.some_float v) }
      | "n9_c4" -> { b with n9_c4 = (PDBjDict.some_float v) }
      | "n9_c8" -> { b with n9_c8 = (PDBjDict.some_float v) }
      | "c1_c2_c3" -> { b with c1_c2_c3 = (PDBjDict.some_float v) }
      | "c2_c3_c4" -> { b with c2_c3_c4 = (PDBjDict.some_float v) }
      | "c3_c4_o4" -> { b with c3_c4_o4 = (PDBjDict.some_float v) }
      | "c4_o4_c1" -> { b with c4_o4_c1 = (PDBjDict.some_float v) }
      | "o4_c1_c2" -> { b with o4_c1_c2 = (PDBjDict.some_float v) }
      | "p_o5_c5" -> { b with p_o5_c5 = (PDBjDict.some_float v) }
      | "o5_c5_c4" -> { b with o5_c5_c4 = (PDBjDict.some_float v) }
      | "c5_c4_c3" -> { b with c5_c4_c3 = (PDBjDict.some_float v) }
      | "c4_c3_o3" -> { b with c4_c3_o3 = (PDBjDict.some_float v) }
      | "c3_o3_p" -> { b with c3_o3_p = (PDBjDict.some_float v) }
      | "o3_p_o5" -> { b with o3_p_o5 = (PDBjDict.some_float v) }
      | "o4_c1_n1_9" -> { b with o4_c1_n1_9 = (PDBjDict.some_float v) }
      | "c1_n1_9_c2_4" -> { b with c1_n1_9_c2_4 = (PDBjDict.some_float v) }
      | "c5_c4_o4" -> { b with c5_c4_o4 = (PDBjDict.some_float v) }
      | "c2_c3_o3" -> { b with c2_c3_o3 = (PDBjDict.some_float v) }
      | "o1p_p_o2p" -> { b with o1p_p_o2p = (PDBjDict.some_float v) }
      | "c2_c1_n1_9" -> { b with c2_c1_n1_9 = (PDBjDict.some_float v) }
      | "c1_n1_9_c6_8" -> { b with c1_n1_9_c6_8 = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id", string_of_int v)) a.model_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("label_asym_id",  v)) a.label_asym_id;
      Option.map (fun v -> ("label_comp_id",  v)) a.label_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("label_seq_id", string_of_int v)) a.label_seq_id;
      Option.map (fun v -> ("neighbor_comp_id_5prime",  v)) a.neighbor_comp_id_5prime;
      Option.map (fun v -> ("neighbor_comp_id_3prime",  v)) a.neighbor_comp_id_3prime;
      Option.map (fun v -> ("o3_p_o5_c5", string_of_float v)) a.o3_p_o5_c5;
      Option.map (fun v -> ("p_o5_c5_c4", string_of_float v)) a.p_o5_c5_c4;
      Option.map (fun v -> ("o5_c5_c4_c3", string_of_float v)) a.o5_c5_c4_c3;
      Option.map (fun v -> ("c5_c4_c3_o3", string_of_float v)) a.c5_c4_c3_o3;
      Option.map (fun v -> ("c4_c3_o3_p", string_of_float v)) a.c4_c3_o3_p;
      Option.map (fun v -> ("c3_o3_p_o5", string_of_float v)) a.c3_o3_p_o5;
      Option.map (fun v -> ("c4_o4_c1_n1_9", string_of_float v)) a.c4_o4_c1_n1_9;
      Option.map (fun v -> ("o4_c1_n1_9_c2_4", string_of_float v)) a.o4_c1_n1_9_c2_4;
      Option.map (fun v -> ("o4_c1_n1_9_c6_8", string_of_float v)) a.o4_c1_n1_9_c6_8;
      Option.map (fun v -> ("c4_o4_c1_c2", string_of_float v)) a.c4_o4_c1_c2;
      Option.map (fun v -> ("o4_c1_c2_c3", string_of_float v)) a.o4_c1_c2_c3;
      Option.map (fun v -> ("c1_c2_c3_c4", string_of_float v)) a.c1_c2_c3_c4;
      Option.map (fun v -> ("c2_c3_c4_o4", string_of_float v)) a.c2_c3_c4_o4;
      Option.map (fun v -> ("c3_c4_o4_c1", string_of_float v)) a.c3_c4_o4_c1;
      Option.map (fun v -> ("c5_c4_c3_c2", string_of_float v)) a.c5_c4_c3_c2;
      Option.map (fun v -> ("o4_c4_c3_o3", string_of_float v)) a.o4_c4_c3_o3;
      Option.map (fun v -> ("o3_c3_c2_o2", string_of_float v)) a.o3_c3_c2_o2;
      Option.map (fun v -> ("o5_c5_c4_o4", string_of_float v)) a.o5_c5_c4_o4;
      Option.map (fun v -> ("pseudorot", string_of_float v)) a.pseudorot;
      Option.map (fun v -> ("maxtorsion", string_of_float v)) a.maxtorsion;
      Option.map (fun v -> ("next_label_comp_id",  v)) a.next_label_comp_id;
      Option.map (fun v -> ("next_label_seq_id", string_of_int v)) a.next_label_seq_id;
      Option.map (fun v -> ("next_o3_p_o5_c5", string_of_float v)) a.next_o3_p_o5_c5;
      Option.map (fun v -> ("next_p_o5_c5_c4", string_of_float v)) a.next_p_o5_c5_c4;
      Option.map (fun v -> ("next_o5_c5_c4_c3", string_of_float v)) a.next_o5_c5_c4_c3;
      Option.map (fun v -> ("next_c5_c4_c3_o3", string_of_float v)) a.next_c5_c4_c3_o3;
      Option.map (fun v -> ("next_c4_c3_o3_p", string_of_float v)) a.next_c4_c3_o3_p;
      Option.map (fun v -> ("next_c3_o3_p_o5", string_of_float v)) a.next_c3_o3_p_o5;
      Option.map (fun v -> ("next_c4_o4_c1_n1_9", string_of_float v)) a.next_c4_o4_c1_n1_9;
      Option.map (fun v -> ("next_o4_c1_n1_9_c2_4", string_of_float v)) a.next_o4_c1_n1_9_c2_4;
      Option.map (fun v -> ("c1_c2", string_of_float v)) a.c1_c2;
      Option.map (fun v -> ("c2_c3", string_of_float v)) a.c2_c3;
      Option.map (fun v -> ("c3_c4", string_of_float v)) a.c3_c4;
      Option.map (fun v -> ("c4_o4", string_of_float v)) a.c4_o4;
      Option.map (fun v -> ("o4_c1", string_of_float v)) a.o4_c1;
      Option.map (fun v -> ("p_o5", string_of_float v)) a.p_o5;
      Option.map (fun v -> ("o5_c5", string_of_float v)) a.o5_c5;
      Option.map (fun v -> ("c5_c4", string_of_float v)) a.c5_c4;
      Option.map (fun v -> ("c3_o3", string_of_float v)) a.c3_o3;
      Option.map (fun v -> ("o3_p", string_of_float v)) a.o3_p;
      Option.map (fun v -> ("p_o1p", string_of_float v)) a.p_o1p;
      Option.map (fun v -> ("p_o2p", string_of_float v)) a.p_o2p;
      Option.map (fun v -> ("c1_n9_1", string_of_float v)) a.c1_n9_1;
      Option.map (fun v -> ("n1_c2", string_of_float v)) a.n1_c2;
      Option.map (fun v -> ("n1_c6", string_of_float v)) a.n1_c6;
      Option.map (fun v -> ("n9_c4", string_of_float v)) a.n9_c4;
      Option.map (fun v -> ("n9_c8", string_of_float v)) a.n9_c8;
      Option.map (fun v -> ("c1_c2_c3", string_of_float v)) a.c1_c2_c3;
      Option.map (fun v -> ("c2_c3_c4", string_of_float v)) a.c2_c3_c4;
      Option.map (fun v -> ("c3_c4_o4", string_of_float v)) a.c3_c4_o4;
      Option.map (fun v -> ("c4_o4_c1", string_of_float v)) a.c4_o4_c1;
      Option.map (fun v -> ("o4_c1_c2", string_of_float v)) a.o4_c1_c2;
      Option.map (fun v -> ("p_o5_c5", string_of_float v)) a.p_o5_c5;
      Option.map (fun v -> ("o5_c5_c4", string_of_float v)) a.o5_c5_c4;
      Option.map (fun v -> ("c5_c4_c3", string_of_float v)) a.c5_c4_c3;
      Option.map (fun v -> ("c4_c3_o3", string_of_float v)) a.c4_c3_o3;
      Option.map (fun v -> ("c3_o3_p", string_of_float v)) a.c3_o3_p;
      Option.map (fun v -> ("o3_p_o5", string_of_float v)) a.o3_p_o5;
      Option.map (fun v -> ("o4_c1_n1_9", string_of_float v)) a.o4_c1_n1_9;
      Option.map (fun v -> ("c1_n1_9_c2_4", string_of_float v)) a.c1_n1_9_c2_4;
      Option.map (fun v -> ("c5_c4_o4", string_of_float v)) a.c5_c4_o4;
      Option.map (fun v -> ("c2_c3_o3", string_of_float v)) a.c2_c3_o3;
      Option.map (fun v -> ("o1p_p_o2p", string_of_float v)) a.o1p_p_o2p;
      Option.map (fun v -> ("c2_c1_n1_9", string_of_float v)) a.c2_c1_n1_9;
      Option.map (fun v -> ("c1_n1_9_c6_8", string_of_float v)) a.c1_n1_9_c6_8;
    ]

end

module Pdbx_nmr_computing = struct
  type t = {
    entry_id: string option;
    collection: string option;
    collection_version: string option;
    processing: string option;
    processing_version: string option;
    data_analysis: string option;
    data_analysis_version: string option;
    structure_solution: string option;
    structure_solution_version: string option;
    refinement: string option;
    refinement_version: string option;
    iterative_relaxation_matrix: string option;
    iterative_relaxation_matrix_version: string option;
  }

  let default = {
    entry_id = None;
    collection = None;
    collection_version = None;
    processing = None;
    processing_version = None;
    data_analysis = None;
    data_analysis_version = None;
    structure_solution = None;
    structure_solution_version = None;
    refinement = None;
    refinement_version = None;
    iterative_relaxation_matrix = None;
    iterative_relaxation_matrix_version = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "entry_id" -> { b with entry_id = (Some v) }
      | "collection" -> { b with collection = (Some v) }
      | "collection_version" -> { b with collection_version = (Some v) }
      | "processing" -> { b with processing = (Some v) }
      | "processing_version" -> { b with processing_version = (Some v) }
      | "data_analysis" -> { b with data_analysis = (Some v) }
      | "data_analysis_version" -> { b with data_analysis_version = (Some v) }
      | "structure_solution" -> { b with structure_solution = (Some v) }
      | "structure_solution_version" -> { b with structure_solution_version = (Some v) }
      | "refinement" -> { b with refinement = (Some v) }
      | "refinement_version" -> { b with refinement_version = (Some v) }
      | "iterative_relaxation_matrix" -> { b with iterative_relaxation_matrix = (Some v) }
      | "iterative_relaxation_matrix_version" -> { b with iterative_relaxation_matrix_version = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("entry_id",  v)) a.entry_id;
      Option.map (fun v -> ("collection",  v)) a.collection;
      Option.map (fun v -> ("collection_version",  v)) a.collection_version;
      Option.map (fun v -> ("processing",  v)) a.processing;
      Option.map (fun v -> ("processing_version",  v)) a.processing_version;
      Option.map (fun v -> ("data_analysis",  v)) a.data_analysis;
      Option.map (fun v -> ("data_analysis_version",  v)) a.data_analysis_version;
      Option.map (fun v -> ("structure_solution",  v)) a.structure_solution;
      Option.map (fun v -> ("structure_solution_version",  v)) a.structure_solution_version;
      Option.map (fun v -> ("refinement",  v)) a.refinement;
      Option.map (fun v -> ("refinement_version",  v)) a.refinement_version;
      Option.map (fun v -> ("iterative_relaxation_matrix",  v)) a.iterative_relaxation_matrix;
      Option.map (fun v -> ("iterative_relaxation_matrix_version",  v)) a.iterative_relaxation_matrix_version;
    ]

end

module Pdbx_audit_conform_extension = struct
  type t = {
    extension_dict_location: string option;
    extension_dict_name: string option;
    extension_dict_version: string option;
  }

  let default = {
    extension_dict_location = None;
    extension_dict_name = None;
    extension_dict_version = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "extension_dict_location" -> { b with extension_dict_location = (Some v) }
      | "extension_dict_name" -> { b with extension_dict_name = (Some v) }
      | "extension_dict_version" -> { b with extension_dict_version = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("extension_dict_location",  v)) a.extension_dict_location;
      Option.map (fun v -> ("extension_dict_name",  v)) a.extension_dict_name;
      Option.map (fun v -> ("extension_dict_version",  v)) a.extension_dict_version;
    ]

end

module Pdbx_dcc_mapman = struct
  type t = {
    pdbid: string option;
    details: string option;
  }

  let default = {
    pdbid = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdbid" -> { b with pdbid = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdbid",  v)) a.pdbid;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_dcc_rscc_mapman = struct
  type t = {
    id: int option;
    model_id: string option;
    pdb_id: string option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    label_alt_id: string option;
    label_ins_code: string option;
    correlation: float option;
    real_space_R: float option;
    weighted_real_space_R: float option;
    real_space_Zscore: float option;
    biso_mean: float option;
    occupancy_mean: float option;
    flag: string option;
  }

  let default = {
    id = None;
    model_id = None;
    pdb_id = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    label_alt_id = None;
    label_ins_code = None;
    correlation = None;
    real_space_R = None;
    weighted_real_space_R = None;
    real_space_Zscore = None;
    biso_mean = None;
    occupancy_mean = None;
    flag = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (Some v) }
      | "pdb_id" -> { b with pdb_id = (Some v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_ins_code" -> { b with label_ins_code = (Some v) }
      | "correlation" -> { b with correlation = (PDBjDict.some_float v) }
      | "real_space_R" -> { b with real_space_R = (PDBjDict.some_float v) }
      | "weighted_real_space_R" -> { b with weighted_real_space_R = (PDBjDict.some_float v) }
      | "real_space_Zscore" -> { b with real_space_Zscore = (PDBjDict.some_float v) }
      | "Biso_mean" -> { b with biso_mean = (PDBjDict.some_float v) }
      | "occupancy_mean" -> { b with occupancy_mean = (PDBjDict.some_float v) }
      | "flag" -> { b with flag = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id",  v)) a.model_id;
      Option.map (fun v -> ("pdb_id",  v)) a.pdb_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_ins_code",  v)) a.label_ins_code;
      Option.map (fun v -> ("correlation", string_of_float v)) a.correlation;
      Option.map (fun v -> ("real_space_R", string_of_float v)) a.real_space_R;
      Option.map (fun v -> ("weighted_real_space_R", string_of_float v)) a.weighted_real_space_R;
      Option.map (fun v -> ("real_space_Zscore", string_of_float v)) a.real_space_Zscore;
      Option.map (fun v -> ("Biso_mean", string_of_float v)) a.biso_mean;
      Option.map (fun v -> ("occupancy_mean", string_of_float v)) a.occupancy_mean;
      Option.map (fun v -> ("flag",  v)) a.flag;
    ]

end

module Pdbx_dcc_rscc_mapman_overall = struct
  type t = {
    pdbid: string option;
    correlation: float option;
    correlation_sigma: float option;
    real_space_R: float option;
    real_space_R_sigma: float option;
  }

  let default = {
    pdbid = None;
    correlation = None;
    correlation_sigma = None;
    real_space_R = None;
    real_space_R_sigma = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdbid" -> { b with pdbid = (Some v) }
      | "correlation" -> { b with correlation = (PDBjDict.some_float v) }
      | "correlation_sigma" -> { b with correlation_sigma = (PDBjDict.some_float v) }
      | "real_space_R" -> { b with real_space_R = (PDBjDict.some_float v) }
      | "real_space_R_sigma" -> { b with real_space_R_sigma = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdbid",  v)) a.pdbid;
      Option.map (fun v -> ("correlation", string_of_float v)) a.correlation;
      Option.map (fun v -> ("correlation_sigma", string_of_float v)) a.correlation_sigma;
      Option.map (fun v -> ("real_space_R", string_of_float v)) a.real_space_R;
      Option.map (fun v -> ("real_space_R_sigma", string_of_float v)) a.real_space_R_sigma;
    ]

end

module Pdbx_dcc_density = struct
  type t = {
    dCC_version: string option;
    pdbid: string option;
    pdbtype: string option;
    unit_cell: string option;
    space_group_name_H_M: string option;
    space_group_pointless: string option;
    ls_d_res_high: float option;
    ls_d_res_high_sf: float option;
    ls_d_res_low_sf: float option;
    r_value_R_work: float option;
    r_value_R_free: float option;
    working_set_count: int option;
    free_set_count: int option;
    occupancy_min: float option;
    occupancy_max: float option;
    occupancy_mean: float option;
    biso_min: float option;
    biso_max: float option;
    biso_mean: float option;
    b_wilson: float option;
    b_wilson_scale: float option;
    mean_I2_over_mean_I_square: float option;
    mean_F_square_over_mean_F2: float option;
    mean_E2_1_abs: float option;
    padilla_Yeates_L_mean: float option;
    padilla_Yeates_L2_mean: float option;
    padilla_Yeates_L2_mean_pointless: float option;
    z_score_L_test: float option;
    twin_type: string option;
    twin_operator_xtriage: string option;
    twin_fraction_xtriage: float option;
    twin_Rfactor: float option;
    i_over_sigI_resh: float option;
    i_over_sigI_diff: float option;
    i_over_sigI_mean: float option;
    ice_ring: string option;
    anisotropy: float option;
    z_score: float option;
    prob_peak_value: float option;
    translational_pseudo_symmetry: string option;
    wavelength: float option;
    b_solvent: float option;
    k_solvent: float option;
    tLS_refinement_reported: string option;
    partial_B_value_correction_attempted: string option;
    partial_B_value_correction_success: string option;
    reflection_status_archived: string option;
    reflection_status_used: string option;
    iso_B_value_type: string option;
    reflns_twin: string option;
    twin_by_xtriage: string option;
    twin_operator: string option;
    twin_fraction: string option;
    tls_group_number: int option;
    ncs_group_number: int option;
    mtrix_number: int option;
    matthew_coeff: float option;
    solvent_content: float option;
    cruickshank_dpi_xyz: float option;
    dpi_free_R: float option;
    fom: float option;
    correlation_overall: float option;
    real_space_R_overall: float option;
    mFo_DFc_3sigma_positive: int option;
    mFo_DFc_6sigma_positive: int option;
    mFo_DFc_3sigma_negative: int option;
    mFo_DFc_6sigma_negative: int option;
    bmean_Bwilson: float option;
    rfree_Rwork: float option;
    error: string option;
  }

  let default = {
    dCC_version = None;
    pdbid = None;
    pdbtype = None;
    unit_cell = None;
    space_group_name_H_M = None;
    space_group_pointless = None;
    ls_d_res_high = None;
    ls_d_res_high_sf = None;
    ls_d_res_low_sf = None;
    r_value_R_work = None;
    r_value_R_free = None;
    working_set_count = None;
    free_set_count = None;
    occupancy_min = None;
    occupancy_max = None;
    occupancy_mean = None;
    biso_min = None;
    biso_max = None;
    biso_mean = None;
    b_wilson = None;
    b_wilson_scale = None;
    mean_I2_over_mean_I_square = None;
    mean_F_square_over_mean_F2 = None;
    mean_E2_1_abs = None;
    padilla_Yeates_L_mean = None;
    padilla_Yeates_L2_mean = None;
    padilla_Yeates_L2_mean_pointless = None;
    z_score_L_test = None;
    twin_type = None;
    twin_operator_xtriage = None;
    twin_fraction_xtriage = None;
    twin_Rfactor = None;
    i_over_sigI_resh = None;
    i_over_sigI_diff = None;
    i_over_sigI_mean = None;
    ice_ring = None;
    anisotropy = None;
    z_score = None;
    prob_peak_value = None;
    translational_pseudo_symmetry = None;
    wavelength = None;
    b_solvent = None;
    k_solvent = None;
    tLS_refinement_reported = None;
    partial_B_value_correction_attempted = None;
    partial_B_value_correction_success = None;
    reflection_status_archived = None;
    reflection_status_used = None;
    iso_B_value_type = None;
    reflns_twin = None;
    twin_by_xtriage = None;
    twin_operator = None;
    twin_fraction = None;
    tls_group_number = None;
    ncs_group_number = None;
    mtrix_number = None;
    matthew_coeff = None;
    solvent_content = None;
    cruickshank_dpi_xyz = None;
    dpi_free_R = None;
    fom = None;
    correlation_overall = None;
    real_space_R_overall = None;
    mFo_DFc_3sigma_positive = None;
    mFo_DFc_6sigma_positive = None;
    mFo_DFc_3sigma_negative = None;
    mFo_DFc_6sigma_negative = None;
    bmean_Bwilson = None;
    rfree_Rwork = None;
    error = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "DCC_version" -> { b with dCC_version = (Some v) }
      | "pdbid" -> { b with pdbid = (Some v) }
      | "pdbtype" -> { b with pdbtype = (Some v) }
      | "unit_cell" -> { b with unit_cell = (Some v) }
      | "space_group_name_H-M" -> { b with space_group_name_H_M = (Some v) }
      | "space_group_pointless" -> { b with space_group_pointless = (Some v) }
      | "ls_d_res_high" -> { b with ls_d_res_high = (PDBjDict.some_float v) }
      | "ls_d_res_high_sf" -> { b with ls_d_res_high_sf = (PDBjDict.some_float v) }
      | "ls_d_res_low_sf" -> { b with ls_d_res_low_sf = (PDBjDict.some_float v) }
      | "R_value_R_work" -> { b with r_value_R_work = (PDBjDict.some_float v) }
      | "R_value_R_free" -> { b with r_value_R_free = (PDBjDict.some_float v) }
      | "working_set_count" -> { b with working_set_count = (PDBjDict.some_int v) }
      | "free_set_count" -> { b with free_set_count = (PDBjDict.some_int v) }
      | "occupancy_min" -> { b with occupancy_min = (PDBjDict.some_float v) }
      | "occupancy_max" -> { b with occupancy_max = (PDBjDict.some_float v) }
      | "occupancy_mean" -> { b with occupancy_mean = (PDBjDict.some_float v) }
      | "Biso_min" -> { b with biso_min = (PDBjDict.some_float v) }
      | "Biso_max" -> { b with biso_max = (PDBjDict.some_float v) }
      | "Biso_mean" -> { b with biso_mean = (PDBjDict.some_float v) }
      | "B_wilson" -> { b with b_wilson = (PDBjDict.some_float v) }
      | "B_wilson_scale" -> { b with b_wilson_scale = (PDBjDict.some_float v) }
      | "mean_I2_over_mean_I_square" -> { b with mean_I2_over_mean_I_square = (PDBjDict.some_float v) }
      | "mean_F_square_over_mean_F2" -> { b with mean_F_square_over_mean_F2 = (PDBjDict.some_float v) }
      | "mean_E2_1_abs" -> { b with mean_E2_1_abs = (PDBjDict.some_float v) }
      | "Padilla-Yeates_L_mean" -> { b with padilla_Yeates_L_mean = (PDBjDict.some_float v) }
      | "Padilla-Yeates_L2_mean" -> { b with padilla_Yeates_L2_mean = (PDBjDict.some_float v) }
      | "Padilla-Yeates_L2_mean_pointless" -> { b with padilla_Yeates_L2_mean_pointless = (PDBjDict.some_float v) }
      | "Z_score_L_test" -> { b with z_score_L_test = (PDBjDict.some_float v) }
      | "twin_type" -> { b with twin_type = (Some v) }
      | "twin_operator_xtriage" -> { b with twin_operator_xtriage = (Some v) }
      | "twin_fraction_xtriage" -> { b with twin_fraction_xtriage = (PDBjDict.some_float v) }
      | "twin_Rfactor" -> { b with twin_Rfactor = (PDBjDict.some_float v) }
      | "I_over_sigI_resh" -> { b with i_over_sigI_resh = (PDBjDict.some_float v) }
      | "I_over_sigI_diff" -> { b with i_over_sigI_diff = (PDBjDict.some_float v) }
      | "I_over_sigI_mean" -> { b with i_over_sigI_mean = (PDBjDict.some_float v) }
      | "ice_ring" -> { b with ice_ring = (Some v) }
      | "anisotropy" -> { b with anisotropy = (PDBjDict.some_float v) }
      | "Z-score" -> { b with z_score = (PDBjDict.some_float v) }
      | "prob_peak_value" -> { b with prob_peak_value = (PDBjDict.some_float v) }
      | "translational_pseudo_symmetry" -> { b with translational_pseudo_symmetry = (Some v) }
      | "wavelength" -> { b with wavelength = (PDBjDict.some_float v) }
      | "B_solvent" -> { b with b_solvent = (PDBjDict.some_float v) }
      | "K_solvent" -> { b with k_solvent = (PDBjDict.some_float v) }
      | "TLS_refinement_reported" -> { b with tLS_refinement_reported = (Some v) }
      | "partial_B_value_correction_attempted" -> { b with partial_B_value_correction_attempted = (Some v) }
      | "partial_B_value_correction_success" -> { b with partial_B_value_correction_success = (Some v) }
      | "reflection_status_archived" -> { b with reflection_status_archived = (Some v) }
      | "reflection_status_used" -> { b with reflection_status_used = (Some v) }
      | "iso_B_value_type" -> { b with iso_B_value_type = (Some v) }
      | "reflns_twin" -> { b with reflns_twin = (Some v) }
      | "twin_by_xtriage" -> { b with twin_by_xtriage = (Some v) }
      | "twin_operator" -> { b with twin_operator = (Some v) }
      | "twin_fraction" -> { b with twin_fraction = (Some v) }
      | "tls_group_number" -> { b with tls_group_number = (PDBjDict.some_int v) }
      | "ncs_group_number" -> { b with ncs_group_number = (PDBjDict.some_int v) }
      | "mtrix_number" -> { b with mtrix_number = (PDBjDict.some_int v) }
      | "Matthew_coeff" -> { b with matthew_coeff = (PDBjDict.some_float v) }
      | "solvent_content" -> { b with solvent_content = (PDBjDict.some_float v) }
      | "Cruickshank_dpi_xyz" -> { b with cruickshank_dpi_xyz = (PDBjDict.some_float v) }
      | "dpi_free_R" -> { b with dpi_free_R = (PDBjDict.some_float v) }
      | "fom" -> { b with fom = (PDBjDict.some_float v) }
      | "correlation_overall" -> { b with correlation_overall = (PDBjDict.some_float v) }
      | "real_space_R_overall" -> { b with real_space_R_overall = (PDBjDict.some_float v) }
      | "mFo-DFc-3sigma_positive" -> { b with mFo_DFc_3sigma_positive = (PDBjDict.some_int v) }
      | "mFo-DFc-6sigma_positive" -> { b with mFo_DFc_6sigma_positive = (PDBjDict.some_int v) }
      | "mFo-DFc-3sigma_negative" -> { b with mFo_DFc_3sigma_negative = (PDBjDict.some_int v) }
      | "mFo-DFc-6sigma_negative" -> { b with mFo_DFc_6sigma_negative = (PDBjDict.some_int v) }
      | "Bmean-Bwilson" -> { b with bmean_Bwilson = (PDBjDict.some_float v) }
      | "Rfree-Rwork" -> { b with rfree_Rwork = (PDBjDict.some_float v) }
      | "error" -> { b with error = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("DCC_version",  v)) a.dCC_version;
      Option.map (fun v -> ("pdbid",  v)) a.pdbid;
      Option.map (fun v -> ("pdbtype",  v)) a.pdbtype;
      Option.map (fun v -> ("unit_cell",  v)) a.unit_cell;
      Option.map (fun v -> ("space_group_name_H-M",  v)) a.space_group_name_H_M;
      Option.map (fun v -> ("space_group_pointless",  v)) a.space_group_pointless;
      Option.map (fun v -> ("ls_d_res_high", string_of_float v)) a.ls_d_res_high;
      Option.map (fun v -> ("ls_d_res_high_sf", string_of_float v)) a.ls_d_res_high_sf;
      Option.map (fun v -> ("ls_d_res_low_sf", string_of_float v)) a.ls_d_res_low_sf;
      Option.map (fun v -> ("R_value_R_work", string_of_float v)) a.r_value_R_work;
      Option.map (fun v -> ("R_value_R_free", string_of_float v)) a.r_value_R_free;
      Option.map (fun v -> ("working_set_count", string_of_int v)) a.working_set_count;
      Option.map (fun v -> ("free_set_count", string_of_int v)) a.free_set_count;
      Option.map (fun v -> ("occupancy_min", string_of_float v)) a.occupancy_min;
      Option.map (fun v -> ("occupancy_max", string_of_float v)) a.occupancy_max;
      Option.map (fun v -> ("occupancy_mean", string_of_float v)) a.occupancy_mean;
      Option.map (fun v -> ("Biso_min", string_of_float v)) a.biso_min;
      Option.map (fun v -> ("Biso_max", string_of_float v)) a.biso_max;
      Option.map (fun v -> ("Biso_mean", string_of_float v)) a.biso_mean;
      Option.map (fun v -> ("B_wilson", string_of_float v)) a.b_wilson;
      Option.map (fun v -> ("B_wilson_scale", string_of_float v)) a.b_wilson_scale;
      Option.map (fun v -> ("mean_I2_over_mean_I_square", string_of_float v)) a.mean_I2_over_mean_I_square;
      Option.map (fun v -> ("mean_F_square_over_mean_F2", string_of_float v)) a.mean_F_square_over_mean_F2;
      Option.map (fun v -> ("mean_E2_1_abs", string_of_float v)) a.mean_E2_1_abs;
      Option.map (fun v -> ("Padilla-Yeates_L_mean", string_of_float v)) a.padilla_Yeates_L_mean;
      Option.map (fun v -> ("Padilla-Yeates_L2_mean", string_of_float v)) a.padilla_Yeates_L2_mean;
      Option.map (fun v -> ("Padilla-Yeates_L2_mean_pointless", string_of_float v)) a.padilla_Yeates_L2_mean_pointless;
      Option.map (fun v -> ("Z_score_L_test", string_of_float v)) a.z_score_L_test;
      Option.map (fun v -> ("twin_type",  v)) a.twin_type;
      Option.map (fun v -> ("twin_operator_xtriage",  v)) a.twin_operator_xtriage;
      Option.map (fun v -> ("twin_fraction_xtriage", string_of_float v)) a.twin_fraction_xtriage;
      Option.map (fun v -> ("twin_Rfactor", string_of_float v)) a.twin_Rfactor;
      Option.map (fun v -> ("I_over_sigI_resh", string_of_float v)) a.i_over_sigI_resh;
      Option.map (fun v -> ("I_over_sigI_diff", string_of_float v)) a.i_over_sigI_diff;
      Option.map (fun v -> ("I_over_sigI_mean", string_of_float v)) a.i_over_sigI_mean;
      Option.map (fun v -> ("ice_ring",  v)) a.ice_ring;
      Option.map (fun v -> ("anisotropy", string_of_float v)) a.anisotropy;
      Option.map (fun v -> ("Z-score", string_of_float v)) a.z_score;
      Option.map (fun v -> ("prob_peak_value", string_of_float v)) a.prob_peak_value;
      Option.map (fun v -> ("translational_pseudo_symmetry",  v)) a.translational_pseudo_symmetry;
      Option.map (fun v -> ("wavelength", string_of_float v)) a.wavelength;
      Option.map (fun v -> ("B_solvent", string_of_float v)) a.b_solvent;
      Option.map (fun v -> ("K_solvent", string_of_float v)) a.k_solvent;
      Option.map (fun v -> ("TLS_refinement_reported",  v)) a.tLS_refinement_reported;
      Option.map (fun v -> ("partial_B_value_correction_attempted",  v)) a.partial_B_value_correction_attempted;
      Option.map (fun v -> ("partial_B_value_correction_success",  v)) a.partial_B_value_correction_success;
      Option.map (fun v -> ("reflection_status_archived",  v)) a.reflection_status_archived;
      Option.map (fun v -> ("reflection_status_used",  v)) a.reflection_status_used;
      Option.map (fun v -> ("iso_B_value_type",  v)) a.iso_B_value_type;
      Option.map (fun v -> ("reflns_twin",  v)) a.reflns_twin;
      Option.map (fun v -> ("twin_by_xtriage",  v)) a.twin_by_xtriage;
      Option.map (fun v -> ("twin_operator",  v)) a.twin_operator;
      Option.map (fun v -> ("twin_fraction",  v)) a.twin_fraction;
      Option.map (fun v -> ("tls_group_number", string_of_int v)) a.tls_group_number;
      Option.map (fun v -> ("ncs_group_number", string_of_int v)) a.ncs_group_number;
      Option.map (fun v -> ("mtrix_number", string_of_int v)) a.mtrix_number;
      Option.map (fun v -> ("Matthew_coeff", string_of_float v)) a.matthew_coeff;
      Option.map (fun v -> ("solvent_content", string_of_float v)) a.solvent_content;
      Option.map (fun v -> ("Cruickshank_dpi_xyz", string_of_float v)) a.cruickshank_dpi_xyz;
      Option.map (fun v -> ("dpi_free_R", string_of_float v)) a.dpi_free_R;
      Option.map (fun v -> ("fom", string_of_float v)) a.fom;
      Option.map (fun v -> ("correlation_overall", string_of_float v)) a.correlation_overall;
      Option.map (fun v -> ("real_space_R_overall", string_of_float v)) a.real_space_R_overall;
      Option.map (fun v -> ("mFo-DFc-3sigma_positive", string_of_int v)) a.mFo_DFc_3sigma_positive;
      Option.map (fun v -> ("mFo-DFc-6sigma_positive", string_of_int v)) a.mFo_DFc_6sigma_positive;
      Option.map (fun v -> ("mFo-DFc-3sigma_negative", string_of_int v)) a.mFo_DFc_3sigma_negative;
      Option.map (fun v -> ("mFo-DFc-6sigma_negative", string_of_int v)) a.mFo_DFc_6sigma_negative;
      Option.map (fun v -> ("Bmean-Bwilson", string_of_float v)) a.bmean_Bwilson;
      Option.map (fun v -> ("Rfree-Rwork", string_of_float v)) a.rfree_Rwork;
      Option.map (fun v -> ("error",  v)) a.error;
    ]

end

module Pdbx_dcc_geometry = struct
  type t = {
    pdbid: string option;
    ramachandran_outlier_percent: float option;
    ramachandran_outlier_number: int option;
    ramachandran_allowed_percent: float option;
    ramachandran_allowed_number: int option;
    ramachandran_favored_percent: float option;
    ramachandran_favored_number: int option;
    rotamer_outliers_percent: float option;
    rotamer_outliers_number: int option;
    cbeta_deviations: int option;
    all_atom_clashscore: float option;
    overall_score: float option;
    bond_overall_rms: float option;
    bond_overall_max: float option;
    bond_ligand_rms: float option;
    bond_ligand_max: float option;
    angle_overall_rms: float option;
    angle_overall_max: float option;
    angle_ligand_rms: float option;
    angle_ligand_max: float option;
    dihedral_overall_rms: float option;
    dihedral_overall_max: float option;
    chirality_overall_rms: float option;
    chirality_overall_max: float option;
    planarity_overall_rms: float option;
    planarity_overall_max: float option;
    non_bonded_rms: float option;
  }

  let default = {
    pdbid = None;
    ramachandran_outlier_percent = None;
    ramachandran_outlier_number = None;
    ramachandran_allowed_percent = None;
    ramachandran_allowed_number = None;
    ramachandran_favored_percent = None;
    ramachandran_favored_number = None;
    rotamer_outliers_percent = None;
    rotamer_outliers_number = None;
    cbeta_deviations = None;
    all_atom_clashscore = None;
    overall_score = None;
    bond_overall_rms = None;
    bond_overall_max = None;
    bond_ligand_rms = None;
    bond_ligand_max = None;
    angle_overall_rms = None;
    angle_overall_max = None;
    angle_ligand_rms = None;
    angle_ligand_max = None;
    dihedral_overall_rms = None;
    dihedral_overall_max = None;
    chirality_overall_rms = None;
    chirality_overall_max = None;
    planarity_overall_rms = None;
    planarity_overall_max = None;
    non_bonded_rms = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "pdbid" -> { b with pdbid = (Some v) }
      | "Ramachandran_outlier_percent" -> { b with ramachandran_outlier_percent = (PDBjDict.some_float v) }
      | "Ramachandran_outlier_number" -> { b with ramachandran_outlier_number = (PDBjDict.some_int v) }
      | "Ramachandran_allowed_percent" -> { b with ramachandran_allowed_percent = (PDBjDict.some_float v) }
      | "Ramachandran_allowed_number" -> { b with ramachandran_allowed_number = (PDBjDict.some_int v) }
      | "Ramachandran_favored_percent" -> { b with ramachandran_favored_percent = (PDBjDict.some_float v) }
      | "Ramachandran_favored_number" -> { b with ramachandran_favored_number = (PDBjDict.some_int v) }
      | "rotamer_outliers_percent" -> { b with rotamer_outliers_percent = (PDBjDict.some_float v) }
      | "rotamer_outliers_number" -> { b with rotamer_outliers_number = (PDBjDict.some_int v) }
      | "cbeta_deviations" -> { b with cbeta_deviations = (PDBjDict.some_int v) }
      | "all_atom_clashscore" -> { b with all_atom_clashscore = (PDBjDict.some_float v) }
      | "overall_score" -> { b with overall_score = (PDBjDict.some_float v) }
      | "bond_overall_rms" -> { b with bond_overall_rms = (PDBjDict.some_float v) }
      | "bond_overall_max" -> { b with bond_overall_max = (PDBjDict.some_float v) }
      | "bond_ligand_rms" -> { b with bond_ligand_rms = (PDBjDict.some_float v) }
      | "bond_ligand_max" -> { b with bond_ligand_max = (PDBjDict.some_float v) }
      | "angle_overall_rms" -> { b with angle_overall_rms = (PDBjDict.some_float v) }
      | "angle_overall_max" -> { b with angle_overall_max = (PDBjDict.some_float v) }
      | "angle_ligand_rms" -> { b with angle_ligand_rms = (PDBjDict.some_float v) }
      | "angle_ligand_max" -> { b with angle_ligand_max = (PDBjDict.some_float v) }
      | "dihedral_overall_rms" -> { b with dihedral_overall_rms = (PDBjDict.some_float v) }
      | "dihedral_overall_max" -> { b with dihedral_overall_max = (PDBjDict.some_float v) }
      | "chirality_overall_rms" -> { b with chirality_overall_rms = (PDBjDict.some_float v) }
      | "chirality_overall_max" -> { b with chirality_overall_max = (PDBjDict.some_float v) }
      | "planarity_overall_rms" -> { b with planarity_overall_rms = (PDBjDict.some_float v) }
      | "planarity_overall_max" -> { b with planarity_overall_max = (PDBjDict.some_float v) }
      | "non-bonded_rms" -> { b with non_bonded_rms = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("pdbid",  v)) a.pdbid;
      Option.map (fun v -> ("Ramachandran_outlier_percent", string_of_float v)) a.ramachandran_outlier_percent;
      Option.map (fun v -> ("Ramachandran_outlier_number", string_of_int v)) a.ramachandran_outlier_number;
      Option.map (fun v -> ("Ramachandran_allowed_percent", string_of_float v)) a.ramachandran_allowed_percent;
      Option.map (fun v -> ("Ramachandran_allowed_number", string_of_int v)) a.ramachandran_allowed_number;
      Option.map (fun v -> ("Ramachandran_favored_percent", string_of_float v)) a.ramachandran_favored_percent;
      Option.map (fun v -> ("Ramachandran_favored_number", string_of_int v)) a.ramachandran_favored_number;
      Option.map (fun v -> ("rotamer_outliers_percent", string_of_float v)) a.rotamer_outliers_percent;
      Option.map (fun v -> ("rotamer_outliers_number", string_of_int v)) a.rotamer_outliers_number;
      Option.map (fun v -> ("cbeta_deviations", string_of_int v)) a.cbeta_deviations;
      Option.map (fun v -> ("all_atom_clashscore", string_of_float v)) a.all_atom_clashscore;
      Option.map (fun v -> ("overall_score", string_of_float v)) a.overall_score;
      Option.map (fun v -> ("bond_overall_rms", string_of_float v)) a.bond_overall_rms;
      Option.map (fun v -> ("bond_overall_max", string_of_float v)) a.bond_overall_max;
      Option.map (fun v -> ("bond_ligand_rms", string_of_float v)) a.bond_ligand_rms;
      Option.map (fun v -> ("bond_ligand_max", string_of_float v)) a.bond_ligand_max;
      Option.map (fun v -> ("angle_overall_rms", string_of_float v)) a.angle_overall_rms;
      Option.map (fun v -> ("angle_overall_max", string_of_float v)) a.angle_overall_max;
      Option.map (fun v -> ("angle_ligand_rms", string_of_float v)) a.angle_ligand_rms;
      Option.map (fun v -> ("angle_ligand_max", string_of_float v)) a.angle_ligand_max;
      Option.map (fun v -> ("dihedral_overall_rms", string_of_float v)) a.dihedral_overall_rms;
      Option.map (fun v -> ("dihedral_overall_max", string_of_float v)) a.dihedral_overall_max;
      Option.map (fun v -> ("chirality_overall_rms", string_of_float v)) a.chirality_overall_rms;
      Option.map (fun v -> ("chirality_overall_max", string_of_float v)) a.chirality_overall_max;
      Option.map (fun v -> ("planarity_overall_rms", string_of_float v)) a.planarity_overall_rms;
      Option.map (fun v -> ("planarity_overall_max", string_of_float v)) a.planarity_overall_max;
      Option.map (fun v -> ("non-bonded_rms", string_of_float v)) a.non_bonded_rms;
    ]

end

module Pdbx_dcc_density_corr = struct
  type t = {
    ordinal: int option;
    program: string option;
    ls_d_res_high: float option;
    ls_d_res_low: float option;
    ls_R_factor_R_all: float option;
    ls_R_factor_R_work: float option;
    ls_R_factor_R_free: float option;
    ls_number_reflns_obs: int option;
    ls_percent_reflns_obs: float option;
    ls_number_reflns_R_free: int option;
    correlation_coeff_Fo_to_Fc: float option;
    real_space_R: float option;
    correlation: float option;
    details: string option;
  }

  let default = {
    ordinal = None;
    program = None;
    ls_d_res_high = None;
    ls_d_res_low = None;
    ls_R_factor_R_all = None;
    ls_R_factor_R_work = None;
    ls_R_factor_R_free = None;
    ls_number_reflns_obs = None;
    ls_percent_reflns_obs = None;
    ls_number_reflns_R_free = None;
    correlation_coeff_Fo_to_Fc = None;
    real_space_R = None;
    correlation = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "program" -> { b with program = (Some v) }
      | "ls_d_res_high" -> { b with ls_d_res_high = (PDBjDict.some_float v) }
      | "ls_d_res_low" -> { b with ls_d_res_low = (PDBjDict.some_float v) }
      | "ls_R_factor_R_all" -> { b with ls_R_factor_R_all = (PDBjDict.some_float v) }
      | "ls_R_factor_R_work" -> { b with ls_R_factor_R_work = (PDBjDict.some_float v) }
      | "ls_R_factor_R_free" -> { b with ls_R_factor_R_free = (PDBjDict.some_float v) }
      | "ls_number_reflns_obs" -> { b with ls_number_reflns_obs = (PDBjDict.some_int v) }
      | "ls_percent_reflns_obs" -> { b with ls_percent_reflns_obs = (PDBjDict.some_float v) }
      | "ls_number_reflns_R_free" -> { b with ls_number_reflns_R_free = (PDBjDict.some_int v) }
      | "correlation_coeff_Fo_to_Fc" -> { b with correlation_coeff_Fo_to_Fc = (PDBjDict.some_float v) }
      | "real_space_R" -> { b with real_space_R = (PDBjDict.some_float v) }
      | "correlation" -> { b with correlation = (PDBjDict.some_float v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("program",  v)) a.program;
      Option.map (fun v -> ("ls_d_res_high", string_of_float v)) a.ls_d_res_high;
      Option.map (fun v -> ("ls_d_res_low", string_of_float v)) a.ls_d_res_low;
      Option.map (fun v -> ("ls_R_factor_R_all", string_of_float v)) a.ls_R_factor_R_all;
      Option.map (fun v -> ("ls_R_factor_R_work", string_of_float v)) a.ls_R_factor_R_work;
      Option.map (fun v -> ("ls_R_factor_R_free", string_of_float v)) a.ls_R_factor_R_free;
      Option.map (fun v -> ("ls_number_reflns_obs", string_of_int v)) a.ls_number_reflns_obs;
      Option.map (fun v -> ("ls_percent_reflns_obs", string_of_float v)) a.ls_percent_reflns_obs;
      Option.map (fun v -> ("ls_number_reflns_R_free", string_of_int v)) a.ls_number_reflns_R_free;
      Option.map (fun v -> ("correlation_coeff_Fo_to_Fc", string_of_float v)) a.correlation_coeff_Fo_to_Fc;
      Option.map (fun v -> ("real_space_R", string_of_float v)) a.real_space_R;
      Option.map (fun v -> ("correlation", string_of_float v)) a.correlation;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_dcc_map = struct
  type t = {
    id: int option;
    model_id: string option;
    pdb_id: string option;
    auth_asym_id: string option;
    auth_comp_id: string option;
    auth_seq_id: string option;
    label_alt_id: string option;
    label_ins_code: string option;
    rSCC: float option;
    rSR: float option;
    weighted_RSR: float option;
    rSRZ: float option;
    weighted_RSRZ: float option;
    biso_mean: float option;
    occupancy_mean: float option;
    rSCC_main_chain: float option;
    rSR_main_chain: float option;
    wRSR_main_chain: float option;
    rSRZ_main_chain: float option;
    wRSRZ_main_chain: float option;
    biso_mean_main_chain: float option;
    occupancy_mean_main_chain: float option;
    rSCC_side_chain: float option;
    rSR_side_chain: float option;
    wRSR_side_chain: float option;
    rSRZ_side_chain: float option;
    wRSRZ_side_chain: float option;
    biso_mean_side_chain: float option;
    occupancy_mean_side_chain: float option;
    rSCC_phosphate_group: float option;
    rSR_phosphate_group: float option;
    wRSR_phosphate_group: float option;
    rSRZ_phosphate_group: float option;
    wRSRZ_phosphate_group: float option;
    biso_mean_phosphate_group: float option;
    occupancy_mean_phosphate_group: float option;
    shift: float option;
    shift_main_chain: float option;
    shift_side_chain: float option;
    density_connectivity: float option;
    density_index_main_chain: float option;
    density_index_side_chain: float option;
    rSZD: float option;
    rSZO: float option;
    rSZO_Zscore: float option;
    lLDF: float option;
    rSZD_main_chain: float option;
    rSZO_main_chain: float option;
    rSZD_side_chain: float option;
    rSZO_side_chain: float option;
    rSZD_phosphate_group: float option;
    rSZO_phosphate_group: float option;
    quality_indicator: string option;
  }

  let default = {
    id = None;
    model_id = None;
    pdb_id = None;
    auth_asym_id = None;
    auth_comp_id = None;
    auth_seq_id = None;
    label_alt_id = None;
    label_ins_code = None;
    rSCC = None;
    rSR = None;
    weighted_RSR = None;
    rSRZ = None;
    weighted_RSRZ = None;
    biso_mean = None;
    occupancy_mean = None;
    rSCC_main_chain = None;
    rSR_main_chain = None;
    wRSR_main_chain = None;
    rSRZ_main_chain = None;
    wRSRZ_main_chain = None;
    biso_mean_main_chain = None;
    occupancy_mean_main_chain = None;
    rSCC_side_chain = None;
    rSR_side_chain = None;
    wRSR_side_chain = None;
    rSRZ_side_chain = None;
    wRSRZ_side_chain = None;
    biso_mean_side_chain = None;
    occupancy_mean_side_chain = None;
    rSCC_phosphate_group = None;
    rSR_phosphate_group = None;
    wRSR_phosphate_group = None;
    rSRZ_phosphate_group = None;
    wRSRZ_phosphate_group = None;
    biso_mean_phosphate_group = None;
    occupancy_mean_phosphate_group = None;
    shift = None;
    shift_main_chain = None;
    shift_side_chain = None;
    density_connectivity = None;
    density_index_main_chain = None;
    density_index_side_chain = None;
    rSZD = None;
    rSZO = None;
    rSZO_Zscore = None;
    lLDF = None;
    rSZD_main_chain = None;
    rSZO_main_chain = None;
    rSZD_side_chain = None;
    rSZO_side_chain = None;
    rSZD_phosphate_group = None;
    rSZO_phosphate_group = None;
    quality_indicator = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (PDBjDict.some_int v) }
      | "model_id" -> { b with model_id = (Some v) }
      | "pdb_id" -> { b with pdb_id = (Some v) }
      | "auth_asym_id" -> { b with auth_asym_id = (Some v) }
      | "auth_comp_id" -> { b with auth_comp_id = (Some v) }
      | "auth_seq_id" -> { b with auth_seq_id = (Some v) }
      | "label_alt_id" -> { b with label_alt_id = (Some v) }
      | "label_ins_code" -> { b with label_ins_code = (Some v) }
      | "RSCC" -> { b with rSCC = (PDBjDict.some_float v) }
      | "RSR" -> { b with rSR = (PDBjDict.some_float v) }
      | "weighted_RSR" -> { b with weighted_RSR = (PDBjDict.some_float v) }
      | "RSRZ" -> { b with rSRZ = (PDBjDict.some_float v) }
      | "weighted_RSRZ" -> { b with weighted_RSRZ = (PDBjDict.some_float v) }
      | "Biso_mean" -> { b with biso_mean = (PDBjDict.some_float v) }
      | "occupancy_mean" -> { b with occupancy_mean = (PDBjDict.some_float v) }
      | "RSCC_main_chain" -> { b with rSCC_main_chain = (PDBjDict.some_float v) }
      | "RSR_main_chain" -> { b with rSR_main_chain = (PDBjDict.some_float v) }
      | "wRSR_main_chain" -> { b with wRSR_main_chain = (PDBjDict.some_float v) }
      | "RSRZ_main_chain" -> { b with rSRZ_main_chain = (PDBjDict.some_float v) }
      | "wRSRZ_main_chain" -> { b with wRSRZ_main_chain = (PDBjDict.some_float v) }
      | "Biso_mean_main_chain" -> { b with biso_mean_main_chain = (PDBjDict.some_float v) }
      | "occupancy_mean_main_chain" -> { b with occupancy_mean_main_chain = (PDBjDict.some_float v) }
      | "RSCC_side_chain" -> { b with rSCC_side_chain = (PDBjDict.some_float v) }
      | "RSR_side_chain" -> { b with rSR_side_chain = (PDBjDict.some_float v) }
      | "wRSR_side_chain" -> { b with wRSR_side_chain = (PDBjDict.some_float v) }
      | "RSRZ_side_chain" -> { b with rSRZ_side_chain = (PDBjDict.some_float v) }
      | "wRSRZ_side_chain" -> { b with wRSRZ_side_chain = (PDBjDict.some_float v) }
      | "Biso_mean_side_chain" -> { b with biso_mean_side_chain = (PDBjDict.some_float v) }
      | "occupancy_mean_side_chain" -> { b with occupancy_mean_side_chain = (PDBjDict.some_float v) }
      | "RSCC_phosphate_group" -> { b with rSCC_phosphate_group = (PDBjDict.some_float v) }
      | "RSR_phosphate_group" -> { b with rSR_phosphate_group = (PDBjDict.some_float v) }
      | "wRSR_phosphate_group" -> { b with wRSR_phosphate_group = (PDBjDict.some_float v) }
      | "RSRZ_phosphate_group" -> { b with rSRZ_phosphate_group = (PDBjDict.some_float v) }
      | "wRSRZ_phosphate_group" -> { b with wRSRZ_phosphate_group = (PDBjDict.some_float v) }
      | "Biso_mean_phosphate_group" -> { b with biso_mean_phosphate_group = (PDBjDict.some_float v) }
      | "occupancy_mean_phosphate_group" -> { b with occupancy_mean_phosphate_group = (PDBjDict.some_float v) }
      | "shift" -> { b with shift = (PDBjDict.some_float v) }
      | "shift_main_chain" -> { b with shift_main_chain = (PDBjDict.some_float v) }
      | "shift_side_chain" -> { b with shift_side_chain = (PDBjDict.some_float v) }
      | "density_connectivity" -> { b with density_connectivity = (PDBjDict.some_float v) }
      | "density_index_main_chain" -> { b with density_index_main_chain = (PDBjDict.some_float v) }
      | "density_index_side_chain" -> { b with density_index_side_chain = (PDBjDict.some_float v) }
      | "RSZD" -> { b with rSZD = (PDBjDict.some_float v) }
      | "RSZO" -> { b with rSZO = (PDBjDict.some_float v) }
      | "RSZO_Zscore" -> { b with rSZO_Zscore = (PDBjDict.some_float v) }
      | "LLDF" -> { b with lLDF = (PDBjDict.some_float v) }
      | "RSZD_main_chain" -> { b with rSZD_main_chain = (PDBjDict.some_float v) }
      | "RSZO_main_chain" -> { b with rSZO_main_chain = (PDBjDict.some_float v) }
      | "RSZD_side_chain" -> { b with rSZD_side_chain = (PDBjDict.some_float v) }
      | "RSZO_side_chain" -> { b with rSZO_side_chain = (PDBjDict.some_float v) }
      | "RSZD_phosphate_group" -> { b with rSZD_phosphate_group = (PDBjDict.some_float v) }
      | "RSZO_phosphate_group" -> { b with rSZO_phosphate_group = (PDBjDict.some_float v) }
      | "quality_indicator" -> { b with quality_indicator = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id", string_of_int v)) a.id;
      Option.map (fun v -> ("model_id",  v)) a.model_id;
      Option.map (fun v -> ("pdb_id",  v)) a.pdb_id;
      Option.map (fun v -> ("auth_asym_id",  v)) a.auth_asym_id;
      Option.map (fun v -> ("auth_comp_id",  v)) a.auth_comp_id;
      Option.map (fun v -> ("auth_seq_id",  v)) a.auth_seq_id;
      Option.map (fun v -> ("label_alt_id",  v)) a.label_alt_id;
      Option.map (fun v -> ("label_ins_code",  v)) a.label_ins_code;
      Option.map (fun v -> ("RSCC", string_of_float v)) a.rSCC;
      Option.map (fun v -> ("RSR", string_of_float v)) a.rSR;
      Option.map (fun v -> ("weighted_RSR", string_of_float v)) a.weighted_RSR;
      Option.map (fun v -> ("RSRZ", string_of_float v)) a.rSRZ;
      Option.map (fun v -> ("weighted_RSRZ", string_of_float v)) a.weighted_RSRZ;
      Option.map (fun v -> ("Biso_mean", string_of_float v)) a.biso_mean;
      Option.map (fun v -> ("occupancy_mean", string_of_float v)) a.occupancy_mean;
      Option.map (fun v -> ("RSCC_main_chain", string_of_float v)) a.rSCC_main_chain;
      Option.map (fun v -> ("RSR_main_chain", string_of_float v)) a.rSR_main_chain;
      Option.map (fun v -> ("wRSR_main_chain", string_of_float v)) a.wRSR_main_chain;
      Option.map (fun v -> ("RSRZ_main_chain", string_of_float v)) a.rSRZ_main_chain;
      Option.map (fun v -> ("wRSRZ_main_chain", string_of_float v)) a.wRSRZ_main_chain;
      Option.map (fun v -> ("Biso_mean_main_chain", string_of_float v)) a.biso_mean_main_chain;
      Option.map (fun v -> ("occupancy_mean_main_chain", string_of_float v)) a.occupancy_mean_main_chain;
      Option.map (fun v -> ("RSCC_side_chain", string_of_float v)) a.rSCC_side_chain;
      Option.map (fun v -> ("RSR_side_chain", string_of_float v)) a.rSR_side_chain;
      Option.map (fun v -> ("wRSR_side_chain", string_of_float v)) a.wRSR_side_chain;
      Option.map (fun v -> ("RSRZ_side_chain", string_of_float v)) a.rSRZ_side_chain;
      Option.map (fun v -> ("wRSRZ_side_chain", string_of_float v)) a.wRSRZ_side_chain;
      Option.map (fun v -> ("Biso_mean_side_chain", string_of_float v)) a.biso_mean_side_chain;
      Option.map (fun v -> ("occupancy_mean_side_chain", string_of_float v)) a.occupancy_mean_side_chain;
      Option.map (fun v -> ("RSCC_phosphate_group", string_of_float v)) a.rSCC_phosphate_group;
      Option.map (fun v -> ("RSR_phosphate_group", string_of_float v)) a.rSR_phosphate_group;
      Option.map (fun v -> ("wRSR_phosphate_group", string_of_float v)) a.wRSR_phosphate_group;
      Option.map (fun v -> ("RSRZ_phosphate_group", string_of_float v)) a.rSRZ_phosphate_group;
      Option.map (fun v -> ("wRSRZ_phosphate_group", string_of_float v)) a.wRSRZ_phosphate_group;
      Option.map (fun v -> ("Biso_mean_phosphate_group", string_of_float v)) a.biso_mean_phosphate_group;
      Option.map (fun v -> ("occupancy_mean_phosphate_group", string_of_float v)) a.occupancy_mean_phosphate_group;
      Option.map (fun v -> ("shift", string_of_float v)) a.shift;
      Option.map (fun v -> ("shift_main_chain", string_of_float v)) a.shift_main_chain;
      Option.map (fun v -> ("shift_side_chain", string_of_float v)) a.shift_side_chain;
      Option.map (fun v -> ("density_connectivity", string_of_float v)) a.density_connectivity;
      Option.map (fun v -> ("density_index_main_chain", string_of_float v)) a.density_index_main_chain;
      Option.map (fun v -> ("density_index_side_chain", string_of_float v)) a.density_index_side_chain;
      Option.map (fun v -> ("RSZD", string_of_float v)) a.rSZD;
      Option.map (fun v -> ("RSZO", string_of_float v)) a.rSZO;
      Option.map (fun v -> ("RSZO_Zscore", string_of_float v)) a.rSZO_Zscore;
      Option.map (fun v -> ("LLDF", string_of_float v)) a.lLDF;
      Option.map (fun v -> ("RSZD_main_chain", string_of_float v)) a.rSZD_main_chain;
      Option.map (fun v -> ("RSZO_main_chain", string_of_float v)) a.rSZO_main_chain;
      Option.map (fun v -> ("RSZD_side_chain", string_of_float v)) a.rSZD_side_chain;
      Option.map (fun v -> ("RSZO_side_chain", string_of_float v)) a.rSZO_side_chain;
      Option.map (fun v -> ("RSZD_phosphate_group", string_of_float v)) a.rSZD_phosphate_group;
      Option.map (fun v -> ("RSZO_phosphate_group", string_of_float v)) a.rSZO_phosphate_group;
      Option.map (fun v -> ("quality_indicator",  v)) a.quality_indicator;
    ]

end

module Pdbx_deposit_group = struct
  type t = {
    group_id: string option;
    group_title: string option;
    group_description: string option;
    group_type: string option;
  }

  let default = {
    group_id = None;
    group_title = None;
    group_description = None;
    group_type = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "group_id" -> { b with group_id = (Some v) }
      | "group_title" -> { b with group_title = (Some v) }
      | "group_description" -> { b with group_description = (Some v) }
      | "group_type" -> { b with group_type = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("group_id",  v)) a.group_id;
      Option.map (fun v -> ("group_title",  v)) a.group_title;
      Option.map (fun v -> ("group_description",  v)) a.group_description;
      Option.map (fun v -> ("group_type",  v)) a.group_type;
    ]

end

module Pdbx_deposit_group_index = struct
  type t = {
    group_id: string option;
    ordinal_id: int option;
    dep_set_id: string option;
    pdb_id_code: string option;
    group_file_name: string option;
    group_file_timestamp: string option;
    auth_file_label: string option;
    auth_file_content_type: string option;
    auth_file_format_type: string option;
    auth_file_name: string option;
    auth_file_size: int option;
  }

  let default = {
    group_id = None;
    ordinal_id = None;
    dep_set_id = None;
    pdb_id_code = None;
    group_file_name = None;
    group_file_timestamp = None;
    auth_file_label = None;
    auth_file_content_type = None;
    auth_file_format_type = None;
    auth_file_name = None;
    auth_file_size = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "group_id" -> { b with group_id = (Some v) }
      | "ordinal_id" -> { b with ordinal_id = (PDBjDict.some_int v) }
      | "dep_set_id" -> { b with dep_set_id = (Some v) }
      | "pdb_id_code" -> { b with pdb_id_code = (Some v) }
      | "group_file_name" -> { b with group_file_name = (Some v) }
      | "group_file_timestamp" -> { b with group_file_timestamp = (Some v) }
      | "auth_file_label" -> { b with auth_file_label = (Some v) }
      | "auth_file_content_type" -> { b with auth_file_content_type = (Some v) }
      | "auth_file_format_type" -> { b with auth_file_format_type = (Some v) }
      | "auth_file_name" -> { b with auth_file_name = (Some v) }
      | "auth_file_size" -> { b with auth_file_size = (PDBjDict.some_int v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("group_id",  v)) a.group_id;
      Option.map (fun v -> ("ordinal_id", string_of_int v)) a.ordinal_id;
      Option.map (fun v -> ("dep_set_id",  v)) a.dep_set_id;
      Option.map (fun v -> ("pdb_id_code",  v)) a.pdb_id_code;
      Option.map (fun v -> ("group_file_name",  v)) a.group_file_name;
      Option.map (fun v -> ("group_file_timestamp",  v)) a.group_file_timestamp;
      Option.map (fun v -> ("auth_file_label",  v)) a.auth_file_label;
      Option.map (fun v -> ("auth_file_content_type",  v)) a.auth_file_content_type;
      Option.map (fun v -> ("auth_file_format_type",  v)) a.auth_file_format_type;
      Option.map (fun v -> ("auth_file_name",  v)) a.auth_file_name;
      Option.map (fun v -> ("auth_file_size", string_of_int v)) a.auth_file_size;
    ]

end

module Pdbx_struct_assembly_auth_evidence = struct
  type t = {
    id: string option;
    assembly_id: string option;
    experimental_support: string option;
    details: string option;
  }

  let default = {
    id = None;
    assembly_id = None;
    experimental_support = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "id" -> { b with id = (Some v) }
      | "assembly_id" -> { b with assembly_id = (Some v) }
      | "experimental_support" -> { b with experimental_support = (Some v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("id",  v)) a.id;
      Option.map (fun v -> ("assembly_id",  v)) a.assembly_id;
      Option.map (fun v -> ("experimental_support",  v)) a.experimental_support;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Pdbx_struct_assembly_auth_classification = struct
  type t = {
    assembly_id: string option;
    reason_for_interest: string option;
  }

  let default = {
    assembly_id = None;
    reason_for_interest = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "assembly_id" -> { b with assembly_id = (Some v) }
      | "reason_for_interest" -> { b with reason_for_interest = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("assembly_id",  v)) a.assembly_id;
      Option.map (fun v -> ("reason_for_interest",  v)) a.reason_for_interest;
    ]

end

module Pdbx_crystal_alignment = struct
  type t = {
    crystal_id: string option;
    oscillation_range: float option;
    oscillation_start: float option;
    oscillation_end: float option;
    xbeam: float option;
    xbeam_esd: float option;
    ybeam: float option;
    ybeam_esd: float option;
    crysx_spindle: float option;
    crysx_spindle_esd: float option;
    crysy_vertical: float option;
    crysy_vertical_esd: float option;
    crysz_beam: float option;
    crysz_beam_esd: float option;
    crystal_to_detector_distance: float option;
    crystal_to_detector_distance_esd: float option;
    crossfire_x: float option;
    crossfire_x_esd: float option;
    crossfire_y: float option;
    crossfire_y_esd: float option;
    crossfire_xy: float option;
    crossfire_xy_esd: float option;
  }

  let default = {
    crystal_id = None;
    oscillation_range = None;
    oscillation_start = None;
    oscillation_end = None;
    xbeam = None;
    xbeam_esd = None;
    ybeam = None;
    ybeam_esd = None;
    crysx_spindle = None;
    crysx_spindle_esd = None;
    crysy_vertical = None;
    crysy_vertical_esd = None;
    crysz_beam = None;
    crysz_beam_esd = None;
    crystal_to_detector_distance = None;
    crystal_to_detector_distance_esd = None;
    crossfire_x = None;
    crossfire_x_esd = None;
    crossfire_y = None;
    crossfire_y_esd = None;
    crossfire_xy = None;
    crossfire_xy_esd = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "crystal_id" -> { b with crystal_id = (Some v) }
      | "oscillation_range" -> { b with oscillation_range = (PDBjDict.some_float v) }
      | "oscillation_start" -> { b with oscillation_start = (PDBjDict.some_float v) }
      | "oscillation_end" -> { b with oscillation_end = (PDBjDict.some_float v) }
      | "xbeam" -> { b with xbeam = (PDBjDict.some_float v) }
      | "xbeam_esd" -> { b with xbeam_esd = (PDBjDict.some_float v) }
      | "ybeam" -> { b with ybeam = (PDBjDict.some_float v) }
      | "ybeam_esd" -> { b with ybeam_esd = (PDBjDict.some_float v) }
      | "crysx_spindle" -> { b with crysx_spindle = (PDBjDict.some_float v) }
      | "crysx_spindle_esd" -> { b with crysx_spindle_esd = (PDBjDict.some_float v) }
      | "crysy_vertical" -> { b with crysy_vertical = (PDBjDict.some_float v) }
      | "crysy_vertical_esd" -> { b with crysy_vertical_esd = (PDBjDict.some_float v) }
      | "crysz_beam" -> { b with crysz_beam = (PDBjDict.some_float v) }
      | "crysz_beam_esd" -> { b with crysz_beam_esd = (PDBjDict.some_float v) }
      | "crystal_to_detector_distance" -> { b with crystal_to_detector_distance = (PDBjDict.some_float v) }
      | "crystal_to_detector_distance_esd" -> { b with crystal_to_detector_distance_esd = (PDBjDict.some_float v) }
      | "crossfire_x" -> { b with crossfire_x = (PDBjDict.some_float v) }
      | "crossfire_x_esd" -> { b with crossfire_x_esd = (PDBjDict.some_float v) }
      | "crossfire_y" -> { b with crossfire_y = (PDBjDict.some_float v) }
      | "crossfire_y_esd" -> { b with crossfire_y_esd = (PDBjDict.some_float v) }
      | "crossfire_xy" -> { b with crossfire_xy = (PDBjDict.some_float v) }
      | "crossfire_xy_esd" -> { b with crossfire_xy_esd = (PDBjDict.some_float v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("crystal_id",  v)) a.crystal_id;
      Option.map (fun v -> ("oscillation_range", string_of_float v)) a.oscillation_range;
      Option.map (fun v -> ("oscillation_start", string_of_float v)) a.oscillation_start;
      Option.map (fun v -> ("oscillation_end", string_of_float v)) a.oscillation_end;
      Option.map (fun v -> ("xbeam", string_of_float v)) a.xbeam;
      Option.map (fun v -> ("xbeam_esd", string_of_float v)) a.xbeam_esd;
      Option.map (fun v -> ("ybeam", string_of_float v)) a.ybeam;
      Option.map (fun v -> ("ybeam_esd", string_of_float v)) a.ybeam_esd;
      Option.map (fun v -> ("crysx_spindle", string_of_float v)) a.crysx_spindle;
      Option.map (fun v -> ("crysx_spindle_esd", string_of_float v)) a.crysx_spindle_esd;
      Option.map (fun v -> ("crysy_vertical", string_of_float v)) a.crysy_vertical;
      Option.map (fun v -> ("crysy_vertical_esd", string_of_float v)) a.crysy_vertical_esd;
      Option.map (fun v -> ("crysz_beam", string_of_float v)) a.crysz_beam;
      Option.map (fun v -> ("crysz_beam_esd", string_of_float v)) a.crysz_beam_esd;
      Option.map (fun v -> ("crystal_to_detector_distance", string_of_float v)) a.crystal_to_detector_distance;
      Option.map (fun v -> ("crystal_to_detector_distance_esd", string_of_float v)) a.crystal_to_detector_distance_esd;
      Option.map (fun v -> ("crossfire_x", string_of_float v)) a.crossfire_x;
      Option.map (fun v -> ("crossfire_x_esd", string_of_float v)) a.crossfire_x_esd;
      Option.map (fun v -> ("crossfire_y", string_of_float v)) a.crossfire_y;
      Option.map (fun v -> ("crossfire_y_esd", string_of_float v)) a.crossfire_y_esd;
      Option.map (fun v -> ("crossfire_xy", string_of_float v)) a.crossfire_xy;
      Option.map (fun v -> ("crossfire_xy_esd", string_of_float v)) a.crossfire_xy_esd;
    ]

end

module Pdbx_audit_revision_history = struct
  type t = {
    ordinal: int option;
    data_content_type: string option;
    major_revision: int option;
    minor_revision: int option;
    revision_date: string option;
    internal_version: int option;
    internal_deposition_id: string option;
  }

  let default = {
    ordinal = None;
    data_content_type = None;
    major_revision = None;
    minor_revision = None;
    revision_date = None;
    internal_version = None;
    internal_deposition_id = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "data_content_type" -> { b with data_content_type = (Some v) }
      | "major_revision" -> { b with major_revision = (PDBjDict.some_int v) }
      | "minor_revision" -> { b with minor_revision = (PDBjDict.some_int v) }
      | "revision_date" -> { b with revision_date = (Some v) }
      | "internal_version" -> { b with internal_version = (PDBjDict.some_int v) }
      | "internal_deposition_id" -> { b with internal_deposition_id = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("data_content_type",  v)) a.data_content_type;
      Option.map (fun v -> ("major_revision", string_of_int v)) a.major_revision;
      Option.map (fun v -> ("minor_revision", string_of_int v)) a.minor_revision;
      Option.map (fun v -> ("revision_date",  v)) a.revision_date;
      Option.map (fun v -> ("internal_version", string_of_int v)) a.internal_version;
      Option.map (fun v -> ("internal_deposition_id",  v)) a.internal_deposition_id;
    ]

end

module Pdbx_audit_revision_group = struct
  type t = {
    ordinal: int option;
    revision_ordinal: int option;
    data_content_type: string option;
    group: string option;
  }

  let default = {
    ordinal = None;
    revision_ordinal = None;
    data_content_type = None;
    group = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "revision_ordinal" -> { b with revision_ordinal = (PDBjDict.some_int v) }
      | "data_content_type" -> { b with data_content_type = (Some v) }
      | "group" -> { b with group = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("revision_ordinal", string_of_int v)) a.revision_ordinal;
      Option.map (fun v -> ("data_content_type",  v)) a.data_content_type;
      Option.map (fun v -> ("group",  v)) a.group;
    ]

end

module Pdbx_audit_revision_category = struct
  type t = {
    ordinal: int option;
    revision_ordinal: int option;
    data_content_type: string option;
    category: string option;
  }

  let default = {
    ordinal = None;
    revision_ordinal = None;
    data_content_type = None;
    category = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "revision_ordinal" -> { b with revision_ordinal = (PDBjDict.some_int v) }
      | "data_content_type" -> { b with data_content_type = (Some v) }
      | "category" -> { b with category = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("revision_ordinal", string_of_int v)) a.revision_ordinal;
      Option.map (fun v -> ("data_content_type",  v)) a.data_content_type;
      Option.map (fun v -> ("category",  v)) a.category;
    ]

end

module Pdbx_audit_revision_details = struct
  type t = {
    ordinal: int option;
    revision_ordinal: int option;
    data_content_type: string option;
    provider: string option;
    type_: string option;
    description: string option;
  }

  let default = {
    ordinal = None;
    revision_ordinal = None;
    data_content_type = None;
    provider = None;
    type_ = None;
    description = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "revision_ordinal" -> { b with revision_ordinal = (PDBjDict.some_int v) }
      | "data_content_type" -> { b with data_content_type = (Some v) }
      | "provider" -> { b with provider = (Some v) }
      | "type" -> { b with type_ = (Some v) }
      | "description" -> { b with description = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("revision_ordinal", string_of_int v)) a.revision_ordinal;
      Option.map (fun v -> ("data_content_type",  v)) a.data_content_type;
      Option.map (fun v -> ("provider",  v)) a.provider;
      Option.map (fun v -> ("type",  v)) a.type_;
      Option.map (fun v -> ("description",  v)) a.description;
    ]

end

module Pdbx_audit_revision_item = struct
  type t = {
    ordinal: int option;
    revision_ordinal: int option;
    data_content_type: string option;
    item: string option;
  }

  let default = {
    ordinal = None;
    revision_ordinal = None;
    data_content_type = None;
    item = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "revision_ordinal" -> { b with revision_ordinal = (PDBjDict.some_int v) }
      | "data_content_type" -> { b with data_content_type = (Some v) }
      | "item" -> { b with item = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("revision_ordinal", string_of_int v)) a.revision_ordinal;
      Option.map (fun v -> ("data_content_type",  v)) a.data_content_type;
      Option.map (fun v -> ("item",  v)) a.item;
    ]

end

module Pdbx_supporting_exp_data_set = struct
  type t = {
    ordinal: int option;
    data_content_type: string option;
    data_version_major: int option;
    data_version_minor: int option;
    details: string option;
  }

  let default = {
    ordinal = None;
    data_content_type = None;
    data_version_major = None;
    data_version_minor = None;
    details = None;
  }

  let of_mmCIF items =
    let conv b (k,v) =
      match k with
      | "ordinal" -> { b with ordinal = (PDBjDict.some_int v) }
      | "data_content_type" -> { b with data_content_type = (Some v) }
      | "data_version_major" -> { b with data_version_major = (PDBjDict.some_int v) }
      | "data_version_minor" -> { b with data_version_minor = (PDBjDict.some_int v) }
      | "details" -> { b with details = (Some v) }
      | _ -> b in
    List.fold_left conv default items

  let to_mmCIF a =
    List.filter_map (fun x -> x) [
      Option.map (fun v -> ("ordinal", string_of_int v)) a.ordinal;
      Option.map (fun v -> ("data_content_type",  v)) a.data_content_type;
      Option.map (fun v -> ("data_version_major", string_of_int v)) a.data_version_major;
      Option.map (fun v -> ("data_version_minor", string_of_int v)) a.data_version_minor;
      Option.map (fun v -> ("details",  v)) a.details;
    ]

end

module Datablock = struct
  type t = {
    datablockName: string;
    jV_command: JV_command.t list;
    atom_site: Atom_site.t list;
    atom_site_anisotrop: Atom_site_anisotrop.t list;
    atom_sites: Atom_sites.t list;
    atom_sites_alt: Atom_sites_alt.t list;
    atom_sites_alt_ens: Atom_sites_alt_ens.t list;
    atom_sites_alt_gen: Atom_sites_alt_gen.t list;
    atom_sites_footnote: Atom_sites_footnote.t list;
    atom_type: Atom_type.t list;
    audit: Audit.t list;
    audit_author: Audit_author.t list;
    audit_conform: Audit_conform.t list;
    audit_contact_author: Audit_contact_author.t list;
    cell: Cell.t list;
    cell_measurement: Cell_measurement.t list;
    cell_measurement_refln: Cell_measurement_refln.t list;
    chem_comp: Chem_comp.t list;
    chem_comp_angle: Chem_comp_angle.t list;
    chem_comp_atom: Chem_comp_atom.t list;
    chem_comp_bond: Chem_comp_bond.t list;
    chem_comp_chir: Chem_comp_chir.t list;
    chem_comp_chir_atom: Chem_comp_chir_atom.t list;
    chem_comp_link: Chem_comp_link.t list;
    chem_comp_plane: Chem_comp_plane.t list;
    chem_comp_plane_atom: Chem_comp_plane_atom.t list;
    chem_comp_tor: Chem_comp_tor.t list;
    chem_comp_tor_value: Chem_comp_tor_value.t list;
    chem_link: Chem_link.t list;
    chem_link_angle: Chem_link_angle.t list;
    chem_link_bond: Chem_link_bond.t list;
    chem_link_chir: Chem_link_chir.t list;
    chem_link_chir_atom: Chem_link_chir_atom.t list;
    chem_link_plane: Chem_link_plane.t list;
    chem_link_plane_atom: Chem_link_plane_atom.t list;
    chem_link_tor: Chem_link_tor.t list;
    chem_link_tor_value: Chem_link_tor_value.t list;
    chemical: Chemical.t list;
    chemical_conn_atom: Chemical_conn_atom.t list;
    chemical_conn_bond: Chemical_conn_bond.t list;
    chemical_formula: Chemical_formula.t list;
    citation: Citation.t list;
    citation_author: Citation_author.t list;
    citation_editor: Citation_editor.t list;
    computing: Computing.t list;
    database: Database.t list;
    database_2: Database_2.t list;
    database_PDB_caveat: Database_PDB_caveat.t list;
    database_PDB_matrix: Database_PDB_matrix.t list;
    database_PDB_remark: Database_PDB_remark.t list;
    database_PDB_rev: Database_PDB_rev.t list;
    database_PDB_rev_record: Database_PDB_rev_record.t list;
    database_PDB_tvect: Database_PDB_tvect.t list;
    diffrn: Diffrn.t list;
    diffrn_attenuator: Diffrn_attenuator.t list;
    diffrn_detector: Diffrn_detector.t list;
    diffrn_measurement: Diffrn_measurement.t list;
    diffrn_orient_matrix: Diffrn_orient_matrix.t list;
    diffrn_orient_refln: Diffrn_orient_refln.t list;
    diffrn_radiation: Diffrn_radiation.t list;
    diffrn_radiation_wavelength: Diffrn_radiation_wavelength.t list;
    diffrn_refln: Diffrn_refln.t list;
    diffrn_reflns: Diffrn_reflns.t list;
    diffrn_scale_group: Diffrn_scale_group.t list;
    diffrn_source: Diffrn_source.t list;
    diffrn_standard_refln: Diffrn_standard_refln.t list;
    diffrn_standards: Diffrn_standards.t list;
    entity: Entity.t list;
    entity_keywords: Entity_keywords.t list;
    entity_link: Entity_link.t list;
    entity_name_com: Entity_name_com.t list;
    entity_name_sys: Entity_name_sys.t list;
    entity_poly: Entity_poly.t list;
    entity_poly_seq: Entity_poly_seq.t list;
    entry: Entry.t list;
    entry_link: Entry_link.t list;
    exptl: Exptl.t list;
    exptl_crystal: Exptl_crystal.t list;
    exptl_crystal_face: Exptl_crystal_face.t list;
    exptl_crystal_grow: Exptl_crystal_grow.t list;
    exptl_crystal_grow_comp: Exptl_crystal_grow_comp.t list;
    geom: Geom.t list;
    geom_angle: Geom_angle.t list;
    geom_bond: Geom_bond.t list;
    geom_contact: Geom_contact.t list;
    geom_hbond: Geom_hbond.t list;
    geom_torsion: Geom_torsion.t list;
    journal: Journal.t list;
    journal_index: Journal_index.t list;
    phasing: Phasing.t list;
    phasing_averaging: Phasing_averaging.t list;
    phasing_isomorphous: Phasing_isomorphous.t list;
    phasing_MAD: Phasing_MAD.t list;
    phasing_MAD_clust: Phasing_MAD_clust.t list;
    phasing_MAD_expt: Phasing_MAD_expt.t list;
    phasing_MAD_ratio: Phasing_MAD_ratio.t list;
    phasing_MAD_set: Phasing_MAD_set.t list;
    phasing_MIR: Phasing_MIR.t list;
    phasing_MIR_der: Phasing_MIR_der.t list;
    phasing_MIR_der_refln: Phasing_MIR_der_refln.t list;
    phasing_MIR_der_shell: Phasing_MIR_der_shell.t list;
    phasing_MIR_der_site: Phasing_MIR_der_site.t list;
    phasing_MIR_shell: Phasing_MIR_shell.t list;
    phasing_set: Phasing_set.t list;
    phasing_set_refln: Phasing_set_refln.t list;
    publ: Publ.t list;
    publ_author: Publ_author.t list;
    publ_body: Publ_body.t list;
    publ_manuscript_incl: Publ_manuscript_incl.t list;
    refine: Refine.t list;
    refine_analyze: Refine_analyze.t list;
    refine_B_iso: Refine_B_iso.t list;
    refine_funct_minimized: Refine_funct_minimized.t list;
    refine_hist: Refine_hist.t list;
    refine_ls_restr: Refine_ls_restr.t list;
    refine_ls_restr_ncs: Refine_ls_restr_ncs.t list;
    refine_ls_restr_type: Refine_ls_restr_type.t list;
    refine_ls_shell: Refine_ls_shell.t list;
    refine_occupancy: Refine_occupancy.t list;
    refln: Refln.t list;
    refln_sys_abs: Refln_sys_abs.t list;
    reflns: Reflns.t list;
    reflns_scale: Reflns_scale.t list;
    reflns_shell: Reflns_shell.t list;
    software: Software.t list;
    struct_: Struct.t list;
    struct_asym: Struct_asym.t list;
    struct_biol: Struct_biol.t list;
    struct_biol_gen: Struct_biol_gen.t list;
    struct_biol_keywords: Struct_biol_keywords.t list;
    struct_biol_view: Struct_biol_view.t list;
    struct_conf: Struct_conf.t list;
    struct_conf_type: Struct_conf_type.t list;
    struct_conn: Struct_conn.t list;
    struct_conn_type: Struct_conn_type.t list;
    struct_keywords: Struct_keywords.t list;
    struct_mon_details: Struct_mon_details.t list;
    struct_mon_nucl: Struct_mon_nucl.t list;
    struct_mon_prot: Struct_mon_prot.t list;
    struct_mon_prot_cis: Struct_mon_prot_cis.t list;
    struct_ncs_dom: Struct_ncs_dom.t list;
    struct_ncs_dom_lim: Struct_ncs_dom_lim.t list;
    struct_ncs_ens: Struct_ncs_ens.t list;
    struct_ncs_ens_gen: Struct_ncs_ens_gen.t list;
    struct_ncs_oper: Struct_ncs_oper.t list;
    struct_ref: Struct_ref.t list;
    struct_ref_seq: Struct_ref_seq.t list;
    struct_ref_seq_dif: Struct_ref_seq_dif.t list;
    struct_sheet: Struct_sheet.t list;
    struct_sheet_hbond: Struct_sheet_hbond.t list;
    struct_sheet_order: Struct_sheet_order.t list;
    struct_sheet_range: Struct_sheet_range.t list;
    struct_sheet_topology: Struct_sheet_topology.t list;
    struct_site: Struct_site.t list;
    struct_site_gen: Struct_site_gen.t list;
    struct_site_keywords: Struct_site_keywords.t list;
    struct_site_view: Struct_site_view.t list;
    symmetry: Symmetry.t list;
    symmetry_equiv: Symmetry_equiv.t list;
    audit_link: Audit_link.t list;
    diffrn_reflns_class: Diffrn_reflns_class.t list;
    refine_ls_class: Refine_ls_class.t list;
    reflns_class: Reflns_class.t list;
    space_group: Space_group.t list;
    space_group_symop: Space_group_symop.t list;
    valence_param: Valence_param.t list;
    valence_ref: Valence_ref.t list;
    pdbx_audit: Pdbx_audit.t list;
    pdbx_version: Pdbx_version.t list;
    pdbx_audit_author: Pdbx_audit_author.t list;
    pdbx_database_message: Pdbx_database_message.t list;
    pdbx_database_PDB_obs_spr: Pdbx_database_PDB_obs_spr.t list;
    pdbx_database_proc: Pdbx_database_proc.t list;
    pdbx_database_remark: Pdbx_database_remark.t list;
    pdbx_database_status: Pdbx_database_status.t list;
    pdbx_entity_name: Pdbx_entity_name.t list;
    pdbx_prerelease_seq: Pdbx_prerelease_seq.t list;
    pdbx_poly_seq_scheme: Pdbx_poly_seq_scheme.t list;
    pdbx_nonpoly_scheme: Pdbx_nonpoly_scheme.t list;
    pdbx_refine: Pdbx_refine.t list;
    pdbx_struct_sheet_hbond: Pdbx_struct_sheet_hbond.t list;
    pdbx_xplor_file: Pdbx_xplor_file.t list;
    pdbx_refine_aux_file: Pdbx_refine_aux_file.t list;
    pdbx_database_related: Pdbx_database_related.t list;
    pdbx_entity_assembly: Pdbx_entity_assembly.t list;
    pdbx_exptl_crystal_grow_comp: Pdbx_exptl_crystal_grow_comp.t list;
    pdbx_exptl_crystal_grow_sol: Pdbx_exptl_crystal_grow_sol.t list;
    pdbx_exptl_crystal_cryo_treatment: Pdbx_exptl_crystal_cryo_treatment.t list;
    pdbx_refine_tls: Pdbx_refine_tls.t list;
    pdbx_refine_tls_group: Pdbx_refine_tls_group.t list;
    pdbx_contact_author: Pdbx_contact_author.t list;
    pdbx_SG_project: Pdbx_SG_project.t list;
    pdbx_atom_site_aniso_tls: Pdbx_atom_site_aniso_tls.t list;
    pdbx_nmr_details: Pdbx_nmr_details.t list;
    pdbx_nmr_sample_details: Pdbx_nmr_sample_details.t list;
    pdbx_nmr_exptl_sample: Pdbx_nmr_exptl_sample.t list;
    pdbx_nmr_exptl_sample_conditions: Pdbx_nmr_exptl_sample_conditions.t list;
    pdbx_nmr_spectrometer: Pdbx_nmr_spectrometer.t list;
    pdbx_nmr_exptl: Pdbx_nmr_exptl.t list;
    pdbx_nmr_software: Pdbx_nmr_software.t list;
    pdbx_nmr_constraints: Pdbx_nmr_constraints.t list;
    pdbx_nmr_ensemble: Pdbx_nmr_ensemble.t list;
    pdbx_nmr_ensemble_rms: Pdbx_nmr_ensemble_rms.t list;
    pdbx_nmr_representative: Pdbx_nmr_representative.t list;
    pdbx_nmr_refine: Pdbx_nmr_refine.t list;
    pdbx_nmr_force_constants: Pdbx_nmr_force_constants.t list;
    ndb_struct_conf_na: Ndb_struct_conf_na.t list;
    ndb_struct_feature_na: Ndb_struct_feature_na.t list;
    ndb_struct_na_base_pair: Ndb_struct_na_base_pair.t list;
    ndb_struct_na_base_pair_step: Ndb_struct_na_base_pair_step.t list;
    ndb_original_ndb_coordinates: Ndb_original_ndb_coordinates.t list;
    pdbx_entity_nonpoly: Pdbx_entity_nonpoly.t list;
    pdbx_phasing_dm: Pdbx_phasing_dm.t list;
    pdbx_phasing_dm_shell: Pdbx_phasing_dm_shell.t list;
    pdbx_phasing_MAD_shell: Pdbx_phasing_MAD_shell.t list;
    pdbx_phasing_MAD_set: Pdbx_phasing_MAD_set.t list;
    pdbx_phasing_MAD_set_shell: Pdbx_phasing_MAD_set_shell.t list;
    pdbx_phasing_MAD_set_site: Pdbx_phasing_MAD_set_site.t list;
    pdbx_phasing_MR: Pdbx_phasing_MR.t list;
    pdbx_refine_component: Pdbx_refine_component.t list;
    pdbx_entity_prod_protocol: Pdbx_entity_prod_protocol.t list;
    pdbx_entity_src_gen_prod_other: Pdbx_entity_src_gen_prod_other.t list;
    pdbx_entity_src_gen_prod_other_parameter: Pdbx_entity_src_gen_prod_other_parameter.t list;
    pdbx_entity_src_gen_prod_pcr: Pdbx_entity_src_gen_prod_pcr.t list;
    pdbx_entity_src_gen_prod_digest: Pdbx_entity_src_gen_prod_digest.t list;
    pdbx_entity_src_gen_clone: Pdbx_entity_src_gen_clone.t list;
    pdbx_entity_src_gen_clone_ligation: Pdbx_entity_src_gen_clone_ligation.t list;
    pdbx_entity_src_gen_clone_recombination: Pdbx_entity_src_gen_clone_recombination.t list;
    pdbx_entity_src_gen_express: Pdbx_entity_src_gen_express.t list;
    pdbx_entity_src_gen_express_timepoint: Pdbx_entity_src_gen_express_timepoint.t list;
    pdbx_entity_src_gen_lysis: Pdbx_entity_src_gen_lysis.t list;
    pdbx_entity_src_gen_refold: Pdbx_entity_src_gen_refold.t list;
    pdbx_entity_src_gen_proteolysis: Pdbx_entity_src_gen_proteolysis.t list;
    pdbx_entity_src_gen_chrom: Pdbx_entity_src_gen_chrom.t list;
    pdbx_entity_src_gen_fract: Pdbx_entity_src_gen_fract.t list;
    pdbx_entity_src_gen_pure: Pdbx_entity_src_gen_pure.t list;
    pdbx_entity_src_gen_character: Pdbx_entity_src_gen_character.t list;
    pdbx_construct: Pdbx_construct.t list;
    pdbx_construct_feature: Pdbx_construct_feature.t list;
    pdbx_robot_system: Pdbx_robot_system.t list;
    pdbx_buffer: Pdbx_buffer.t list;
    pdbx_buffer_components: Pdbx_buffer_components.t list;
    pdbx_domain: Pdbx_domain.t list;
    pdbx_domain_range: Pdbx_domain_range.t list;
    pdbx_sequence_range: Pdbx_sequence_range.t list;
    pdbx_feature_entry: Pdbx_feature_entry.t list;
    pdbx_feature_domain: Pdbx_feature_domain.t list;
    pdbx_feature_sequence_range: Pdbx_feature_sequence_range.t list;
    pdbx_feature_assembly: Pdbx_feature_assembly.t list;
    pdbx_feature_monomer: Pdbx_feature_monomer.t list;
    pdbx_exptl_pd: Pdbx_exptl_pd.t list;
    pdbx_reflns_twin: Pdbx_reflns_twin.t list;
    pdbx_struct_info: Pdbx_struct_info.t list;
    pdbx_re_refinement: Pdbx_re_refinement.t list;
    pdbx_struct_assembly_prop: Pdbx_struct_assembly_prop.t list;
    pdbx_struct_ref_seq_feature: Pdbx_struct_ref_seq_feature.t list;
    pdbx_struct_ref_seq_feature_prop: Pdbx_struct_ref_seq_feature_prop.t list;
    pdbx_struct_chem_comp_diagnostics: Pdbx_struct_chem_comp_diagnostics.t list;
    pdbx_chem_comp_feature: Pdbx_chem_comp_feature.t list;
    pdbx_coordinate_model: Pdbx_coordinate_model.t list;
    pdbx_struct_chem_comp_feature: Pdbx_struct_chem_comp_feature.t list;
    pdbx_diffrn_reflns_shell: Pdbx_diffrn_reflns_shell.t list;
    pdbx_bond_distance_limits: Pdbx_bond_distance_limits.t list;
    pdbx_soln_scatter: Pdbx_soln_scatter.t list;
    pdbx_soln_scatter_model: Pdbx_soln_scatter_model.t list;
    pdbx_chem_comp_descriptor: Pdbx_chem_comp_descriptor.t list;
    pdbx_chem_comp_identifier: Pdbx_chem_comp_identifier.t list;
    pdbx_chem_comp_import: Pdbx_chem_comp_import.t list;
    pdbx_chem_comp_atom_edit: Pdbx_chem_comp_atom_edit.t list;
    pdbx_chem_comp_bond_edit: Pdbx_chem_comp_bond_edit.t list;
    pdbx_chem_comp_audit: Pdbx_chem_comp_audit.t list;
    pdbx_validate_close_contact: Pdbx_validate_close_contact.t list;
    pdbx_validate_symm_contact: Pdbx_validate_symm_contact.t list;
    pdbx_validate_rmsd_bond: Pdbx_validate_rmsd_bond.t list;
    pdbx_validate_rmsd_angle: Pdbx_validate_rmsd_angle.t list;
    pdbx_validate_torsion: Pdbx_validate_torsion.t list;
    pdbx_validate_peptide_omega: Pdbx_validate_peptide_omega.t list;
    pdbx_validate_chiral: Pdbx_validate_chiral.t list;
    pdbx_validate_planes: Pdbx_validate_planes.t list;
    pdbx_validate_planes_atom: Pdbx_validate_planes_atom.t list;
    pdbx_validate_main_chain_plane: Pdbx_validate_main_chain_plane.t list;
    pdbx_struct_conn_angle: Pdbx_struct_conn_angle.t list;
    pdbx_unobs_or_zero_occ_residues: Pdbx_unobs_or_zero_occ_residues.t list;
    pdbx_unobs_or_zero_occ_atoms: Pdbx_unobs_or_zero_occ_atoms.t list;
    pdbx_entry_details: Pdbx_entry_details.t list;
    pdbx_struct_mod_residue: Pdbx_struct_mod_residue.t list;
    pdbx_struct_ref_seq_insertion: Pdbx_struct_ref_seq_insertion.t list;
    pdbx_struct_ref_seq_deletion: Pdbx_struct_ref_seq_deletion.t list;
    pdbx_remediation_atom_site_mapping: Pdbx_remediation_atom_site_mapping.t list;
    pdbx_validate_polymer_linkage: Pdbx_validate_polymer_linkage.t list;
    pdbx_helical_symmetry: Pdbx_helical_symmetry.t list;
    pdbx_point_symmetry: Pdbx_point_symmetry.t list;
    pdbx_struct_entity_inst: Pdbx_struct_entity_inst.t list;
    pdbx_struct_oper_list: Pdbx_struct_oper_list.t list;
    pdbx_struct_assembly: Pdbx_struct_assembly.t list;
    pdbx_struct_assembly_gen: Pdbx_struct_assembly_gen.t list;
    pdbx_struct_asym_gen: Pdbx_struct_asym_gen.t list;
    pdbx_struct_msym_gen: Pdbx_struct_msym_gen.t list;
    pdbx_struct_legacy_oper_list: Pdbx_struct_legacy_oper_list.t list;
    pdbx_chem_comp_atom_feature: Pdbx_chem_comp_atom_feature.t list;
    pdbx_reference_molecule_family: Pdbx_reference_molecule_family.t list;
    pdbx_reference_molecule_list: Pdbx_reference_molecule_list.t list;
    pdbx_reference_molecule: Pdbx_reference_molecule.t list;
    pdbx_reference_entity_list: Pdbx_reference_entity_list.t list;
    pdbx_reference_entity_nonpoly: Pdbx_reference_entity_nonpoly.t list;
    pdbx_reference_entity_link: Pdbx_reference_entity_link.t list;
    pdbx_reference_entity_poly_link: Pdbx_reference_entity_poly_link.t list;
    pdbx_reference_entity_poly: Pdbx_reference_entity_poly.t list;
    pdbx_reference_entity_poly_seq: Pdbx_reference_entity_poly_seq.t list;
    pdbx_reference_entity_sequence: Pdbx_reference_entity_sequence.t list;
    pdbx_reference_entity_src_nat: Pdbx_reference_entity_src_nat.t list;
    pdbx_reference_molecule_details: Pdbx_reference_molecule_details.t list;
    pdbx_reference_molecule_synonyms: Pdbx_reference_molecule_synonyms.t list;
    pdbx_reference_entity_subcomponents: Pdbx_reference_entity_subcomponents.t list;
    pdbx_reference_molecule_annotation: Pdbx_reference_molecule_annotation.t list;
    pdbx_reference_molecule_features: Pdbx_reference_molecule_features.t list;
    pdbx_reference_molecule_related_structures: Pdbx_reference_molecule_related_structures.t list;
    pdbx_struct_group_list: Pdbx_struct_group_list.t list;
    pdbx_struct_group_components: Pdbx_struct_group_components.t list;
    pdbx_struct_group_component_range: Pdbx_struct_group_component_range.t list;
    pdbx_prd_audit: Pdbx_prd_audit.t list;
    pdbx_family_prd_audit: Pdbx_family_prd_audit.t list;
    pdbx_molecule: Pdbx_molecule.t list;
    pdbx_molecule_features: Pdbx_molecule_features.t list;
    pdbx_family_group_index: Pdbx_family_group_index.t list;
    pdbx_distant_solvent_atoms: Pdbx_distant_solvent_atoms.t list;
    pdbx_struct_special_symmetry: Pdbx_struct_special_symmetry.t list;
    pdbx_reference_publication_list: Pdbx_reference_publication_list.t list;
    pdbx_nmr_assigned_chem_shift_list: Pdbx_nmr_assigned_chem_shift_list.t list;
    pdbx_nmr_chem_shift_experiment: Pdbx_nmr_chem_shift_experiment.t list;
    pdbx_nmr_chem_shift_ref: Pdbx_nmr_chem_shift_ref.t list;
    pdbx_nmr_chem_shift_reference: Pdbx_nmr_chem_shift_reference.t list;
    pdbx_nmr_chem_shift_software: Pdbx_nmr_chem_shift_software.t list;
    pdbx_nmr_constraint_file: Pdbx_nmr_constraint_file.t list;
    pdbx_nmr_software_task: Pdbx_nmr_software_task.t list;
    pdbx_nmr_spectral_dim: Pdbx_nmr_spectral_dim.t list;
    pdbx_nmr_spectral_peak_list: Pdbx_nmr_spectral_peak_list.t list;
    pdbx_nmr_spectral_peak_software: Pdbx_nmr_spectral_peak_software.t list;
    pdbx_nmr_systematic_chem_shift_offset: Pdbx_nmr_systematic_chem_shift_offset.t list;
    pdbx_nmr_upload: Pdbx_nmr_upload.t list;
    pdbx_audit_support: Pdbx_audit_support.t list;
    pdbx_chem_comp_subcomponent_struct_conn: Pdbx_chem_comp_subcomponent_struct_conn.t list;
    pdbx_chem_comp_subcomponent_entity_list: Pdbx_chem_comp_subcomponent_entity_list.t list;
    entity_src_nat: Entity_src_nat.t list;
    entity_src_gen: Entity_src_gen.t list;
    pdbx_entity_src_syn: Pdbx_entity_src_syn.t list;
    pdbx_entity_poly_comp_link_list: Pdbx_entity_poly_comp_link_list.t list;
    pdbx_linked_entity: Pdbx_linked_entity.t list;
    pdbx_linked_entity_instance_list: Pdbx_linked_entity_instance_list.t list;
    pdbx_linked_entity_list: Pdbx_linked_entity_list.t list;
    pdbx_linked_entity_link_list: Pdbx_linked_entity_link_list.t list;
    pdbx_entity_descriptor: Pdbx_entity_descriptor.t list;
    pdbx_reference_linked_entity: Pdbx_reference_linked_entity.t list;
    pdbx_reference_linked_entity_comp_list: Pdbx_reference_linked_entity_comp_list.t list;
    pdbx_reference_linked_entity_comp_link: Pdbx_reference_linked_entity_comp_link.t list;
    pdbx_reference_linked_entity_link: Pdbx_reference_linked_entity_link.t list;
    pdbx_related_exp_data_set: Pdbx_related_exp_data_set.t list;
    pdbx_database_status_history: Pdbx_database_status_history.t list;
    em_assembly: Em_assembly.t list;
    em_entity_assembly: Em_entity_assembly.t list;
    em_virus_entity: Em_virus_entity.t list;
    em_sample_preparation: Em_sample_preparation.t list;
    em_sample_support: Em_sample_support.t list;
    em_buffer: Em_buffer.t list;
    em_vitrification: Em_vitrification.t list;
    em_imaging: Em_imaging.t list;
    em_detector: Em_detector.t list;
    em_image_scans: Em_image_scans.t list;
    em_2d_projection_selection: Em_2d_projection_selection.t list;
    em_3d_reconstruction: Em_3d_reconstruction.t list;
    em_3d_fitting: Em_3d_fitting.t list;
    em_3d_fitting_list: Em_3d_fitting_list.t list;
    em_helical_entity: Em_helical_entity.t list;
    em_experiment: Em_experiment.t list;
    em_single_particle_entity: Em_single_particle_entity.t list;
    em_admin: Em_admin.t list;
    em_author_list: Em_author_list.t list;
    em_db_reference: Em_db_reference.t list;
    em_db_reference_auxiliary: Em_db_reference_auxiliary.t list;
    em_depui: Em_depui.t list;
    em_obsolete: Em_obsolete.t list;
    em_supersede: Em_supersede.t list;
    em_entity_assembly_molwt: Em_entity_assembly_molwt.t list;
    em_entity_assembly_naturalsource: Em_entity_assembly_naturalsource.t list;
    em_entity_assembly_recombinant: Em_entity_assembly_recombinant.t list;
    em_virus_natural_host: Em_virus_natural_host.t list;
    em_virus_shell: Em_virus_shell.t list;
    em_specimen: Em_specimen.t list;
    em_embedding: Em_embedding.t list;
    em_fiducial_markers: Em_fiducial_markers.t list;
    em_focused_ion_beam: Em_focused_ion_beam.t list;
    em_grid_pretreatment: Em_grid_pretreatment.t list;
    em_ultramicrotomy: Em_ultramicrotomy.t list;
    em_high_pressure_freezing: Em_high_pressure_freezing.t list;
    em_shadowing: Em_shadowing.t list;
    em_tomography_specimen: Em_tomography_specimen.t list;
    em_crystal_formation: Em_crystal_formation.t list;
    em_staining: Em_staining.t list;
    em_support_film: Em_support_film.t list;
    em_buffer_component: Em_buffer_component.t list;
    em_diffraction: Em_diffraction.t list;
    em_diffraction_shell: Em_diffraction_shell.t list;
    em_diffraction_stats: Em_diffraction_stats.t list;
    em_tomography: Em_tomography.t list;
    em_image_recording: Em_image_recording.t list;
    em_imaging_optics: Em_imaging_optics.t list;
    em_final_classification: Em_final_classification.t list;
    em_start_model: Em_start_model.t list;
    em_software: Em_software.t list;
    em_euler_angle_assignment: Em_euler_angle_assignment.t list;
    em_ctf_correction: Em_ctf_correction.t list;
    em_volume_selection: Em_volume_selection.t list;
    em_3d_crystal_entity: Em_3d_crystal_entity.t list;
    em_2d_crystal_entity: Em_2d_crystal_entity.t list;
    em_image_processing: Em_image_processing.t list;
    em_particle_selection: Em_particle_selection.t list;
    em_map: Em_map.t list;
    em_fsc_curve: Em_fsc_curve.t list;
    em_interpret_figure: Em_interpret_figure.t list;
    em_layer_lines: Em_layer_lines.t list;
    em_structure_factors: Em_structure_factors.t list;
    em_depositor_info: Em_depositor_info.t list;
    em_map_depositor_info: Em_map_depositor_info.t list;
    em_mask_depositor_info: Em_mask_depositor_info.t list;
    em_figure_depositor_info: Em_figure_depositor_info.t list;
    em_layer_lines_depositor_info: Em_layer_lines_depositor_info.t list;
    em_structure_factors_depositor_info: Em_structure_factors_depositor_info.t list;
    pdbx_seq_map_depositor_info: Pdbx_seq_map_depositor_info.t list;
    pdbx_chem_comp_depositor_info: Pdbx_chem_comp_depositor_info.t list;
    pdbx_struct_ref_seq_depositor_info: Pdbx_struct_ref_seq_depositor_info.t list;
    pdbx_struct_ref_seq_dif_depositor_info: Pdbx_struct_ref_seq_dif_depositor_info.t list;
    pdbx_struct_assembly_prop_depositor_info: Pdbx_struct_assembly_prop_depositor_info.t list;
    pdbx_struct_assembly_depositor_info: Pdbx_struct_assembly_depositor_info.t list;
    pdbx_struct_assembly_gen_depositor_info: Pdbx_struct_assembly_gen_depositor_info.t list;
    pdbx_struct_oper_list_depositor_info: Pdbx_struct_oper_list_depositor_info.t list;
    pdbx_point_symmetry_depositor_info: Pdbx_point_symmetry_depositor_info.t list;
    pdbx_helical_symmetry_depositor_info: Pdbx_helical_symmetry_depositor_info.t list;
    pdbx_struct_assembly_auth_evidence_depositor_info: Pdbx_struct_assembly_auth_evidence_depositor_info.t list;
    pdbx_solvent_atom_site_mapping: Pdbx_solvent_atom_site_mapping.t list;
    pdbx_molecule_features_depositor_info: Pdbx_molecule_features_depositor_info.t list;
    pdbx_chem_comp_instance_depositor_info: Pdbx_chem_comp_instance_depositor_info.t list;
    pdbx_depui_status_flags: Pdbx_depui_status_flags.t list;
    pdbx_depui_upload: Pdbx_depui_upload.t list;
    pdbx_depui_validation_status_flags: Pdbx_depui_validation_status_flags.t list;
    pdbx_chem_comp_upload_depositor_info: Pdbx_chem_comp_upload_depositor_info.t list;
    pdbx_depui_entity_status_flags: Pdbx_depui_entity_status_flags.t list;
    pdbx_depui_entity_features: Pdbx_depui_entity_features.t list;
    pdbx_deposition_message_info: Pdbx_deposition_message_info.t list;
    pdbx_deposition_message_file_reference: Pdbx_deposition_message_file_reference.t list;
    pdbx_depui_entry_details: Pdbx_depui_entry_details.t list;
    pdbx_data_processing_status: Pdbx_data_processing_status.t list;
    pdbx_entity_instance_feature: Pdbx_entity_instance_feature.t list;
    pdbx_entity_src_gen_depositor_info: Pdbx_entity_src_gen_depositor_info.t list;
    pdbx_chem_comp_model: Pdbx_chem_comp_model.t list;
    pdbx_chem_comp_model_atom: Pdbx_chem_comp_model_atom.t list;
    pdbx_chem_comp_model_bond: Pdbx_chem_comp_model_bond.t list;
    pdbx_chem_comp_model_feature: Pdbx_chem_comp_model_feature.t list;
    pdbx_chem_comp_model_descriptor: Pdbx_chem_comp_model_descriptor.t list;
    pdbx_chem_comp_model_audit: Pdbx_chem_comp_model_audit.t list;
    pdbx_chem_comp_model_reference: Pdbx_chem_comp_model_reference.t list;
    pdbx_view_category_group: Pdbx_view_category_group.t list;
    pdbx_view_category: Pdbx_view_category.t list;
    pdbx_view_item: Pdbx_view_item.t list;
    pdbx_coord: Pdbx_coord.t list;
    pdbx_connect: Pdbx_connect.t list;
    pdbx_connect_type: Pdbx_connect_type.t list;
    pdbx_connect_modification: Pdbx_connect_modification.t list;
    pdbx_connect_atom: Pdbx_connect_atom.t list;
    pdbx_database_PDB_master: Pdbx_database_PDB_master.t list;
    pdbx_database_pdb_omit: Pdbx_database_pdb_omit.t list;
    pdbx_dbref: Pdbx_dbref.t list;
    pdbx_drug_info: Pdbx_drug_info.t list;
    pdbx_inhibitor_info: Pdbx_inhibitor_info.t list;
    pdbx_ion_info: Pdbx_ion_info.t list;
    pdbx_hybrid: Pdbx_hybrid.t list;
    pdbx_na_strand_info: Pdbx_na_strand_info.t list;
    pdbx_nonstandard_list: Pdbx_nonstandard_list.t list;
    pdbx_pdb_compnd: Pdbx_pdb_compnd.t list;
    pdbx_pdb_source: Pdbx_pdb_source.t list;
    pdbx_protein_info: Pdbx_protein_info.t list;
    pdbx_solvent_info: Pdbx_solvent_info.t list;
    pdbx_source: Pdbx_source.t list;
    pdbx_struct_biol_func: Pdbx_struct_biol_func.t list;
    pdbx_struct_pack_gen: Pdbx_struct_pack_gen.t list;
    pdbx_trna_info: Pdbx_trna_info.t list;
    pdbx_unpair: Pdbx_unpair.t list;
    pdbx_refine_ls_restr_ncs: Pdbx_refine_ls_restr_ncs.t list;
    pdbx_struct_ncs_virus_gen: Pdbx_struct_ncs_virus_gen.t list;
    pdbx_sequence_annotation: Pdbx_sequence_annotation.t list;
    pdbx_chem_comp_synonyms: Pdbx_chem_comp_synonyms.t list;
    pdbx_post_process_details: Pdbx_post_process_details.t list;
    pdbx_post_process_status: Pdbx_post_process_status.t list;
    pdbx_struct_link: Pdbx_struct_link.t list;
    pdbx_missing_residue_list: Pdbx_missing_residue_list.t list;
    pdbx_data_processing_cell: Pdbx_data_processing_cell.t list;
    pdbx_data_processing_reflns: Pdbx_data_processing_reflns.t list;
    pdbx_data_processing_detector: Pdbx_data_processing_detector.t list;
    pdbx_chem_comp_nonstandard: Pdbx_chem_comp_nonstandard.t list;
    pdbx_entity_poly_protein_class: Pdbx_entity_poly_protein_class.t list;
    pdbx_entity_name_taxonomy_tree: Pdbx_entity_name_taxonomy_tree.t list;
    pdbx_entity_name_taxonomy: Pdbx_entity_name_taxonomy.t list;
    pdbx_entity_name_instance: Pdbx_entity_name_instance.t list;
    pdbx_tableinfo: Pdbx_tableinfo.t list;
    pdbx_columninfo: Pdbx_columninfo.t list;
    pdbx_val_angle: Pdbx_val_angle.t list;
    pdbx_val_bond: Pdbx_val_bond.t list;
    pdbx_val_contact: Pdbx_val_contact.t list;
    pdbx_val_sym_contact: Pdbx_val_sym_contact.t list;
    pdbx_rmch_outlier: Pdbx_rmch_outlier.t list;
    pdbx_missing_atom_poly: Pdbx_missing_atom_poly.t list;
    pdbx_missing_atom_nonpoly: Pdbx_missing_atom_nonpoly.t list;
    pdbx_val_chiral: Pdbx_val_chiral.t list;
    pdbx_atlas: Pdbx_atlas.t list;
    pdbx_summary_flags: Pdbx_summary_flags.t list;
    pdbx_entity_func_bind_mode: Pdbx_entity_func_bind_mode.t list;
    pdbx_entity_func_enzyme: Pdbx_entity_func_enzyme.t list;
    pdbx_entity_func_regulatory: Pdbx_entity_func_regulatory.t list;
    pdbx_entity_func_structural: Pdbx_entity_func_structural.t list;
    pdbx_entity_func_other: Pdbx_entity_func_other.t list;
    pdbx_entity_poly_domain: Pdbx_entity_poly_domain.t list;
    pdbx_na_struct_keywds: Pdbx_na_struct_keywds.t list;
    pdbx_entity_poly_na_type: Pdbx_entity_poly_na_type.t list;
    pdbx_entity_poly_na_nonstandard: Pdbx_entity_poly_na_nonstandard.t list;
    pdbx_virtual_angle: Pdbx_virtual_angle.t list;
    pdbx_virtual_bond: Pdbx_virtual_bond.t list;
    pdbx_virtual_torsion: Pdbx_virtual_torsion.t list;
    pdbx_sequence_pattern: Pdbx_sequence_pattern.t list;
    pdbx_stereochemistry: Pdbx_stereochemistry.t list;
    pdbx_rms_devs_covalent: Pdbx_rms_devs_covalent.t list;
    pdbx_rms_devs_cov_by_monomer: Pdbx_rms_devs_cov_by_monomer.t list;
    pdbx_sugar_phosphate_geometry: Pdbx_sugar_phosphate_geometry.t list;
    pdbx_nmr_computing: Pdbx_nmr_computing.t list;
    pdbx_audit_conform_extension: Pdbx_audit_conform_extension.t list;
    pdbx_dcc_mapman: Pdbx_dcc_mapman.t list;
    pdbx_dcc_rscc_mapman: Pdbx_dcc_rscc_mapman.t list;
    pdbx_dcc_rscc_mapman_overall: Pdbx_dcc_rscc_mapman_overall.t list;
    pdbx_dcc_density: Pdbx_dcc_density.t list;
    pdbx_dcc_geometry: Pdbx_dcc_geometry.t list;
    pdbx_dcc_density_corr: Pdbx_dcc_density_corr.t list;
    pdbx_dcc_map: Pdbx_dcc_map.t list;
    pdbx_deposit_group: Pdbx_deposit_group.t list;
    pdbx_deposit_group_index: Pdbx_deposit_group_index.t list;
    pdbx_struct_assembly_auth_evidence: Pdbx_struct_assembly_auth_evidence.t list;
    pdbx_struct_assembly_auth_classification: Pdbx_struct_assembly_auth_classification.t list;
    pdbx_crystal_alignment: Pdbx_crystal_alignment.t list;
    pdbx_audit_revision_history: Pdbx_audit_revision_history.t list;
    pdbx_audit_revision_group: Pdbx_audit_revision_group.t list;
    pdbx_audit_revision_category: Pdbx_audit_revision_category.t list;
    pdbx_audit_revision_details: Pdbx_audit_revision_details.t list;
    pdbx_audit_revision_item: Pdbx_audit_revision_item.t list;
    pdbx_supporting_exp_data_set: Pdbx_supporting_exp_data_set.t list;
  }

  let default = {
    datablockName = "?";
    jV_command = [];
    atom_site = [];
    atom_site_anisotrop = [];
    atom_sites = [];
    atom_sites_alt = [];
    atom_sites_alt_ens = [];
    atom_sites_alt_gen = [];
    atom_sites_footnote = [];
    atom_type = [];
    audit = [];
    audit_author = [];
    audit_conform = [];
    audit_contact_author = [];
    cell = [];
    cell_measurement = [];
    cell_measurement_refln = [];
    chem_comp = [];
    chem_comp_angle = [];
    chem_comp_atom = [];
    chem_comp_bond = [];
    chem_comp_chir = [];
    chem_comp_chir_atom = [];
    chem_comp_link = [];
    chem_comp_plane = [];
    chem_comp_plane_atom = [];
    chem_comp_tor = [];
    chem_comp_tor_value = [];
    chem_link = [];
    chem_link_angle = [];
    chem_link_bond = [];
    chem_link_chir = [];
    chem_link_chir_atom = [];
    chem_link_plane = [];
    chem_link_plane_atom = [];
    chem_link_tor = [];
    chem_link_tor_value = [];
    chemical = [];
    chemical_conn_atom = [];
    chemical_conn_bond = [];
    chemical_formula = [];
    citation = [];
    citation_author = [];
    citation_editor = [];
    computing = [];
    database = [];
    database_2 = [];
    database_PDB_caveat = [];
    database_PDB_matrix = [];
    database_PDB_remark = [];
    database_PDB_rev = [];
    database_PDB_rev_record = [];
    database_PDB_tvect = [];
    diffrn = [];
    diffrn_attenuator = [];
    diffrn_detector = [];
    diffrn_measurement = [];
    diffrn_orient_matrix = [];
    diffrn_orient_refln = [];
    diffrn_radiation = [];
    diffrn_radiation_wavelength = [];
    diffrn_refln = [];
    diffrn_reflns = [];
    diffrn_scale_group = [];
    diffrn_source = [];
    diffrn_standard_refln = [];
    diffrn_standards = [];
    entity = [];
    entity_keywords = [];
    entity_link = [];
    entity_name_com = [];
    entity_name_sys = [];
    entity_poly = [];
    entity_poly_seq = [];
    entry = [];
    entry_link = [];
    exptl = [];
    exptl_crystal = [];
    exptl_crystal_face = [];
    exptl_crystal_grow = [];
    exptl_crystal_grow_comp = [];
    geom = [];
    geom_angle = [];
    geom_bond = [];
    geom_contact = [];
    geom_hbond = [];
    geom_torsion = [];
    journal = [];
    journal_index = [];
    phasing = [];
    phasing_averaging = [];
    phasing_isomorphous = [];
    phasing_MAD = [];
    phasing_MAD_clust = [];
    phasing_MAD_expt = [];
    phasing_MAD_ratio = [];
    phasing_MAD_set = [];
    phasing_MIR = [];
    phasing_MIR_der = [];
    phasing_MIR_der_refln = [];
    phasing_MIR_der_shell = [];
    phasing_MIR_der_site = [];
    phasing_MIR_shell = [];
    phasing_set = [];
    phasing_set_refln = [];
    publ = [];
    publ_author = [];
    publ_body = [];
    publ_manuscript_incl = [];
    refine = [];
    refine_analyze = [];
    refine_B_iso = [];
    refine_funct_minimized = [];
    refine_hist = [];
    refine_ls_restr = [];
    refine_ls_restr_ncs = [];
    refine_ls_restr_type = [];
    refine_ls_shell = [];
    refine_occupancy = [];
    refln = [];
    refln_sys_abs = [];
    reflns = [];
    reflns_scale = [];
    reflns_shell = [];
    software = [];
    struct_ = [];
    struct_asym = [];
    struct_biol = [];
    struct_biol_gen = [];
    struct_biol_keywords = [];
    struct_biol_view = [];
    struct_conf = [];
    struct_conf_type = [];
    struct_conn = [];
    struct_conn_type = [];
    struct_keywords = [];
    struct_mon_details = [];
    struct_mon_nucl = [];
    struct_mon_prot = [];
    struct_mon_prot_cis = [];
    struct_ncs_dom = [];
    struct_ncs_dom_lim = [];
    struct_ncs_ens = [];
    struct_ncs_ens_gen = [];
    struct_ncs_oper = [];
    struct_ref = [];
    struct_ref_seq = [];
    struct_ref_seq_dif = [];
    struct_sheet = [];
    struct_sheet_hbond = [];
    struct_sheet_order = [];
    struct_sheet_range = [];
    struct_sheet_topology = [];
    struct_site = [];
    struct_site_gen = [];
    struct_site_keywords = [];
    struct_site_view = [];
    symmetry = [];
    symmetry_equiv = [];
    audit_link = [];
    diffrn_reflns_class = [];
    refine_ls_class = [];
    reflns_class = [];
    space_group = [];
    space_group_symop = [];
    valence_param = [];
    valence_ref = [];
    pdbx_audit = [];
    pdbx_version = [];
    pdbx_audit_author = [];
    pdbx_database_message = [];
    pdbx_database_PDB_obs_spr = [];
    pdbx_database_proc = [];
    pdbx_database_remark = [];
    pdbx_database_status = [];
    pdbx_entity_name = [];
    pdbx_prerelease_seq = [];
    pdbx_poly_seq_scheme = [];
    pdbx_nonpoly_scheme = [];
    pdbx_refine = [];
    pdbx_struct_sheet_hbond = [];
    pdbx_xplor_file = [];
    pdbx_refine_aux_file = [];
    pdbx_database_related = [];
    pdbx_entity_assembly = [];
    pdbx_exptl_crystal_grow_comp = [];
    pdbx_exptl_crystal_grow_sol = [];
    pdbx_exptl_crystal_cryo_treatment = [];
    pdbx_refine_tls = [];
    pdbx_refine_tls_group = [];
    pdbx_contact_author = [];
    pdbx_SG_project = [];
    pdbx_atom_site_aniso_tls = [];
    pdbx_nmr_details = [];
    pdbx_nmr_sample_details = [];
    pdbx_nmr_exptl_sample = [];
    pdbx_nmr_exptl_sample_conditions = [];
    pdbx_nmr_spectrometer = [];
    pdbx_nmr_exptl = [];
    pdbx_nmr_software = [];
    pdbx_nmr_constraints = [];
    pdbx_nmr_ensemble = [];
    pdbx_nmr_ensemble_rms = [];
    pdbx_nmr_representative = [];
    pdbx_nmr_refine = [];
    pdbx_nmr_force_constants = [];
    ndb_struct_conf_na = [];
    ndb_struct_feature_na = [];
    ndb_struct_na_base_pair = [];
    ndb_struct_na_base_pair_step = [];
    ndb_original_ndb_coordinates = [];
    pdbx_entity_nonpoly = [];
    pdbx_phasing_dm = [];
    pdbx_phasing_dm_shell = [];
    pdbx_phasing_MAD_shell = [];
    pdbx_phasing_MAD_set = [];
    pdbx_phasing_MAD_set_shell = [];
    pdbx_phasing_MAD_set_site = [];
    pdbx_phasing_MR = [];
    pdbx_refine_component = [];
    pdbx_entity_prod_protocol = [];
    pdbx_entity_src_gen_prod_other = [];
    pdbx_entity_src_gen_prod_other_parameter = [];
    pdbx_entity_src_gen_prod_pcr = [];
    pdbx_entity_src_gen_prod_digest = [];
    pdbx_entity_src_gen_clone = [];
    pdbx_entity_src_gen_clone_ligation = [];
    pdbx_entity_src_gen_clone_recombination = [];
    pdbx_entity_src_gen_express = [];
    pdbx_entity_src_gen_express_timepoint = [];
    pdbx_entity_src_gen_lysis = [];
    pdbx_entity_src_gen_refold = [];
    pdbx_entity_src_gen_proteolysis = [];
    pdbx_entity_src_gen_chrom = [];
    pdbx_entity_src_gen_fract = [];
    pdbx_entity_src_gen_pure = [];
    pdbx_entity_src_gen_character = [];
    pdbx_construct = [];
    pdbx_construct_feature = [];
    pdbx_robot_system = [];
    pdbx_buffer = [];
    pdbx_buffer_components = [];
    pdbx_domain = [];
    pdbx_domain_range = [];
    pdbx_sequence_range = [];
    pdbx_feature_entry = [];
    pdbx_feature_domain = [];
    pdbx_feature_sequence_range = [];
    pdbx_feature_assembly = [];
    pdbx_feature_monomer = [];
    pdbx_exptl_pd = [];
    pdbx_reflns_twin = [];
    pdbx_struct_info = [];
    pdbx_re_refinement = [];
    pdbx_struct_assembly_prop = [];
    pdbx_struct_ref_seq_feature = [];
    pdbx_struct_ref_seq_feature_prop = [];
    pdbx_struct_chem_comp_diagnostics = [];
    pdbx_chem_comp_feature = [];
    pdbx_coordinate_model = [];
    pdbx_struct_chem_comp_feature = [];
    pdbx_diffrn_reflns_shell = [];
    pdbx_bond_distance_limits = [];
    pdbx_soln_scatter = [];
    pdbx_soln_scatter_model = [];
    pdbx_chem_comp_descriptor = [];
    pdbx_chem_comp_identifier = [];
    pdbx_chem_comp_import = [];
    pdbx_chem_comp_atom_edit = [];
    pdbx_chem_comp_bond_edit = [];
    pdbx_chem_comp_audit = [];
    pdbx_validate_close_contact = [];
    pdbx_validate_symm_contact = [];
    pdbx_validate_rmsd_bond = [];
    pdbx_validate_rmsd_angle = [];
    pdbx_validate_torsion = [];
    pdbx_validate_peptide_omega = [];
    pdbx_validate_chiral = [];
    pdbx_validate_planes = [];
    pdbx_validate_planes_atom = [];
    pdbx_validate_main_chain_plane = [];
    pdbx_struct_conn_angle = [];
    pdbx_unobs_or_zero_occ_residues = [];
    pdbx_unobs_or_zero_occ_atoms = [];
    pdbx_entry_details = [];
    pdbx_struct_mod_residue = [];
    pdbx_struct_ref_seq_insertion = [];
    pdbx_struct_ref_seq_deletion = [];
    pdbx_remediation_atom_site_mapping = [];
    pdbx_validate_polymer_linkage = [];
    pdbx_helical_symmetry = [];
    pdbx_point_symmetry = [];
    pdbx_struct_entity_inst = [];
    pdbx_struct_oper_list = [];
    pdbx_struct_assembly = [];
    pdbx_struct_assembly_gen = [];
    pdbx_struct_asym_gen = [];
    pdbx_struct_msym_gen = [];
    pdbx_struct_legacy_oper_list = [];
    pdbx_chem_comp_atom_feature = [];
    pdbx_reference_molecule_family = [];
    pdbx_reference_molecule_list = [];
    pdbx_reference_molecule = [];
    pdbx_reference_entity_list = [];
    pdbx_reference_entity_nonpoly = [];
    pdbx_reference_entity_link = [];
    pdbx_reference_entity_poly_link = [];
    pdbx_reference_entity_poly = [];
    pdbx_reference_entity_poly_seq = [];
    pdbx_reference_entity_sequence = [];
    pdbx_reference_entity_src_nat = [];
    pdbx_reference_molecule_details = [];
    pdbx_reference_molecule_synonyms = [];
    pdbx_reference_entity_subcomponents = [];
    pdbx_reference_molecule_annotation = [];
    pdbx_reference_molecule_features = [];
    pdbx_reference_molecule_related_structures = [];
    pdbx_struct_group_list = [];
    pdbx_struct_group_components = [];
    pdbx_struct_group_component_range = [];
    pdbx_prd_audit = [];
    pdbx_family_prd_audit = [];
    pdbx_molecule = [];
    pdbx_molecule_features = [];
    pdbx_family_group_index = [];
    pdbx_distant_solvent_atoms = [];
    pdbx_struct_special_symmetry = [];
    pdbx_reference_publication_list = [];
    pdbx_nmr_assigned_chem_shift_list = [];
    pdbx_nmr_chem_shift_experiment = [];
    pdbx_nmr_chem_shift_ref = [];
    pdbx_nmr_chem_shift_reference = [];
    pdbx_nmr_chem_shift_software = [];
    pdbx_nmr_constraint_file = [];
    pdbx_nmr_software_task = [];
    pdbx_nmr_spectral_dim = [];
    pdbx_nmr_spectral_peak_list = [];
    pdbx_nmr_spectral_peak_software = [];
    pdbx_nmr_systematic_chem_shift_offset = [];
    pdbx_nmr_upload = [];
    pdbx_audit_support = [];
    pdbx_chem_comp_subcomponent_struct_conn = [];
    pdbx_chem_comp_subcomponent_entity_list = [];
    entity_src_nat = [];
    entity_src_gen = [];
    pdbx_entity_src_syn = [];
    pdbx_entity_poly_comp_link_list = [];
    pdbx_linked_entity = [];
    pdbx_linked_entity_instance_list = [];
    pdbx_linked_entity_list = [];
    pdbx_linked_entity_link_list = [];
    pdbx_entity_descriptor = [];
    pdbx_reference_linked_entity = [];
    pdbx_reference_linked_entity_comp_list = [];
    pdbx_reference_linked_entity_comp_link = [];
    pdbx_reference_linked_entity_link = [];
    pdbx_related_exp_data_set = [];
    pdbx_database_status_history = [];
    em_assembly = [];
    em_entity_assembly = [];
    em_virus_entity = [];
    em_sample_preparation = [];
    em_sample_support = [];
    em_buffer = [];
    em_vitrification = [];
    em_imaging = [];
    em_detector = [];
    em_image_scans = [];
    em_2d_projection_selection = [];
    em_3d_reconstruction = [];
    em_3d_fitting = [];
    em_3d_fitting_list = [];
    em_helical_entity = [];
    em_experiment = [];
    em_single_particle_entity = [];
    em_admin = [];
    em_author_list = [];
    em_db_reference = [];
    em_db_reference_auxiliary = [];
    em_depui = [];
    em_obsolete = [];
    em_supersede = [];
    em_entity_assembly_molwt = [];
    em_entity_assembly_naturalsource = [];
    em_entity_assembly_recombinant = [];
    em_virus_natural_host = [];
    em_virus_shell = [];
    em_specimen = [];
    em_embedding = [];
    em_fiducial_markers = [];
    em_focused_ion_beam = [];
    em_grid_pretreatment = [];
    em_ultramicrotomy = [];
    em_high_pressure_freezing = [];
    em_shadowing = [];
    em_tomography_specimen = [];
    em_crystal_formation = [];
    em_staining = [];
    em_support_film = [];
    em_buffer_component = [];
    em_diffraction = [];
    em_diffraction_shell = [];
    em_diffraction_stats = [];
    em_tomography = [];
    em_image_recording = [];
    em_imaging_optics = [];
    em_final_classification = [];
    em_start_model = [];
    em_software = [];
    em_euler_angle_assignment = [];
    em_ctf_correction = [];
    em_volume_selection = [];
    em_3d_crystal_entity = [];
    em_2d_crystal_entity = [];
    em_image_processing = [];
    em_particle_selection = [];
    em_map = [];
    em_fsc_curve = [];
    em_interpret_figure = [];
    em_layer_lines = [];
    em_structure_factors = [];
    em_depositor_info = [];
    em_map_depositor_info = [];
    em_mask_depositor_info = [];
    em_figure_depositor_info = [];
    em_layer_lines_depositor_info = [];
    em_structure_factors_depositor_info = [];
    pdbx_seq_map_depositor_info = [];
    pdbx_chem_comp_depositor_info = [];
    pdbx_struct_ref_seq_depositor_info = [];
    pdbx_struct_ref_seq_dif_depositor_info = [];
    pdbx_struct_assembly_prop_depositor_info = [];
    pdbx_struct_assembly_depositor_info = [];
    pdbx_struct_assembly_gen_depositor_info = [];
    pdbx_struct_oper_list_depositor_info = [];
    pdbx_point_symmetry_depositor_info = [];
    pdbx_helical_symmetry_depositor_info = [];
    pdbx_struct_assembly_auth_evidence_depositor_info = [];
    pdbx_solvent_atom_site_mapping = [];
    pdbx_molecule_features_depositor_info = [];
    pdbx_chem_comp_instance_depositor_info = [];
    pdbx_depui_status_flags = [];
    pdbx_depui_upload = [];
    pdbx_depui_validation_status_flags = [];
    pdbx_chem_comp_upload_depositor_info = [];
    pdbx_depui_entity_status_flags = [];
    pdbx_depui_entity_features = [];
    pdbx_deposition_message_info = [];
    pdbx_deposition_message_file_reference = [];
    pdbx_depui_entry_details = [];
    pdbx_data_processing_status = [];
    pdbx_entity_instance_feature = [];
    pdbx_entity_src_gen_depositor_info = [];
    pdbx_chem_comp_model = [];
    pdbx_chem_comp_model_atom = [];
    pdbx_chem_comp_model_bond = [];
    pdbx_chem_comp_model_feature = [];
    pdbx_chem_comp_model_descriptor = [];
    pdbx_chem_comp_model_audit = [];
    pdbx_chem_comp_model_reference = [];
    pdbx_view_category_group = [];
    pdbx_view_category = [];
    pdbx_view_item = [];
    pdbx_coord = [];
    pdbx_connect = [];
    pdbx_connect_type = [];
    pdbx_connect_modification = [];
    pdbx_connect_atom = [];
    pdbx_database_PDB_master = [];
    pdbx_database_pdb_omit = [];
    pdbx_dbref = [];
    pdbx_drug_info = [];
    pdbx_inhibitor_info = [];
    pdbx_ion_info = [];
    pdbx_hybrid = [];
    pdbx_na_strand_info = [];
    pdbx_nonstandard_list = [];
    pdbx_pdb_compnd = [];
    pdbx_pdb_source = [];
    pdbx_protein_info = [];
    pdbx_solvent_info = [];
    pdbx_source = [];
    pdbx_struct_biol_func = [];
    pdbx_struct_pack_gen = [];
    pdbx_trna_info = [];
    pdbx_unpair = [];
    pdbx_refine_ls_restr_ncs = [];
    pdbx_struct_ncs_virus_gen = [];
    pdbx_sequence_annotation = [];
    pdbx_chem_comp_synonyms = [];
    pdbx_post_process_details = [];
    pdbx_post_process_status = [];
    pdbx_struct_link = [];
    pdbx_missing_residue_list = [];
    pdbx_data_processing_cell = [];
    pdbx_data_processing_reflns = [];
    pdbx_data_processing_detector = [];
    pdbx_chem_comp_nonstandard = [];
    pdbx_entity_poly_protein_class = [];
    pdbx_entity_name_taxonomy_tree = [];
    pdbx_entity_name_taxonomy = [];
    pdbx_entity_name_instance = [];
    pdbx_tableinfo = [];
    pdbx_columninfo = [];
    pdbx_val_angle = [];
    pdbx_val_bond = [];
    pdbx_val_contact = [];
    pdbx_val_sym_contact = [];
    pdbx_rmch_outlier = [];
    pdbx_missing_atom_poly = [];
    pdbx_missing_atom_nonpoly = [];
    pdbx_val_chiral = [];
    pdbx_atlas = [];
    pdbx_summary_flags = [];
    pdbx_entity_func_bind_mode = [];
    pdbx_entity_func_enzyme = [];
    pdbx_entity_func_regulatory = [];
    pdbx_entity_func_structural = [];
    pdbx_entity_func_other = [];
    pdbx_entity_poly_domain = [];
    pdbx_na_struct_keywds = [];
    pdbx_entity_poly_na_type = [];
    pdbx_entity_poly_na_nonstandard = [];
    pdbx_virtual_angle = [];
    pdbx_virtual_bond = [];
    pdbx_virtual_torsion = [];
    pdbx_sequence_pattern = [];
    pdbx_stereochemistry = [];
    pdbx_rms_devs_covalent = [];
    pdbx_rms_devs_cov_by_monomer = [];
    pdbx_sugar_phosphate_geometry = [];
    pdbx_nmr_computing = [];
    pdbx_audit_conform_extension = [];
    pdbx_dcc_mapman = [];
    pdbx_dcc_rscc_mapman = [];
    pdbx_dcc_rscc_mapman_overall = [];
    pdbx_dcc_density = [];
    pdbx_dcc_geometry = [];
    pdbx_dcc_density_corr = [];
    pdbx_dcc_map = [];
    pdbx_deposit_group = [];
    pdbx_deposit_group_index = [];
    pdbx_struct_assembly_auth_evidence = [];
    pdbx_struct_assembly_auth_classification = [];
    pdbx_crystal_alignment = [];
    pdbx_audit_revision_history = [];
    pdbx_audit_revision_group = [];
    pdbx_audit_revision_category = [];
    pdbx_audit_revision_details = [];
    pdbx_audit_revision_item = [];
    pdbx_supporting_exp_data_set = [];
  }

  let of_mmCIF (dbName,lst) =
    List.fold_left (fun d (cat,lst) ->
      match cat with
      | "jV_command" -> { d with jV_command = List.map JV_command.of_mmCIF lst }
      | "atom_site" -> { d with atom_site = List.map Atom_site.of_mmCIF lst }
      | "atom_site_anisotrop" -> { d with atom_site_anisotrop = List.map Atom_site_anisotrop.of_mmCIF lst }
      | "atom_sites" -> { d with atom_sites = List.map Atom_sites.of_mmCIF lst }
      | "atom_sites_alt" -> { d with atom_sites_alt = List.map Atom_sites_alt.of_mmCIF lst }
      | "atom_sites_alt_ens" -> { d with atom_sites_alt_ens = List.map Atom_sites_alt_ens.of_mmCIF lst }
      | "atom_sites_alt_gen" -> { d with atom_sites_alt_gen = List.map Atom_sites_alt_gen.of_mmCIF lst }
      | "atom_sites_footnote" -> { d with atom_sites_footnote = List.map Atom_sites_footnote.of_mmCIF lst }
      | "atom_type" -> { d with atom_type = List.map Atom_type.of_mmCIF lst }
      | "audit" -> { d with audit = List.map Audit.of_mmCIF lst }
      | "audit_author" -> { d with audit_author = List.map Audit_author.of_mmCIF lst }
      | "audit_conform" -> { d with audit_conform = List.map Audit_conform.of_mmCIF lst }
      | "audit_contact_author" -> { d with audit_contact_author = List.map Audit_contact_author.of_mmCIF lst }
      | "cell" -> { d with cell = List.map Cell.of_mmCIF lst }
      | "cell_measurement" -> { d with cell_measurement = List.map Cell_measurement.of_mmCIF lst }
      | "cell_measurement_refln" -> { d with cell_measurement_refln = List.map Cell_measurement_refln.of_mmCIF lst }
      | "chem_comp" -> { d with chem_comp = List.map Chem_comp.of_mmCIF lst }
      | "chem_comp_angle" -> { d with chem_comp_angle = List.map Chem_comp_angle.of_mmCIF lst }
      | "chem_comp_atom" -> { d with chem_comp_atom = List.map Chem_comp_atom.of_mmCIF lst }
      | "chem_comp_bond" -> { d with chem_comp_bond = List.map Chem_comp_bond.of_mmCIF lst }
      | "chem_comp_chir" -> { d with chem_comp_chir = List.map Chem_comp_chir.of_mmCIF lst }
      | "chem_comp_chir_atom" -> { d with chem_comp_chir_atom = List.map Chem_comp_chir_atom.of_mmCIF lst }
      | "chem_comp_link" -> { d with chem_comp_link = List.map Chem_comp_link.of_mmCIF lst }
      | "chem_comp_plane" -> { d with chem_comp_plane = List.map Chem_comp_plane.of_mmCIF lst }
      | "chem_comp_plane_atom" -> { d with chem_comp_plane_atom = List.map Chem_comp_plane_atom.of_mmCIF lst }
      | "chem_comp_tor" -> { d with chem_comp_tor = List.map Chem_comp_tor.of_mmCIF lst }
      | "chem_comp_tor_value" -> { d with chem_comp_tor_value = List.map Chem_comp_tor_value.of_mmCIF lst }
      | "chem_link" -> { d with chem_link = List.map Chem_link.of_mmCIF lst }
      | "chem_link_angle" -> { d with chem_link_angle = List.map Chem_link_angle.of_mmCIF lst }
      | "chem_link_bond" -> { d with chem_link_bond = List.map Chem_link_bond.of_mmCIF lst }
      | "chem_link_chir" -> { d with chem_link_chir = List.map Chem_link_chir.of_mmCIF lst }
      | "chem_link_chir_atom" -> { d with chem_link_chir_atom = List.map Chem_link_chir_atom.of_mmCIF lst }
      | "chem_link_plane" -> { d with chem_link_plane = List.map Chem_link_plane.of_mmCIF lst }
      | "chem_link_plane_atom" -> { d with chem_link_plane_atom = List.map Chem_link_plane_atom.of_mmCIF lst }
      | "chem_link_tor" -> { d with chem_link_tor = List.map Chem_link_tor.of_mmCIF lst }
      | "chem_link_tor_value" -> { d with chem_link_tor_value = List.map Chem_link_tor_value.of_mmCIF lst }
      | "chemical" -> { d with chemical = List.map Chemical.of_mmCIF lst }
      | "chemical_conn_atom" -> { d with chemical_conn_atom = List.map Chemical_conn_atom.of_mmCIF lst }
      | "chemical_conn_bond" -> { d with chemical_conn_bond = List.map Chemical_conn_bond.of_mmCIF lst }
      | "chemical_formula" -> { d with chemical_formula = List.map Chemical_formula.of_mmCIF lst }
      | "citation" -> { d with citation = List.map Citation.of_mmCIF lst }
      | "citation_author" -> { d with citation_author = List.map Citation_author.of_mmCIF lst }
      | "citation_editor" -> { d with citation_editor = List.map Citation_editor.of_mmCIF lst }
      | "computing" -> { d with computing = List.map Computing.of_mmCIF lst }
      | "database" -> { d with database = List.map Database.of_mmCIF lst }
      | "database_2" -> { d with database_2 = List.map Database_2.of_mmCIF lst }
      | "database_PDB_caveat" -> { d with database_PDB_caveat = List.map Database_PDB_caveat.of_mmCIF lst }
      | "database_PDB_matrix" -> { d with database_PDB_matrix = List.map Database_PDB_matrix.of_mmCIF lst }
      | "database_PDB_remark" -> { d with database_PDB_remark = List.map Database_PDB_remark.of_mmCIF lst }
      | "database_PDB_rev" -> { d with database_PDB_rev = List.map Database_PDB_rev.of_mmCIF lst }
      | "database_PDB_rev_record" -> { d with database_PDB_rev_record = List.map Database_PDB_rev_record.of_mmCIF lst }
      | "database_PDB_tvect" -> { d with database_PDB_tvect = List.map Database_PDB_tvect.of_mmCIF lst }
      | "diffrn" -> { d with diffrn = List.map Diffrn.of_mmCIF lst }
      | "diffrn_attenuator" -> { d with diffrn_attenuator = List.map Diffrn_attenuator.of_mmCIF lst }
      | "diffrn_detector" -> { d with diffrn_detector = List.map Diffrn_detector.of_mmCIF lst }
      | "diffrn_measurement" -> { d with diffrn_measurement = List.map Diffrn_measurement.of_mmCIF lst }
      | "diffrn_orient_matrix" -> { d with diffrn_orient_matrix = List.map Diffrn_orient_matrix.of_mmCIF lst }
      | "diffrn_orient_refln" -> { d with diffrn_orient_refln = List.map Diffrn_orient_refln.of_mmCIF lst }
      | "diffrn_radiation" -> { d with diffrn_radiation = List.map Diffrn_radiation.of_mmCIF lst }
      | "diffrn_radiation_wavelength" -> { d with diffrn_radiation_wavelength = List.map Diffrn_radiation_wavelength.of_mmCIF lst }
      | "diffrn_refln" -> { d with diffrn_refln = List.map Diffrn_refln.of_mmCIF lst }
      | "diffrn_reflns" -> { d with diffrn_reflns = List.map Diffrn_reflns.of_mmCIF lst }
      | "diffrn_scale_group" -> { d with diffrn_scale_group = List.map Diffrn_scale_group.of_mmCIF lst }
      | "diffrn_source" -> { d with diffrn_source = List.map Diffrn_source.of_mmCIF lst }
      | "diffrn_standard_refln" -> { d with diffrn_standard_refln = List.map Diffrn_standard_refln.of_mmCIF lst }
      | "diffrn_standards" -> { d with diffrn_standards = List.map Diffrn_standards.of_mmCIF lst }
      | "entity" -> { d with entity = List.map Entity.of_mmCIF lst }
      | "entity_keywords" -> { d with entity_keywords = List.map Entity_keywords.of_mmCIF lst }
      | "entity_link" -> { d with entity_link = List.map Entity_link.of_mmCIF lst }
      | "entity_name_com" -> { d with entity_name_com = List.map Entity_name_com.of_mmCIF lst }
      | "entity_name_sys" -> { d with entity_name_sys = List.map Entity_name_sys.of_mmCIF lst }
      | "entity_poly" -> { d with entity_poly = List.map Entity_poly.of_mmCIF lst }
      | "entity_poly_seq" -> { d with entity_poly_seq = List.map Entity_poly_seq.of_mmCIF lst }
      | "entry" -> { d with entry = List.map Entry.of_mmCIF lst }
      | "entry_link" -> { d with entry_link = List.map Entry_link.of_mmCIF lst }
      | "exptl" -> { d with exptl = List.map Exptl.of_mmCIF lst }
      | "exptl_crystal" -> { d with exptl_crystal = List.map Exptl_crystal.of_mmCIF lst }
      | "exptl_crystal_face" -> { d with exptl_crystal_face = List.map Exptl_crystal_face.of_mmCIF lst }
      | "exptl_crystal_grow" -> { d with exptl_crystal_grow = List.map Exptl_crystal_grow.of_mmCIF lst }
      | "exptl_crystal_grow_comp" -> { d with exptl_crystal_grow_comp = List.map Exptl_crystal_grow_comp.of_mmCIF lst }
      | "geom" -> { d with geom = List.map Geom.of_mmCIF lst }
      | "geom_angle" -> { d with geom_angle = List.map Geom_angle.of_mmCIF lst }
      | "geom_bond" -> { d with geom_bond = List.map Geom_bond.of_mmCIF lst }
      | "geom_contact" -> { d with geom_contact = List.map Geom_contact.of_mmCIF lst }
      | "geom_hbond" -> { d with geom_hbond = List.map Geom_hbond.of_mmCIF lst }
      | "geom_torsion" -> { d with geom_torsion = List.map Geom_torsion.of_mmCIF lst }
      | "journal" -> { d with journal = List.map Journal.of_mmCIF lst }
      | "journal_index" -> { d with journal_index = List.map Journal_index.of_mmCIF lst }
      | "phasing" -> { d with phasing = List.map Phasing.of_mmCIF lst }
      | "phasing_averaging" -> { d with phasing_averaging = List.map Phasing_averaging.of_mmCIF lst }
      | "phasing_isomorphous" -> { d with phasing_isomorphous = List.map Phasing_isomorphous.of_mmCIF lst }
      | "phasing_MAD" -> { d with phasing_MAD = List.map Phasing_MAD.of_mmCIF lst }
      | "phasing_MAD_clust" -> { d with phasing_MAD_clust = List.map Phasing_MAD_clust.of_mmCIF lst }
      | "phasing_MAD_expt" -> { d with phasing_MAD_expt = List.map Phasing_MAD_expt.of_mmCIF lst }
      | "phasing_MAD_ratio" -> { d with phasing_MAD_ratio = List.map Phasing_MAD_ratio.of_mmCIF lst }
      | "phasing_MAD_set" -> { d with phasing_MAD_set = List.map Phasing_MAD_set.of_mmCIF lst }
      | "phasing_MIR" -> { d with phasing_MIR = List.map Phasing_MIR.of_mmCIF lst }
      | "phasing_MIR_der" -> { d with phasing_MIR_der = List.map Phasing_MIR_der.of_mmCIF lst }
      | "phasing_MIR_der_refln" -> { d with phasing_MIR_der_refln = List.map Phasing_MIR_der_refln.of_mmCIF lst }
      | "phasing_MIR_der_shell" -> { d with phasing_MIR_der_shell = List.map Phasing_MIR_der_shell.of_mmCIF lst }
      | "phasing_MIR_der_site" -> { d with phasing_MIR_der_site = List.map Phasing_MIR_der_site.of_mmCIF lst }
      | "phasing_MIR_shell" -> { d with phasing_MIR_shell = List.map Phasing_MIR_shell.of_mmCIF lst }
      | "phasing_set" -> { d with phasing_set = List.map Phasing_set.of_mmCIF lst }
      | "phasing_set_refln" -> { d with phasing_set_refln = List.map Phasing_set_refln.of_mmCIF lst }
      | "publ" -> { d with publ = List.map Publ.of_mmCIF lst }
      | "publ_author" -> { d with publ_author = List.map Publ_author.of_mmCIF lst }
      | "publ_body" -> { d with publ_body = List.map Publ_body.of_mmCIF lst }
      | "publ_manuscript_incl" -> { d with publ_manuscript_incl = List.map Publ_manuscript_incl.of_mmCIF lst }
      | "refine" -> { d with refine = List.map Refine.of_mmCIF lst }
      | "refine_analyze" -> { d with refine_analyze = List.map Refine_analyze.of_mmCIF lst }
      | "refine_B_iso" -> { d with refine_B_iso = List.map Refine_B_iso.of_mmCIF lst }
      | "refine_funct_minimized" -> { d with refine_funct_minimized = List.map Refine_funct_minimized.of_mmCIF lst }
      | "refine_hist" -> { d with refine_hist = List.map Refine_hist.of_mmCIF lst }
      | "refine_ls_restr" -> { d with refine_ls_restr = List.map Refine_ls_restr.of_mmCIF lst }
      | "refine_ls_restr_ncs" -> { d with refine_ls_restr_ncs = List.map Refine_ls_restr_ncs.of_mmCIF lst }
      | "refine_ls_restr_type" -> { d with refine_ls_restr_type = List.map Refine_ls_restr_type.of_mmCIF lst }
      | "refine_ls_shell" -> { d with refine_ls_shell = List.map Refine_ls_shell.of_mmCIF lst }
      | "refine_occupancy" -> { d with refine_occupancy = List.map Refine_occupancy.of_mmCIF lst }
      | "refln" -> { d with refln = List.map Refln.of_mmCIF lst }
      | "refln_sys_abs" -> { d with refln_sys_abs = List.map Refln_sys_abs.of_mmCIF lst }
      | "reflns" -> { d with reflns = List.map Reflns.of_mmCIF lst }
      | "reflns_scale" -> { d with reflns_scale = List.map Reflns_scale.of_mmCIF lst }
      | "reflns_shell" -> { d with reflns_shell = List.map Reflns_shell.of_mmCIF lst }
      | "software" -> { d with software = List.map Software.of_mmCIF lst }
      | "struct" -> { d with struct_ = List.map Struct.of_mmCIF lst }
      | "struct_asym" -> { d with struct_asym = List.map Struct_asym.of_mmCIF lst }
      | "struct_biol" -> { d with struct_biol = List.map Struct_biol.of_mmCIF lst }
      | "struct_biol_gen" -> { d with struct_biol_gen = List.map Struct_biol_gen.of_mmCIF lst }
      | "struct_biol_keywords" -> { d with struct_biol_keywords = List.map Struct_biol_keywords.of_mmCIF lst }
      | "struct_biol_view" -> { d with struct_biol_view = List.map Struct_biol_view.of_mmCIF lst }
      | "struct_conf" -> { d with struct_conf = List.map Struct_conf.of_mmCIF lst }
      | "struct_conf_type" -> { d with struct_conf_type = List.map Struct_conf_type.of_mmCIF lst }
      | "struct_conn" -> { d with struct_conn = List.map Struct_conn.of_mmCIF lst }
      | "struct_conn_type" -> { d with struct_conn_type = List.map Struct_conn_type.of_mmCIF lst }
      | "struct_keywords" -> { d with struct_keywords = List.map Struct_keywords.of_mmCIF lst }
      | "struct_mon_details" -> { d with struct_mon_details = List.map Struct_mon_details.of_mmCIF lst }
      | "struct_mon_nucl" -> { d with struct_mon_nucl = List.map Struct_mon_nucl.of_mmCIF lst }
      | "struct_mon_prot" -> { d with struct_mon_prot = List.map Struct_mon_prot.of_mmCIF lst }
      | "struct_mon_prot_cis" -> { d with struct_mon_prot_cis = List.map Struct_mon_prot_cis.of_mmCIF lst }
      | "struct_ncs_dom" -> { d with struct_ncs_dom = List.map Struct_ncs_dom.of_mmCIF lst }
      | "struct_ncs_dom_lim" -> { d with struct_ncs_dom_lim = List.map Struct_ncs_dom_lim.of_mmCIF lst }
      | "struct_ncs_ens" -> { d with struct_ncs_ens = List.map Struct_ncs_ens.of_mmCIF lst }
      | "struct_ncs_ens_gen" -> { d with struct_ncs_ens_gen = List.map Struct_ncs_ens_gen.of_mmCIF lst }
      | "struct_ncs_oper" -> { d with struct_ncs_oper = List.map Struct_ncs_oper.of_mmCIF lst }
      | "struct_ref" -> { d with struct_ref = List.map Struct_ref.of_mmCIF lst }
      | "struct_ref_seq" -> { d with struct_ref_seq = List.map Struct_ref_seq.of_mmCIF lst }
      | "struct_ref_seq_dif" -> { d with struct_ref_seq_dif = List.map Struct_ref_seq_dif.of_mmCIF lst }
      | "struct_sheet" -> { d with struct_sheet = List.map Struct_sheet.of_mmCIF lst }
      | "struct_sheet_hbond" -> { d with struct_sheet_hbond = List.map Struct_sheet_hbond.of_mmCIF lst }
      | "struct_sheet_order" -> { d with struct_sheet_order = List.map Struct_sheet_order.of_mmCIF lst }
      | "struct_sheet_range" -> { d with struct_sheet_range = List.map Struct_sheet_range.of_mmCIF lst }
      | "struct_sheet_topology" -> { d with struct_sheet_topology = List.map Struct_sheet_topology.of_mmCIF lst }
      | "struct_site" -> { d with struct_site = List.map Struct_site.of_mmCIF lst }
      | "struct_site_gen" -> { d with struct_site_gen = List.map Struct_site_gen.of_mmCIF lst }
      | "struct_site_keywords" -> { d with struct_site_keywords = List.map Struct_site_keywords.of_mmCIF lst }
      | "struct_site_view" -> { d with struct_site_view = List.map Struct_site_view.of_mmCIF lst }
      | "symmetry" -> { d with symmetry = List.map Symmetry.of_mmCIF lst }
      | "symmetry_equiv" -> { d with symmetry_equiv = List.map Symmetry_equiv.of_mmCIF lst }
      | "audit_link" -> { d with audit_link = List.map Audit_link.of_mmCIF lst }
      | "diffrn_reflns_class" -> { d with diffrn_reflns_class = List.map Diffrn_reflns_class.of_mmCIF lst }
      | "refine_ls_class" -> { d with refine_ls_class = List.map Refine_ls_class.of_mmCIF lst }
      | "reflns_class" -> { d with reflns_class = List.map Reflns_class.of_mmCIF lst }
      | "space_group" -> { d with space_group = List.map Space_group.of_mmCIF lst }
      | "space_group_symop" -> { d with space_group_symop = List.map Space_group_symop.of_mmCIF lst }
      | "valence_param" -> { d with valence_param = List.map Valence_param.of_mmCIF lst }
      | "valence_ref" -> { d with valence_ref = List.map Valence_ref.of_mmCIF lst }
      | "pdbx_audit" -> { d with pdbx_audit = List.map Pdbx_audit.of_mmCIF lst }
      | "pdbx_version" -> { d with pdbx_version = List.map Pdbx_version.of_mmCIF lst }
      | "pdbx_audit_author" -> { d with pdbx_audit_author = List.map Pdbx_audit_author.of_mmCIF lst }
      | "pdbx_database_message" -> { d with pdbx_database_message = List.map Pdbx_database_message.of_mmCIF lst }
      | "pdbx_database_PDB_obs_spr" -> { d with pdbx_database_PDB_obs_spr = List.map Pdbx_database_PDB_obs_spr.of_mmCIF lst }
      | "pdbx_database_proc" -> { d with pdbx_database_proc = List.map Pdbx_database_proc.of_mmCIF lst }
      | "pdbx_database_remark" -> { d with pdbx_database_remark = List.map Pdbx_database_remark.of_mmCIF lst }
      | "pdbx_database_status" -> { d with pdbx_database_status = List.map Pdbx_database_status.of_mmCIF lst }
      | "pdbx_entity_name" -> { d with pdbx_entity_name = List.map Pdbx_entity_name.of_mmCIF lst }
      | "pdbx_prerelease_seq" -> { d with pdbx_prerelease_seq = List.map Pdbx_prerelease_seq.of_mmCIF lst }
      | "pdbx_poly_seq_scheme" -> { d with pdbx_poly_seq_scheme = List.map Pdbx_poly_seq_scheme.of_mmCIF lst }
      | "pdbx_nonpoly_scheme" -> { d with pdbx_nonpoly_scheme = List.map Pdbx_nonpoly_scheme.of_mmCIF lst }
      | "pdbx_refine" -> { d with pdbx_refine = List.map Pdbx_refine.of_mmCIF lst }
      | "pdbx_struct_sheet_hbond" -> { d with pdbx_struct_sheet_hbond = List.map Pdbx_struct_sheet_hbond.of_mmCIF lst }
      | "pdbx_xplor_file" -> { d with pdbx_xplor_file = List.map Pdbx_xplor_file.of_mmCIF lst }
      | "pdbx_refine_aux_file" -> { d with pdbx_refine_aux_file = List.map Pdbx_refine_aux_file.of_mmCIF lst }
      | "pdbx_database_related" -> { d with pdbx_database_related = List.map Pdbx_database_related.of_mmCIF lst }
      | "pdbx_entity_assembly" -> { d with pdbx_entity_assembly = List.map Pdbx_entity_assembly.of_mmCIF lst }
      | "pdbx_exptl_crystal_grow_comp" -> { d with pdbx_exptl_crystal_grow_comp = List.map Pdbx_exptl_crystal_grow_comp.of_mmCIF lst }
      | "pdbx_exptl_crystal_grow_sol" -> { d with pdbx_exptl_crystal_grow_sol = List.map Pdbx_exptl_crystal_grow_sol.of_mmCIF lst }
      | "pdbx_exptl_crystal_cryo_treatment" -> { d with pdbx_exptl_crystal_cryo_treatment = List.map Pdbx_exptl_crystal_cryo_treatment.of_mmCIF lst }
      | "pdbx_refine_tls" -> { d with pdbx_refine_tls = List.map Pdbx_refine_tls.of_mmCIF lst }
      | "pdbx_refine_tls_group" -> { d with pdbx_refine_tls_group = List.map Pdbx_refine_tls_group.of_mmCIF lst }
      | "pdbx_contact_author" -> { d with pdbx_contact_author = List.map Pdbx_contact_author.of_mmCIF lst }
      | "pdbx_SG_project" -> { d with pdbx_SG_project = List.map Pdbx_SG_project.of_mmCIF lst }
      | "pdbx_atom_site_aniso_tls" -> { d with pdbx_atom_site_aniso_tls = List.map Pdbx_atom_site_aniso_tls.of_mmCIF lst }
      | "pdbx_nmr_details" -> { d with pdbx_nmr_details = List.map Pdbx_nmr_details.of_mmCIF lst }
      | "pdbx_nmr_sample_details" -> { d with pdbx_nmr_sample_details = List.map Pdbx_nmr_sample_details.of_mmCIF lst }
      | "pdbx_nmr_exptl_sample" -> { d with pdbx_nmr_exptl_sample = List.map Pdbx_nmr_exptl_sample.of_mmCIF lst }
      | "pdbx_nmr_exptl_sample_conditions" -> { d with pdbx_nmr_exptl_sample_conditions = List.map Pdbx_nmr_exptl_sample_conditions.of_mmCIF lst }
      | "pdbx_nmr_spectrometer" -> { d with pdbx_nmr_spectrometer = List.map Pdbx_nmr_spectrometer.of_mmCIF lst }
      | "pdbx_nmr_exptl" -> { d with pdbx_nmr_exptl = List.map Pdbx_nmr_exptl.of_mmCIF lst }
      | "pdbx_nmr_software" -> { d with pdbx_nmr_software = List.map Pdbx_nmr_software.of_mmCIF lst }
      | "pdbx_nmr_constraints" -> { d with pdbx_nmr_constraints = List.map Pdbx_nmr_constraints.of_mmCIF lst }
      | "pdbx_nmr_ensemble" -> { d with pdbx_nmr_ensemble = List.map Pdbx_nmr_ensemble.of_mmCIF lst }
      | "pdbx_nmr_ensemble_rms" -> { d with pdbx_nmr_ensemble_rms = List.map Pdbx_nmr_ensemble_rms.of_mmCIF lst }
      | "pdbx_nmr_representative" -> { d with pdbx_nmr_representative = List.map Pdbx_nmr_representative.of_mmCIF lst }
      | "pdbx_nmr_refine" -> { d with pdbx_nmr_refine = List.map Pdbx_nmr_refine.of_mmCIF lst }
      | "pdbx_nmr_force_constants" -> { d with pdbx_nmr_force_constants = List.map Pdbx_nmr_force_constants.of_mmCIF lst }
      | "ndb_struct_conf_na" -> { d with ndb_struct_conf_na = List.map Ndb_struct_conf_na.of_mmCIF lst }
      | "ndb_struct_feature_na" -> { d with ndb_struct_feature_na = List.map Ndb_struct_feature_na.of_mmCIF lst }
      | "ndb_struct_na_base_pair" -> { d with ndb_struct_na_base_pair = List.map Ndb_struct_na_base_pair.of_mmCIF lst }
      | "ndb_struct_na_base_pair_step" -> { d with ndb_struct_na_base_pair_step = List.map Ndb_struct_na_base_pair_step.of_mmCIF lst }
      | "ndb_original_ndb_coordinates" -> { d with ndb_original_ndb_coordinates = List.map Ndb_original_ndb_coordinates.of_mmCIF lst }
      | "pdbx_entity_nonpoly" -> { d with pdbx_entity_nonpoly = List.map Pdbx_entity_nonpoly.of_mmCIF lst }
      | "pdbx_phasing_dm" -> { d with pdbx_phasing_dm = List.map Pdbx_phasing_dm.of_mmCIF lst }
      | "pdbx_phasing_dm_shell" -> { d with pdbx_phasing_dm_shell = List.map Pdbx_phasing_dm_shell.of_mmCIF lst }
      | "pdbx_phasing_MAD_shell" -> { d with pdbx_phasing_MAD_shell = List.map Pdbx_phasing_MAD_shell.of_mmCIF lst }
      | "pdbx_phasing_MAD_set" -> { d with pdbx_phasing_MAD_set = List.map Pdbx_phasing_MAD_set.of_mmCIF lst }
      | "pdbx_phasing_MAD_set_shell" -> { d with pdbx_phasing_MAD_set_shell = List.map Pdbx_phasing_MAD_set_shell.of_mmCIF lst }
      | "pdbx_phasing_MAD_set_site" -> { d with pdbx_phasing_MAD_set_site = List.map Pdbx_phasing_MAD_set_site.of_mmCIF lst }
      | "pdbx_phasing_MR" -> { d with pdbx_phasing_MR = List.map Pdbx_phasing_MR.of_mmCIF lst }
      | "pdbx_refine_component" -> { d with pdbx_refine_component = List.map Pdbx_refine_component.of_mmCIF lst }
      | "pdbx_entity_prod_protocol" -> { d with pdbx_entity_prod_protocol = List.map Pdbx_entity_prod_protocol.of_mmCIF lst }
      | "pdbx_entity_src_gen_prod_other" -> { d with pdbx_entity_src_gen_prod_other = List.map Pdbx_entity_src_gen_prod_other.of_mmCIF lst }
      | "pdbx_entity_src_gen_prod_other_parameter" -> { d with pdbx_entity_src_gen_prod_other_parameter = List.map Pdbx_entity_src_gen_prod_other_parameter.of_mmCIF lst }
      | "pdbx_entity_src_gen_prod_pcr" -> { d with pdbx_entity_src_gen_prod_pcr = List.map Pdbx_entity_src_gen_prod_pcr.of_mmCIF lst }
      | "pdbx_entity_src_gen_prod_digest" -> { d with pdbx_entity_src_gen_prod_digest = List.map Pdbx_entity_src_gen_prod_digest.of_mmCIF lst }
      | "pdbx_entity_src_gen_clone" -> { d with pdbx_entity_src_gen_clone = List.map Pdbx_entity_src_gen_clone.of_mmCIF lst }
      | "pdbx_entity_src_gen_clone_ligation" -> { d with pdbx_entity_src_gen_clone_ligation = List.map Pdbx_entity_src_gen_clone_ligation.of_mmCIF lst }
      | "pdbx_entity_src_gen_clone_recombination" -> { d with pdbx_entity_src_gen_clone_recombination = List.map Pdbx_entity_src_gen_clone_recombination.of_mmCIF lst }
      | "pdbx_entity_src_gen_express" -> { d with pdbx_entity_src_gen_express = List.map Pdbx_entity_src_gen_express.of_mmCIF lst }
      | "pdbx_entity_src_gen_express_timepoint" -> { d with pdbx_entity_src_gen_express_timepoint = List.map Pdbx_entity_src_gen_express_timepoint.of_mmCIF lst }
      | "pdbx_entity_src_gen_lysis" -> { d with pdbx_entity_src_gen_lysis = List.map Pdbx_entity_src_gen_lysis.of_mmCIF lst }
      | "pdbx_entity_src_gen_refold" -> { d with pdbx_entity_src_gen_refold = List.map Pdbx_entity_src_gen_refold.of_mmCIF lst }
      | "pdbx_entity_src_gen_proteolysis" -> { d with pdbx_entity_src_gen_proteolysis = List.map Pdbx_entity_src_gen_proteolysis.of_mmCIF lst }
      | "pdbx_entity_src_gen_chrom" -> { d with pdbx_entity_src_gen_chrom = List.map Pdbx_entity_src_gen_chrom.of_mmCIF lst }
      | "pdbx_entity_src_gen_fract" -> { d with pdbx_entity_src_gen_fract = List.map Pdbx_entity_src_gen_fract.of_mmCIF lst }
      | "pdbx_entity_src_gen_pure" -> { d with pdbx_entity_src_gen_pure = List.map Pdbx_entity_src_gen_pure.of_mmCIF lst }
      | "pdbx_entity_src_gen_character" -> { d with pdbx_entity_src_gen_character = List.map Pdbx_entity_src_gen_character.of_mmCIF lst }
      | "pdbx_construct" -> { d with pdbx_construct = List.map Pdbx_construct.of_mmCIF lst }
      | "pdbx_construct_feature" -> { d with pdbx_construct_feature = List.map Pdbx_construct_feature.of_mmCIF lst }
      | "pdbx_robot_system" -> { d with pdbx_robot_system = List.map Pdbx_robot_system.of_mmCIF lst }
      | "pdbx_buffer" -> { d with pdbx_buffer = List.map Pdbx_buffer.of_mmCIF lst }
      | "pdbx_buffer_components" -> { d with pdbx_buffer_components = List.map Pdbx_buffer_components.of_mmCIF lst }
      | "pdbx_domain" -> { d with pdbx_domain = List.map Pdbx_domain.of_mmCIF lst }
      | "pdbx_domain_range" -> { d with pdbx_domain_range = List.map Pdbx_domain_range.of_mmCIF lst }
      | "pdbx_sequence_range" -> { d with pdbx_sequence_range = List.map Pdbx_sequence_range.of_mmCIF lst }
      | "pdbx_feature_entry" -> { d with pdbx_feature_entry = List.map Pdbx_feature_entry.of_mmCIF lst }
      | "pdbx_feature_domain" -> { d with pdbx_feature_domain = List.map Pdbx_feature_domain.of_mmCIF lst }
      | "pdbx_feature_sequence_range" -> { d with pdbx_feature_sequence_range = List.map Pdbx_feature_sequence_range.of_mmCIF lst }
      | "pdbx_feature_assembly" -> { d with pdbx_feature_assembly = List.map Pdbx_feature_assembly.of_mmCIF lst }
      | "pdbx_feature_monomer" -> { d with pdbx_feature_monomer = List.map Pdbx_feature_monomer.of_mmCIF lst }
      | "pdbx_exptl_pd" -> { d with pdbx_exptl_pd = List.map Pdbx_exptl_pd.of_mmCIF lst }
      | "pdbx_reflns_twin" -> { d with pdbx_reflns_twin = List.map Pdbx_reflns_twin.of_mmCIF lst }
      | "pdbx_struct_info" -> { d with pdbx_struct_info = List.map Pdbx_struct_info.of_mmCIF lst }
      | "pdbx_re_refinement" -> { d with pdbx_re_refinement = List.map Pdbx_re_refinement.of_mmCIF lst }
      | "pdbx_struct_assembly_prop" -> { d with pdbx_struct_assembly_prop = List.map Pdbx_struct_assembly_prop.of_mmCIF lst }
      | "pdbx_struct_ref_seq_feature" -> { d with pdbx_struct_ref_seq_feature = List.map Pdbx_struct_ref_seq_feature.of_mmCIF lst }
      | "pdbx_struct_ref_seq_feature_prop" -> { d with pdbx_struct_ref_seq_feature_prop = List.map Pdbx_struct_ref_seq_feature_prop.of_mmCIF lst }
      | "pdbx_struct_chem_comp_diagnostics" -> { d with pdbx_struct_chem_comp_diagnostics = List.map Pdbx_struct_chem_comp_diagnostics.of_mmCIF lst }
      | "pdbx_chem_comp_feature" -> { d with pdbx_chem_comp_feature = List.map Pdbx_chem_comp_feature.of_mmCIF lst }
      | "pdbx_coordinate_model" -> { d with pdbx_coordinate_model = List.map Pdbx_coordinate_model.of_mmCIF lst }
      | "pdbx_struct_chem_comp_feature" -> { d with pdbx_struct_chem_comp_feature = List.map Pdbx_struct_chem_comp_feature.of_mmCIF lst }
      | "pdbx_diffrn_reflns_shell" -> { d with pdbx_diffrn_reflns_shell = List.map Pdbx_diffrn_reflns_shell.of_mmCIF lst }
      | "pdbx_bond_distance_limits" -> { d with pdbx_bond_distance_limits = List.map Pdbx_bond_distance_limits.of_mmCIF lst }
      | "pdbx_soln_scatter" -> { d with pdbx_soln_scatter = List.map Pdbx_soln_scatter.of_mmCIF lst }
      | "pdbx_soln_scatter_model" -> { d with pdbx_soln_scatter_model = List.map Pdbx_soln_scatter_model.of_mmCIF lst }
      | "pdbx_chem_comp_descriptor" -> { d with pdbx_chem_comp_descriptor = List.map Pdbx_chem_comp_descriptor.of_mmCIF lst }
      | "pdbx_chem_comp_identifier" -> { d with pdbx_chem_comp_identifier = List.map Pdbx_chem_comp_identifier.of_mmCIF lst }
      | "pdbx_chem_comp_import" -> { d with pdbx_chem_comp_import = List.map Pdbx_chem_comp_import.of_mmCIF lst }
      | "pdbx_chem_comp_atom_edit" -> { d with pdbx_chem_comp_atom_edit = List.map Pdbx_chem_comp_atom_edit.of_mmCIF lst }
      | "pdbx_chem_comp_bond_edit" -> { d with pdbx_chem_comp_bond_edit = List.map Pdbx_chem_comp_bond_edit.of_mmCIF lst }
      | "pdbx_chem_comp_audit" -> { d with pdbx_chem_comp_audit = List.map Pdbx_chem_comp_audit.of_mmCIF lst }
      | "pdbx_validate_close_contact" -> { d with pdbx_validate_close_contact = List.map Pdbx_validate_close_contact.of_mmCIF lst }
      | "pdbx_validate_symm_contact" -> { d with pdbx_validate_symm_contact = List.map Pdbx_validate_symm_contact.of_mmCIF lst }
      | "pdbx_validate_rmsd_bond" -> { d with pdbx_validate_rmsd_bond = List.map Pdbx_validate_rmsd_bond.of_mmCIF lst }
      | "pdbx_validate_rmsd_angle" -> { d with pdbx_validate_rmsd_angle = List.map Pdbx_validate_rmsd_angle.of_mmCIF lst }
      | "pdbx_validate_torsion" -> { d with pdbx_validate_torsion = List.map Pdbx_validate_torsion.of_mmCIF lst }
      | "pdbx_validate_peptide_omega" -> { d with pdbx_validate_peptide_omega = List.map Pdbx_validate_peptide_omega.of_mmCIF lst }
      | "pdbx_validate_chiral" -> { d with pdbx_validate_chiral = List.map Pdbx_validate_chiral.of_mmCIF lst }
      | "pdbx_validate_planes" -> { d with pdbx_validate_planes = List.map Pdbx_validate_planes.of_mmCIF lst }
      | "pdbx_validate_planes_atom" -> { d with pdbx_validate_planes_atom = List.map Pdbx_validate_planes_atom.of_mmCIF lst }
      | "pdbx_validate_main_chain_plane" -> { d with pdbx_validate_main_chain_plane = List.map Pdbx_validate_main_chain_plane.of_mmCIF lst }
      | "pdbx_struct_conn_angle" -> { d with pdbx_struct_conn_angle = List.map Pdbx_struct_conn_angle.of_mmCIF lst }
      | "pdbx_unobs_or_zero_occ_residues" -> { d with pdbx_unobs_or_zero_occ_residues = List.map Pdbx_unobs_or_zero_occ_residues.of_mmCIF lst }
      | "pdbx_unobs_or_zero_occ_atoms" -> { d with pdbx_unobs_or_zero_occ_atoms = List.map Pdbx_unobs_or_zero_occ_atoms.of_mmCIF lst }
      | "pdbx_entry_details" -> { d with pdbx_entry_details = List.map Pdbx_entry_details.of_mmCIF lst }
      | "pdbx_struct_mod_residue" -> { d with pdbx_struct_mod_residue = List.map Pdbx_struct_mod_residue.of_mmCIF lst }
      | "pdbx_struct_ref_seq_insertion" -> { d with pdbx_struct_ref_seq_insertion = List.map Pdbx_struct_ref_seq_insertion.of_mmCIF lst }
      | "pdbx_struct_ref_seq_deletion" -> { d with pdbx_struct_ref_seq_deletion = List.map Pdbx_struct_ref_seq_deletion.of_mmCIF lst }
      | "pdbx_remediation_atom_site_mapping" -> { d with pdbx_remediation_atom_site_mapping = List.map Pdbx_remediation_atom_site_mapping.of_mmCIF lst }
      | "pdbx_validate_polymer_linkage" -> { d with pdbx_validate_polymer_linkage = List.map Pdbx_validate_polymer_linkage.of_mmCIF lst }
      | "pdbx_helical_symmetry" -> { d with pdbx_helical_symmetry = List.map Pdbx_helical_symmetry.of_mmCIF lst }
      | "pdbx_point_symmetry" -> { d with pdbx_point_symmetry = List.map Pdbx_point_symmetry.of_mmCIF lst }
      | "pdbx_struct_entity_inst" -> { d with pdbx_struct_entity_inst = List.map Pdbx_struct_entity_inst.of_mmCIF lst }
      | "pdbx_struct_oper_list" -> { d with pdbx_struct_oper_list = List.map Pdbx_struct_oper_list.of_mmCIF lst }
      | "pdbx_struct_assembly" -> { d with pdbx_struct_assembly = List.map Pdbx_struct_assembly.of_mmCIF lst }
      | "pdbx_struct_assembly_gen" -> { d with pdbx_struct_assembly_gen = List.map Pdbx_struct_assembly_gen.of_mmCIF lst }
      | "pdbx_struct_asym_gen" -> { d with pdbx_struct_asym_gen = List.map Pdbx_struct_asym_gen.of_mmCIF lst }
      | "pdbx_struct_msym_gen" -> { d with pdbx_struct_msym_gen = List.map Pdbx_struct_msym_gen.of_mmCIF lst }
      | "pdbx_struct_legacy_oper_list" -> { d with pdbx_struct_legacy_oper_list = List.map Pdbx_struct_legacy_oper_list.of_mmCIF lst }
      | "pdbx_chem_comp_atom_feature" -> { d with pdbx_chem_comp_atom_feature = List.map Pdbx_chem_comp_atom_feature.of_mmCIF lst }
      | "pdbx_reference_molecule_family" -> { d with pdbx_reference_molecule_family = List.map Pdbx_reference_molecule_family.of_mmCIF lst }
      | "pdbx_reference_molecule_list" -> { d with pdbx_reference_molecule_list = List.map Pdbx_reference_molecule_list.of_mmCIF lst }
      | "pdbx_reference_molecule" -> { d with pdbx_reference_molecule = List.map Pdbx_reference_molecule.of_mmCIF lst }
      | "pdbx_reference_entity_list" -> { d with pdbx_reference_entity_list = List.map Pdbx_reference_entity_list.of_mmCIF lst }
      | "pdbx_reference_entity_nonpoly" -> { d with pdbx_reference_entity_nonpoly = List.map Pdbx_reference_entity_nonpoly.of_mmCIF lst }
      | "pdbx_reference_entity_link" -> { d with pdbx_reference_entity_link = List.map Pdbx_reference_entity_link.of_mmCIF lst }
      | "pdbx_reference_entity_poly_link" -> { d with pdbx_reference_entity_poly_link = List.map Pdbx_reference_entity_poly_link.of_mmCIF lst }
      | "pdbx_reference_entity_poly" -> { d with pdbx_reference_entity_poly = List.map Pdbx_reference_entity_poly.of_mmCIF lst }
      | "pdbx_reference_entity_poly_seq" -> { d with pdbx_reference_entity_poly_seq = List.map Pdbx_reference_entity_poly_seq.of_mmCIF lst }
      | "pdbx_reference_entity_sequence" -> { d with pdbx_reference_entity_sequence = List.map Pdbx_reference_entity_sequence.of_mmCIF lst }
      | "pdbx_reference_entity_src_nat" -> { d with pdbx_reference_entity_src_nat = List.map Pdbx_reference_entity_src_nat.of_mmCIF lst }
      | "pdbx_reference_molecule_details" -> { d with pdbx_reference_molecule_details = List.map Pdbx_reference_molecule_details.of_mmCIF lst }
      | "pdbx_reference_molecule_synonyms" -> { d with pdbx_reference_molecule_synonyms = List.map Pdbx_reference_molecule_synonyms.of_mmCIF lst }
      | "pdbx_reference_entity_subcomponents" -> { d with pdbx_reference_entity_subcomponents = List.map Pdbx_reference_entity_subcomponents.of_mmCIF lst }
      | "pdbx_reference_molecule_annotation" -> { d with pdbx_reference_molecule_annotation = List.map Pdbx_reference_molecule_annotation.of_mmCIF lst }
      | "pdbx_reference_molecule_features" -> { d with pdbx_reference_molecule_features = List.map Pdbx_reference_molecule_features.of_mmCIF lst }
      | "pdbx_reference_molecule_related_structures" -> { d with pdbx_reference_molecule_related_structures = List.map Pdbx_reference_molecule_related_structures.of_mmCIF lst }
      | "pdbx_struct_group_list" -> { d with pdbx_struct_group_list = List.map Pdbx_struct_group_list.of_mmCIF lst }
      | "pdbx_struct_group_components" -> { d with pdbx_struct_group_components = List.map Pdbx_struct_group_components.of_mmCIF lst }
      | "pdbx_struct_group_component_range" -> { d with pdbx_struct_group_component_range = List.map Pdbx_struct_group_component_range.of_mmCIF lst }
      | "pdbx_prd_audit" -> { d with pdbx_prd_audit = List.map Pdbx_prd_audit.of_mmCIF lst }
      | "pdbx_family_prd_audit" -> { d with pdbx_family_prd_audit = List.map Pdbx_family_prd_audit.of_mmCIF lst }
      | "pdbx_molecule" -> { d with pdbx_molecule = List.map Pdbx_molecule.of_mmCIF lst }
      | "pdbx_molecule_features" -> { d with pdbx_molecule_features = List.map Pdbx_molecule_features.of_mmCIF lst }
      | "pdbx_family_group_index" -> { d with pdbx_family_group_index = List.map Pdbx_family_group_index.of_mmCIF lst }
      | "pdbx_distant_solvent_atoms" -> { d with pdbx_distant_solvent_atoms = List.map Pdbx_distant_solvent_atoms.of_mmCIF lst }
      | "pdbx_struct_special_symmetry" -> { d with pdbx_struct_special_symmetry = List.map Pdbx_struct_special_symmetry.of_mmCIF lst }
      | "pdbx_reference_publication_list" -> { d with pdbx_reference_publication_list = List.map Pdbx_reference_publication_list.of_mmCIF lst }
      | "pdbx_nmr_assigned_chem_shift_list" -> { d with pdbx_nmr_assigned_chem_shift_list = List.map Pdbx_nmr_assigned_chem_shift_list.of_mmCIF lst }
      | "pdbx_nmr_chem_shift_experiment" -> { d with pdbx_nmr_chem_shift_experiment = List.map Pdbx_nmr_chem_shift_experiment.of_mmCIF lst }
      | "pdbx_nmr_chem_shift_ref" -> { d with pdbx_nmr_chem_shift_ref = List.map Pdbx_nmr_chem_shift_ref.of_mmCIF lst }
      | "pdbx_nmr_chem_shift_reference" -> { d with pdbx_nmr_chem_shift_reference = List.map Pdbx_nmr_chem_shift_reference.of_mmCIF lst }
      | "pdbx_nmr_chem_shift_software" -> { d with pdbx_nmr_chem_shift_software = List.map Pdbx_nmr_chem_shift_software.of_mmCIF lst }
      | "pdbx_nmr_constraint_file" -> { d with pdbx_nmr_constraint_file = List.map Pdbx_nmr_constraint_file.of_mmCIF lst }
      | "pdbx_nmr_software_task" -> { d with pdbx_nmr_software_task = List.map Pdbx_nmr_software_task.of_mmCIF lst }
      | "pdbx_nmr_spectral_dim" -> { d with pdbx_nmr_spectral_dim = List.map Pdbx_nmr_spectral_dim.of_mmCIF lst }
      | "pdbx_nmr_spectral_peak_list" -> { d with pdbx_nmr_spectral_peak_list = List.map Pdbx_nmr_spectral_peak_list.of_mmCIF lst }
      | "pdbx_nmr_spectral_peak_software" -> { d with pdbx_nmr_spectral_peak_software = List.map Pdbx_nmr_spectral_peak_software.of_mmCIF lst }
      | "pdbx_nmr_systematic_chem_shift_offset" -> { d with pdbx_nmr_systematic_chem_shift_offset = List.map Pdbx_nmr_systematic_chem_shift_offset.of_mmCIF lst }
      | "pdbx_nmr_upload" -> { d with pdbx_nmr_upload = List.map Pdbx_nmr_upload.of_mmCIF lst }
      | "pdbx_audit_support" -> { d with pdbx_audit_support = List.map Pdbx_audit_support.of_mmCIF lst }
      | "pdbx_chem_comp_subcomponent_struct_conn" -> { d with pdbx_chem_comp_subcomponent_struct_conn = List.map Pdbx_chem_comp_subcomponent_struct_conn.of_mmCIF lst }
      | "pdbx_chem_comp_subcomponent_entity_list" -> { d with pdbx_chem_comp_subcomponent_entity_list = List.map Pdbx_chem_comp_subcomponent_entity_list.of_mmCIF lst }
      | "entity_src_nat" -> { d with entity_src_nat = List.map Entity_src_nat.of_mmCIF lst }
      | "entity_src_gen" -> { d with entity_src_gen = List.map Entity_src_gen.of_mmCIF lst }
      | "pdbx_entity_src_syn" -> { d with pdbx_entity_src_syn = List.map Pdbx_entity_src_syn.of_mmCIF lst }
      | "pdbx_entity_poly_comp_link_list" -> { d with pdbx_entity_poly_comp_link_list = List.map Pdbx_entity_poly_comp_link_list.of_mmCIF lst }
      | "pdbx_linked_entity" -> { d with pdbx_linked_entity = List.map Pdbx_linked_entity.of_mmCIF lst }
      | "pdbx_linked_entity_instance_list" -> { d with pdbx_linked_entity_instance_list = List.map Pdbx_linked_entity_instance_list.of_mmCIF lst }
      | "pdbx_linked_entity_list" -> { d with pdbx_linked_entity_list = List.map Pdbx_linked_entity_list.of_mmCIF lst }
      | "pdbx_linked_entity_link_list" -> { d with pdbx_linked_entity_link_list = List.map Pdbx_linked_entity_link_list.of_mmCIF lst }
      | "pdbx_entity_descriptor" -> { d with pdbx_entity_descriptor = List.map Pdbx_entity_descriptor.of_mmCIF lst }
      | "pdbx_reference_linked_entity" -> { d with pdbx_reference_linked_entity = List.map Pdbx_reference_linked_entity.of_mmCIF lst }
      | "pdbx_reference_linked_entity_comp_list" -> { d with pdbx_reference_linked_entity_comp_list = List.map Pdbx_reference_linked_entity_comp_list.of_mmCIF lst }
      | "pdbx_reference_linked_entity_comp_link" -> { d with pdbx_reference_linked_entity_comp_link = List.map Pdbx_reference_linked_entity_comp_link.of_mmCIF lst }
      | "pdbx_reference_linked_entity_link" -> { d with pdbx_reference_linked_entity_link = List.map Pdbx_reference_linked_entity_link.of_mmCIF lst }
      | "pdbx_related_exp_data_set" -> { d with pdbx_related_exp_data_set = List.map Pdbx_related_exp_data_set.of_mmCIF lst }
      | "pdbx_database_status_history" -> { d with pdbx_database_status_history = List.map Pdbx_database_status_history.of_mmCIF lst }
      | "em_assembly" -> { d with em_assembly = List.map Em_assembly.of_mmCIF lst }
      | "em_entity_assembly" -> { d with em_entity_assembly = List.map Em_entity_assembly.of_mmCIF lst }
      | "em_virus_entity" -> { d with em_virus_entity = List.map Em_virus_entity.of_mmCIF lst }
      | "em_sample_preparation" -> { d with em_sample_preparation = List.map Em_sample_preparation.of_mmCIF lst }
      | "em_sample_support" -> { d with em_sample_support = List.map Em_sample_support.of_mmCIF lst }
      | "em_buffer" -> { d with em_buffer = List.map Em_buffer.of_mmCIF lst }
      | "em_vitrification" -> { d with em_vitrification = List.map Em_vitrification.of_mmCIF lst }
      | "em_imaging" -> { d with em_imaging = List.map Em_imaging.of_mmCIF lst }
      | "em_detector" -> { d with em_detector = List.map Em_detector.of_mmCIF lst }
      | "em_image_scans" -> { d with em_image_scans = List.map Em_image_scans.of_mmCIF lst }
      | "em_2d_projection_selection" -> { d with em_2d_projection_selection = List.map Em_2d_projection_selection.of_mmCIF lst }
      | "em_3d_reconstruction" -> { d with em_3d_reconstruction = List.map Em_3d_reconstruction.of_mmCIF lst }
      | "em_3d_fitting" -> { d with em_3d_fitting = List.map Em_3d_fitting.of_mmCIF lst }
      | "em_3d_fitting_list" -> { d with em_3d_fitting_list = List.map Em_3d_fitting_list.of_mmCIF lst }
      | "em_helical_entity" -> { d with em_helical_entity = List.map Em_helical_entity.of_mmCIF lst }
      | "em_experiment" -> { d with em_experiment = List.map Em_experiment.of_mmCIF lst }
      | "em_single_particle_entity" -> { d with em_single_particle_entity = List.map Em_single_particle_entity.of_mmCIF lst }
      | "em_admin" -> { d with em_admin = List.map Em_admin.of_mmCIF lst }
      | "em_author_list" -> { d with em_author_list = List.map Em_author_list.of_mmCIF lst }
      | "em_db_reference" -> { d with em_db_reference = List.map Em_db_reference.of_mmCIF lst }
      | "em_db_reference_auxiliary" -> { d with em_db_reference_auxiliary = List.map Em_db_reference_auxiliary.of_mmCIF lst }
      | "em_depui" -> { d with em_depui = List.map Em_depui.of_mmCIF lst }
      | "em_obsolete" -> { d with em_obsolete = List.map Em_obsolete.of_mmCIF lst }
      | "em_supersede" -> { d with em_supersede = List.map Em_supersede.of_mmCIF lst }
      | "em_entity_assembly_molwt" -> { d with em_entity_assembly_molwt = List.map Em_entity_assembly_molwt.of_mmCIF lst }
      | "em_entity_assembly_naturalsource" -> { d with em_entity_assembly_naturalsource = List.map Em_entity_assembly_naturalsource.of_mmCIF lst }
      | "em_entity_assembly_recombinant" -> { d with em_entity_assembly_recombinant = List.map Em_entity_assembly_recombinant.of_mmCIF lst }
      | "em_virus_natural_host" -> { d with em_virus_natural_host = List.map Em_virus_natural_host.of_mmCIF lst }
      | "em_virus_shell" -> { d with em_virus_shell = List.map Em_virus_shell.of_mmCIF lst }
      | "em_specimen" -> { d with em_specimen = List.map Em_specimen.of_mmCIF lst }
      | "em_embedding" -> { d with em_embedding = List.map Em_embedding.of_mmCIF lst }
      | "em_fiducial_markers" -> { d with em_fiducial_markers = List.map Em_fiducial_markers.of_mmCIF lst }
      | "em_focused_ion_beam" -> { d with em_focused_ion_beam = List.map Em_focused_ion_beam.of_mmCIF lst }
      | "em_grid_pretreatment" -> { d with em_grid_pretreatment = List.map Em_grid_pretreatment.of_mmCIF lst }
      | "em_ultramicrotomy" -> { d with em_ultramicrotomy = List.map Em_ultramicrotomy.of_mmCIF lst }
      | "em_high_pressure_freezing" -> { d with em_high_pressure_freezing = List.map Em_high_pressure_freezing.of_mmCIF lst }
      | "em_shadowing" -> { d with em_shadowing = List.map Em_shadowing.of_mmCIF lst }
      | "em_tomography_specimen" -> { d with em_tomography_specimen = List.map Em_tomography_specimen.of_mmCIF lst }
      | "em_crystal_formation" -> { d with em_crystal_formation = List.map Em_crystal_formation.of_mmCIF lst }
      | "em_staining" -> { d with em_staining = List.map Em_staining.of_mmCIF lst }
      | "em_support_film" -> { d with em_support_film = List.map Em_support_film.of_mmCIF lst }
      | "em_buffer_component" -> { d with em_buffer_component = List.map Em_buffer_component.of_mmCIF lst }
      | "em_diffraction" -> { d with em_diffraction = List.map Em_diffraction.of_mmCIF lst }
      | "em_diffraction_shell" -> { d with em_diffraction_shell = List.map Em_diffraction_shell.of_mmCIF lst }
      | "em_diffraction_stats" -> { d with em_diffraction_stats = List.map Em_diffraction_stats.of_mmCIF lst }
      | "em_tomography" -> { d with em_tomography = List.map Em_tomography.of_mmCIF lst }
      | "em_image_recording" -> { d with em_image_recording = List.map Em_image_recording.of_mmCIF lst }
      | "em_imaging_optics" -> { d with em_imaging_optics = List.map Em_imaging_optics.of_mmCIF lst }
      | "em_final_classification" -> { d with em_final_classification = List.map Em_final_classification.of_mmCIF lst }
      | "em_start_model" -> { d with em_start_model = List.map Em_start_model.of_mmCIF lst }
      | "em_software" -> { d with em_software = List.map Em_software.of_mmCIF lst }
      | "em_euler_angle_assignment" -> { d with em_euler_angle_assignment = List.map Em_euler_angle_assignment.of_mmCIF lst }
      | "em_ctf_correction" -> { d with em_ctf_correction = List.map Em_ctf_correction.of_mmCIF lst }
      | "em_volume_selection" -> { d with em_volume_selection = List.map Em_volume_selection.of_mmCIF lst }
      | "em_3d_crystal_entity" -> { d with em_3d_crystal_entity = List.map Em_3d_crystal_entity.of_mmCIF lst }
      | "em_2d_crystal_entity" -> { d with em_2d_crystal_entity = List.map Em_2d_crystal_entity.of_mmCIF lst }
      | "em_image_processing" -> { d with em_image_processing = List.map Em_image_processing.of_mmCIF lst }
      | "em_particle_selection" -> { d with em_particle_selection = List.map Em_particle_selection.of_mmCIF lst }
      | "em_map" -> { d with em_map = List.map Em_map.of_mmCIF lst }
      | "em_fsc_curve" -> { d with em_fsc_curve = List.map Em_fsc_curve.of_mmCIF lst }
      | "em_interpret_figure" -> { d with em_interpret_figure = List.map Em_interpret_figure.of_mmCIF lst }
      | "em_layer_lines" -> { d with em_layer_lines = List.map Em_layer_lines.of_mmCIF lst }
      | "em_structure_factors" -> { d with em_structure_factors = List.map Em_structure_factors.of_mmCIF lst }
      | "em_depositor_info" -> { d with em_depositor_info = List.map Em_depositor_info.of_mmCIF lst }
      | "em_map_depositor_info" -> { d with em_map_depositor_info = List.map Em_map_depositor_info.of_mmCIF lst }
      | "em_mask_depositor_info" -> { d with em_mask_depositor_info = List.map Em_mask_depositor_info.of_mmCIF lst }
      | "em_figure_depositor_info" -> { d with em_figure_depositor_info = List.map Em_figure_depositor_info.of_mmCIF lst }
      | "em_layer_lines_depositor_info" -> { d with em_layer_lines_depositor_info = List.map Em_layer_lines_depositor_info.of_mmCIF lst }
      | "em_structure_factors_depositor_info" -> { d with em_structure_factors_depositor_info = List.map Em_structure_factors_depositor_info.of_mmCIF lst }
      | "pdbx_seq_map_depositor_info" -> { d with pdbx_seq_map_depositor_info = List.map Pdbx_seq_map_depositor_info.of_mmCIF lst }
      | "pdbx_chem_comp_depositor_info" -> { d with pdbx_chem_comp_depositor_info = List.map Pdbx_chem_comp_depositor_info.of_mmCIF lst }
      | "pdbx_struct_ref_seq_depositor_info" -> { d with pdbx_struct_ref_seq_depositor_info = List.map Pdbx_struct_ref_seq_depositor_info.of_mmCIF lst }
      | "pdbx_struct_ref_seq_dif_depositor_info" -> { d with pdbx_struct_ref_seq_dif_depositor_info = List.map Pdbx_struct_ref_seq_dif_depositor_info.of_mmCIF lst }
      | "pdbx_struct_assembly_prop_depositor_info" -> { d with pdbx_struct_assembly_prop_depositor_info = List.map Pdbx_struct_assembly_prop_depositor_info.of_mmCIF lst }
      | "pdbx_struct_assembly_depositor_info" -> { d with pdbx_struct_assembly_depositor_info = List.map Pdbx_struct_assembly_depositor_info.of_mmCIF lst }
      | "pdbx_struct_assembly_gen_depositor_info" -> { d with pdbx_struct_assembly_gen_depositor_info = List.map Pdbx_struct_assembly_gen_depositor_info.of_mmCIF lst }
      | "pdbx_struct_oper_list_depositor_info" -> { d with pdbx_struct_oper_list_depositor_info = List.map Pdbx_struct_oper_list_depositor_info.of_mmCIF lst }
      | "pdbx_point_symmetry_depositor_info" -> { d with pdbx_point_symmetry_depositor_info = List.map Pdbx_point_symmetry_depositor_info.of_mmCIF lst }
      | "pdbx_helical_symmetry_depositor_info" -> { d with pdbx_helical_symmetry_depositor_info = List.map Pdbx_helical_symmetry_depositor_info.of_mmCIF lst }
      | "pdbx_struct_assembly_auth_evidence_depositor_info" -> { d with pdbx_struct_assembly_auth_evidence_depositor_info = List.map Pdbx_struct_assembly_auth_evidence_depositor_info.of_mmCIF lst }
      | "pdbx_solvent_atom_site_mapping" -> { d with pdbx_solvent_atom_site_mapping = List.map Pdbx_solvent_atom_site_mapping.of_mmCIF lst }
      | "pdbx_molecule_features_depositor_info" -> { d with pdbx_molecule_features_depositor_info = List.map Pdbx_molecule_features_depositor_info.of_mmCIF lst }
      | "pdbx_chem_comp_instance_depositor_info" -> { d with pdbx_chem_comp_instance_depositor_info = List.map Pdbx_chem_comp_instance_depositor_info.of_mmCIF lst }
      | "pdbx_depui_status_flags" -> { d with pdbx_depui_status_flags = List.map Pdbx_depui_status_flags.of_mmCIF lst }
      | "pdbx_depui_upload" -> { d with pdbx_depui_upload = List.map Pdbx_depui_upload.of_mmCIF lst }
      | "pdbx_depui_validation_status_flags" -> { d with pdbx_depui_validation_status_flags = List.map Pdbx_depui_validation_status_flags.of_mmCIF lst }
      | "pdbx_chem_comp_upload_depositor_info" -> { d with pdbx_chem_comp_upload_depositor_info = List.map Pdbx_chem_comp_upload_depositor_info.of_mmCIF lst }
      | "pdbx_depui_entity_status_flags" -> { d with pdbx_depui_entity_status_flags = List.map Pdbx_depui_entity_status_flags.of_mmCIF lst }
      | "pdbx_depui_entity_features" -> { d with pdbx_depui_entity_features = List.map Pdbx_depui_entity_features.of_mmCIF lst }
      | "pdbx_deposition_message_info" -> { d with pdbx_deposition_message_info = List.map Pdbx_deposition_message_info.of_mmCIF lst }
      | "pdbx_deposition_message_file_reference" -> { d with pdbx_deposition_message_file_reference = List.map Pdbx_deposition_message_file_reference.of_mmCIF lst }
      | "pdbx_depui_entry_details" -> { d with pdbx_depui_entry_details = List.map Pdbx_depui_entry_details.of_mmCIF lst }
      | "pdbx_data_processing_status" -> { d with pdbx_data_processing_status = List.map Pdbx_data_processing_status.of_mmCIF lst }
      | "pdbx_entity_instance_feature" -> { d with pdbx_entity_instance_feature = List.map Pdbx_entity_instance_feature.of_mmCIF lst }
      | "pdbx_entity_src_gen_depositor_info" -> { d with pdbx_entity_src_gen_depositor_info = List.map Pdbx_entity_src_gen_depositor_info.of_mmCIF lst }
      | "pdbx_chem_comp_model" -> { d with pdbx_chem_comp_model = List.map Pdbx_chem_comp_model.of_mmCIF lst }
      | "pdbx_chem_comp_model_atom" -> { d with pdbx_chem_comp_model_atom = List.map Pdbx_chem_comp_model_atom.of_mmCIF lst }
      | "pdbx_chem_comp_model_bond" -> { d with pdbx_chem_comp_model_bond = List.map Pdbx_chem_comp_model_bond.of_mmCIF lst }
      | "pdbx_chem_comp_model_feature" -> { d with pdbx_chem_comp_model_feature = List.map Pdbx_chem_comp_model_feature.of_mmCIF lst }
      | "pdbx_chem_comp_model_descriptor" -> { d with pdbx_chem_comp_model_descriptor = List.map Pdbx_chem_comp_model_descriptor.of_mmCIF lst }
      | "pdbx_chem_comp_model_audit" -> { d with pdbx_chem_comp_model_audit = List.map Pdbx_chem_comp_model_audit.of_mmCIF lst }
      | "pdbx_chem_comp_model_reference" -> { d with pdbx_chem_comp_model_reference = List.map Pdbx_chem_comp_model_reference.of_mmCIF lst }
      | "pdbx_view_category_group" -> { d with pdbx_view_category_group = List.map Pdbx_view_category_group.of_mmCIF lst }
      | "pdbx_view_category" -> { d with pdbx_view_category = List.map Pdbx_view_category.of_mmCIF lst }
      | "pdbx_view_item" -> { d with pdbx_view_item = List.map Pdbx_view_item.of_mmCIF lst }
      | "pdbx_coord" -> { d with pdbx_coord = List.map Pdbx_coord.of_mmCIF lst }
      | "pdbx_connect" -> { d with pdbx_connect = List.map Pdbx_connect.of_mmCIF lst }
      | "pdbx_connect_type" -> { d with pdbx_connect_type = List.map Pdbx_connect_type.of_mmCIF lst }
      | "pdbx_connect_modification" -> { d with pdbx_connect_modification = List.map Pdbx_connect_modification.of_mmCIF lst }
      | "pdbx_connect_atom" -> { d with pdbx_connect_atom = List.map Pdbx_connect_atom.of_mmCIF lst }
      | "pdbx_database_PDB_master" -> { d with pdbx_database_PDB_master = List.map Pdbx_database_PDB_master.of_mmCIF lst }
      | "pdbx_database_pdb_omit" -> { d with pdbx_database_pdb_omit = List.map Pdbx_database_pdb_omit.of_mmCIF lst }
      | "pdbx_dbref" -> { d with pdbx_dbref = List.map Pdbx_dbref.of_mmCIF lst }
      | "pdbx_drug_info" -> { d with pdbx_drug_info = List.map Pdbx_drug_info.of_mmCIF lst }
      | "pdbx_inhibitor_info" -> { d with pdbx_inhibitor_info = List.map Pdbx_inhibitor_info.of_mmCIF lst }
      | "pdbx_ion_info" -> { d with pdbx_ion_info = List.map Pdbx_ion_info.of_mmCIF lst }
      | "pdbx_hybrid" -> { d with pdbx_hybrid = List.map Pdbx_hybrid.of_mmCIF lst }
      | "pdbx_na_strand_info" -> { d with pdbx_na_strand_info = List.map Pdbx_na_strand_info.of_mmCIF lst }
      | "pdbx_nonstandard_list" -> { d with pdbx_nonstandard_list = List.map Pdbx_nonstandard_list.of_mmCIF lst }
      | "pdbx_pdb_compnd" -> { d with pdbx_pdb_compnd = List.map Pdbx_pdb_compnd.of_mmCIF lst }
      | "pdbx_pdb_source" -> { d with pdbx_pdb_source = List.map Pdbx_pdb_source.of_mmCIF lst }
      | "pdbx_protein_info" -> { d with pdbx_protein_info = List.map Pdbx_protein_info.of_mmCIF lst }
      | "pdbx_solvent_info" -> { d with pdbx_solvent_info = List.map Pdbx_solvent_info.of_mmCIF lst }
      | "pdbx_source" -> { d with pdbx_source = List.map Pdbx_source.of_mmCIF lst }
      | "pdbx_struct_biol_func" -> { d with pdbx_struct_biol_func = List.map Pdbx_struct_biol_func.of_mmCIF lst }
      | "pdbx_struct_pack_gen" -> { d with pdbx_struct_pack_gen = List.map Pdbx_struct_pack_gen.of_mmCIF lst }
      | "pdbx_trna_info" -> { d with pdbx_trna_info = List.map Pdbx_trna_info.of_mmCIF lst }
      | "pdbx_unpair" -> { d with pdbx_unpair = List.map Pdbx_unpair.of_mmCIF lst }
      | "pdbx_refine_ls_restr_ncs" -> { d with pdbx_refine_ls_restr_ncs = List.map Pdbx_refine_ls_restr_ncs.of_mmCIF lst }
      | "pdbx_struct_ncs_virus_gen" -> { d with pdbx_struct_ncs_virus_gen = List.map Pdbx_struct_ncs_virus_gen.of_mmCIF lst }
      | "pdbx_sequence_annotation" -> { d with pdbx_sequence_annotation = List.map Pdbx_sequence_annotation.of_mmCIF lst }
      | "pdbx_chem_comp_synonyms" -> { d with pdbx_chem_comp_synonyms = List.map Pdbx_chem_comp_synonyms.of_mmCIF lst }
      | "pdbx_post_process_details" -> { d with pdbx_post_process_details = List.map Pdbx_post_process_details.of_mmCIF lst }
      | "pdbx_post_process_status" -> { d with pdbx_post_process_status = List.map Pdbx_post_process_status.of_mmCIF lst }
      | "pdbx_struct_link" -> { d with pdbx_struct_link = List.map Pdbx_struct_link.of_mmCIF lst }
      | "pdbx_missing_residue_list" -> { d with pdbx_missing_residue_list = List.map Pdbx_missing_residue_list.of_mmCIF lst }
      | "pdbx_data_processing_cell" -> { d with pdbx_data_processing_cell = List.map Pdbx_data_processing_cell.of_mmCIF lst }
      | "pdbx_data_processing_reflns" -> { d with pdbx_data_processing_reflns = List.map Pdbx_data_processing_reflns.of_mmCIF lst }
      | "pdbx_data_processing_detector" -> { d with pdbx_data_processing_detector = List.map Pdbx_data_processing_detector.of_mmCIF lst }
      | "pdbx_chem_comp_nonstandard" -> { d with pdbx_chem_comp_nonstandard = List.map Pdbx_chem_comp_nonstandard.of_mmCIF lst }
      | "pdbx_entity_poly_protein_class" -> { d with pdbx_entity_poly_protein_class = List.map Pdbx_entity_poly_protein_class.of_mmCIF lst }
      | "pdbx_entity_name_taxonomy_tree" -> { d with pdbx_entity_name_taxonomy_tree = List.map Pdbx_entity_name_taxonomy_tree.of_mmCIF lst }
      | "pdbx_entity_name_taxonomy" -> { d with pdbx_entity_name_taxonomy = List.map Pdbx_entity_name_taxonomy.of_mmCIF lst }
      | "pdbx_entity_name_instance" -> { d with pdbx_entity_name_instance = List.map Pdbx_entity_name_instance.of_mmCIF lst }
      | "pdbx_tableinfo" -> { d with pdbx_tableinfo = List.map Pdbx_tableinfo.of_mmCIF lst }
      | "pdbx_columninfo" -> { d with pdbx_columninfo = List.map Pdbx_columninfo.of_mmCIF lst }
      | "pdbx_val_angle" -> { d with pdbx_val_angle = List.map Pdbx_val_angle.of_mmCIF lst }
      | "pdbx_val_bond" -> { d with pdbx_val_bond = List.map Pdbx_val_bond.of_mmCIF lst }
      | "pdbx_val_contact" -> { d with pdbx_val_contact = List.map Pdbx_val_contact.of_mmCIF lst }
      | "pdbx_val_sym_contact" -> { d with pdbx_val_sym_contact = List.map Pdbx_val_sym_contact.of_mmCIF lst }
      | "pdbx_rmch_outlier" -> { d with pdbx_rmch_outlier = List.map Pdbx_rmch_outlier.of_mmCIF lst }
      | "pdbx_missing_atom_poly" -> { d with pdbx_missing_atom_poly = List.map Pdbx_missing_atom_poly.of_mmCIF lst }
      | "pdbx_missing_atom_nonpoly" -> { d with pdbx_missing_atom_nonpoly = List.map Pdbx_missing_atom_nonpoly.of_mmCIF lst }
      | "pdbx_val_chiral" -> { d with pdbx_val_chiral = List.map Pdbx_val_chiral.of_mmCIF lst }
      | "pdbx_atlas" -> { d with pdbx_atlas = List.map Pdbx_atlas.of_mmCIF lst }
      | "pdbx_summary_flags" -> { d with pdbx_summary_flags = List.map Pdbx_summary_flags.of_mmCIF lst }
      | "pdbx_entity_func_bind_mode" -> { d with pdbx_entity_func_bind_mode = List.map Pdbx_entity_func_bind_mode.of_mmCIF lst }
      | "pdbx_entity_func_enzyme" -> { d with pdbx_entity_func_enzyme = List.map Pdbx_entity_func_enzyme.of_mmCIF lst }
      | "pdbx_entity_func_regulatory" -> { d with pdbx_entity_func_regulatory = List.map Pdbx_entity_func_regulatory.of_mmCIF lst }
      | "pdbx_entity_func_structural" -> { d with pdbx_entity_func_structural = List.map Pdbx_entity_func_structural.of_mmCIF lst }
      | "pdbx_entity_func_other" -> { d with pdbx_entity_func_other = List.map Pdbx_entity_func_other.of_mmCIF lst }
      | "pdbx_entity_poly_domain" -> { d with pdbx_entity_poly_domain = List.map Pdbx_entity_poly_domain.of_mmCIF lst }
      | "pdbx_na_struct_keywds" -> { d with pdbx_na_struct_keywds = List.map Pdbx_na_struct_keywds.of_mmCIF lst }
      | "pdbx_entity_poly_na_type" -> { d with pdbx_entity_poly_na_type = List.map Pdbx_entity_poly_na_type.of_mmCIF lst }
      | "pdbx_entity_poly_na_nonstandard" -> { d with pdbx_entity_poly_na_nonstandard = List.map Pdbx_entity_poly_na_nonstandard.of_mmCIF lst }
      | "pdbx_virtual_angle" -> { d with pdbx_virtual_angle = List.map Pdbx_virtual_angle.of_mmCIF lst }
      | "pdbx_virtual_bond" -> { d with pdbx_virtual_bond = List.map Pdbx_virtual_bond.of_mmCIF lst }
      | "pdbx_virtual_torsion" -> { d with pdbx_virtual_torsion = List.map Pdbx_virtual_torsion.of_mmCIF lst }
      | "pdbx_sequence_pattern" -> { d with pdbx_sequence_pattern = List.map Pdbx_sequence_pattern.of_mmCIF lst }
      | "pdbx_stereochemistry" -> { d with pdbx_stereochemistry = List.map Pdbx_stereochemistry.of_mmCIF lst }
      | "pdbx_rms_devs_covalent" -> { d with pdbx_rms_devs_covalent = List.map Pdbx_rms_devs_covalent.of_mmCIF lst }
      | "pdbx_rms_devs_cov_by_monomer" -> { d with pdbx_rms_devs_cov_by_monomer = List.map Pdbx_rms_devs_cov_by_monomer.of_mmCIF lst }
      | "pdbx_sugar_phosphate_geometry" -> { d with pdbx_sugar_phosphate_geometry = List.map Pdbx_sugar_phosphate_geometry.of_mmCIF lst }
      | "pdbx_nmr_computing" -> { d with pdbx_nmr_computing = List.map Pdbx_nmr_computing.of_mmCIF lst }
      | "pdbx_audit_conform_extension" -> { d with pdbx_audit_conform_extension = List.map Pdbx_audit_conform_extension.of_mmCIF lst }
      | "pdbx_dcc_mapman" -> { d with pdbx_dcc_mapman = List.map Pdbx_dcc_mapman.of_mmCIF lst }
      | "pdbx_dcc_rscc_mapman" -> { d with pdbx_dcc_rscc_mapman = List.map Pdbx_dcc_rscc_mapman.of_mmCIF lst }
      | "pdbx_dcc_rscc_mapman_overall" -> { d with pdbx_dcc_rscc_mapman_overall = List.map Pdbx_dcc_rscc_mapman_overall.of_mmCIF lst }
      | "pdbx_dcc_density" -> { d with pdbx_dcc_density = List.map Pdbx_dcc_density.of_mmCIF lst }
      | "pdbx_dcc_geometry" -> { d with pdbx_dcc_geometry = List.map Pdbx_dcc_geometry.of_mmCIF lst }
      | "pdbx_dcc_density_corr" -> { d with pdbx_dcc_density_corr = List.map Pdbx_dcc_density_corr.of_mmCIF lst }
      | "pdbx_dcc_map" -> { d with pdbx_dcc_map = List.map Pdbx_dcc_map.of_mmCIF lst }
      | "pdbx_deposit_group" -> { d with pdbx_deposit_group = List.map Pdbx_deposit_group.of_mmCIF lst }
      | "pdbx_deposit_group_index" -> { d with pdbx_deposit_group_index = List.map Pdbx_deposit_group_index.of_mmCIF lst }
      | "pdbx_struct_assembly_auth_evidence" -> { d with pdbx_struct_assembly_auth_evidence = List.map Pdbx_struct_assembly_auth_evidence.of_mmCIF lst }
      | "pdbx_struct_assembly_auth_classification" -> { d with pdbx_struct_assembly_auth_classification = List.map Pdbx_struct_assembly_auth_classification.of_mmCIF lst }
      | "pdbx_crystal_alignment" -> { d with pdbx_crystal_alignment = List.map Pdbx_crystal_alignment.of_mmCIF lst }
      | "pdbx_audit_revision_history" -> { d with pdbx_audit_revision_history = List.map Pdbx_audit_revision_history.of_mmCIF lst }
      | "pdbx_audit_revision_group" -> { d with pdbx_audit_revision_group = List.map Pdbx_audit_revision_group.of_mmCIF lst }
      | "pdbx_audit_revision_category" -> { d with pdbx_audit_revision_category = List.map Pdbx_audit_revision_category.of_mmCIF lst }
      | "pdbx_audit_revision_details" -> { d with pdbx_audit_revision_details = List.map Pdbx_audit_revision_details.of_mmCIF lst }
      | "pdbx_audit_revision_item" -> { d with pdbx_audit_revision_item = List.map Pdbx_audit_revision_item.of_mmCIF lst }
      | "pdbx_supporting_exp_data_set" -> { d with pdbx_supporting_exp_data_set = List.map Pdbx_supporting_exp_data_set.of_mmCIF lst }
      | _ -> d)
    { default with datablockName = dbName } lst

  let to_mmCIF d =
    let lst = List.filter (fun (_,v) -> v <> []) [
      "jV_command",(List.map JV_command.to_mmCIF d.jV_command);
      "atom_site",(List.map Atom_site.to_mmCIF d.atom_site);
      "atom_site_anisotrop",(List.map Atom_site_anisotrop.to_mmCIF d.atom_site_anisotrop);
      "atom_sites",(List.map Atom_sites.to_mmCIF d.atom_sites);
      "atom_sites_alt",(List.map Atom_sites_alt.to_mmCIF d.atom_sites_alt);
      "atom_sites_alt_ens",(List.map Atom_sites_alt_ens.to_mmCIF d.atom_sites_alt_ens);
      "atom_sites_alt_gen",(List.map Atom_sites_alt_gen.to_mmCIF d.atom_sites_alt_gen);
      "atom_sites_footnote",(List.map Atom_sites_footnote.to_mmCIF d.atom_sites_footnote);
      "atom_type",(List.map Atom_type.to_mmCIF d.atom_type);
      "audit",(List.map Audit.to_mmCIF d.audit);
      "audit_author",(List.map Audit_author.to_mmCIF d.audit_author);
      "audit_conform",(List.map Audit_conform.to_mmCIF d.audit_conform);
      "audit_contact_author",(List.map Audit_contact_author.to_mmCIF d.audit_contact_author);
      "cell",(List.map Cell.to_mmCIF d.cell);
      "cell_measurement",(List.map Cell_measurement.to_mmCIF d.cell_measurement);
      "cell_measurement_refln",(List.map Cell_measurement_refln.to_mmCIF d.cell_measurement_refln);
      "chem_comp",(List.map Chem_comp.to_mmCIF d.chem_comp);
      "chem_comp_angle",(List.map Chem_comp_angle.to_mmCIF d.chem_comp_angle);
      "chem_comp_atom",(List.map Chem_comp_atom.to_mmCIF d.chem_comp_atom);
      "chem_comp_bond",(List.map Chem_comp_bond.to_mmCIF d.chem_comp_bond);
      "chem_comp_chir",(List.map Chem_comp_chir.to_mmCIF d.chem_comp_chir);
      "chem_comp_chir_atom",(List.map Chem_comp_chir_atom.to_mmCIF d.chem_comp_chir_atom);
      "chem_comp_link",(List.map Chem_comp_link.to_mmCIF d.chem_comp_link);
      "chem_comp_plane",(List.map Chem_comp_plane.to_mmCIF d.chem_comp_plane);
      "chem_comp_plane_atom",(List.map Chem_comp_plane_atom.to_mmCIF d.chem_comp_plane_atom);
      "chem_comp_tor",(List.map Chem_comp_tor.to_mmCIF d.chem_comp_tor);
      "chem_comp_tor_value",(List.map Chem_comp_tor_value.to_mmCIF d.chem_comp_tor_value);
      "chem_link",(List.map Chem_link.to_mmCIF d.chem_link);
      "chem_link_angle",(List.map Chem_link_angle.to_mmCIF d.chem_link_angle);
      "chem_link_bond",(List.map Chem_link_bond.to_mmCIF d.chem_link_bond);
      "chem_link_chir",(List.map Chem_link_chir.to_mmCIF d.chem_link_chir);
      "chem_link_chir_atom",(List.map Chem_link_chir_atom.to_mmCIF d.chem_link_chir_atom);
      "chem_link_plane",(List.map Chem_link_plane.to_mmCIF d.chem_link_plane);
      "chem_link_plane_atom",(List.map Chem_link_plane_atom.to_mmCIF d.chem_link_plane_atom);
      "chem_link_tor",(List.map Chem_link_tor.to_mmCIF d.chem_link_tor);
      "chem_link_tor_value",(List.map Chem_link_tor_value.to_mmCIF d.chem_link_tor_value);
      "chemical",(List.map Chemical.to_mmCIF d.chemical);
      "chemical_conn_atom",(List.map Chemical_conn_atom.to_mmCIF d.chemical_conn_atom);
      "chemical_conn_bond",(List.map Chemical_conn_bond.to_mmCIF d.chemical_conn_bond);
      "chemical_formula",(List.map Chemical_formula.to_mmCIF d.chemical_formula);
      "citation",(List.map Citation.to_mmCIF d.citation);
      "citation_author",(List.map Citation_author.to_mmCIF d.citation_author);
      "citation_editor",(List.map Citation_editor.to_mmCIF d.citation_editor);
      "computing",(List.map Computing.to_mmCIF d.computing);
      "database",(List.map Database.to_mmCIF d.database);
      "database_2",(List.map Database_2.to_mmCIF d.database_2);
      "database_PDB_caveat",(List.map Database_PDB_caveat.to_mmCIF d.database_PDB_caveat);
      "database_PDB_matrix",(List.map Database_PDB_matrix.to_mmCIF d.database_PDB_matrix);
      "database_PDB_remark",(List.map Database_PDB_remark.to_mmCIF d.database_PDB_remark);
      "database_PDB_rev",(List.map Database_PDB_rev.to_mmCIF d.database_PDB_rev);
      "database_PDB_rev_record",(List.map Database_PDB_rev_record.to_mmCIF d.database_PDB_rev_record);
      "database_PDB_tvect",(List.map Database_PDB_tvect.to_mmCIF d.database_PDB_tvect);
      "diffrn",(List.map Diffrn.to_mmCIF d.diffrn);
      "diffrn_attenuator",(List.map Diffrn_attenuator.to_mmCIF d.diffrn_attenuator);
      "diffrn_detector",(List.map Diffrn_detector.to_mmCIF d.diffrn_detector);
      "diffrn_measurement",(List.map Diffrn_measurement.to_mmCIF d.diffrn_measurement);
      "diffrn_orient_matrix",(List.map Diffrn_orient_matrix.to_mmCIF d.diffrn_orient_matrix);
      "diffrn_orient_refln",(List.map Diffrn_orient_refln.to_mmCIF d.diffrn_orient_refln);
      "diffrn_radiation",(List.map Diffrn_radiation.to_mmCIF d.diffrn_radiation);
      "diffrn_radiation_wavelength",(List.map Diffrn_radiation_wavelength.to_mmCIF d.diffrn_radiation_wavelength);
      "diffrn_refln",(List.map Diffrn_refln.to_mmCIF d.diffrn_refln);
      "diffrn_reflns",(List.map Diffrn_reflns.to_mmCIF d.diffrn_reflns);
      "diffrn_scale_group",(List.map Diffrn_scale_group.to_mmCIF d.diffrn_scale_group);
      "diffrn_source",(List.map Diffrn_source.to_mmCIF d.diffrn_source);
      "diffrn_standard_refln",(List.map Diffrn_standard_refln.to_mmCIF d.diffrn_standard_refln);
      "diffrn_standards",(List.map Diffrn_standards.to_mmCIF d.diffrn_standards);
      "entity",(List.map Entity.to_mmCIF d.entity);
      "entity_keywords",(List.map Entity_keywords.to_mmCIF d.entity_keywords);
      "entity_link",(List.map Entity_link.to_mmCIF d.entity_link);
      "entity_name_com",(List.map Entity_name_com.to_mmCIF d.entity_name_com);
      "entity_name_sys",(List.map Entity_name_sys.to_mmCIF d.entity_name_sys);
      "entity_poly",(List.map Entity_poly.to_mmCIF d.entity_poly);
      "entity_poly_seq",(List.map Entity_poly_seq.to_mmCIF d.entity_poly_seq);
      "entry",(List.map Entry.to_mmCIF d.entry);
      "entry_link",(List.map Entry_link.to_mmCIF d.entry_link);
      "exptl",(List.map Exptl.to_mmCIF d.exptl);
      "exptl_crystal",(List.map Exptl_crystal.to_mmCIF d.exptl_crystal);
      "exptl_crystal_face",(List.map Exptl_crystal_face.to_mmCIF d.exptl_crystal_face);
      "exptl_crystal_grow",(List.map Exptl_crystal_grow.to_mmCIF d.exptl_crystal_grow);
      "exptl_crystal_grow_comp",(List.map Exptl_crystal_grow_comp.to_mmCIF d.exptl_crystal_grow_comp);
      "geom",(List.map Geom.to_mmCIF d.geom);
      "geom_angle",(List.map Geom_angle.to_mmCIF d.geom_angle);
      "geom_bond",(List.map Geom_bond.to_mmCIF d.geom_bond);
      "geom_contact",(List.map Geom_contact.to_mmCIF d.geom_contact);
      "geom_hbond",(List.map Geom_hbond.to_mmCIF d.geom_hbond);
      "geom_torsion",(List.map Geom_torsion.to_mmCIF d.geom_torsion);
      "journal",(List.map Journal.to_mmCIF d.journal);
      "journal_index",(List.map Journal_index.to_mmCIF d.journal_index);
      "phasing",(List.map Phasing.to_mmCIF d.phasing);
      "phasing_averaging",(List.map Phasing_averaging.to_mmCIF d.phasing_averaging);
      "phasing_isomorphous",(List.map Phasing_isomorphous.to_mmCIF d.phasing_isomorphous);
      "phasing_MAD",(List.map Phasing_MAD.to_mmCIF d.phasing_MAD);
      "phasing_MAD_clust",(List.map Phasing_MAD_clust.to_mmCIF d.phasing_MAD_clust);
      "phasing_MAD_expt",(List.map Phasing_MAD_expt.to_mmCIF d.phasing_MAD_expt);
      "phasing_MAD_ratio",(List.map Phasing_MAD_ratio.to_mmCIF d.phasing_MAD_ratio);
      "phasing_MAD_set",(List.map Phasing_MAD_set.to_mmCIF d.phasing_MAD_set);
      "phasing_MIR",(List.map Phasing_MIR.to_mmCIF d.phasing_MIR);
      "phasing_MIR_der",(List.map Phasing_MIR_der.to_mmCIF d.phasing_MIR_der);
      "phasing_MIR_der_refln",(List.map Phasing_MIR_der_refln.to_mmCIF d.phasing_MIR_der_refln);
      "phasing_MIR_der_shell",(List.map Phasing_MIR_der_shell.to_mmCIF d.phasing_MIR_der_shell);
      "phasing_MIR_der_site",(List.map Phasing_MIR_der_site.to_mmCIF d.phasing_MIR_der_site);
      "phasing_MIR_shell",(List.map Phasing_MIR_shell.to_mmCIF d.phasing_MIR_shell);
      "phasing_set",(List.map Phasing_set.to_mmCIF d.phasing_set);
      "phasing_set_refln",(List.map Phasing_set_refln.to_mmCIF d.phasing_set_refln);
      "publ",(List.map Publ.to_mmCIF d.publ);
      "publ_author",(List.map Publ_author.to_mmCIF d.publ_author);
      "publ_body",(List.map Publ_body.to_mmCIF d.publ_body);
      "publ_manuscript_incl",(List.map Publ_manuscript_incl.to_mmCIF d.publ_manuscript_incl);
      "refine",(List.map Refine.to_mmCIF d.refine);
      "refine_analyze",(List.map Refine_analyze.to_mmCIF d.refine_analyze);
      "refine_B_iso",(List.map Refine_B_iso.to_mmCIF d.refine_B_iso);
      "refine_funct_minimized",(List.map Refine_funct_minimized.to_mmCIF d.refine_funct_minimized);
      "refine_hist",(List.map Refine_hist.to_mmCIF d.refine_hist);
      "refine_ls_restr",(List.map Refine_ls_restr.to_mmCIF d.refine_ls_restr);
      "refine_ls_restr_ncs",(List.map Refine_ls_restr_ncs.to_mmCIF d.refine_ls_restr_ncs);
      "refine_ls_restr_type",(List.map Refine_ls_restr_type.to_mmCIF d.refine_ls_restr_type);
      "refine_ls_shell",(List.map Refine_ls_shell.to_mmCIF d.refine_ls_shell);
      "refine_occupancy",(List.map Refine_occupancy.to_mmCIF d.refine_occupancy);
      "refln",(List.map Refln.to_mmCIF d.refln);
      "refln_sys_abs",(List.map Refln_sys_abs.to_mmCIF d.refln_sys_abs);
      "reflns",(List.map Reflns.to_mmCIF d.reflns);
      "reflns_scale",(List.map Reflns_scale.to_mmCIF d.reflns_scale);
      "reflns_shell",(List.map Reflns_shell.to_mmCIF d.reflns_shell);
      "software",(List.map Software.to_mmCIF d.software);
      "struct",(List.map Struct.to_mmCIF d.struct_);
      "struct_asym",(List.map Struct_asym.to_mmCIF d.struct_asym);
      "struct_biol",(List.map Struct_biol.to_mmCIF d.struct_biol);
      "struct_biol_gen",(List.map Struct_biol_gen.to_mmCIF d.struct_biol_gen);
      "struct_biol_keywords",(List.map Struct_biol_keywords.to_mmCIF d.struct_biol_keywords);
      "struct_biol_view",(List.map Struct_biol_view.to_mmCIF d.struct_biol_view);
      "struct_conf",(List.map Struct_conf.to_mmCIF d.struct_conf);
      "struct_conf_type",(List.map Struct_conf_type.to_mmCIF d.struct_conf_type);
      "struct_conn",(List.map Struct_conn.to_mmCIF d.struct_conn);
      "struct_conn_type",(List.map Struct_conn_type.to_mmCIF d.struct_conn_type);
      "struct_keywords",(List.map Struct_keywords.to_mmCIF d.struct_keywords);
      "struct_mon_details",(List.map Struct_mon_details.to_mmCIF d.struct_mon_details);
      "struct_mon_nucl",(List.map Struct_mon_nucl.to_mmCIF d.struct_mon_nucl);
      "struct_mon_prot",(List.map Struct_mon_prot.to_mmCIF d.struct_mon_prot);
      "struct_mon_prot_cis",(List.map Struct_mon_prot_cis.to_mmCIF d.struct_mon_prot_cis);
      "struct_ncs_dom",(List.map Struct_ncs_dom.to_mmCIF d.struct_ncs_dom);
      "struct_ncs_dom_lim",(List.map Struct_ncs_dom_lim.to_mmCIF d.struct_ncs_dom_lim);
      "struct_ncs_ens",(List.map Struct_ncs_ens.to_mmCIF d.struct_ncs_ens);
      "struct_ncs_ens_gen",(List.map Struct_ncs_ens_gen.to_mmCIF d.struct_ncs_ens_gen);
      "struct_ncs_oper",(List.map Struct_ncs_oper.to_mmCIF d.struct_ncs_oper);
      "struct_ref",(List.map Struct_ref.to_mmCIF d.struct_ref);
      "struct_ref_seq",(List.map Struct_ref_seq.to_mmCIF d.struct_ref_seq);
      "struct_ref_seq_dif",(List.map Struct_ref_seq_dif.to_mmCIF d.struct_ref_seq_dif);
      "struct_sheet",(List.map Struct_sheet.to_mmCIF d.struct_sheet);
      "struct_sheet_hbond",(List.map Struct_sheet_hbond.to_mmCIF d.struct_sheet_hbond);
      "struct_sheet_order",(List.map Struct_sheet_order.to_mmCIF d.struct_sheet_order);
      "struct_sheet_range",(List.map Struct_sheet_range.to_mmCIF d.struct_sheet_range);
      "struct_sheet_topology",(List.map Struct_sheet_topology.to_mmCIF d.struct_sheet_topology);
      "struct_site",(List.map Struct_site.to_mmCIF d.struct_site);
      "struct_site_gen",(List.map Struct_site_gen.to_mmCIF d.struct_site_gen);
      "struct_site_keywords",(List.map Struct_site_keywords.to_mmCIF d.struct_site_keywords);
      "struct_site_view",(List.map Struct_site_view.to_mmCIF d.struct_site_view);
      "symmetry",(List.map Symmetry.to_mmCIF d.symmetry);
      "symmetry_equiv",(List.map Symmetry_equiv.to_mmCIF d.symmetry_equiv);
      "audit_link",(List.map Audit_link.to_mmCIF d.audit_link);
      "diffrn_reflns_class",(List.map Diffrn_reflns_class.to_mmCIF d.diffrn_reflns_class);
      "refine_ls_class",(List.map Refine_ls_class.to_mmCIF d.refine_ls_class);
      "reflns_class",(List.map Reflns_class.to_mmCIF d.reflns_class);
      "space_group",(List.map Space_group.to_mmCIF d.space_group);
      "space_group_symop",(List.map Space_group_symop.to_mmCIF d.space_group_symop);
      "valence_param",(List.map Valence_param.to_mmCIF d.valence_param);
      "valence_ref",(List.map Valence_ref.to_mmCIF d.valence_ref);
      "pdbx_audit",(List.map Pdbx_audit.to_mmCIF d.pdbx_audit);
      "pdbx_version",(List.map Pdbx_version.to_mmCIF d.pdbx_version);
      "pdbx_audit_author",(List.map Pdbx_audit_author.to_mmCIF d.pdbx_audit_author);
      "pdbx_database_message",(List.map Pdbx_database_message.to_mmCIF d.pdbx_database_message);
      "pdbx_database_PDB_obs_spr",(List.map Pdbx_database_PDB_obs_spr.to_mmCIF d.pdbx_database_PDB_obs_spr);
      "pdbx_database_proc",(List.map Pdbx_database_proc.to_mmCIF d.pdbx_database_proc);
      "pdbx_database_remark",(List.map Pdbx_database_remark.to_mmCIF d.pdbx_database_remark);
      "pdbx_database_status",(List.map Pdbx_database_status.to_mmCIF d.pdbx_database_status);
      "pdbx_entity_name",(List.map Pdbx_entity_name.to_mmCIF d.pdbx_entity_name);
      "pdbx_prerelease_seq",(List.map Pdbx_prerelease_seq.to_mmCIF d.pdbx_prerelease_seq);
      "pdbx_poly_seq_scheme",(List.map Pdbx_poly_seq_scheme.to_mmCIF d.pdbx_poly_seq_scheme);
      "pdbx_nonpoly_scheme",(List.map Pdbx_nonpoly_scheme.to_mmCIF d.pdbx_nonpoly_scheme);
      "pdbx_refine",(List.map Pdbx_refine.to_mmCIF d.pdbx_refine);
      "pdbx_struct_sheet_hbond",(List.map Pdbx_struct_sheet_hbond.to_mmCIF d.pdbx_struct_sheet_hbond);
      "pdbx_xplor_file",(List.map Pdbx_xplor_file.to_mmCIF d.pdbx_xplor_file);
      "pdbx_refine_aux_file",(List.map Pdbx_refine_aux_file.to_mmCIF d.pdbx_refine_aux_file);
      "pdbx_database_related",(List.map Pdbx_database_related.to_mmCIF d.pdbx_database_related);
      "pdbx_entity_assembly",(List.map Pdbx_entity_assembly.to_mmCIF d.pdbx_entity_assembly);
      "pdbx_exptl_crystal_grow_comp",(List.map Pdbx_exptl_crystal_grow_comp.to_mmCIF d.pdbx_exptl_crystal_grow_comp);
      "pdbx_exptl_crystal_grow_sol",(List.map Pdbx_exptl_crystal_grow_sol.to_mmCIF d.pdbx_exptl_crystal_grow_sol);
      "pdbx_exptl_crystal_cryo_treatment",(List.map Pdbx_exptl_crystal_cryo_treatment.to_mmCIF d.pdbx_exptl_crystal_cryo_treatment);
      "pdbx_refine_tls",(List.map Pdbx_refine_tls.to_mmCIF d.pdbx_refine_tls);
      "pdbx_refine_tls_group",(List.map Pdbx_refine_tls_group.to_mmCIF d.pdbx_refine_tls_group);
      "pdbx_contact_author",(List.map Pdbx_contact_author.to_mmCIF d.pdbx_contact_author);
      "pdbx_SG_project",(List.map Pdbx_SG_project.to_mmCIF d.pdbx_SG_project);
      "pdbx_atom_site_aniso_tls",(List.map Pdbx_atom_site_aniso_tls.to_mmCIF d.pdbx_atom_site_aniso_tls);
      "pdbx_nmr_details",(List.map Pdbx_nmr_details.to_mmCIF d.pdbx_nmr_details);
      "pdbx_nmr_sample_details",(List.map Pdbx_nmr_sample_details.to_mmCIF d.pdbx_nmr_sample_details);
      "pdbx_nmr_exptl_sample",(List.map Pdbx_nmr_exptl_sample.to_mmCIF d.pdbx_nmr_exptl_sample);
      "pdbx_nmr_exptl_sample_conditions",(List.map Pdbx_nmr_exptl_sample_conditions.to_mmCIF d.pdbx_nmr_exptl_sample_conditions);
      "pdbx_nmr_spectrometer",(List.map Pdbx_nmr_spectrometer.to_mmCIF d.pdbx_nmr_spectrometer);
      "pdbx_nmr_exptl",(List.map Pdbx_nmr_exptl.to_mmCIF d.pdbx_nmr_exptl);
      "pdbx_nmr_software",(List.map Pdbx_nmr_software.to_mmCIF d.pdbx_nmr_software);
      "pdbx_nmr_constraints",(List.map Pdbx_nmr_constraints.to_mmCIF d.pdbx_nmr_constraints);
      "pdbx_nmr_ensemble",(List.map Pdbx_nmr_ensemble.to_mmCIF d.pdbx_nmr_ensemble);
      "pdbx_nmr_ensemble_rms",(List.map Pdbx_nmr_ensemble_rms.to_mmCIF d.pdbx_nmr_ensemble_rms);
      "pdbx_nmr_representative",(List.map Pdbx_nmr_representative.to_mmCIF d.pdbx_nmr_representative);
      "pdbx_nmr_refine",(List.map Pdbx_nmr_refine.to_mmCIF d.pdbx_nmr_refine);
      "pdbx_nmr_force_constants",(List.map Pdbx_nmr_force_constants.to_mmCIF d.pdbx_nmr_force_constants);
      "ndb_struct_conf_na",(List.map Ndb_struct_conf_na.to_mmCIF d.ndb_struct_conf_na);
      "ndb_struct_feature_na",(List.map Ndb_struct_feature_na.to_mmCIF d.ndb_struct_feature_na);
      "ndb_struct_na_base_pair",(List.map Ndb_struct_na_base_pair.to_mmCIF d.ndb_struct_na_base_pair);
      "ndb_struct_na_base_pair_step",(List.map Ndb_struct_na_base_pair_step.to_mmCIF d.ndb_struct_na_base_pair_step);
      "ndb_original_ndb_coordinates",(List.map Ndb_original_ndb_coordinates.to_mmCIF d.ndb_original_ndb_coordinates);
      "pdbx_entity_nonpoly",(List.map Pdbx_entity_nonpoly.to_mmCIF d.pdbx_entity_nonpoly);
      "pdbx_phasing_dm",(List.map Pdbx_phasing_dm.to_mmCIF d.pdbx_phasing_dm);
      "pdbx_phasing_dm_shell",(List.map Pdbx_phasing_dm_shell.to_mmCIF d.pdbx_phasing_dm_shell);
      "pdbx_phasing_MAD_shell",(List.map Pdbx_phasing_MAD_shell.to_mmCIF d.pdbx_phasing_MAD_shell);
      "pdbx_phasing_MAD_set",(List.map Pdbx_phasing_MAD_set.to_mmCIF d.pdbx_phasing_MAD_set);
      "pdbx_phasing_MAD_set_shell",(List.map Pdbx_phasing_MAD_set_shell.to_mmCIF d.pdbx_phasing_MAD_set_shell);
      "pdbx_phasing_MAD_set_site",(List.map Pdbx_phasing_MAD_set_site.to_mmCIF d.pdbx_phasing_MAD_set_site);
      "pdbx_phasing_MR",(List.map Pdbx_phasing_MR.to_mmCIF d.pdbx_phasing_MR);
      "pdbx_refine_component",(List.map Pdbx_refine_component.to_mmCIF d.pdbx_refine_component);
      "pdbx_entity_prod_protocol",(List.map Pdbx_entity_prod_protocol.to_mmCIF d.pdbx_entity_prod_protocol);
      "pdbx_entity_src_gen_prod_other",(List.map Pdbx_entity_src_gen_prod_other.to_mmCIF d.pdbx_entity_src_gen_prod_other);
      "pdbx_entity_src_gen_prod_other_parameter",(List.map Pdbx_entity_src_gen_prod_other_parameter.to_mmCIF d.pdbx_entity_src_gen_prod_other_parameter);
      "pdbx_entity_src_gen_prod_pcr",(List.map Pdbx_entity_src_gen_prod_pcr.to_mmCIF d.pdbx_entity_src_gen_prod_pcr);
      "pdbx_entity_src_gen_prod_digest",(List.map Pdbx_entity_src_gen_prod_digest.to_mmCIF d.pdbx_entity_src_gen_prod_digest);
      "pdbx_entity_src_gen_clone",(List.map Pdbx_entity_src_gen_clone.to_mmCIF d.pdbx_entity_src_gen_clone);
      "pdbx_entity_src_gen_clone_ligation",(List.map Pdbx_entity_src_gen_clone_ligation.to_mmCIF d.pdbx_entity_src_gen_clone_ligation);
      "pdbx_entity_src_gen_clone_recombination",(List.map Pdbx_entity_src_gen_clone_recombination.to_mmCIF d.pdbx_entity_src_gen_clone_recombination);
      "pdbx_entity_src_gen_express",(List.map Pdbx_entity_src_gen_express.to_mmCIF d.pdbx_entity_src_gen_express);
      "pdbx_entity_src_gen_express_timepoint",(List.map Pdbx_entity_src_gen_express_timepoint.to_mmCIF d.pdbx_entity_src_gen_express_timepoint);
      "pdbx_entity_src_gen_lysis",(List.map Pdbx_entity_src_gen_lysis.to_mmCIF d.pdbx_entity_src_gen_lysis);
      "pdbx_entity_src_gen_refold",(List.map Pdbx_entity_src_gen_refold.to_mmCIF d.pdbx_entity_src_gen_refold);
      "pdbx_entity_src_gen_proteolysis",(List.map Pdbx_entity_src_gen_proteolysis.to_mmCIF d.pdbx_entity_src_gen_proteolysis);
      "pdbx_entity_src_gen_chrom",(List.map Pdbx_entity_src_gen_chrom.to_mmCIF d.pdbx_entity_src_gen_chrom);
      "pdbx_entity_src_gen_fract",(List.map Pdbx_entity_src_gen_fract.to_mmCIF d.pdbx_entity_src_gen_fract);
      "pdbx_entity_src_gen_pure",(List.map Pdbx_entity_src_gen_pure.to_mmCIF d.pdbx_entity_src_gen_pure);
      "pdbx_entity_src_gen_character",(List.map Pdbx_entity_src_gen_character.to_mmCIF d.pdbx_entity_src_gen_character);
      "pdbx_construct",(List.map Pdbx_construct.to_mmCIF d.pdbx_construct);
      "pdbx_construct_feature",(List.map Pdbx_construct_feature.to_mmCIF d.pdbx_construct_feature);
      "pdbx_robot_system",(List.map Pdbx_robot_system.to_mmCIF d.pdbx_robot_system);
      "pdbx_buffer",(List.map Pdbx_buffer.to_mmCIF d.pdbx_buffer);
      "pdbx_buffer_components",(List.map Pdbx_buffer_components.to_mmCIF d.pdbx_buffer_components);
      "pdbx_domain",(List.map Pdbx_domain.to_mmCIF d.pdbx_domain);
      "pdbx_domain_range",(List.map Pdbx_domain_range.to_mmCIF d.pdbx_domain_range);
      "pdbx_sequence_range",(List.map Pdbx_sequence_range.to_mmCIF d.pdbx_sequence_range);
      "pdbx_feature_entry",(List.map Pdbx_feature_entry.to_mmCIF d.pdbx_feature_entry);
      "pdbx_feature_domain",(List.map Pdbx_feature_domain.to_mmCIF d.pdbx_feature_domain);
      "pdbx_feature_sequence_range",(List.map Pdbx_feature_sequence_range.to_mmCIF d.pdbx_feature_sequence_range);
      "pdbx_feature_assembly",(List.map Pdbx_feature_assembly.to_mmCIF d.pdbx_feature_assembly);
      "pdbx_feature_monomer",(List.map Pdbx_feature_monomer.to_mmCIF d.pdbx_feature_monomer);
      "pdbx_exptl_pd",(List.map Pdbx_exptl_pd.to_mmCIF d.pdbx_exptl_pd);
      "pdbx_reflns_twin",(List.map Pdbx_reflns_twin.to_mmCIF d.pdbx_reflns_twin);
      "pdbx_struct_info",(List.map Pdbx_struct_info.to_mmCIF d.pdbx_struct_info);
      "pdbx_re_refinement",(List.map Pdbx_re_refinement.to_mmCIF d.pdbx_re_refinement);
      "pdbx_struct_assembly_prop",(List.map Pdbx_struct_assembly_prop.to_mmCIF d.pdbx_struct_assembly_prop);
      "pdbx_struct_ref_seq_feature",(List.map Pdbx_struct_ref_seq_feature.to_mmCIF d.pdbx_struct_ref_seq_feature);
      "pdbx_struct_ref_seq_feature_prop",(List.map Pdbx_struct_ref_seq_feature_prop.to_mmCIF d.pdbx_struct_ref_seq_feature_prop);
      "pdbx_struct_chem_comp_diagnostics",(List.map Pdbx_struct_chem_comp_diagnostics.to_mmCIF d.pdbx_struct_chem_comp_diagnostics);
      "pdbx_chem_comp_feature",(List.map Pdbx_chem_comp_feature.to_mmCIF d.pdbx_chem_comp_feature);
      "pdbx_coordinate_model",(List.map Pdbx_coordinate_model.to_mmCIF d.pdbx_coordinate_model);
      "pdbx_struct_chem_comp_feature",(List.map Pdbx_struct_chem_comp_feature.to_mmCIF d.pdbx_struct_chem_comp_feature);
      "pdbx_diffrn_reflns_shell",(List.map Pdbx_diffrn_reflns_shell.to_mmCIF d.pdbx_diffrn_reflns_shell);
      "pdbx_bond_distance_limits",(List.map Pdbx_bond_distance_limits.to_mmCIF d.pdbx_bond_distance_limits);
      "pdbx_soln_scatter",(List.map Pdbx_soln_scatter.to_mmCIF d.pdbx_soln_scatter);
      "pdbx_soln_scatter_model",(List.map Pdbx_soln_scatter_model.to_mmCIF d.pdbx_soln_scatter_model);
      "pdbx_chem_comp_descriptor",(List.map Pdbx_chem_comp_descriptor.to_mmCIF d.pdbx_chem_comp_descriptor);
      "pdbx_chem_comp_identifier",(List.map Pdbx_chem_comp_identifier.to_mmCIF d.pdbx_chem_comp_identifier);
      "pdbx_chem_comp_import",(List.map Pdbx_chem_comp_import.to_mmCIF d.pdbx_chem_comp_import);
      "pdbx_chem_comp_atom_edit",(List.map Pdbx_chem_comp_atom_edit.to_mmCIF d.pdbx_chem_comp_atom_edit);
      "pdbx_chem_comp_bond_edit",(List.map Pdbx_chem_comp_bond_edit.to_mmCIF d.pdbx_chem_comp_bond_edit);
      "pdbx_chem_comp_audit",(List.map Pdbx_chem_comp_audit.to_mmCIF d.pdbx_chem_comp_audit);
      "pdbx_validate_close_contact",(List.map Pdbx_validate_close_contact.to_mmCIF d.pdbx_validate_close_contact);
      "pdbx_validate_symm_contact",(List.map Pdbx_validate_symm_contact.to_mmCIF d.pdbx_validate_symm_contact);
      "pdbx_validate_rmsd_bond",(List.map Pdbx_validate_rmsd_bond.to_mmCIF d.pdbx_validate_rmsd_bond);
      "pdbx_validate_rmsd_angle",(List.map Pdbx_validate_rmsd_angle.to_mmCIF d.pdbx_validate_rmsd_angle);
      "pdbx_validate_torsion",(List.map Pdbx_validate_torsion.to_mmCIF d.pdbx_validate_torsion);
      "pdbx_validate_peptide_omega",(List.map Pdbx_validate_peptide_omega.to_mmCIF d.pdbx_validate_peptide_omega);
      "pdbx_validate_chiral",(List.map Pdbx_validate_chiral.to_mmCIF d.pdbx_validate_chiral);
      "pdbx_validate_planes",(List.map Pdbx_validate_planes.to_mmCIF d.pdbx_validate_planes);
      "pdbx_validate_planes_atom",(List.map Pdbx_validate_planes_atom.to_mmCIF d.pdbx_validate_planes_atom);
      "pdbx_validate_main_chain_plane",(List.map Pdbx_validate_main_chain_plane.to_mmCIF d.pdbx_validate_main_chain_plane);
      "pdbx_struct_conn_angle",(List.map Pdbx_struct_conn_angle.to_mmCIF d.pdbx_struct_conn_angle);
      "pdbx_unobs_or_zero_occ_residues",(List.map Pdbx_unobs_or_zero_occ_residues.to_mmCIF d.pdbx_unobs_or_zero_occ_residues);
      "pdbx_unobs_or_zero_occ_atoms",(List.map Pdbx_unobs_or_zero_occ_atoms.to_mmCIF d.pdbx_unobs_or_zero_occ_atoms);
      "pdbx_entry_details",(List.map Pdbx_entry_details.to_mmCIF d.pdbx_entry_details);
      "pdbx_struct_mod_residue",(List.map Pdbx_struct_mod_residue.to_mmCIF d.pdbx_struct_mod_residue);
      "pdbx_struct_ref_seq_insertion",(List.map Pdbx_struct_ref_seq_insertion.to_mmCIF d.pdbx_struct_ref_seq_insertion);
      "pdbx_struct_ref_seq_deletion",(List.map Pdbx_struct_ref_seq_deletion.to_mmCIF d.pdbx_struct_ref_seq_deletion);
      "pdbx_remediation_atom_site_mapping",(List.map Pdbx_remediation_atom_site_mapping.to_mmCIF d.pdbx_remediation_atom_site_mapping);
      "pdbx_validate_polymer_linkage",(List.map Pdbx_validate_polymer_linkage.to_mmCIF d.pdbx_validate_polymer_linkage);
      "pdbx_helical_symmetry",(List.map Pdbx_helical_symmetry.to_mmCIF d.pdbx_helical_symmetry);
      "pdbx_point_symmetry",(List.map Pdbx_point_symmetry.to_mmCIF d.pdbx_point_symmetry);
      "pdbx_struct_entity_inst",(List.map Pdbx_struct_entity_inst.to_mmCIF d.pdbx_struct_entity_inst);
      "pdbx_struct_oper_list",(List.map Pdbx_struct_oper_list.to_mmCIF d.pdbx_struct_oper_list);
      "pdbx_struct_assembly",(List.map Pdbx_struct_assembly.to_mmCIF d.pdbx_struct_assembly);
      "pdbx_struct_assembly_gen",(List.map Pdbx_struct_assembly_gen.to_mmCIF d.pdbx_struct_assembly_gen);
      "pdbx_struct_asym_gen",(List.map Pdbx_struct_asym_gen.to_mmCIF d.pdbx_struct_asym_gen);
      "pdbx_struct_msym_gen",(List.map Pdbx_struct_msym_gen.to_mmCIF d.pdbx_struct_msym_gen);
      "pdbx_struct_legacy_oper_list",(List.map Pdbx_struct_legacy_oper_list.to_mmCIF d.pdbx_struct_legacy_oper_list);
      "pdbx_chem_comp_atom_feature",(List.map Pdbx_chem_comp_atom_feature.to_mmCIF d.pdbx_chem_comp_atom_feature);
      "pdbx_reference_molecule_family",(List.map Pdbx_reference_molecule_family.to_mmCIF d.pdbx_reference_molecule_family);
      "pdbx_reference_molecule_list",(List.map Pdbx_reference_molecule_list.to_mmCIF d.pdbx_reference_molecule_list);
      "pdbx_reference_molecule",(List.map Pdbx_reference_molecule.to_mmCIF d.pdbx_reference_molecule);
      "pdbx_reference_entity_list",(List.map Pdbx_reference_entity_list.to_mmCIF d.pdbx_reference_entity_list);
      "pdbx_reference_entity_nonpoly",(List.map Pdbx_reference_entity_nonpoly.to_mmCIF d.pdbx_reference_entity_nonpoly);
      "pdbx_reference_entity_link",(List.map Pdbx_reference_entity_link.to_mmCIF d.pdbx_reference_entity_link);
      "pdbx_reference_entity_poly_link",(List.map Pdbx_reference_entity_poly_link.to_mmCIF d.pdbx_reference_entity_poly_link);
      "pdbx_reference_entity_poly",(List.map Pdbx_reference_entity_poly.to_mmCIF d.pdbx_reference_entity_poly);
      "pdbx_reference_entity_poly_seq",(List.map Pdbx_reference_entity_poly_seq.to_mmCIF d.pdbx_reference_entity_poly_seq);
      "pdbx_reference_entity_sequence",(List.map Pdbx_reference_entity_sequence.to_mmCIF d.pdbx_reference_entity_sequence);
      "pdbx_reference_entity_src_nat",(List.map Pdbx_reference_entity_src_nat.to_mmCIF d.pdbx_reference_entity_src_nat);
      "pdbx_reference_molecule_details",(List.map Pdbx_reference_molecule_details.to_mmCIF d.pdbx_reference_molecule_details);
      "pdbx_reference_molecule_synonyms",(List.map Pdbx_reference_molecule_synonyms.to_mmCIF d.pdbx_reference_molecule_synonyms);
      "pdbx_reference_entity_subcomponents",(List.map Pdbx_reference_entity_subcomponents.to_mmCIF d.pdbx_reference_entity_subcomponents);
      "pdbx_reference_molecule_annotation",(List.map Pdbx_reference_molecule_annotation.to_mmCIF d.pdbx_reference_molecule_annotation);
      "pdbx_reference_molecule_features",(List.map Pdbx_reference_molecule_features.to_mmCIF d.pdbx_reference_molecule_features);
      "pdbx_reference_molecule_related_structures",(List.map Pdbx_reference_molecule_related_structures.to_mmCIF d.pdbx_reference_molecule_related_structures);
      "pdbx_struct_group_list",(List.map Pdbx_struct_group_list.to_mmCIF d.pdbx_struct_group_list);
      "pdbx_struct_group_components",(List.map Pdbx_struct_group_components.to_mmCIF d.pdbx_struct_group_components);
      "pdbx_struct_group_component_range",(List.map Pdbx_struct_group_component_range.to_mmCIF d.pdbx_struct_group_component_range);
      "pdbx_prd_audit",(List.map Pdbx_prd_audit.to_mmCIF d.pdbx_prd_audit);
      "pdbx_family_prd_audit",(List.map Pdbx_family_prd_audit.to_mmCIF d.pdbx_family_prd_audit);
      "pdbx_molecule",(List.map Pdbx_molecule.to_mmCIF d.pdbx_molecule);
      "pdbx_molecule_features",(List.map Pdbx_molecule_features.to_mmCIF d.pdbx_molecule_features);
      "pdbx_family_group_index",(List.map Pdbx_family_group_index.to_mmCIF d.pdbx_family_group_index);
      "pdbx_distant_solvent_atoms",(List.map Pdbx_distant_solvent_atoms.to_mmCIF d.pdbx_distant_solvent_atoms);
      "pdbx_struct_special_symmetry",(List.map Pdbx_struct_special_symmetry.to_mmCIF d.pdbx_struct_special_symmetry);
      "pdbx_reference_publication_list",(List.map Pdbx_reference_publication_list.to_mmCIF d.pdbx_reference_publication_list);
      "pdbx_nmr_assigned_chem_shift_list",(List.map Pdbx_nmr_assigned_chem_shift_list.to_mmCIF d.pdbx_nmr_assigned_chem_shift_list);
      "pdbx_nmr_chem_shift_experiment",(List.map Pdbx_nmr_chem_shift_experiment.to_mmCIF d.pdbx_nmr_chem_shift_experiment);
      "pdbx_nmr_chem_shift_ref",(List.map Pdbx_nmr_chem_shift_ref.to_mmCIF d.pdbx_nmr_chem_shift_ref);
      "pdbx_nmr_chem_shift_reference",(List.map Pdbx_nmr_chem_shift_reference.to_mmCIF d.pdbx_nmr_chem_shift_reference);
      "pdbx_nmr_chem_shift_software",(List.map Pdbx_nmr_chem_shift_software.to_mmCIF d.pdbx_nmr_chem_shift_software);
      "pdbx_nmr_constraint_file",(List.map Pdbx_nmr_constraint_file.to_mmCIF d.pdbx_nmr_constraint_file);
      "pdbx_nmr_software_task",(List.map Pdbx_nmr_software_task.to_mmCIF d.pdbx_nmr_software_task);
      "pdbx_nmr_spectral_dim",(List.map Pdbx_nmr_spectral_dim.to_mmCIF d.pdbx_nmr_spectral_dim);
      "pdbx_nmr_spectral_peak_list",(List.map Pdbx_nmr_spectral_peak_list.to_mmCIF d.pdbx_nmr_spectral_peak_list);
      "pdbx_nmr_spectral_peak_software",(List.map Pdbx_nmr_spectral_peak_software.to_mmCIF d.pdbx_nmr_spectral_peak_software);
      "pdbx_nmr_systematic_chem_shift_offset",(List.map Pdbx_nmr_systematic_chem_shift_offset.to_mmCIF d.pdbx_nmr_systematic_chem_shift_offset);
      "pdbx_nmr_upload",(List.map Pdbx_nmr_upload.to_mmCIF d.pdbx_nmr_upload);
      "pdbx_audit_support",(List.map Pdbx_audit_support.to_mmCIF d.pdbx_audit_support);
      "pdbx_chem_comp_subcomponent_struct_conn",(List.map Pdbx_chem_comp_subcomponent_struct_conn.to_mmCIF d.pdbx_chem_comp_subcomponent_struct_conn);
      "pdbx_chem_comp_subcomponent_entity_list",(List.map Pdbx_chem_comp_subcomponent_entity_list.to_mmCIF d.pdbx_chem_comp_subcomponent_entity_list);
      "entity_src_nat",(List.map Entity_src_nat.to_mmCIF d.entity_src_nat);
      "entity_src_gen",(List.map Entity_src_gen.to_mmCIF d.entity_src_gen);
      "pdbx_entity_src_syn",(List.map Pdbx_entity_src_syn.to_mmCIF d.pdbx_entity_src_syn);
      "pdbx_entity_poly_comp_link_list",(List.map Pdbx_entity_poly_comp_link_list.to_mmCIF d.pdbx_entity_poly_comp_link_list);
      "pdbx_linked_entity",(List.map Pdbx_linked_entity.to_mmCIF d.pdbx_linked_entity);
      "pdbx_linked_entity_instance_list",(List.map Pdbx_linked_entity_instance_list.to_mmCIF d.pdbx_linked_entity_instance_list);
      "pdbx_linked_entity_list",(List.map Pdbx_linked_entity_list.to_mmCIF d.pdbx_linked_entity_list);
      "pdbx_linked_entity_link_list",(List.map Pdbx_linked_entity_link_list.to_mmCIF d.pdbx_linked_entity_link_list);
      "pdbx_entity_descriptor",(List.map Pdbx_entity_descriptor.to_mmCIF d.pdbx_entity_descriptor);
      "pdbx_reference_linked_entity",(List.map Pdbx_reference_linked_entity.to_mmCIF d.pdbx_reference_linked_entity);
      "pdbx_reference_linked_entity_comp_list",(List.map Pdbx_reference_linked_entity_comp_list.to_mmCIF d.pdbx_reference_linked_entity_comp_list);
      "pdbx_reference_linked_entity_comp_link",(List.map Pdbx_reference_linked_entity_comp_link.to_mmCIF d.pdbx_reference_linked_entity_comp_link);
      "pdbx_reference_linked_entity_link",(List.map Pdbx_reference_linked_entity_link.to_mmCIF d.pdbx_reference_linked_entity_link);
      "pdbx_related_exp_data_set",(List.map Pdbx_related_exp_data_set.to_mmCIF d.pdbx_related_exp_data_set);
      "pdbx_database_status_history",(List.map Pdbx_database_status_history.to_mmCIF d.pdbx_database_status_history);
      "em_assembly",(List.map Em_assembly.to_mmCIF d.em_assembly);
      "em_entity_assembly",(List.map Em_entity_assembly.to_mmCIF d.em_entity_assembly);
      "em_virus_entity",(List.map Em_virus_entity.to_mmCIF d.em_virus_entity);
      "em_sample_preparation",(List.map Em_sample_preparation.to_mmCIF d.em_sample_preparation);
      "em_sample_support",(List.map Em_sample_support.to_mmCIF d.em_sample_support);
      "em_buffer",(List.map Em_buffer.to_mmCIF d.em_buffer);
      "em_vitrification",(List.map Em_vitrification.to_mmCIF d.em_vitrification);
      "em_imaging",(List.map Em_imaging.to_mmCIF d.em_imaging);
      "em_detector",(List.map Em_detector.to_mmCIF d.em_detector);
      "em_image_scans",(List.map Em_image_scans.to_mmCIF d.em_image_scans);
      "em_2d_projection_selection",(List.map Em_2d_projection_selection.to_mmCIF d.em_2d_projection_selection);
      "em_3d_reconstruction",(List.map Em_3d_reconstruction.to_mmCIF d.em_3d_reconstruction);
      "em_3d_fitting",(List.map Em_3d_fitting.to_mmCIF d.em_3d_fitting);
      "em_3d_fitting_list",(List.map Em_3d_fitting_list.to_mmCIF d.em_3d_fitting_list);
      "em_helical_entity",(List.map Em_helical_entity.to_mmCIF d.em_helical_entity);
      "em_experiment",(List.map Em_experiment.to_mmCIF d.em_experiment);
      "em_single_particle_entity",(List.map Em_single_particle_entity.to_mmCIF d.em_single_particle_entity);
      "em_admin",(List.map Em_admin.to_mmCIF d.em_admin);
      "em_author_list",(List.map Em_author_list.to_mmCIF d.em_author_list);
      "em_db_reference",(List.map Em_db_reference.to_mmCIF d.em_db_reference);
      "em_db_reference_auxiliary",(List.map Em_db_reference_auxiliary.to_mmCIF d.em_db_reference_auxiliary);
      "em_depui",(List.map Em_depui.to_mmCIF d.em_depui);
      "em_obsolete",(List.map Em_obsolete.to_mmCIF d.em_obsolete);
      "em_supersede",(List.map Em_supersede.to_mmCIF d.em_supersede);
      "em_entity_assembly_molwt",(List.map Em_entity_assembly_molwt.to_mmCIF d.em_entity_assembly_molwt);
      "em_entity_assembly_naturalsource",(List.map Em_entity_assembly_naturalsource.to_mmCIF d.em_entity_assembly_naturalsource);
      "em_entity_assembly_recombinant",(List.map Em_entity_assembly_recombinant.to_mmCIF d.em_entity_assembly_recombinant);
      "em_virus_natural_host",(List.map Em_virus_natural_host.to_mmCIF d.em_virus_natural_host);
      "em_virus_shell",(List.map Em_virus_shell.to_mmCIF d.em_virus_shell);
      "em_specimen",(List.map Em_specimen.to_mmCIF d.em_specimen);
      "em_embedding",(List.map Em_embedding.to_mmCIF d.em_embedding);
      "em_fiducial_markers",(List.map Em_fiducial_markers.to_mmCIF d.em_fiducial_markers);
      "em_focused_ion_beam",(List.map Em_focused_ion_beam.to_mmCIF d.em_focused_ion_beam);
      "em_grid_pretreatment",(List.map Em_grid_pretreatment.to_mmCIF d.em_grid_pretreatment);
      "em_ultramicrotomy",(List.map Em_ultramicrotomy.to_mmCIF d.em_ultramicrotomy);
      "em_high_pressure_freezing",(List.map Em_high_pressure_freezing.to_mmCIF d.em_high_pressure_freezing);
      "em_shadowing",(List.map Em_shadowing.to_mmCIF d.em_shadowing);
      "em_tomography_specimen",(List.map Em_tomography_specimen.to_mmCIF d.em_tomography_specimen);
      "em_crystal_formation",(List.map Em_crystal_formation.to_mmCIF d.em_crystal_formation);
      "em_staining",(List.map Em_staining.to_mmCIF d.em_staining);
      "em_support_film",(List.map Em_support_film.to_mmCIF d.em_support_film);
      "em_buffer_component",(List.map Em_buffer_component.to_mmCIF d.em_buffer_component);
      "em_diffraction",(List.map Em_diffraction.to_mmCIF d.em_diffraction);
      "em_diffraction_shell",(List.map Em_diffraction_shell.to_mmCIF d.em_diffraction_shell);
      "em_diffraction_stats",(List.map Em_diffraction_stats.to_mmCIF d.em_diffraction_stats);
      "em_tomography",(List.map Em_tomography.to_mmCIF d.em_tomography);
      "em_image_recording",(List.map Em_image_recording.to_mmCIF d.em_image_recording);
      "em_imaging_optics",(List.map Em_imaging_optics.to_mmCIF d.em_imaging_optics);
      "em_final_classification",(List.map Em_final_classification.to_mmCIF d.em_final_classification);
      "em_start_model",(List.map Em_start_model.to_mmCIF d.em_start_model);
      "em_software",(List.map Em_software.to_mmCIF d.em_software);
      "em_euler_angle_assignment",(List.map Em_euler_angle_assignment.to_mmCIF d.em_euler_angle_assignment);
      "em_ctf_correction",(List.map Em_ctf_correction.to_mmCIF d.em_ctf_correction);
      "em_volume_selection",(List.map Em_volume_selection.to_mmCIF d.em_volume_selection);
      "em_3d_crystal_entity",(List.map Em_3d_crystal_entity.to_mmCIF d.em_3d_crystal_entity);
      "em_2d_crystal_entity",(List.map Em_2d_crystal_entity.to_mmCIF d.em_2d_crystal_entity);
      "em_image_processing",(List.map Em_image_processing.to_mmCIF d.em_image_processing);
      "em_particle_selection",(List.map Em_particle_selection.to_mmCIF d.em_particle_selection);
      "em_map",(List.map Em_map.to_mmCIF d.em_map);
      "em_fsc_curve",(List.map Em_fsc_curve.to_mmCIF d.em_fsc_curve);
      "em_interpret_figure",(List.map Em_interpret_figure.to_mmCIF d.em_interpret_figure);
      "em_layer_lines",(List.map Em_layer_lines.to_mmCIF d.em_layer_lines);
      "em_structure_factors",(List.map Em_structure_factors.to_mmCIF d.em_structure_factors);
      "em_depositor_info",(List.map Em_depositor_info.to_mmCIF d.em_depositor_info);
      "em_map_depositor_info",(List.map Em_map_depositor_info.to_mmCIF d.em_map_depositor_info);
      "em_mask_depositor_info",(List.map Em_mask_depositor_info.to_mmCIF d.em_mask_depositor_info);
      "em_figure_depositor_info",(List.map Em_figure_depositor_info.to_mmCIF d.em_figure_depositor_info);
      "em_layer_lines_depositor_info",(List.map Em_layer_lines_depositor_info.to_mmCIF d.em_layer_lines_depositor_info);
      "em_structure_factors_depositor_info",(List.map Em_structure_factors_depositor_info.to_mmCIF d.em_structure_factors_depositor_info);
      "pdbx_seq_map_depositor_info",(List.map Pdbx_seq_map_depositor_info.to_mmCIF d.pdbx_seq_map_depositor_info);
      "pdbx_chem_comp_depositor_info",(List.map Pdbx_chem_comp_depositor_info.to_mmCIF d.pdbx_chem_comp_depositor_info);
      "pdbx_struct_ref_seq_depositor_info",(List.map Pdbx_struct_ref_seq_depositor_info.to_mmCIF d.pdbx_struct_ref_seq_depositor_info);
      "pdbx_struct_ref_seq_dif_depositor_info",(List.map Pdbx_struct_ref_seq_dif_depositor_info.to_mmCIF d.pdbx_struct_ref_seq_dif_depositor_info);
      "pdbx_struct_assembly_prop_depositor_info",(List.map Pdbx_struct_assembly_prop_depositor_info.to_mmCIF d.pdbx_struct_assembly_prop_depositor_info);
      "pdbx_struct_assembly_depositor_info",(List.map Pdbx_struct_assembly_depositor_info.to_mmCIF d.pdbx_struct_assembly_depositor_info);
      "pdbx_struct_assembly_gen_depositor_info",(List.map Pdbx_struct_assembly_gen_depositor_info.to_mmCIF d.pdbx_struct_assembly_gen_depositor_info);
      "pdbx_struct_oper_list_depositor_info",(List.map Pdbx_struct_oper_list_depositor_info.to_mmCIF d.pdbx_struct_oper_list_depositor_info);
      "pdbx_point_symmetry_depositor_info",(List.map Pdbx_point_symmetry_depositor_info.to_mmCIF d.pdbx_point_symmetry_depositor_info);
      "pdbx_helical_symmetry_depositor_info",(List.map Pdbx_helical_symmetry_depositor_info.to_mmCIF d.pdbx_helical_symmetry_depositor_info);
      "pdbx_struct_assembly_auth_evidence_depositor_info",(List.map Pdbx_struct_assembly_auth_evidence_depositor_info.to_mmCIF d.pdbx_struct_assembly_auth_evidence_depositor_info);
      "pdbx_solvent_atom_site_mapping",(List.map Pdbx_solvent_atom_site_mapping.to_mmCIF d.pdbx_solvent_atom_site_mapping);
      "pdbx_molecule_features_depositor_info",(List.map Pdbx_molecule_features_depositor_info.to_mmCIF d.pdbx_molecule_features_depositor_info);
      "pdbx_chem_comp_instance_depositor_info",(List.map Pdbx_chem_comp_instance_depositor_info.to_mmCIF d.pdbx_chem_comp_instance_depositor_info);
      "pdbx_depui_status_flags",(List.map Pdbx_depui_status_flags.to_mmCIF d.pdbx_depui_status_flags);
      "pdbx_depui_upload",(List.map Pdbx_depui_upload.to_mmCIF d.pdbx_depui_upload);
      "pdbx_depui_validation_status_flags",(List.map Pdbx_depui_validation_status_flags.to_mmCIF d.pdbx_depui_validation_status_flags);
      "pdbx_chem_comp_upload_depositor_info",(List.map Pdbx_chem_comp_upload_depositor_info.to_mmCIF d.pdbx_chem_comp_upload_depositor_info);
      "pdbx_depui_entity_status_flags",(List.map Pdbx_depui_entity_status_flags.to_mmCIF d.pdbx_depui_entity_status_flags);
      "pdbx_depui_entity_features",(List.map Pdbx_depui_entity_features.to_mmCIF d.pdbx_depui_entity_features);
      "pdbx_deposition_message_info",(List.map Pdbx_deposition_message_info.to_mmCIF d.pdbx_deposition_message_info);
      "pdbx_deposition_message_file_reference",(List.map Pdbx_deposition_message_file_reference.to_mmCIF d.pdbx_deposition_message_file_reference);
      "pdbx_depui_entry_details",(List.map Pdbx_depui_entry_details.to_mmCIF d.pdbx_depui_entry_details);
      "pdbx_data_processing_status",(List.map Pdbx_data_processing_status.to_mmCIF d.pdbx_data_processing_status);
      "pdbx_entity_instance_feature",(List.map Pdbx_entity_instance_feature.to_mmCIF d.pdbx_entity_instance_feature);
      "pdbx_entity_src_gen_depositor_info",(List.map Pdbx_entity_src_gen_depositor_info.to_mmCIF d.pdbx_entity_src_gen_depositor_info);
      "pdbx_chem_comp_model",(List.map Pdbx_chem_comp_model.to_mmCIF d.pdbx_chem_comp_model);
      "pdbx_chem_comp_model_atom",(List.map Pdbx_chem_comp_model_atom.to_mmCIF d.pdbx_chem_comp_model_atom);
      "pdbx_chem_comp_model_bond",(List.map Pdbx_chem_comp_model_bond.to_mmCIF d.pdbx_chem_comp_model_bond);
      "pdbx_chem_comp_model_feature",(List.map Pdbx_chem_comp_model_feature.to_mmCIF d.pdbx_chem_comp_model_feature);
      "pdbx_chem_comp_model_descriptor",(List.map Pdbx_chem_comp_model_descriptor.to_mmCIF d.pdbx_chem_comp_model_descriptor);
      "pdbx_chem_comp_model_audit",(List.map Pdbx_chem_comp_model_audit.to_mmCIF d.pdbx_chem_comp_model_audit);
      "pdbx_chem_comp_model_reference",(List.map Pdbx_chem_comp_model_reference.to_mmCIF d.pdbx_chem_comp_model_reference);
      "pdbx_view_category_group",(List.map Pdbx_view_category_group.to_mmCIF d.pdbx_view_category_group);
      "pdbx_view_category",(List.map Pdbx_view_category.to_mmCIF d.pdbx_view_category);
      "pdbx_view_item",(List.map Pdbx_view_item.to_mmCIF d.pdbx_view_item);
      "pdbx_coord",(List.map Pdbx_coord.to_mmCIF d.pdbx_coord);
      "pdbx_connect",(List.map Pdbx_connect.to_mmCIF d.pdbx_connect);
      "pdbx_connect_type",(List.map Pdbx_connect_type.to_mmCIF d.pdbx_connect_type);
      "pdbx_connect_modification",(List.map Pdbx_connect_modification.to_mmCIF d.pdbx_connect_modification);
      "pdbx_connect_atom",(List.map Pdbx_connect_atom.to_mmCIF d.pdbx_connect_atom);
      "pdbx_database_PDB_master",(List.map Pdbx_database_PDB_master.to_mmCIF d.pdbx_database_PDB_master);
      "pdbx_database_pdb_omit",(List.map Pdbx_database_pdb_omit.to_mmCIF d.pdbx_database_pdb_omit);
      "pdbx_dbref",(List.map Pdbx_dbref.to_mmCIF d.pdbx_dbref);
      "pdbx_drug_info",(List.map Pdbx_drug_info.to_mmCIF d.pdbx_drug_info);
      "pdbx_inhibitor_info",(List.map Pdbx_inhibitor_info.to_mmCIF d.pdbx_inhibitor_info);
      "pdbx_ion_info",(List.map Pdbx_ion_info.to_mmCIF d.pdbx_ion_info);
      "pdbx_hybrid",(List.map Pdbx_hybrid.to_mmCIF d.pdbx_hybrid);
      "pdbx_na_strand_info",(List.map Pdbx_na_strand_info.to_mmCIF d.pdbx_na_strand_info);
      "pdbx_nonstandard_list",(List.map Pdbx_nonstandard_list.to_mmCIF d.pdbx_nonstandard_list);
      "pdbx_pdb_compnd",(List.map Pdbx_pdb_compnd.to_mmCIF d.pdbx_pdb_compnd);
      "pdbx_pdb_source",(List.map Pdbx_pdb_source.to_mmCIF d.pdbx_pdb_source);
      "pdbx_protein_info",(List.map Pdbx_protein_info.to_mmCIF d.pdbx_protein_info);
      "pdbx_solvent_info",(List.map Pdbx_solvent_info.to_mmCIF d.pdbx_solvent_info);
      "pdbx_source",(List.map Pdbx_source.to_mmCIF d.pdbx_source);
      "pdbx_struct_biol_func",(List.map Pdbx_struct_biol_func.to_mmCIF d.pdbx_struct_biol_func);
      "pdbx_struct_pack_gen",(List.map Pdbx_struct_pack_gen.to_mmCIF d.pdbx_struct_pack_gen);
      "pdbx_trna_info",(List.map Pdbx_trna_info.to_mmCIF d.pdbx_trna_info);
      "pdbx_unpair",(List.map Pdbx_unpair.to_mmCIF d.pdbx_unpair);
      "pdbx_refine_ls_restr_ncs",(List.map Pdbx_refine_ls_restr_ncs.to_mmCIF d.pdbx_refine_ls_restr_ncs);
      "pdbx_struct_ncs_virus_gen",(List.map Pdbx_struct_ncs_virus_gen.to_mmCIF d.pdbx_struct_ncs_virus_gen);
      "pdbx_sequence_annotation",(List.map Pdbx_sequence_annotation.to_mmCIF d.pdbx_sequence_annotation);
      "pdbx_chem_comp_synonyms",(List.map Pdbx_chem_comp_synonyms.to_mmCIF d.pdbx_chem_comp_synonyms);
      "pdbx_post_process_details",(List.map Pdbx_post_process_details.to_mmCIF d.pdbx_post_process_details);
      "pdbx_post_process_status",(List.map Pdbx_post_process_status.to_mmCIF d.pdbx_post_process_status);
      "pdbx_struct_link",(List.map Pdbx_struct_link.to_mmCIF d.pdbx_struct_link);
      "pdbx_missing_residue_list",(List.map Pdbx_missing_residue_list.to_mmCIF d.pdbx_missing_residue_list);
      "pdbx_data_processing_cell",(List.map Pdbx_data_processing_cell.to_mmCIF d.pdbx_data_processing_cell);
      "pdbx_data_processing_reflns",(List.map Pdbx_data_processing_reflns.to_mmCIF d.pdbx_data_processing_reflns);
      "pdbx_data_processing_detector",(List.map Pdbx_data_processing_detector.to_mmCIF d.pdbx_data_processing_detector);
      "pdbx_chem_comp_nonstandard",(List.map Pdbx_chem_comp_nonstandard.to_mmCIF d.pdbx_chem_comp_nonstandard);
      "pdbx_entity_poly_protein_class",(List.map Pdbx_entity_poly_protein_class.to_mmCIF d.pdbx_entity_poly_protein_class);
      "pdbx_entity_name_taxonomy_tree",(List.map Pdbx_entity_name_taxonomy_tree.to_mmCIF d.pdbx_entity_name_taxonomy_tree);
      "pdbx_entity_name_taxonomy",(List.map Pdbx_entity_name_taxonomy.to_mmCIF d.pdbx_entity_name_taxonomy);
      "pdbx_entity_name_instance",(List.map Pdbx_entity_name_instance.to_mmCIF d.pdbx_entity_name_instance);
      "pdbx_tableinfo",(List.map Pdbx_tableinfo.to_mmCIF d.pdbx_tableinfo);
      "pdbx_columninfo",(List.map Pdbx_columninfo.to_mmCIF d.pdbx_columninfo);
      "pdbx_val_angle",(List.map Pdbx_val_angle.to_mmCIF d.pdbx_val_angle);
      "pdbx_val_bond",(List.map Pdbx_val_bond.to_mmCIF d.pdbx_val_bond);
      "pdbx_val_contact",(List.map Pdbx_val_contact.to_mmCIF d.pdbx_val_contact);
      "pdbx_val_sym_contact",(List.map Pdbx_val_sym_contact.to_mmCIF d.pdbx_val_sym_contact);
      "pdbx_rmch_outlier",(List.map Pdbx_rmch_outlier.to_mmCIF d.pdbx_rmch_outlier);
      "pdbx_missing_atom_poly",(List.map Pdbx_missing_atom_poly.to_mmCIF d.pdbx_missing_atom_poly);
      "pdbx_missing_atom_nonpoly",(List.map Pdbx_missing_atom_nonpoly.to_mmCIF d.pdbx_missing_atom_nonpoly);
      "pdbx_val_chiral",(List.map Pdbx_val_chiral.to_mmCIF d.pdbx_val_chiral);
      "pdbx_atlas",(List.map Pdbx_atlas.to_mmCIF d.pdbx_atlas);
      "pdbx_summary_flags",(List.map Pdbx_summary_flags.to_mmCIF d.pdbx_summary_flags);
      "pdbx_entity_func_bind_mode",(List.map Pdbx_entity_func_bind_mode.to_mmCIF d.pdbx_entity_func_bind_mode);
      "pdbx_entity_func_enzyme",(List.map Pdbx_entity_func_enzyme.to_mmCIF d.pdbx_entity_func_enzyme);
      "pdbx_entity_func_regulatory",(List.map Pdbx_entity_func_regulatory.to_mmCIF d.pdbx_entity_func_regulatory);
      "pdbx_entity_func_structural",(List.map Pdbx_entity_func_structural.to_mmCIF d.pdbx_entity_func_structural);
      "pdbx_entity_func_other",(List.map Pdbx_entity_func_other.to_mmCIF d.pdbx_entity_func_other);
      "pdbx_entity_poly_domain",(List.map Pdbx_entity_poly_domain.to_mmCIF d.pdbx_entity_poly_domain);
      "pdbx_na_struct_keywds",(List.map Pdbx_na_struct_keywds.to_mmCIF d.pdbx_na_struct_keywds);
      "pdbx_entity_poly_na_type",(List.map Pdbx_entity_poly_na_type.to_mmCIF d.pdbx_entity_poly_na_type);
      "pdbx_entity_poly_na_nonstandard",(List.map Pdbx_entity_poly_na_nonstandard.to_mmCIF d.pdbx_entity_poly_na_nonstandard);
      "pdbx_virtual_angle",(List.map Pdbx_virtual_angle.to_mmCIF d.pdbx_virtual_angle);
      "pdbx_virtual_bond",(List.map Pdbx_virtual_bond.to_mmCIF d.pdbx_virtual_bond);
      "pdbx_virtual_torsion",(List.map Pdbx_virtual_torsion.to_mmCIF d.pdbx_virtual_torsion);
      "pdbx_sequence_pattern",(List.map Pdbx_sequence_pattern.to_mmCIF d.pdbx_sequence_pattern);
      "pdbx_stereochemistry",(List.map Pdbx_stereochemistry.to_mmCIF d.pdbx_stereochemistry);
      "pdbx_rms_devs_covalent",(List.map Pdbx_rms_devs_covalent.to_mmCIF d.pdbx_rms_devs_covalent);
      "pdbx_rms_devs_cov_by_monomer",(List.map Pdbx_rms_devs_cov_by_monomer.to_mmCIF d.pdbx_rms_devs_cov_by_monomer);
      "pdbx_sugar_phosphate_geometry",(List.map Pdbx_sugar_phosphate_geometry.to_mmCIF d.pdbx_sugar_phosphate_geometry);
      "pdbx_nmr_computing",(List.map Pdbx_nmr_computing.to_mmCIF d.pdbx_nmr_computing);
      "pdbx_audit_conform_extension",(List.map Pdbx_audit_conform_extension.to_mmCIF d.pdbx_audit_conform_extension);
      "pdbx_dcc_mapman",(List.map Pdbx_dcc_mapman.to_mmCIF d.pdbx_dcc_mapman);
      "pdbx_dcc_rscc_mapman",(List.map Pdbx_dcc_rscc_mapman.to_mmCIF d.pdbx_dcc_rscc_mapman);
      "pdbx_dcc_rscc_mapman_overall",(List.map Pdbx_dcc_rscc_mapman_overall.to_mmCIF d.pdbx_dcc_rscc_mapman_overall);
      "pdbx_dcc_density",(List.map Pdbx_dcc_density.to_mmCIF d.pdbx_dcc_density);
      "pdbx_dcc_geometry",(List.map Pdbx_dcc_geometry.to_mmCIF d.pdbx_dcc_geometry);
      "pdbx_dcc_density_corr",(List.map Pdbx_dcc_density_corr.to_mmCIF d.pdbx_dcc_density_corr);
      "pdbx_dcc_map",(List.map Pdbx_dcc_map.to_mmCIF d.pdbx_dcc_map);
      "pdbx_deposit_group",(List.map Pdbx_deposit_group.to_mmCIF d.pdbx_deposit_group);
      "pdbx_deposit_group_index",(List.map Pdbx_deposit_group_index.to_mmCIF d.pdbx_deposit_group_index);
      "pdbx_struct_assembly_auth_evidence",(List.map Pdbx_struct_assembly_auth_evidence.to_mmCIF d.pdbx_struct_assembly_auth_evidence);
      "pdbx_struct_assembly_auth_classification",(List.map Pdbx_struct_assembly_auth_classification.to_mmCIF d.pdbx_struct_assembly_auth_classification);
      "pdbx_crystal_alignment",(List.map Pdbx_crystal_alignment.to_mmCIF d.pdbx_crystal_alignment);
      "pdbx_audit_revision_history",(List.map Pdbx_audit_revision_history.to_mmCIF d.pdbx_audit_revision_history);
      "pdbx_audit_revision_group",(List.map Pdbx_audit_revision_group.to_mmCIF d.pdbx_audit_revision_group);
      "pdbx_audit_revision_category",(List.map Pdbx_audit_revision_category.to_mmCIF d.pdbx_audit_revision_category);
      "pdbx_audit_revision_details",(List.map Pdbx_audit_revision_details.to_mmCIF d.pdbx_audit_revision_details);
      "pdbx_audit_revision_item",(List.map Pdbx_audit_revision_item.to_mmCIF d.pdbx_audit_revision_item);
      "pdbx_supporting_exp_data_set",(List.map Pdbx_supporting_exp_data_set.to_mmCIF d.pdbx_supporting_exp_data_set);
    ] in d.datablockName,lst

end

